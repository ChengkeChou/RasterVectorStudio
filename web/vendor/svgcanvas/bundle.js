var svgcanvas_global = (() => {
  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // ../../node_modules/@svgedit/svgcanvas/dist/svgcanvas.js
  var svgcanvas_exports = {};
  __export(svgcanvas_exports, {
    default: () => SvgCanvas
  });
  function _mergeNamespaces(n2, m2) {
    m2.forEach(function(e2) {
      e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k2) {
        if (k2 !== "default" && !(k2 in n2)) {
          var d2 = Object.getOwnPropertyDescriptor(e2, k2);
          Object.defineProperty(n2, k2, d2.get ? d2 : {
            enumerable: true,
            get: function() {
              return e2[k2];
            }
          });
        }
      });
    });
    return Object.freeze(n2);
  }
  (function() {
    if (typeof window === "undefined") return;
    if (!("SVGPathSeg" in window)) {
      window.SVGPathSeg = function(type, typeAsLetter, owningPathSegList) {
        this.pathSegType = type;
        this.pathSegTypeAsLetter = typeAsLetter;
        this._owningPathSegList = owningPathSegList;
      };
      window.SVGPathSeg.prototype.classname = "SVGPathSeg";
      window.SVGPathSeg.PATHSEG_UNKNOWN = 0;
      window.SVGPathSeg.PATHSEG_CLOSEPATH = 1;
      window.SVGPathSeg.PATHSEG_MOVETO_ABS = 2;
      window.SVGPathSeg.PATHSEG_MOVETO_REL = 3;
      window.SVGPathSeg.PATHSEG_LINETO_ABS = 4;
      window.SVGPathSeg.PATHSEG_LINETO_REL = 5;
      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
      window.SVGPathSeg.PATHSEG_ARC_ABS = 10;
      window.SVGPathSeg.PATHSEG_ARC_REL = 11;
      window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
      window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
      window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
      window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;
      window.SVGPathSeg.prototype._segmentChanged = function() {
        if (this._owningPathSegList) this._owningPathSegList.segmentChanged(this);
      };
      window.SVGPathSegClosePath = function(owningPathSegList) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CLOSEPATH, "z", owningPathSegList);
      };
      window.SVGPathSegClosePath.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegClosePath.prototype.toString = function() {
        return "[object SVGPathSegClosePath]";
      };
      window.SVGPathSegClosePath.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter;
      };
      window.SVGPathSegClosePath.prototype.clone = function() {
        return new window.SVGPathSegClosePath(void 0);
      };
      window.SVGPathSegMovetoAbs = function(owningPathSegList, x2, y2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_ABS, "M", owningPathSegList);
        this._x = x2;
        this._y = y2;
      };
      window.SVGPathSegMovetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegMovetoAbs.prototype.toString = function() {
        return "[object SVGPathSegMovetoAbs]";
      };
      window.SVGPathSegMovetoAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
      };
      window.SVGPathSegMovetoAbs.prototype.clone = function() {
        return new window.SVGPathSegMovetoAbs(void 0, this._x, this._y);
      };
      Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegMovetoRel = function(owningPathSegList, x2, y2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_REL, "m", owningPathSegList);
        this._x = x2;
        this._y = y2;
      };
      window.SVGPathSegMovetoRel.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegMovetoRel.prototype.toString = function() {
        return "[object SVGPathSegMovetoRel]";
      };
      window.SVGPathSegMovetoRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
      };
      window.SVGPathSegMovetoRel.prototype.clone = function() {
        return new window.SVGPathSegMovetoRel(void 0, this._x, this._y);
      };
      Object.defineProperty(window.SVGPathSegMovetoRel.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegMovetoRel.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegLinetoAbs = function(owningPathSegList, x2, y2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_ABS, "L", owningPathSegList);
        this._x = x2;
        this._y = y2;
      };
      window.SVGPathSegLinetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegLinetoAbs.prototype.toString = function() {
        return "[object SVGPathSegLinetoAbs]";
      };
      window.SVGPathSegLinetoAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
      };
      window.SVGPathSegLinetoAbs.prototype.clone = function() {
        return new window.SVGPathSegLinetoAbs(void 0, this._x, this._y);
      };
      Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegLinetoRel = function(owningPathSegList, x2, y2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_REL, "l", owningPathSegList);
        this._x = x2;
        this._y = y2;
      };
      window.SVGPathSegLinetoRel.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegLinetoRel.prototype.toString = function() {
        return "[object SVGPathSegLinetoRel]";
      };
      window.SVGPathSegLinetoRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
      };
      window.SVGPathSegLinetoRel.prototype.clone = function() {
        return new window.SVGPathSegLinetoRel(void 0, this._x, this._y);
      };
      Object.defineProperty(window.SVGPathSegLinetoRel.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegLinetoRel.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegCurvetoCubicAbs = function(owningPathSegList, x2, y2, x1, y1, x22, y22) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, "C", owningPathSegList);
        this._x = x2;
        this._y = y2;
        this._x1 = x1;
        this._y1 = y1;
        this._x2 = x22;
        this._y2 = y22;
      };
      window.SVGPathSegCurvetoCubicAbs.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegCurvetoCubicAbs.prototype.toString = function() {
        return "[object SVGPathSegCurvetoCubicAbs]";
      };
      window.SVGPathSegCurvetoCubicAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
      };
      window.SVGPathSegCurvetoCubicAbs.prototype.clone = function() {
        return new window.SVGPathSegCurvetoCubicAbs(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
      };
      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x1", {
        get: function() {
          return this._x1;
        },
        set: function(x1) {
          this._x1 = x1;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y1", {
        get: function() {
          return this._y1;
        },
        set: function(y1) {
          this._y1 = y1;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x2", {
        get: function() {
          return this._x2;
        },
        set: function(x2) {
          this._x2 = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y2", {
        get: function() {
          return this._y2;
        },
        set: function(y2) {
          this._y2 = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegCurvetoCubicRel = function(owningPathSegList, x2, y2, x1, y1, x22, y22) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, "c", owningPathSegList);
        this._x = x2;
        this._y = y2;
        this._x1 = x1;
        this._y1 = y1;
        this._x2 = x22;
        this._y2 = y22;
      };
      window.SVGPathSegCurvetoCubicRel.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegCurvetoCubicRel.prototype.toString = function() {
        return "[object SVGPathSegCurvetoCubicRel]";
      };
      window.SVGPathSegCurvetoCubicRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
      };
      window.SVGPathSegCurvetoCubicRel.prototype.clone = function() {
        return new window.SVGPathSegCurvetoCubicRel(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
      };
      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x1", {
        get: function() {
          return this._x1;
        },
        set: function(x1) {
          this._x1 = x1;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y1", {
        get: function() {
          return this._y1;
        },
        set: function(y1) {
          this._y1 = y1;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x2", {
        get: function() {
          return this._x2;
        },
        set: function(x2) {
          this._x2 = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y2", {
        get: function() {
          return this._y2;
        },
        set: function(y2) {
          this._y2 = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegCurvetoQuadraticAbs = function(owningPathSegList, x2, y2, x1, y1) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, "Q", owningPathSegList);
        this._x = x2;
        this._y = y2;
        this._x1 = x1;
        this._y1 = y1;
      };
      window.SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegCurvetoQuadraticAbs.prototype.toString = function() {
        return "[object SVGPathSegCurvetoQuadraticAbs]";
      };
      window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;
      };
      window.SVGPathSegCurvetoQuadraticAbs.prototype.clone = function() {
        return new window.SVGPathSegCurvetoQuadraticAbs(void 0, this._x, this._y, this._x1, this._y1);
      };
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "x1", {
        get: function() {
          return this._x1;
        },
        set: function(x1) {
          this._x1 = x1;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "y1", {
        get: function() {
          return this._y1;
        },
        set: function(y1) {
          this._y1 = y1;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegCurvetoQuadraticRel = function(owningPathSegList, x2, y2, x1, y1) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, "q", owningPathSegList);
        this._x = x2;
        this._y = y2;
        this._x1 = x1;
        this._y1 = y1;
      };
      window.SVGPathSegCurvetoQuadraticRel.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegCurvetoQuadraticRel.prototype.toString = function() {
        return "[object SVGPathSegCurvetoQuadraticRel]";
      };
      window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;
      };
      window.SVGPathSegCurvetoQuadraticRel.prototype.clone = function() {
        return new window.SVGPathSegCurvetoQuadraticRel(void 0, this._x, this._y, this._x1, this._y1);
      };
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "x1", {
        get: function() {
          return this._x1;
        },
        set: function(x1) {
          this._x1 = x1;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "y1", {
        get: function() {
          return this._y1;
        },
        set: function(y1) {
          this._y1 = y1;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegArcAbs = function(owningPathSegList, x2, y2, r1, r2, angle2, largeArcFlag, sweepFlag) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_ABS, "A", owningPathSegList);
        this._x = x2;
        this._y = y2;
        this._r1 = r1;
        this._r2 = r2;
        this._angle = angle2;
        this._largeArcFlag = largeArcFlag;
        this._sweepFlag = sweepFlag;
      };
      window.SVGPathSegArcAbs.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegArcAbs.prototype.toString = function() {
        return "[object SVGPathSegArcAbs]";
      };
      window.SVGPathSegArcAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;
      };
      window.SVGPathSegArcAbs.prototype.clone = function() {
        return new window.SVGPathSegArcAbs(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
      };
      Object.defineProperty(window.SVGPathSegArcAbs.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcAbs.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcAbs.prototype, "r1", {
        get: function() {
          return this._r1;
        },
        set: function(r1) {
          this._r1 = r1;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcAbs.prototype, "r2", {
        get: function() {
          return this._r2;
        },
        set: function(r2) {
          this._r2 = r2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcAbs.prototype, "angle", {
        get: function() {
          return this._angle;
        },
        set: function(angle2) {
          this._angle = angle2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcAbs.prototype, "largeArcFlag", {
        get: function() {
          return this._largeArcFlag;
        },
        set: function(largeArcFlag) {
          this._largeArcFlag = largeArcFlag;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcAbs.prototype, "sweepFlag", {
        get: function() {
          return this._sweepFlag;
        },
        set: function(sweepFlag) {
          this._sweepFlag = sweepFlag;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegArcRel = function(owningPathSegList, x2, y2, r1, r2, angle2, largeArcFlag, sweepFlag) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_REL, "a", owningPathSegList);
        this._x = x2;
        this._y = y2;
        this._r1 = r1;
        this._r2 = r2;
        this._angle = angle2;
        this._largeArcFlag = largeArcFlag;
        this._sweepFlag = sweepFlag;
      };
      window.SVGPathSegArcRel.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegArcRel.prototype.toString = function() {
        return "[object SVGPathSegArcRel]";
      };
      window.SVGPathSegArcRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;
      };
      window.SVGPathSegArcRel.prototype.clone = function() {
        return new window.SVGPathSegArcRel(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
      };
      Object.defineProperty(window.SVGPathSegArcRel.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcRel.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcRel.prototype, "r1", {
        get: function() {
          return this._r1;
        },
        set: function(r1) {
          this._r1 = r1;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcRel.prototype, "r2", {
        get: function() {
          return this._r2;
        },
        set: function(r2) {
          this._r2 = r2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcRel.prototype, "angle", {
        get: function() {
          return this._angle;
        },
        set: function(angle2) {
          this._angle = angle2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcRel.prototype, "largeArcFlag", {
        get: function() {
          return this._largeArcFlag;
        },
        set: function(largeArcFlag) {
          this._largeArcFlag = largeArcFlag;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegArcRel.prototype, "sweepFlag", {
        get: function() {
          return this._sweepFlag;
        },
        set: function(sweepFlag) {
          this._sweepFlag = sweepFlag;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegLinetoHorizontalAbs = function(owningPathSegList, x2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, "H", owningPathSegList);
        this._x = x2;
      };
      window.SVGPathSegLinetoHorizontalAbs.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegLinetoHorizontalAbs.prototype.toString = function() {
        return "[object SVGPathSegLinetoHorizontalAbs]";
      };
      window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x;
      };
      window.SVGPathSegLinetoHorizontalAbs.prototype.clone = function() {
        return new window.SVGPathSegLinetoHorizontalAbs(void 0, this._x);
      };
      Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegLinetoHorizontalRel = function(owningPathSegList, x2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, "h", owningPathSegList);
        this._x = x2;
      };
      window.SVGPathSegLinetoHorizontalRel.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegLinetoHorizontalRel.prototype.toString = function() {
        return "[object SVGPathSegLinetoHorizontalRel]";
      };
      window.SVGPathSegLinetoHorizontalRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x;
      };
      window.SVGPathSegLinetoHorizontalRel.prototype.clone = function() {
        return new window.SVGPathSegLinetoHorizontalRel(void 0, this._x);
      };
      Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegLinetoVerticalAbs = function(owningPathSegList, y2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, "V", owningPathSegList);
        this._y = y2;
      };
      window.SVGPathSegLinetoVerticalAbs.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegLinetoVerticalAbs.prototype.toString = function() {
        return "[object SVGPathSegLinetoVerticalAbs]";
      };
      window.SVGPathSegLinetoVerticalAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._y;
      };
      window.SVGPathSegLinetoVerticalAbs.prototype.clone = function() {
        return new window.SVGPathSegLinetoVerticalAbs(void 0, this._y);
      };
      Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegLinetoVerticalRel = function(owningPathSegList, y2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, "v", owningPathSegList);
        this._y = y2;
      };
      window.SVGPathSegLinetoVerticalRel.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegLinetoVerticalRel.prototype.toString = function() {
        return "[object SVGPathSegLinetoVerticalRel]";
      };
      window.SVGPathSegLinetoVerticalRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._y;
      };
      window.SVGPathSegLinetoVerticalRel.prototype.clone = function() {
        return new window.SVGPathSegLinetoVerticalRel(void 0, this._y);
      };
      Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegCurvetoCubicSmoothAbs = function(owningPathSegList, x2, y2, x22, y22) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, "S", owningPathSegList);
        this._x = x2;
        this._y = y2;
        this._x2 = x22;
        this._y2 = y22;
      };
      window.SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function() {
        return "[object SVGPathSegCurvetoCubicSmoothAbs]";
      };
      window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
      };
      window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function() {
        return new window.SVGPathSegCurvetoCubicSmoothAbs(void 0, this._x, this._y, this._x2, this._y2);
      };
      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "x2", {
        get: function() {
          return this._x2;
        },
        set: function(x2) {
          this._x2 = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "y2", {
        get: function() {
          return this._y2;
        },
        set: function(y2) {
          this._y2 = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegCurvetoCubicSmoothRel = function(owningPathSegList, x2, y2, x22, y22) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, "s", owningPathSegList);
        this._x = x2;
        this._y = y2;
        this._x2 = x22;
        this._y2 = y22;
      };
      window.SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function() {
        return "[object SVGPathSegCurvetoCubicSmoothRel]";
      };
      window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
      };
      window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function() {
        return new window.SVGPathSegCurvetoCubicSmoothRel(void 0, this._x, this._y, this._x2, this._y2);
      };
      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "x2", {
        get: function() {
          return this._x2;
        },
        set: function(x2) {
          this._x2 = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "y2", {
        get: function() {
          return this._y2;
        },
        set: function(y2) {
          this._y2 = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegCurvetoQuadraticSmoothAbs = function(owningPathSegList, x2, y2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, "T", owningPathSegList);
        this._x = x2;
        this._y = y2;
      };
      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function() {
        return "[object SVGPathSegCurvetoQuadraticSmoothAbs]";
      };
      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
      };
      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function() {
        return new window.SVGPathSegCurvetoQuadraticSmoothAbs(void 0, this._x, this._y);
      };
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathSegCurvetoQuadraticSmoothRel = function(owningPathSegList, x2, y2) {
        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, "t", owningPathSegList);
        this._x = x2;
        this._y = y2;
      };
      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);
      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function() {
        return "[object SVGPathSegCurvetoQuadraticSmoothRel]";
      };
      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
      };
      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function() {
        return new window.SVGPathSegCurvetoQuadraticSmoothRel(void 0, this._x, this._y);
      };
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(x2) {
          this._x = x2;
          this._segmentChanged();
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(y2) {
          this._y = y2;
          this._segmentChanged();
        },
        enumerable: true
      });
      window.SVGPathElement.prototype.createSVGPathSegClosePath = function() {
        return new window.SVGPathSegClosePath(void 0);
      };
      window.SVGPathElement.prototype.createSVGPathSegMovetoAbs = function(x2, y2) {
        return new window.SVGPathSegMovetoAbs(void 0, x2, y2);
      };
      window.SVGPathElement.prototype.createSVGPathSegMovetoRel = function(x2, y2) {
        return new window.SVGPathSegMovetoRel(void 0, x2, y2);
      };
      window.SVGPathElement.prototype.createSVGPathSegLinetoAbs = function(x2, y2) {
        return new window.SVGPathSegLinetoAbs(void 0, x2, y2);
      };
      window.SVGPathElement.prototype.createSVGPathSegLinetoRel = function(x2, y2) {
        return new window.SVGPathSegLinetoRel(void 0, x2, y2);
      };
      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function(x2, y2, x1, y1, x22, y22) {
        return new window.SVGPathSegCurvetoCubicAbs(void 0, x2, y2, x1, y1, x22, y22);
      };
      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function(x2, y2, x1, y1, x22, y22) {
        return new window.SVGPathSegCurvetoCubicRel(void 0, x2, y2, x1, y1, x22, y22);
      };
      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function(x2, y2, x1, y1) {
        return new window.SVGPathSegCurvetoQuadraticAbs(void 0, x2, y2, x1, y1);
      };
      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function(x2, y2, x1, y1) {
        return new window.SVGPathSegCurvetoQuadraticRel(void 0, x2, y2, x1, y1);
      };
      window.SVGPathElement.prototype.createSVGPathSegArcAbs = function(x2, y2, r1, r2, angle2, largeArcFlag, sweepFlag) {
        return new window.SVGPathSegArcAbs(void 0, x2, y2, r1, r2, angle2, largeArcFlag, sweepFlag);
      };
      window.SVGPathElement.prototype.createSVGPathSegArcRel = function(x2, y2, r1, r2, angle2, largeArcFlag, sweepFlag) {
        return new window.SVGPathSegArcRel(void 0, x2, y2, r1, r2, angle2, largeArcFlag, sweepFlag);
      };
      window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function(x2) {
        return new window.SVGPathSegLinetoHorizontalAbs(void 0, x2);
      };
      window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function(x2) {
        return new window.SVGPathSegLinetoHorizontalRel(void 0, x2);
      };
      window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function(y2) {
        return new window.SVGPathSegLinetoVerticalAbs(void 0, y2);
      };
      window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function(y2) {
        return new window.SVGPathSegLinetoVerticalRel(void 0, y2);
      };
      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function(x2, y2, x22, y22) {
        return new window.SVGPathSegCurvetoCubicSmoothAbs(void 0, x2, y2, x22, y22);
      };
      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function(x2, y2, x22, y22) {
        return new window.SVGPathSegCurvetoCubicSmoothRel(void 0, x2, y2, x22, y22);
      };
      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function(x2, y2) {
        return new window.SVGPathSegCurvetoQuadraticSmoothAbs(void 0, x2, y2);
      };
      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function(x2, y2) {
        return new window.SVGPathSegCurvetoQuadraticSmoothRel(void 0, x2, y2);
      };
      if (!("getPathSegAtLength" in window.SVGPathElement.prototype)) {
        window.SVGPathElement.prototype.getPathSegAtLength = function(distance) {
          if (distance === void 0 || !isFinite(distance)) throw "Invalid arguments.";
          var measurementElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
          measurementElement.setAttribute("d", this.getAttribute("d"));
          var lastPathSegment = measurementElement.pathSegList.numberOfItems - 1;
          if (lastPathSegment <= 0) return 0;
          do {
            measurementElement.pathSegList.removeItem(lastPathSegment);
            if (distance > measurementElement.getTotalLength()) break;
            lastPathSegment--;
          } while (lastPathSegment > 0);
          return lastPathSegment;
        };
      }
    }
    if (!("SVGPathSegList" in window) || !("appendItem" in window.SVGPathSegList.prototype)) {
      window.SVGPathSegList = function(pathElement) {
        this._pathElement = pathElement;
        this._list = this._parsePath(this._pathElement.getAttribute("d"));
        this._mutationObserverConfig = {
          "attributes": true,
          "attributeFilter": ["d"]
        };
        this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));
        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
      };
      window.SVGPathSegList.prototype.classname = "SVGPathSegList";
      Object.defineProperty(window.SVGPathSegList.prototype, "numberOfItems", {
        get: function() {
          this._checkPathSynchronizedToList();
          return this._list.length;
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathSegList.prototype, "length", {
        get: function() {
          this._checkPathSynchronizedToList();
          return this._list.length;
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathElement.prototype, "pathSegList", {
        get: function() {
          if (!this._pathSegList) this._pathSegList = new window.SVGPathSegList(this);
          return this._pathSegList;
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathElement.prototype, "normalizedPathSegList", {
        get: function() {
          return this.pathSegList;
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathElement.prototype, "animatedPathSegList", {
        get: function() {
          return this.pathSegList;
        },
        enumerable: true
      });
      Object.defineProperty(window.SVGPathElement.prototype, "animatedNormalizedPathSegList", {
        get: function() {
          return this.pathSegList;
        },
        enumerable: true
      });
      window.SVGPathSegList.prototype._checkPathSynchronizedToList = function() {
        this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());
      };
      window.SVGPathSegList.prototype._updateListFromPathMutations = function(mutationRecords) {
        if (!this._pathElement) return;
        var hasPathMutations = false;
        mutationRecords.forEach(function(record) {
          if (record.attributeName == "d") hasPathMutations = true;
        });
        if (hasPathMutations) this._list = this._parsePath(this._pathElement.getAttribute("d"));
      };
      window.SVGPathSegList.prototype._writeListToPath = function() {
        this._pathElementMutationObserver.disconnect();
        this._pathElement.setAttribute("d", window.SVGPathSegList._pathSegArrayAsString(this._list));
        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
      };
      window.SVGPathSegList.prototype.segmentChanged = function(pathSeg) {
        this._writeListToPath();
      };
      window.SVGPathSegList.prototype.clear = function() {
        this._checkPathSynchronizedToList();
        this._list.forEach(function(pathSeg) {
          pathSeg._owningPathSegList = null;
        });
        this._list = [];
        this._writeListToPath();
      };
      window.SVGPathSegList.prototype.initialize = function(newItem) {
        this._checkPathSynchronizedToList();
        this._list = [newItem];
        newItem._owningPathSegList = this;
        this._writeListToPath();
        return newItem;
      };
      window.SVGPathSegList.prototype._checkValidIndex = function(index2) {
        if (isNaN(index2) || index2 < 0 || index2 >= this.numberOfItems) throw "INDEX_SIZE_ERR";
      };
      window.SVGPathSegList.prototype.getItem = function(index2) {
        this._checkPathSynchronizedToList();
        this._checkValidIndex(index2);
        return this._list[index2];
      };
      window.SVGPathSegList.prototype.insertItemBefore = function(newItem, index2) {
        this._checkPathSynchronizedToList();
        if (index2 > this.numberOfItems) index2 = this.numberOfItems;
        if (newItem._owningPathSegList) {
          newItem = newItem.clone();
        }
        this._list.splice(index2, 0, newItem);
        newItem._owningPathSegList = this;
        this._writeListToPath();
        return newItem;
      };
      window.SVGPathSegList.prototype.replaceItem = function(newItem, index2) {
        this._checkPathSynchronizedToList();
        if (newItem._owningPathSegList) {
          newItem = newItem.clone();
        }
        this._checkValidIndex(index2);
        this._list[index2] = newItem;
        newItem._owningPathSegList = this;
        this._writeListToPath();
        return newItem;
      };
      window.SVGPathSegList.prototype.removeItem = function(index2) {
        this._checkPathSynchronizedToList();
        this._checkValidIndex(index2);
        var item = this._list[index2];
        this._list.splice(index2, 1);
        this._writeListToPath();
        return item;
      };
      window.SVGPathSegList.prototype.appendItem = function(newItem) {
        this._checkPathSynchronizedToList();
        if (newItem._owningPathSegList) {
          newItem = newItem.clone();
        }
        this._list.push(newItem);
        newItem._owningPathSegList = this;
        this._writeListToPath();
        return newItem;
      };
      window.SVGPathSegList._pathSegArrayAsString = function(pathSegArray) {
        var string = "";
        var first = true;
        pathSegArray.forEach(function(pathSeg) {
          if (first) {
            first = false;
            string += pathSeg._asPathString();
          } else {
            string += " " + pathSeg._asPathString();
          }
        });
        return string;
      };
      window.SVGPathSegList.prototype._parsePath = function(string) {
        if (!string || string.length == 0) return [];
        var owningPathSegList = this;
        var Builder = function() {
          this.pathSegList = [];
        };
        Builder.prototype.appendSegment = function(pathSeg2) {
          this.pathSegList.push(pathSeg2);
        };
        var Source = function(string2) {
          this._string = string2;
          this._currentIndex = 0;
          this._endIndex = this._string.length;
          this._previousCommand = window.SVGPathSeg.PATHSEG_UNKNOWN;
          this._skipOptionalSpaces();
        };
        Source.prototype._isCurrentSpace = function() {
          var character = this._string[this._currentIndex];
          return character <= " " && (character == " " || character == "\n" || character == "	" || character == "\r" || character == "\f");
        };
        Source.prototype._skipOptionalSpaces = function() {
          while (this._currentIndex < this._endIndex && this._isCurrentSpace()) this._currentIndex++;
          return this._currentIndex < this._endIndex;
        };
        Source.prototype._skipOptionalSpacesOrDelimiter = function() {
          if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string.charAt(this._currentIndex) != ",") return false;
          if (this._skipOptionalSpaces()) {
            if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ",") {
              this._currentIndex++;
              this._skipOptionalSpaces();
            }
          }
          return this._currentIndex < this._endIndex;
        };
        Source.prototype.hasMoreData = function() {
          return this._currentIndex < this._endIndex;
        };
        Source.prototype.peekSegmentType = function() {
          var lookahead = this._string[this._currentIndex];
          return this._pathSegTypeFromChar(lookahead);
        };
        Source.prototype._pathSegTypeFromChar = function(lookahead) {
          switch (lookahead) {
            case "Z":
            case "z":
              return window.SVGPathSeg.PATHSEG_CLOSEPATH;
            case "M":
              return window.SVGPathSeg.PATHSEG_MOVETO_ABS;
            case "m":
              return window.SVGPathSeg.PATHSEG_MOVETO_REL;
            case "L":
              return window.SVGPathSeg.PATHSEG_LINETO_ABS;
            case "l":
              return window.SVGPathSeg.PATHSEG_LINETO_REL;
            case "C":
              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;
            case "c":
              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;
            case "Q":
              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;
            case "q":
              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;
            case "A":
              return window.SVGPathSeg.PATHSEG_ARC_ABS;
            case "a":
              return window.SVGPathSeg.PATHSEG_ARC_REL;
            case "H":
              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;
            case "h":
              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;
            case "V":
              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;
            case "v":
              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;
            case "S":
              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
            case "s":
              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
            case "T":
              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
            case "t":
              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
            default:
              return window.SVGPathSeg.PATHSEG_UNKNOWN;
          }
        };
        Source.prototype._nextCommandHelper = function(lookahead, previousCommand) {
          if ((lookahead == "+" || lookahead == "-" || lookahead == "." || lookahead >= "0" && lookahead <= "9") && previousCommand != window.SVGPathSeg.PATHSEG_CLOSEPATH) {
            if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_ABS) return window.SVGPathSeg.PATHSEG_LINETO_ABS;
            if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_REL) return window.SVGPathSeg.PATHSEG_LINETO_REL;
            return previousCommand;
          }
          return window.SVGPathSeg.PATHSEG_UNKNOWN;
        };
        Source.prototype.initialCommandIsMoveTo = function() {
          if (!this.hasMoreData()) return true;
          var command = this.peekSegmentType();
          return command == window.SVGPathSeg.PATHSEG_MOVETO_ABS || command == window.SVGPathSeg.PATHSEG_MOVETO_REL;
        };
        Source.prototype._parseNumber = function() {
          var exponent = 0;
          var integer = 0;
          var frac = 1;
          var decimal = 0;
          var sign = 1;
          var expsign = 1;
          var startIndex = this._currentIndex;
          this._skipOptionalSpaces();
          if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "+") this._currentIndex++;
          else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "-") {
            this._currentIndex++;
            sign = -1;
          }
          if (this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") && this._string.charAt(this._currentIndex) != ".")
            return void 0;
          var startIntPartIndex = this._currentIndex;
          while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") this._currentIndex++;
          if (this._currentIndex != startIntPartIndex) {
            var scanIntPartIndex = this._currentIndex - 1;
            var multiplier = 1;
            while (scanIntPartIndex >= startIntPartIndex) {
              integer += multiplier * (this._string.charAt(scanIntPartIndex--) - "0");
              multiplier *= 10;
            }
          }
          if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ".") {
            this._currentIndex++;
            if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return void 0;
            while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {
              frac *= 10;
              decimal += (this._string.charAt(this._currentIndex) - "0") / frac;
              this._currentIndex += 1;
            }
          }
          if (this._currentIndex != startIndex && this._currentIndex + 1 < this._endIndex && (this._string.charAt(this._currentIndex) == "e" || this._string.charAt(this._currentIndex) == "E") && this._string.charAt(this._currentIndex + 1) != "x" && this._string.charAt(this._currentIndex + 1) != "m") {
            this._currentIndex++;
            if (this._string.charAt(this._currentIndex) == "+") {
              this._currentIndex++;
            } else if (this._string.charAt(this._currentIndex) == "-") {
              this._currentIndex++;
              expsign = -1;
            }
            if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return void 0;
            while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {
              exponent *= 10;
              exponent += this._string.charAt(this._currentIndex) - "0";
              this._currentIndex++;
            }
          }
          var number = integer + decimal;
          number *= sign;
          if (exponent) number *= Math.pow(10, expsign * exponent);
          if (startIndex == this._currentIndex) return void 0;
          this._skipOptionalSpacesOrDelimiter();
          return number;
        };
        Source.prototype._parseArcFlag = function() {
          if (this._currentIndex >= this._endIndex) return void 0;
          var flag = false;
          var flagChar = this._string.charAt(this._currentIndex++);
          if (flagChar == "0") flag = false;
          else if (flagChar == "1") flag = true;
          else return void 0;
          this._skipOptionalSpacesOrDelimiter();
          return flag;
        };
        Source.prototype.parseSegment = function() {
          var lookahead = this._string[this._currentIndex];
          var command = this._pathSegTypeFromChar(lookahead);
          if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) {
            if (this._previousCommand == window.SVGPathSeg.PATHSEG_UNKNOWN) return null;
            command = this._nextCommandHelper(lookahead, this._previousCommand);
            if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) return null;
          } else {
            this._currentIndex++;
          }
          this._previousCommand = command;
          switch (command) {
            case window.SVGPathSeg.PATHSEG_MOVETO_REL:
              return new window.SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
            case window.SVGPathSeg.PATHSEG_MOVETO_ABS:
              return new window.SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
            case window.SVGPathSeg.PATHSEG_LINETO_REL:
              return new window.SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
            case window.SVGPathSeg.PATHSEG_LINETO_ABS:
              return new window.SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
            case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
              return new window.SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());
            case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
              return new window.SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());
            case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:
              return new window.SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());
            case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
              return new window.SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());
            case window.SVGPathSeg.PATHSEG_CLOSEPATH:
              this._skipOptionalSpaces();
              return new window.SVGPathSegClosePath(owningPathSegList);
            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:
              var points = {
                x1: this._parseNumber(),
                y1: this._parseNumber(),
                x2: this._parseNumber(),
                y2: this._parseNumber(),
                x: this._parseNumber(),
                y: this._parseNumber()
              };
              return new window.SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
              var points = {
                x1: this._parseNumber(),
                y1: this._parseNumber(),
                x2: this._parseNumber(),
                y2: this._parseNumber(),
                x: this._parseNumber(),
                y: this._parseNumber()
              };
              return new window.SVGPathSegCurvetoCubicAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
              var points = {
                x2: this._parseNumber(),
                y2: this._parseNumber(),
                x: this._parseNumber(),
                y: this._parseNumber()
              };
              return new window.SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, points.x, points.y, points.x2, points.y2);
            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
              var points = {
                x2: this._parseNumber(),
                y2: this._parseNumber(),
                x: this._parseNumber(),
                y: this._parseNumber()
              };
              return new window.SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, points.x, points.y, points.x2, points.y2);
            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
              var points = {
                x1: this._parseNumber(),
                y1: this._parseNumber(),
                x: this._parseNumber(),
                y: this._parseNumber()
              };
              return new window.SVGPathSegCurvetoQuadraticRel(owningPathSegList, points.x, points.y, points.x1, points.y1);
            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
              var points = {
                x1: this._parseNumber(),
                y1: this._parseNumber(),
                x: this._parseNumber(),
                y: this._parseNumber()
              };
              return new window.SVGPathSegCurvetoQuadraticAbs(owningPathSegList, points.x, points.y, points.x1, points.y1);
            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:
              return new window.SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());
            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:
              return new window.SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
            case window.SVGPathSeg.PATHSEG_ARC_REL:
              var points = {
                x1: this._parseNumber(),
                y1: this._parseNumber(),
                arcAngle: this._parseNumber(),
                arcLarge: this._parseArcFlag(),
                arcSweep: this._parseArcFlag(),
                x: this._parseNumber(),
                y: this._parseNumber()
              };
              return new window.SVGPathSegArcRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
            case window.SVGPathSeg.PATHSEG_ARC_ABS:
              var points = {
                x1: this._parseNumber(),
                y1: this._parseNumber(),
                arcAngle: this._parseNumber(),
                arcLarge: this._parseArcFlag(),
                arcSweep: this._parseArcFlag(),
                x: this._parseNumber(),
                y: this._parseNumber()
              };
              return new window.SVGPathSegArcAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
            default:
              throw "Unknown path seg type.";
          }
        };
        var builder = new Builder();
        var source = new Source(string);
        if (!source.initialCommandIsMoveTo()) return [];
        while (source.hasMoreData()) {
          var pathSeg = source.parseSegment();
          if (!pathSeg) return [];
          builder.appendSegment(pathSeg);
        }
        return builder.pathSegList;
      };
    }
  })();
  var Paint = class {
    /**
     * @param {module:jGraduate.jGraduatePaintOptions} [opt]
     */
    constructor(opt) {
      const options = opt || {};
      this.alpha = isNaN(options.alpha) ? 100 : options.alpha;
      if (options.copy) {
        this.type = options.copy.type;
        this.alpha = options.copy.alpha;
        this.solidColor = null;
        this.linearGradient = null;
        this.radialGradient = null;
        switch (this.type) {
          case "none":
            break;
          case "solidColor":
            this.solidColor = options.copy.solidColor;
            break;
          case "linearGradient":
            this.linearGradient = options.copy.linearGradient.cloneNode(true);
            break;
          case "radialGradient":
            this.radialGradient = options.copy.radialGradient.cloneNode(true);
            break;
        }
      } else if (options.linearGradient) {
        this.type = "linearGradient";
        this.solidColor = null;
        this.radialGradient = null;
        const hrefAttr = options.linearGradient.getAttribute("href") || options.linearGradient.getAttribute("xlink:href");
        if (hrefAttr) {
          const xhref = document.getElementById(hrefAttr.replace(/^#/, ""));
          this.linearGradient = xhref.cloneNode(true);
        } else {
          this.linearGradient = options.linearGradient.cloneNode(true);
        }
      } else if (options.radialGradient) {
        this.type = "radialGradient";
        this.solidColor = null;
        this.linearGradient = null;
        const hrefAttr = options.radialGradient.getAttribute("href") || options.radialGradient.getAttribute("xlink:href");
        if (hrefAttr) {
          const xhref = document.getElementById(hrefAttr.replace(/^#/, ""));
          this.radialGradient = xhref.cloneNode(true);
        } else {
          this.radialGradient = options.radialGradient.cloneNode(true);
        }
      } else if (options.solidColor) {
        this.type = "solidColor";
        this.solidColor = options.solidColor;
      } else {
        this.type = "none";
        this.solidColor = null;
        this.linearGradient = null;
        this.radialGradient = null;
      }
    }
  };
  var NSSVG$1 = "http://www.w3.org/2000/svg";
  var wAttrs = ["x", "x1", "cx", "rx", "width"];
  var hAttrs = ["y", "y1", "cy", "ry", "height"];
  var unitAttrs = ["r", "radius", ...wAttrs, ...hAttrs];
  var elementContainer_;
  var typeMap_ = {};
  var init$k = function(elementContainer) {
    elementContainer_ = elementContainer;
    const svg2 = document.createElementNS(NSSVG$1, "svg");
    document.body.append(svg2);
    const rect = document.createElementNS(NSSVG$1, "rect");
    rect.setAttribute("width", "1em");
    rect.setAttribute("height", "1ex");
    rect.setAttribute("x", "1in");
    svg2.append(rect);
    const bb = rect.getBBox();
    svg2.remove();
    const inch = bb.x;
    typeMap_ = {
      em: bb.width,
      ex: bb.height,
      in: inch,
      cm: inch / 2.54,
      mm: inch / 25.4,
      pt: inch / 72,
      pc: inch / 6,
      px: 1,
      "%": 0
    };
  };
  var getTypeMap = () => {
    return typeMap_;
  };
  var shortFloat = (val) => {
    const digits = elementContainer_.getRoundDigits();
    if (!isNaN(val)) {
      return Number(Number(val).toFixed(digits));
    }
    if (Array.isArray(val)) {
      return shortFloat(val[0]) + "," + shortFloat(val[1]);
    }
    return Number.parseFloat(val).toFixed(digits) - 0;
  };
  var convertUnit = (val, unit) => {
    unit = unit || elementContainer_.getBaseUnit();
    return shortFloat(val / typeMap_[unit]);
  };
  var setUnitAttr = (elem, attr, val) => {
    elem.setAttribute(attr, val);
  };
  var convertToNum = (attr, val) => {
    if (!isNaN(val)) {
      return val - 0;
    }
    if (val.substr(-1) === "%") {
      const num2 = val.substr(0, val.length - 1) / 100;
      const width = elementContainer_.getWidth();
      const height = elementContainer_.getHeight();
      if (wAttrs.includes(attr)) {
        return num2 * width;
      }
      if (hAttrs.includes(attr)) {
        return num2 * height;
      }
      return num2 * Math.sqrt(width * width + height * height) / Math.sqrt(2);
    }
    const unit = val.substr(-2);
    const num = val.substr(0, val.length - 2);
    return num * typeMap_[unit];
  };
  var isValidUnit = (attr, val, selectedElement) => {
    if (unitAttrs.includes(attr)) {
      if (!isNaN(val)) {
        return true;
      }
      val = val.toLowerCase();
      return Object.keys(typeMap_).some((unit) => {
        const re2 = new RegExp("^-?[\\d\\.]+" + unit + "$");
        return re2.test(val);
      });
    }
    if (attr === "id") {
      let result = false;
      try {
        const elem = elementContainer_.getElement(val);
        result = !elem || elem === selectedElement;
      } catch (e2) {
        console.error(e2);
      }
      return result;
    }
    return true;
  };
  var NS = {
    HTML: "http://www.w3.org/1999/xhtml",
    MATH: "http://www.w3.org/1998/Math/MathML",
    SE: "http://svg-edit.googlecode.com",
    SVG: "http://www.w3.org/2000/svg",
    XLINK: "http://www.w3.org/1999/xlink",
    OI: "http://www.optimistik.fr/namespace/svg/OIdata",
    XML: "http://www.w3.org/XML/1998/namespace",
    XMLNS: "http://www.w3.org/2000/xmlns/"
    // see http://www.w3.org/TR/REC-xml-names/#xmlReserved
    // SODIPODI: 'http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd',
    // INKSCAPE: 'http://www.inkscape.org/namespaces/inkscape',
    // RDF: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    // OSB: 'http://www.openswatchbook.org/uri/2009/osb',
    // CC: 'http://creativecommons.org/ns#',
    // DC: 'http://purl.org/dc/elements/1.1/'
  };
  var getReverseNS = function() {
    const reverseNS = {};
    Object.entries(NS).forEach(([name, URI]) => {
      reverseNS[URI] = name.toLowerCase();
    });
    return reverseNS;
  };
  var NEAR_ZERO = 1e-10;
  var svg$2 = document.createElementNS(NS.SVG, "svg");
  var transformPoint = (x2, y2, m2) => ({
    x: m2.a * x2 + m2.c * y2 + m2.e,
    y: m2.b * x2 + m2.d * y2 + m2.f
  });
  var getTransformList = (elem) => {
    if (elem.transform?.baseVal) {
      return elem.transform.baseVal;
    }
    if (elem.gradientTransform?.baseVal) {
      return elem.gradientTransform.baseVal;
    }
    if (elem.patternTransform?.baseVal) {
      return elem.patternTransform.baseVal;
    }
    console.warn("No transform list found. Check browser compatibility.", elem);
  };
  var isIdentity = (m2) => m2.a === 1 && m2.b === 0 && m2.c === 0 && m2.d === 1 && m2.e === 0 && m2.f === 0;
  var matrixMultiply = (...args) => {
    if (args.length === 0) {
      return svg$2.createSVGMatrix();
    }
    const m2 = args.reduceRight((prev, curr) => curr.multiply(prev));
    if (Math.abs(m2.a) < NEAR_ZERO) m2.a = 0;
    if (Math.abs(m2.b) < NEAR_ZERO) m2.b = 0;
    if (Math.abs(m2.c) < NEAR_ZERO) m2.c = 0;
    if (Math.abs(m2.d) < NEAR_ZERO) m2.d = 0;
    if (Math.abs(m2.e) < NEAR_ZERO) m2.e = 0;
    if (Math.abs(m2.f) < NEAR_ZERO) m2.f = 0;
    return m2;
  };
  var hasMatrixTransform = (tlist) => {
    if (!tlist) return false;
    for (let i2 = 0; i2 < tlist.numberOfItems; i2++) {
      const xform = tlist.getItem(i2);
      if (xform.type === SVGTransform.SVG_TRANSFORM_MATRIX && !isIdentity(xform.matrix)) {
        return true;
      }
    }
    return false;
  };
  var transformBox = (l2, t3, w2, h2, m2) => {
    const tl = transformPoint(l2, t3, m2);
    const tr = transformPoint(l2 + w2, t3, m2);
    const bl = transformPoint(l2, t3 + h2, m2);
    const br = transformPoint(l2 + w2, t3 + h2, m2);
    const minx = Math.min(tl.x, tr.x, bl.x, br.x);
    const maxx = Math.max(tl.x, tr.x, bl.x, br.x);
    const miny = Math.min(tl.y, tr.y, bl.y, br.y);
    const maxy = Math.max(tl.y, tr.y, bl.y, br.y);
    return {
      tl,
      tr,
      bl,
      br,
      aabox: {
        x: minx,
        y: miny,
        width: maxx - minx,
        height: maxy - miny
      }
    };
  };
  var transformListToTransform = (tlist, min = 0, max2 = null) => {
    if (!tlist) {
      return svg$2.createSVGTransformFromMatrix(svg$2.createSVGMatrix());
    }
    const start = Number.parseInt(min, 10);
    const end = Number.parseInt(max2 ?? tlist.numberOfItems - 1, 10);
    const low = Math.min(start, end);
    const high = Math.max(start, end);
    let combinedMatrix = svg$2.createSVGMatrix();
    for (let i2 = low; i2 <= high; i2++) {
      const currentMatrix = i2 >= 0 && i2 < tlist.numberOfItems ? tlist.getItem(i2).matrix : svg$2.createSVGMatrix();
      combinedMatrix = matrixMultiply(combinedMatrix, currentMatrix);
    }
    return svg$2.createSVGTransformFromMatrix(combinedMatrix);
  };
  var getMatrix = (elem) => {
    const tlist = getTransformList(elem);
    return transformListToTransform(tlist).matrix;
  };
  var snapToAngle = (x1, y1, x2, y2) => {
    const snap = Math.PI / 4;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const angle2 = Math.atan2(dy, dx);
    const dist = Math.hypot(dx, dy);
    const snapAngle = Math.round(angle2 / snap) * snap;
    return {
      x: x1 + dist * Math.cos(snapAngle),
      y: y1 + dist * Math.sin(snapAngle),
      a: snapAngle
    };
  };
  var rectsIntersect = (r1, r2) => r2.x < r1.x + r1.width && r2.x + r2.width > r1.x && r2.y < r1.y + r1.height && r2.y + r2.height > r1.y;
  function findPos(obj) {
    let curleft = 0;
    let curtop = 0;
    if (obj.offsetParent) {
      do {
        curleft += obj.offsetLeft;
        curtop += obj.offsetTop;
      } while (obj = obj.offsetParent);
      return {
        left: curleft,
        top: curtop
      };
    }
    return {
      left: curleft,
      top: curtop
    };
  }
  function isObject$1(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
  function mergeDeep(target, source) {
    const output = Object.assign({}, target);
    if (isObject$1(target) && isObject$1(source)) {
      Object.keys(source).forEach((key) => {
        if (isObject$1(source[key])) {
          if (!(key in target)) {
            Object.assign(output, {
              [key]: source[key]
            });
          } else {
            output[key] = mergeDeep(target[key], source[key]);
          }
        } else {
          Object.assign(output, {
            [key]: source[key]
          });
        }
      });
    }
    return output;
  }
  function getClosest(elem, selector) {
    const firstChar = selector.charAt(0);
    const supports = "classList" in document.documentElement;
    let attribute;
    let value;
    if (firstChar === "[") {
      selector = selector.substr(1, selector.length - 2);
      attribute = selector.split("=");
      if (attribute.length > 1) {
        value = true;
        attribute[1] = attribute[1].replace(/"/g, "").replace(/'/g, "");
      }
    }
    for (; elem && elem !== document && elem.nodeType === 1; elem = elem.parentNode) {
      if (firstChar === ".") {
        if (supports) {
          if (elem.classList.contains(selector.substr(1))) {
            return elem;
          }
        } else {
          if (new RegExp("(^|\\s)" + selector.substr(1) + "(\\s|$)").test(elem.className)) {
            return elem;
          }
        }
      }
      if (firstChar === "#") {
        if (elem.id === selector.substr(1)) {
          return elem;
        }
      }
      if (firstChar === "[") {
        if (elem.hasAttribute(attribute[0])) {
          if (value) {
            if (elem.getAttribute(attribute[0]) === attribute[1]) {
              return elem;
            }
          } else {
            return elem;
          }
        }
      }
      if (elem.tagName.toLowerCase() === selector) {
        return elem;
      }
    }
    return null;
  }
  function getParents(elem, selector) {
    const parents = [];
    const firstChar = selector?.charAt(0);
    for (; elem && elem !== document; elem = elem.parentNode) {
      if (selector) {
        if (firstChar === ".") {
          if (elem.classList.contains(selector.substr(1))) {
            parents.push(elem);
          }
        }
        if (firstChar === "#") {
          if (elem.id === selector.substr(1)) {
            parents.push(elem);
          }
        }
        if (firstChar === "[") {
          if (elem.hasAttribute(selector.substr(1, selector.length - 1))) {
            parents.push(elem);
          }
        }
        if (elem.tagName.toLowerCase() === selector) {
          parents.push(elem);
        }
      } else {
        parents.push(elem);
      }
    }
    return parents.length ? parents : null;
  }
  function getParentsUntil(elem, parent, selector) {
    const parents = [];
    const parentType = parent?.charAt(0);
    for (; elem && elem !== document; elem = elem.parentNode) {
      {
        if (parentType === ".") {
          if (elem.classList.contains(parent.substr(1))) {
            break;
          }
        }
        if (parentType === "#") {
          if (elem.id === parent.substr(1)) {
            break;
          }
        }
        if (parentType === "[") {
          if (elem.hasAttribute(parent.substr(1, parent.length - 1))) {
            break;
          }
        }
        if (elem.tagName.toLowerCase() === parent) {
          break;
        }
      }
      {
        parents.push(elem);
      }
    }
    return parents.length ? parents : null;
  }
  var visElems$2 = "a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use,clipPath";
  var visElemsArr = visElems$2.split(",");
  var svgCanvas$i = null;
  var svgroot_ = null;
  var init$j = (canvas) => {
    svgCanvas$i = canvas;
    svgroot_ = canvas.getSvgRoot();
  };
  var toXml = (str) => {
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  };
  function encode64(input) {
    input = encodeUTF8(input);
    return window.btoa(input);
  }
  function decode64(input) {
    return decodeUTF8(window.atob(input));
  }
  function hashCode(word) {
    let hash = 0;
    let chr;
    if (word.length === 0) return hash;
    for (let i2 = 0; i2 < word.length; i2++) {
      chr = word.charCodeAt(i2);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return hash;
  }
  function decodeUTF8(argString) {
    return decodeURIComponent(escape(argString));
  }
  var encodeUTF8 = (argString) => {
    return unescape(encodeURIComponent(argString));
  };
  var createObjectURL = (blob) => {
    if (!blob || typeof URL === "undefined" || !URL.createObjectURL) {
      return "";
    }
    return URL.createObjectURL(blob);
  };
  var blankPageObjectURL = (() => {
    if (typeof Blob === "undefined") {
      return "";
    }
    const blob = new Blob(["<html><head><title>SVG-edit</title></head><body>&nbsp;</body></html>"], {
      type: "text/html"
    });
    return createObjectURL(blob);
  })();
  var text2xml = (sXML) => {
    if (sXML.includes("<svg:svg")) {
      sXML = sXML.replace(/<(\/?)svg:/g, "<$1").replace("xmlns:svg", "xmlns");
    }
    let out;
    let dXML;
    try {
      dXML = new DOMParser();
      dXML.async = false;
    } catch (e2) {
      throw new Error("XML Parser could not be instantiated");
    }
    try {
      out = dXML.parseFromString(sXML, "text/xml");
    } catch (e2) {
      throw new Error("Error parsing XML string");
    }
    return out;
  };
  var bboxToObj = ({
    x: x2,
    y: y2,
    width,
    height
  }) => {
    return {
      x: x2,
      y: y2,
      width,
      height
    };
  };
  var walkTree = (elem, cbFn) => {
    if (elem?.nodeType === 1) {
      cbFn(elem);
      let i2 = elem.childNodes.length;
      while (i2--) {
        walkTree(elem.childNodes.item(i2), cbFn);
      }
    }
  };
  var walkTreePost = (elem, cbFn) => {
    if (elem?.nodeType === 1) {
      let i2 = elem.childNodes.length;
      while (i2--) {
        walkTree(elem.childNodes.item(i2), cbFn);
      }
      cbFn(elem);
    }
  };
  var getUrlFromAttr = function(attrVal) {
    if (attrVal) {
      if (attrVal.startsWith('url("')) {
        return attrVal.substring(5, attrVal.indexOf('"', 6));
      }
      if (attrVal.startsWith("url('")) {
        return attrVal.substring(5, attrVal.indexOf("'", 6));
      }
      if (attrVal.startsWith("url(")) {
        return attrVal.substring(4, attrVal.indexOf(")"));
      }
    }
    return null;
  };
  var getHref = function(elem) {
    return elem.getAttribute("href") || elem.getAttributeNS(NS.XLINK, "href");
  };
  var setHref = function(elem, val) {
    elem.setAttribute("href", val);
  };
  var findDefs = function() {
    const svgElement = svgCanvas$i.getSvgContent();
    let defs = svgElement.getElementsByTagNameNS(NS.SVG, "defs");
    if (defs.length > 0) {
      defs = defs[0];
    } else {
      defs = svgElement.ownerDocument.createElementNS(NS.SVG, "defs");
      if (svgElement.firstChild) {
        svgElement.insertBefore(defs, svgElement.firstChild.nextSibling);
      } else {
        svgElement.append(defs);
      }
    }
    return defs;
  };
  var getBBox = function(elem) {
    const selected = elem || svgCanvas$i.getSelectedElements()[0];
    if (elem.nodeType !== 1) {
      return null;
    }
    const elname = selected.nodeName;
    let ret = null;
    switch (elname) {
      case "text":
        if (selected.textContent === "") {
          selected.textContent = "a";
          ret = selected.getBBox();
          selected.textContent = "";
        } else if (selected.getBBox) {
          ret = selected.getBBox();
        }
        break;
      case "path":
      case "g":
      case "a":
        if (selected.getBBox) {
          ret = selected.getBBox();
        }
        break;
      default:
        if (elname === "use") {
          ret = selected.getBBox();
        } else if (visElemsArr.includes(elname)) {
          if (selected) {
            try {
              ret = selected.getBBox();
            } catch (err2) {
              const extent = selected.getExtentOfChar(0);
              const width = selected.getComputedTextLength();
              ret = {
                x: extent.x,
                y: extent.y,
                width,
                height: extent.height
              };
            }
          } else {
            const fo = getClosest(selected.parentNode, "foreignObject");
            if (fo.length && fo[0].getBBox) {
              ret = fo[0].getBBox();
            }
          }
        }
    }
    if (ret) {
      ret = bboxToObj(ret);
    }
    return ret;
  };
  var getPathDFromSegments = function(pathSegments) {
    let d2 = "";
    pathSegments.forEach(function([singleChar, pts], _j) {
      d2 += singleChar;
      for (let i2 = 0; i2 < pts.length; i2 += 2) {
        d2 += pts[i2] + "," + pts[i2 + 1] + " ";
      }
    });
    return d2;
  };
  var getPathDFromElement = function(elem) {
    let num = 1.81;
    let d2;
    let rx;
    let ry;
    switch (elem.tagName) {
      case "ellipse":
      case "circle": {
        rx = Number(elem.getAttribute("rx"));
        ry = Number(elem.getAttribute("ry"));
        const cx = Number(elem.getAttribute("cx"));
        const cy = Number(elem.getAttribute("cy"));
        if (elem.tagName === "circle" && elem.hasAttribute("r")) {
          ry = Number(elem.getAttribute("r"));
          rx = ry;
        }
        d2 = getPathDFromSegments([["M", [cx - rx, cy]], ["C", [cx - rx, cy - ry / num, cx - rx / num, cy - ry, cx, cy - ry]], ["C", [cx + rx / num, cy - ry, cx + rx, cy - ry / num, cx + rx, cy]], ["C", [cx + rx, cy + ry / num, cx + rx / num, cy + ry, cx, cy + ry]], ["C", [cx - rx / num, cy + ry, cx - rx, cy + ry / num, cx - rx, cy]], ["Z", []]]);
        break;
      }
      case "path":
        d2 = elem.getAttribute("d");
        break;
      case "line":
        {
          const x1 = elem.getAttribute("x1");
          const y1 = elem.getAttribute("y1");
          const x2 = elem.getAttribute("x2");
          const y2 = elem.getAttribute("y2");
          d2 = "M" + x1 + "," + y1 + "L" + x2 + "," + y2;
        }
        break;
      case "polyline":
        d2 = "M" + elem.getAttribute("points");
        break;
      case "polygon":
        d2 = "M" + elem.getAttribute("points") + " Z";
        break;
      case "rect": {
        rx = Number(elem.getAttribute("rx"));
        ry = Number(elem.getAttribute("ry"));
        const b2 = elem.getBBox();
        const {
          x: x2,
          y: y2
        } = b2;
        const w2 = b2.width;
        const h2 = b2.height;
        num = 4 - num;
        d2 = !rx && !ry ? getPathDFromSegments([["M", [x2, y2]], ["L", [x2 + w2, y2]], ["L", [x2 + w2, y2 + h2]], ["L", [x2, y2 + h2]], ["L", [x2, y2]], ["Z", []]]) : getPathDFromSegments([["M", [x2, y2 + ry]], ["C", [x2, y2 + ry / num, x2 + rx / num, y2, x2 + rx, y2]], ["L", [x2 + w2 - rx, y2]], ["C", [x2 + w2 - rx / num, y2, x2 + w2, y2 + ry / num, x2 + w2, y2 + ry]], ["L", [x2 + w2, y2 + h2 - ry]], ["C", [x2 + w2, y2 + h2 - ry / num, x2 + w2 - rx / num, y2 + h2, x2 + w2 - rx, y2 + h2]], ["L", [x2 + rx, y2 + h2]], ["C", [x2 + rx / num, y2 + h2, x2, y2 + h2 - ry / num, x2, y2 + h2 - ry]], ["L", [x2, y2 + ry]], ["Z", []]]);
        break;
      }
    }
    return d2;
  };
  var getExtraAttributesForConvertToPath = function(elem) {
    const attrs = {};
    ["marker-start", "marker-end", "marker-mid", "filter", "clip-path"].forEach(function(item) {
      const a2 = elem.getAttribute(item);
      if (a2) {
        attrs[item] = a2;
      }
    });
    return attrs;
  };
  var getBBoxOfElementAsPath = function(elem, addSVGElementsFromJson2, pathActions2) {
    const path2 = addSVGElementsFromJson2({
      element: "path",
      attr: getExtraAttributesForConvertToPath(elem)
    });
    const eltrans = elem.getAttribute("transform");
    if (eltrans) {
      path2.setAttribute("transform", eltrans);
    }
    const {
      parentNode
    } = elem;
    if (elem.nextSibling) {
      elem.before(path2);
    } else {
      parentNode.append(path2);
    }
    const d2 = getPathDFromElement(elem);
    if (d2) {
      path2.setAttribute("d", d2);
    } else {
      path2.remove();
    }
    pathActions2.resetOrientation(path2);
    let bb = false;
    try {
      bb = path2.getBBox();
    } catch (e2) {
    }
    path2.remove();
    return bb;
  };
  var convertToPath = (elem, attrs, svgCanvas2) => {
    const batchCmd = new svgCanvas2.history.BatchCommand("Convert element to Path");
    attrs = mergeDeep(attrs, getExtraAttributesForConvertToPath(elem));
    const path2 = svgCanvas2.addSVGElementsFromJson({
      element: "path",
      attr: attrs
    });
    const eltrans = elem.getAttribute("transform");
    if (eltrans) {
      path2.setAttribute("transform", eltrans);
    }
    const {
      id
    } = elem;
    const {
      parentNode
    } = elem;
    if (elem.nextSibling) {
      elem.before(path2);
    } else {
      parentNode.append(path2);
    }
    const d2 = getPathDFromElement(elem);
    if (d2) {
      path2.setAttribute("d", d2);
      if (eltrans) {
        const tlist = getTransformList(path2);
        if (hasMatrixTransform(tlist)) {
          svgCanvas2.pathActions.resetOrientation(path2);
        }
      }
      const {
        nextSibling
      } = elem;
      batchCmd.addSubCommand(new svgCanvas2.history.RemoveElementCommand(elem, nextSibling, elem.parentNode));
      svgCanvas2.clearSelection();
      elem.remove();
      batchCmd.addSubCommand(new svgCanvas2.history.InsertElementCommand(path2));
      path2.setAttribute("id", id);
      path2.removeAttribute("visibility");
      svgCanvas2.addToSelection([path2], true);
      svgCanvas2.addCommandToHistory(batchCmd);
      return path2;
    }
    path2.remove();
    return null;
  };
  function bBoxCanBeOptimizedOverNativeGetBBox(angle2, hasAMatrixTransform) {
    const angleModulo90 = angle2 % 90;
    const closeTo90 = angleModulo90 < -89.99 || angleModulo90 > 89.99;
    const closeTo0 = angleModulo90 > -1e-3 && angleModulo90 < 1e-3;
    return hasAMatrixTransform || !(closeTo0 || closeTo90);
  }
  var getBBoxWithTransform = function(elem, addSVGElementsFromJson2, pathActions2) {
    let bb = getBBox(elem);
    if (!bb) {
      return null;
    }
    const tlist = getTransformList(elem);
    const angle2 = getRotationAngleFromTransformList(tlist);
    const hasMatrixXForm = hasMatrixTransform(tlist);
    if (angle2 || hasMatrixXForm) {
      let goodBb = false;
      if (bBoxCanBeOptimizedOverNativeGetBBox(angle2, hasMatrixXForm)) {
        const elemNames = ["ellipse", "path", "line", "polyline", "polygon"];
        if (elemNames.includes(elem.tagName)) {
          goodBb = getBBoxOfElementAsPath(elem, addSVGElementsFromJson2, pathActions2);
          bb = goodBb;
        } else if (elem.tagName === "rect") {
          const rx = Number(elem.getAttribute("rx"));
          const ry = Number(elem.getAttribute("ry"));
          if (rx || ry) {
            goodBb = getBBoxOfElementAsPath(elem, addSVGElementsFromJson2, pathActions2);
            bb = goodBb;
          }
        }
      }
      if (!goodBb) {
        const {
          matrix: matrix2
        } = transformListToTransform(tlist);
        bb = transformBox(bb.x, bb.y, bb.width, bb.height, matrix2).aabox;
      }
    }
    return bb;
  };
  var getStrokeOffsetForBBox = (elem) => {
    const sw = elem.getAttribute("stroke-width");
    return !isNaN(sw) && elem.getAttribute("stroke") !== "none" ? sw / 2 : 0;
  };
  var getStrokedBBox = (elems, addSVGElementsFromJson2, pathActions2) => {
    if (!elems || !elems.length) {
      return false;
    }
    let fullBb;
    elems.forEach((elem) => {
      if (fullBb) {
        return;
      }
      if (!elem.parentNode) {
        return;
      }
      fullBb = getBBoxWithTransform(elem, addSVGElementsFromJson2, pathActions2);
    });
    if (!fullBb) {
      return null;
    }
    let maxX = fullBb.x + fullBb.width;
    let maxY = fullBb.y + fullBb.height;
    let minX = fullBb.x;
    let minY = fullBb.y;
    if (elems.length === 1) {
      const offset = getStrokeOffsetForBBox(elems[0]);
      minX -= offset;
      minY -= offset;
      maxX += offset;
      maxY += offset;
    } else {
      elems.forEach((elem) => {
        const curBb = getBBoxWithTransform(elem, addSVGElementsFromJson2, pathActions2);
        if (curBb) {
          const offset = getStrokeOffsetForBBox(elem);
          minX = Math.min(minX, curBb.x - offset);
          minY = Math.min(minY, curBb.y - offset);
          if (elem.nodeType === 1) {
            maxX = Math.max(maxX, curBb.x + curBb.width + offset);
            maxY = Math.max(maxY, curBb.y + curBb.height + offset);
          }
        }
      });
    }
    fullBb.x = shortFloat(minX);
    fullBb.y = shortFloat(minY);
    fullBb.width = shortFloat(maxX - minX);
    fullBb.height = shortFloat(maxY - minY);
    return fullBb;
  };
  var getVisibleElements = (parentElement) => {
    if (!parentElement) {
      const svgContent = svgCanvas$i.getSvgContent();
      for (let i2 = 0; i2 < svgContent.children.length; i2++) {
        if (svgContent.children[i2].getBBox) {
          const bbox = svgContent.children[i2].getBBox();
          if (bbox.width !== 0 && bbox.height !== 0 && bbox.width !== 0 && bbox.height !== 0) {
            parentElement = svgContent.children[i2];
            break;
          }
        }
      }
    }
    const contentElems = [];
    if (parentElement) {
      const children = parentElement.children;
      Array.from(children, (elem) => {
        if (elem.getBBox) {
          contentElems.push(elem);
        }
      });
    }
    return contentElems.reverse();
  };
  var getStrokedBBoxDefaultVisible = (elems) => {
    if (!elems) {
      elems = getVisibleElements();
    }
    return getStrokedBBox(elems, svgCanvas$i.addSVGElementsFromJson, svgCanvas$i.pathActions);
  };
  var getRotationAngleFromTransformList = (tlist, toRad) => {
    if (!tlist) {
      return 0;
    }
    for (let i2 = 0; i2 < tlist.numberOfItems; ++i2) {
      const xform = tlist.getItem(i2);
      if (xform.type === 4) {
        return toRad ? xform.angle * Math.PI / 180 : xform.angle;
      }
    }
    return 0;
  };
  var getRotationAngle = (elem, toRad) => {
    const selected = elem || svgCanvas$i.getSelectedElements()[0];
    const tlist = getTransformList(selected);
    return getRotationAngleFromTransformList(tlist, toRad);
  };
  var getRefElem = (attrVal) => {
    return getElement(getUrlFromAttr(attrVal).substr(1));
  };
  var getFeGaussianBlur = (ele) => {
    if (ele?.firstChild?.tagName === "feGaussianBlur") {
      return ele.firstChild;
    } else {
      const childrens = ele.children;
      for (const [_2, value] of Object.entries(childrens)) {
        if (value.tagName === "feGaussianBlur") {
          return value;
        }
      }
    }
    return null;
  };
  var getElement = (id) => {
    return svgroot_.querySelector("#" + id);
  };
  var assignAttributes = (elem, attrs, suspendLength, unitCheck) => {
    for (const [key, value] of Object.entries(attrs)) {
      const ns = key.substr(0, 4) === "xml:" ? NS.XML : key.substr(0, 6) === "xlink:" ? NS.XLINK : null;
      if (value === void 0) {
        if (ns) {
          elem.removeAttributeNS(ns, key);
        } else {
          elem.removeAttribute(key);
        }
        continue;
      }
      if (ns) {
        elem.setAttributeNS(ns, key, value);
      } else if (!unitCheck) {
        elem.setAttribute(key, value);
      } else {
        setUnitAttr(elem, key, value);
      }
    }
  };
  var cleanupElement = (element) => {
    const defaults = {
      "fill-opacity": 1,
      "stop-opacity": 1,
      opacity: 1,
      stroke: "none",
      "stroke-dasharray": "none",
      "stroke-linejoin": "miter",
      "stroke-linecap": "butt",
      "stroke-opacity": 1,
      "stroke-width": 1,
      rx: 0,
      ry: 0
    };
    if (element.nodeName === "ellipse") {
      delete defaults.rx;
      delete defaults.ry;
    }
    Object.entries(defaults).forEach(([attr, val]) => {
      if (element.getAttribute(attr) === String(val)) {
        element.removeAttribute(attr);
      }
    });
  };
  var snapToGrid = (value) => {
    const unit = svgCanvas$i.getBaseUnit();
    let stepSize = svgCanvas$i.getSnappingStep();
    if (unit !== "px") {
      stepSize *= getTypeMap()[unit];
    }
    value = Math.round(value / stepSize) * stepSize;
    return value;
  };
  var preventClickDefault = (img) => {
    $click(img, (e2) => {
      e2.preventDefault();
    });
  };
  var stringToHTML = (str) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(str, "text/html");
    return doc.body.firstChild;
  };
  var insertChildAtIndex = (parent, child, index2 = 0) => {
    const doc = stringToHTML(child);
    if (index2 >= parent.children.length) {
      parent.appendChild(doc);
    } else {
      parent.insertBefore(doc, parent.children[index2]);
    }
  };
  var $id = (id) => document.getElementById(id);
  var $qq = (sel) => document.querySelector(sel);
  var $qa = (sel) => [...document.querySelectorAll(sel)];
  var $click = (element, handler) => {
    element.addEventListener("click", handler);
    element.addEventListener("touchend", handler);
  };
  var HistoryEventTypes$1 = {
    BEFORE_APPLY: "before_apply",
    AFTER_APPLY: "after_apply",
    BEFORE_UNAPPLY: "before_unapply",
    AFTER_UNAPPLY: "after_unapply"
  };
  var Command = class {
    /**
    * @returns {string}
    */
    getText() {
      return this.text;
    }
    /**
     * @param {module:history.HistoryEventHandler} handler
     * @param {callback} applyFunction
     * @returns {void}
    */
    apply(handler, applyFunction) {
      handler && handler.handleHistoryEvent(HistoryEventTypes$1.BEFORE_APPLY, this);
      applyFunction(handler);
      handler && handler.handleHistoryEvent(HistoryEventTypes$1.AFTER_APPLY, this);
    }
    /**
     * @param {module:history.HistoryEventHandler} handler
     * @param {callback} unapplyFunction
     * @returns {void}
    */
    unapply(handler, unapplyFunction) {
      handler && handler.handleHistoryEvent(HistoryEventTypes$1.BEFORE_UNAPPLY, this);
      unapplyFunction();
      handler && handler.handleHistoryEvent(HistoryEventTypes$1.AFTER_UNAPPLY, this);
    }
    /**
     * @returns {Element[]} Array with element associated with this command
     * This function needs to be surcharged if multiple elements are returned.
    */
    elements() {
      return [this.elem];
    }
    /**
      * @returns {string} String with element associated with this command
    */
    type() {
      return this.constructor.name;
    }
  };
  var MoveElementCommand$1 = class MoveElementCommand extends Command {
    /**
    * @param {Element} elem - The DOM element that was moved
    * @param {Element} oldNextSibling - The element's next sibling before it was moved
    * @param {Element} oldParent - The element's parent before it was moved
    * @param {string} [text] - An optional string visible to user related to this change
    */
    constructor(elem, oldNextSibling, oldParent, text2) {
      super();
      this.elem = elem;
      this.text = text2 ? "Move " + elem.tagName + " to " + text2 : "Move " + elem.tagName;
      this.oldNextSibling = oldNextSibling;
      this.oldParent = oldParent;
      this.newNextSibling = elem.nextSibling;
      this.newParent = elem.parentNode;
    }
    /**
     * Re-positions the element.
     * @param {module:history.HistoryEventHandler} handler
     * @fires module:history~Command#event:history
     * @returns {void}
    */
    apply(handler) {
      super.apply(handler, () => {
        this.elem = this.newParent.insertBefore(this.elem, this.newNextSibling);
      });
    }
    /**
     * Positions the element back to its original location.
     * @param {module:history.HistoryEventHandler} handler
     * @fires module:history~Command#event:history
     * @returns {void}
    */
    unapply(handler) {
      super.unapply(handler, () => {
        this.elem = this.oldParent.insertBefore(this.elem, this.oldNextSibling);
      });
    }
  };
  var InsertElementCommand$4 = class InsertElementCommand extends Command {
    /**
     * @param {Element} elem - The newly added DOM element
     * @param {string} text - An optional string visible to user related to this change
    */
    constructor(elem, text2) {
      super();
      this.elem = elem;
      this.text = text2 || "Create " + elem.tagName;
      this.parent = elem.parentNode;
      this.nextSibling = this.elem.nextSibling;
    }
    /**
    * Re-inserts the new element.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */
    apply(handler) {
      super.apply(handler, () => {
        this.elem = this.parent.insertBefore(this.elem, this.nextSibling);
      });
    }
    /**
    * Removes the element.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */
    unapply(handler) {
      super.unapply(handler, () => {
        this.parent = this.elem.parentNode;
        this.elem.remove();
      });
    }
  };
  var RemoveElementCommand$2 = class RemoveElementCommand extends Command {
    /**
    * @param {Element} elem - The removed DOM element
    * @param {Node} oldNextSibling - The DOM element's nextSibling when it was in the DOM
    * @param {Element} oldParent - The DOM element's parent
    * @param {string} [text] - An optional string visible to user related to this change
    */
    constructor(elem, oldNextSibling, oldParent, text2) {
      super();
      this.elem = elem;
      this.text = text2 || "Delete " + elem.tagName;
      this.nextSibling = oldNextSibling;
      this.parent = oldParent;
    }
    /**
    * Re-removes the new element.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */
    apply(handler) {
      super.apply(handler, () => {
        this.parent = this.elem.parentNode;
        this.elem.remove();
      });
    }
    /**
    * Re-adds the new element.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */
    unapply(handler) {
      super.unapply(handler, () => {
        if (!this.nextSibling) {
          console.error("Reference element was lost");
        }
        this.parent.insertBefore(this.elem, this.nextSibling);
      });
    }
  };
  var ChangeElementCommand$2 = class ChangeElementCommand extends Command {
    /**
    * @param {Element} elem - The DOM element that was changed
    * @param {module:history.CommandAttributes} attrs - Attributes to be changed with the values they had *before* the change
    * @param {string} text - An optional string visible to user related to this change
     */
    constructor(elem, attrs, text2) {
      super();
      this.elem = elem;
      this.text = text2 ? "Change " + elem.tagName + " " + text2 : "Change " + elem.tagName;
      this.newValues = {};
      this.oldValues = attrs;
      for (const attr in attrs) {
        if (attr === "#text") {
          this.newValues[attr] = elem ? elem.textContent : "";
        } else if (attr === "#href") {
          this.newValues[attr] = getHref(elem);
        } else {
          this.newValues[attr] = elem.getAttribute(attr);
        }
      }
    }
    /**
    * Performs the stored change action.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */
    apply(handler) {
      super.apply(handler, () => {
        let bChangedTransform = false;
        Object.entries(this.newValues).forEach(([attr, value]) => {
          if (value) {
            if (attr === "#text") {
              this.elem.textContent = value;
            } else if (attr === "#href") {
              setHref(this.elem, value);
            } else {
              this.elem.setAttribute(attr, value);
            }
          } else if (attr === "#text") {
            this.elem.textContent = "";
          } else {
            this.elem.setAttribute(attr, "");
            this.elem.removeAttribute(attr);
          }
          if (attr === "transform") {
            bChangedTransform = true;
          }
        });
        if (!bChangedTransform) {
          const angle2 = getRotationAngle(this.elem);
          if (angle2) {
            const bbox = getBBox(this.elem);
            const cx = bbox.x + bbox.width / 2;
            const cy = bbox.y + bbox.height / 2;
            const rotate = ["rotate(", angle2, " ", cx, ",", cy, ")"].join("");
            if (rotate !== this.elem.getAttribute("transform")) {
              this.elem.setAttribute("transform", rotate);
            }
          }
        }
      });
    }
    /**
    * Reverses the stored change action.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */
    unapply(handler) {
      super.unapply(handler, () => {
        let bChangedTransform = false;
        Object.entries(this.oldValues).forEach(([attr, value]) => {
          if (value) {
            if (attr === "#text") {
              this.elem.textContent = value;
            } else if (attr === "#href") {
              setHref(this.elem, value);
            } else {
              this.elem.setAttribute(attr, value);
            }
          } else if (attr === "#text") {
            this.elem.textContent = "";
          } else {
            this.elem.removeAttribute(attr);
          }
          if (attr === "transform") {
            bChangedTransform = true;
          }
        });
        if (!bChangedTransform) {
          const angle2 = getRotationAngle(this.elem);
          if (angle2) {
            const bbox = getBBox(this.elem);
            const cx = bbox.x + bbox.width / 2;
            const cy = bbox.y + bbox.height / 2;
            const rotate = ["rotate(", angle2, " ", cx, ",", cy, ")"].join("");
            if (rotate !== this.elem.getAttribute("transform")) {
              this.elem.setAttribute("transform", rotate);
            }
          }
        }
      });
    }
  };
  var BatchCommand$4 = class BatchCommand extends Command {
    /**
    * @param {string} [text] - An optional string visible to user related to this change
    */
    constructor(text2) {
      super();
      this.text = text2 || "Batch Command";
      this.stack = [];
    }
    /**
    * Runs "apply" on all subcommands.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */
    apply(handler) {
      super.apply(handler, () => {
        this.stack.forEach((stackItem) => {
          console.assert(stackItem, "stack item should not be null");
          stackItem && stackItem.apply(handler);
        });
      });
    }
    /**
    * Runs "unapply" on all subcommands.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */
    unapply(handler) {
      super.unapply(handler, () => {
        [...this.stack].reverse().forEach((stackItem) => {
          console.assert(stackItem, "stack item should not be null");
          stackItem && stackItem.unapply(handler);
        });
      });
    }
    /**
    * Iterate through all our subcommands.
    * @returns {Element[]} All the elements we are changing
    */
    elements() {
      const elems = [];
      let cmd = this.stack.length;
      while (cmd--) {
        if (!this.stack[cmd]) continue;
        const thisElems = this.stack[cmd].elements();
        let elem = thisElems.length;
        while (elem--) {
          if (!elems.includes(thisElems[elem])) {
            elems.push(thisElems[elem]);
          }
        }
      }
      return elems;
    }
    /**
    * Adds a given command to the history stack.
    * @param {Command} cmd - The undo command object to add
    * @returns {void}
    */
    addSubCommand(cmd) {
      console.assert(cmd !== null, "cmd should not be null");
      this.stack.push(cmd);
    }
    /**
    * @returns {boolean} Indicates whether or not the batch command is empty
    */
    isEmpty() {
      return !this.stack.length;
    }
  };
  var UndoManager$1 = class UndoManager {
    /**
    * @param {module:history.HistoryEventHandler} historyEventHandler
    */
    constructor(historyEventHandler) {
      this.handler_ = historyEventHandler || null;
      this.undoStackPointer = 0;
      this.undoStack = [];
      this.undoChangeStackPointer = -1;
      this.undoableChangeStack = [];
    }
    /**
    * Resets the undo stack, effectively clearing the undo/redo history.
    * @returns {void}
    */
    resetUndoStack() {
      this.undoStack = [];
      this.undoStackPointer = 0;
    }
    /**
    * @returns {Integer} Current size of the undo history stack
    */
    getUndoStackSize() {
      return this.undoStackPointer;
    }
    /**
    * @returns {Integer} Current size of the redo history stack
    */
    getRedoStackSize() {
      return this.undoStack.length - this.undoStackPointer;
    }
    /**
    * @returns {string} String associated with the next undo command
    */
    getNextUndoCommandText() {
      return this.undoStackPointer > 0 ? this.undoStack[this.undoStackPointer - 1].getText() : "";
    }
    /**
    * @returns {string} String associated with the next redo command
    */
    getNextRedoCommandText() {
      return this.undoStackPointer < this.undoStack.length ? this.undoStack[this.undoStackPointer].getText() : "";
    }
    /**
    * Performs an undo step.
    * @returns {void}
    */
    undo() {
      if (this.undoStackPointer > 0) {
        const cmd = this.undoStack[--this.undoStackPointer];
        cmd.unapply(this.handler_);
      }
    }
    /**
    * Performs a redo step.
    * @returns {void}
    */
    redo() {
      if (this.undoStackPointer < this.undoStack.length && this.undoStack.length > 0) {
        const cmd = this.undoStack[this.undoStackPointer++];
        cmd.apply(this.handler_);
      }
    }
    /**
    * Adds a command object to the undo history stack.
    * @param {Command} cmd - The command object to add
    * @returns {void}
    */
    addCommandToHistory(cmd) {
      if (this.undoStackPointer < this.undoStack.length && this.undoStack.length > 0) {
        this.undoStack = this.undoStack.splice(0, this.undoStackPointer);
      }
      this.undoStack.push(cmd);
      this.undoStackPointer = this.undoStack.length;
    }
    /**
    * This function tells the canvas to remember the old values of the
    * `attrName` attribute for each element sent in.  The elements and values
    * are stored on a stack, so the next call to `finishUndoableChange()` will
    * pop the elements and old values off the stack, gets the current values
    * from the DOM and uses all of these to construct the undo-able command.
    * @param {string} attrName - The name of the attribute being changed
    * @param {Element[]} elems - Array of DOM elements being changed
    * @returns {void}
    */
    beginUndoableChange(attrName, elems) {
      const p2 = ++this.undoChangeStackPointer;
      let i2 = elems.length;
      const oldValues = new Array(i2);
      const elements2 = new Array(i2);
      while (i2--) {
        const elem = elems[i2];
        if (!elem) {
          continue;
        }
        elements2[i2] = elem;
        oldValues[i2] = elem.getAttribute(attrName);
      }
      this.undoableChangeStack[p2] = {
        attrName,
        oldValues,
        elements: elements2
      };
    }
    /**
    * This function returns a `BatchCommand` object which summarizes the
    * change since `beginUndoableChange` was called.  The command can then
    * be added to the command history.
    * @returns {BatchCommand} Batch command object with resulting changes
    */
    finishUndoableChange() {
      const p2 = this.undoChangeStackPointer--;
      const changeset = this.undoableChangeStack[p2];
      const {
        attrName
      } = changeset;
      const batchCmd = new BatchCommand$4("Change " + attrName);
      let i2 = changeset.elements.length;
      while (i2--) {
        const elem = changeset.elements[i2];
        if (!elem) {
          continue;
        }
        const changes = {};
        changes[attrName] = changeset.oldValues[i2];
        if (changes[attrName] !== elem.getAttribute(attrName)) {
          batchCmd.addSubCommand(new ChangeElementCommand$2(elem, changes, attrName));
        }
      }
      this.undoableChangeStack[p2] = null;
      return batchCmd;
    }
  };
  var history = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BatchCommand: BatchCommand$4,
    ChangeElementCommand: ChangeElementCommand$2,
    Command,
    HistoryEventTypes: HistoryEventTypes$1,
    InsertElementCommand: InsertElementCommand$4,
    MoveElementCommand: MoveElementCommand$1,
    RemoveElementCommand: RemoveElementCommand$2,
    UndoManager: UndoManager$1
  });
  var svgCanvas$h = null;
  var init$i = (canvas) => {
    svgCanvas$h = canvas;
  };
  var ptObjToArrMethod = function(type, segItem) {
    const segData2 = svgCanvas$h.getSegData();
    const props = segData2[type];
    return props.map((prop) => {
      return segItem[prop];
    });
  };
  var getGripPtMethod = function(seg, altPt) {
    const {
      path: pth
    } = seg;
    let out = {
      x: altPt ? altPt.x : seg.item.x,
      y: altPt ? altPt.y : seg.item.y
    };
    if (pth.matrix) {
      const pt2 = transformPoint(out.x, out.y, pth.matrix);
      out = pt2;
    }
    const zoom = svgCanvas$h.getZoom();
    out.x *= zoom;
    out.y *= zoom;
    return out;
  };
  var getPointFromGripMethod = function(pt2, pth) {
    const out = {
      x: pt2.x,
      y: pt2.y
    };
    if (pth.matrix) {
      pt2 = transformPoint(out.x, out.y, pth.imatrix);
      out.x = pt2.x;
      out.y = pt2.y;
    }
    const zoom = svgCanvas$h.getZoom();
    out.x /= zoom;
    out.y /= zoom;
    return out;
  };
  var getGripContainerMethod = function() {
    let c2 = getElement("pathpointgrip_container");
    if (!c2) {
      const parentElement = getElement("selectorParentGroup");
      c2 = document.createElementNS(NS.SVG, "g");
      parentElement.append(c2);
      c2.id = "pathpointgrip_container";
    }
    return c2;
  };
  var addPointGripMethod = function(index2, x2, y2) {
    const pointGripContainer = getGripContainerMethod();
    let pointGrip = getElement("pathpointgrip_" + index2);
    if (!pointGrip) {
      pointGrip = document.createElementNS(NS.SVG, "circle");
      const atts = {
        id: "pathpointgrip_" + index2,
        display: "none",
        r: 4,
        fill: "#0FF",
        stroke: "#00F",
        "stroke-width": 2,
        cursor: "move",
        style: "pointer-events:all"
      };
      const uiStrings2 = svgCanvas$h.getUIStrings();
      if ("pathNodeTooltip" in uiStrings2) {
        atts["xlink:title"] = uiStrings2.pathNodeTooltip;
      }
      assignAttributes(pointGrip, atts);
      pointGripContainer.append(pointGrip);
      const grip = document.getElementById("pathpointgrip_" + index2);
      grip?.addEventListener("dblclick", () => {
        const path2 = svgCanvas$h.getPathObj();
        if (path2) {
          path2.setSegType();
        }
      });
    }
    if (x2 && y2) {
      assignAttributes(pointGrip, {
        cx: x2,
        cy: y2,
        display: "inline"
      });
    }
    return pointGrip;
  };
  var addCtrlGripMethod = function(id) {
    let pointGrip = getElement("ctrlpointgrip_" + id);
    if (pointGrip) {
      return pointGrip;
    }
    pointGrip = document.createElementNS(NS.SVG, "circle");
    const atts = {
      id: "ctrlpointgrip_" + id,
      display: "none",
      r: 4,
      fill: "#0FF",
      stroke: "#55F",
      "stroke-width": 1,
      cursor: "move",
      style: "pointer-events:all"
    };
    const uiStrings2 = svgCanvas$h.getUIStrings();
    if ("pathCtrlPtTooltip" in uiStrings2) {
      atts["xlink:title"] = uiStrings2.pathCtrlPtTooltip;
    }
    assignAttributes(pointGrip, atts);
    getGripContainerMethod().append(pointGrip);
    return pointGrip;
  };
  var getCtrlLineMethod = function(id) {
    let ctrlLine = getElement("ctrlLine_" + id);
    if (ctrlLine) {
      return ctrlLine;
    }
    ctrlLine = document.createElementNS(NS.SVG, "line");
    assignAttributes(ctrlLine, {
      id: "ctrlLine_" + id,
      stroke: "#555",
      "stroke-width": 1,
      style: "pointer-events:none"
    });
    getGripContainerMethod().append(ctrlLine);
    return ctrlLine;
  };
  var getPointGripMethod = function(seg, update) {
    const {
      index: index2
    } = seg;
    const pointGrip = addPointGripMethod(index2);
    if (update) {
      const pt2 = getGripPtMethod(seg);
      assignAttributes(pointGrip, {
        cx: pt2.x,
        cy: pt2.y,
        display: "inline"
      });
    }
    return pointGrip;
  };
  var getControlPointsMethod = function(seg) {
    const {
      item,
      index: index2
    } = seg;
    if (!("x1" in item) || !("x2" in item)) {
      return null;
    }
    const cpt = {};
    getGripContainerMethod();
    const path2 = svgCanvas$h.getPathObj();
    const prev = path2.segs[index2 - 1].item;
    const segItems = [prev, item];
    for (let i2 = 1; i2 < 3; i2++) {
      const id = index2 + "c" + i2;
      const ctrlLine = cpt["c" + i2 + "_line"] = getCtrlLineMethod(id);
      const pt2 = getGripPtMethod(seg, {
        x: item["x" + i2],
        y: item["y" + i2]
      });
      const gpt = getGripPtMethod(seg, {
        x: segItems[i2 - 1].x,
        y: segItems[i2 - 1].y
      });
      assignAttributes(ctrlLine, {
        x1: pt2.x,
        y1: pt2.y,
        x2: gpt.x,
        y2: gpt.y,
        display: "inline"
      });
      cpt["c" + i2 + "_line"] = ctrlLine;
      const pointGrip = cpt["c" + i2] = addCtrlGripMethod(id);
      assignAttributes(pointGrip, {
        cx: pt2.x,
        cy: pt2.y,
        display: "inline"
      });
      cpt["c" + i2] = pointGrip;
    }
    return cpt;
  };
  var replacePathSegMethod = function(type, index2, pts, elem) {
    const path2 = svgCanvas$h.getPathObj();
    const pth = elem || path2.elem;
    const pathFuncs2 = svgCanvas$h.getPathFuncs();
    const func = "createSVGPathSeg" + pathFuncs2[type];
    const seg = pth[func](...pts);
    pth.pathSegList.replaceItem(seg, index2);
  };
  var getSegSelectorMethod = function(seg, update) {
    const {
      index: index2
    } = seg;
    let segLine = getElement("segline_" + index2);
    if (!segLine) {
      const pointGripContainer = getGripContainerMethod();
      segLine = document.createElementNS(NS.SVG, "path");
      assignAttributes(segLine, {
        id: "segline_" + index2,
        display: "none",
        fill: "none",
        stroke: "#0FF",
        "stroke-width": 2,
        style: "pointer-events:none",
        d: "M0,0 0,0"
      });
      pointGripContainer.append(segLine);
    }
    if (update) {
      const {
        prev
      } = seg;
      if (!prev) {
        segLine.setAttribute("display", "none");
        return segLine;
      }
      const pt2 = getGripPtMethod(prev);
      replacePathSegMethod(2, 0, [pt2.x, pt2.y], segLine);
      const pts = ptObjToArrMethod(seg.type, seg.item);
      for (let i2 = 0; i2 < pts.length; i2 += 2) {
        const point = getGripPtMethod(seg, {
          x: pts[i2],
          y: pts[i2 + 1]
        });
        pts[i2] = point.x;
        pts[i2 + 1] = point.y;
      }
      replacePathSegMethod(seg.type, 1, pts, segLine);
    }
    return segLine;
  };
  var Segment = class {
    /**
    * @param {Integer} index
    * @param {SVGPathSeg} item
    * @todo Is `item` be more constrained here?
    */
    constructor(index2, item) {
      this.selected = false;
      this.index = index2;
      this.item = item;
      this.type = item.pathSegType;
      this.ctrlpts = [];
      this.ptgrip = null;
      this.segsel = null;
    }
    /**
     * @param {boolean} y
     * @returns {void}
     */
    showCtrlPts(y2) {
      for (const i2 in this.ctrlpts) {
        if ({}.hasOwnProperty.call(this.ctrlpts, i2)) {
          this.ctrlpts[i2].setAttribute("display", y2 ? "inline" : "none");
        }
      }
    }
    /**
     * @param {boolean} y
     * @returns {void}
     */
    selectCtrls(y2) {
      document.getElementById("ctrlpointgrip_" + this.index + "c1").setAttribute("fill", y2 ? "#0FF" : "#EEE");
      document.getElementById("ctrlpointgrip_" + this.index + "c2").setAttribute("fill", y2 ? "#0FF" : "#EEE");
    }
    /**
     * @param {boolean} y
     * @returns {void}
     */
    show(y2) {
      if (this.ptgrip) {
        this.ptgrip.setAttribute("display", y2 ? "inline" : "none");
        this.segsel.setAttribute("display", y2 ? "inline" : "none");
        this.showCtrlPts(y2);
      }
    }
    /**
     * @param {boolean} y
     * @returns {void}
     */
    select(y2) {
      if (this.ptgrip) {
        this.ptgrip.setAttribute("stroke", y2 ? "#0FF" : "#00F");
        this.segsel.setAttribute("display", y2 ? "inline" : "none");
        if (this.ctrlpts) {
          this.selectCtrls(y2);
        }
        this.selected = y2;
      }
    }
    /**
     * @returns {void}
     */
    addGrip() {
      this.ptgrip = getPointGripMethod(this, true);
      this.ctrlpts = getControlPointsMethod(this);
      this.segsel = getSegSelectorMethod(this, true);
    }
    /**
     * @param {boolean} full
     * @returns {void}
     */
    update(full) {
      if (this.ptgrip) {
        const pt2 = getGripPtMethod(this);
        assignAttributes(this.ptgrip, {
          cx: pt2.x,
          cy: pt2.y
        });
        getSegSelectorMethod(this, true);
        if (this.ctrlpts) {
          if (full) {
            const path2 = svgCanvas$h.getPathObj();
            this.item = path2.elem.pathSegList.getItem(this.index);
            this.type = this.item.pathSegType;
          }
          getControlPointsMethod(this);
        }
      }
    }
    /**
     * @param {Integer} dx
     * @param {Integer} dy
     * @returns {void}
     */
    move(dx, dy) {
      const {
        item
      } = this;
      const curPts = this.ctrlpts ? [item.x += dx, item.y += dy, item.x1, item.y1, item.x2 += dx, item.y2 += dy] : [item.x += dx, item.y += dy];
      replacePathSegMethod(
        this.type,
        this.index,
        // type 10 means ARC
        this.type === 10 ? ptObjToArrMethod(this.type, item) : curPts
      );
      if (this.next?.ctrlpts) {
        const next = this.next.item;
        const nextPts = [next.x, next.y, next.x1 += dx, next.y1 += dy, next.x2, next.y2];
        replacePathSegMethod(this.next.type, this.next.index, nextPts);
      }
      if (this.mate) {
        const {
          item: itm
        } = this.mate;
        const pts = [itm.x += dx, itm.y += dy];
        replacePathSegMethod(this.mate.type, this.mate.index, pts);
      }
      this.update(true);
      if (this.next) {
        this.next.update(true);
      }
    }
    /**
     * @param {Integer} num
     * @returns {void}
     */
    setLinked(num) {
      let seg;
      let anum;
      let pt2;
      if (num === 2) {
        anum = 1;
        seg = this.next;
        if (!seg) {
          return;
        }
        pt2 = this.item;
      } else {
        anum = 2;
        seg = this.prev;
        if (!seg) {
          return;
        }
        pt2 = seg.item;
      }
      const {
        item
      } = seg;
      item["x" + anum] = pt2.x + (pt2.x - this.item["x" + num]);
      item["y" + anum] = pt2.y + (pt2.y - this.item["y" + num]);
      const pts = [item.x, item.y, item.x1, item.y1, item.x2, item.y2];
      replacePathSegMethod(seg.type, seg.index, pts);
      seg.update(true);
    }
    /**
     * @param {Integer} num
     * @param {Integer} dx
     * @param {Integer} dy
     * @returns {void}
     */
    moveCtrl(num, dx, dy) {
      const {
        item
      } = this;
      item["x" + num] += dx;
      item["y" + num] += dy;
      const pts = [item.x, item.y, item.x1, item.y1, item.x2, item.y2];
      replacePathSegMethod(this.type, this.index, pts);
      this.update(true);
    }
    /**
     * @param {Integer} newType Possible values set during {@link module:path.init}
     * @param {ArgumentsArray} pts
     * @returns {void}
     */
    setType(newType, pts) {
      replacePathSegMethod(newType, this.index, pts);
      this.type = newType;
      const path2 = svgCanvas$h.getPathObj();
      this.item = path2.elem.pathSegList.getItem(this.index);
      this.showCtrlPts(newType === 6);
      this.ctrlpts = getControlPointsMethod(this);
      this.update(true);
    }
  };
  var Path = class _Path {
    /**
    * @param {SVGPathElement} elem
    * @throws {Error} If constructed without a path element
    */
    constructor(elem) {
      if (!elem || elem.tagName !== "path") {
        throw new Error("svgedit.path.Path constructed without a <path> element");
      }
      this.elem = elem;
      this.segs = [];
      this.selected_pts = [];
      svgCanvas$h.setPathObj(this);
      this.init();
    }
    setPathContext() {
      svgCanvas$h.setPathObj(this);
    }
    /**
    * Reset path data.
    * @returns {module:path.Path}
    */
    init() {
      const pointGripContainer = getGripContainerMethod();
      const elements2 = pointGripContainer.querySelectorAll("*");
      Array.prototype.forEach.call(elements2, function(el) {
        el.setAttribute("display", "none");
      });
      const segList = this.elem.pathSegList;
      const len = segList.numberOfItems;
      this.segs = [];
      this.selected_pts = [];
      this.first_seg = null;
      for (let i2 = 0; i2 < len; i2++) {
        const item = segList.getItem(i2);
        const segment = new Segment(i2, item);
        segment.path = this;
        this.segs.push(segment);
      }
      const {
        segs
      } = this;
      let startI = null;
      for (let i2 = 0; i2 < len; i2++) {
        const seg = segs[i2];
        const nextSeg = i2 + 1 >= len ? null : segs[i2 + 1];
        const prevSeg = i2 - 1 < 0 ? null : segs[i2 - 1];
        if (seg.type === 2) {
          if (prevSeg && prevSeg.type !== 1) {
            const startSeg = segs[startI];
            startSeg.next = segs[startI + 1];
            startSeg.next.prev = startSeg;
            startSeg.addGrip();
          }
          startI = i2;
        } else if (nextSeg?.type === 1) {
          seg.next = segs[startI + 1];
          seg.next.prev = seg;
          seg.mate = segs[startI];
          seg.addGrip();
          if (!this.first_seg) {
            this.first_seg = seg;
          }
        } else if (!nextSeg) {
          if (seg.type !== 1) {
            const startSeg = segs[startI];
            startSeg.next = segs[startI + 1];
            startSeg.next.prev = startSeg;
            startSeg.addGrip();
            seg.addGrip();
            if (!this.first_seg) {
              this.first_seg = segs[startI];
            }
          }
        } else if (seg.type !== 1) {
          seg.addGrip();
          if (nextSeg && nextSeg.type !== 2) {
            seg.next = nextSeg;
            seg.next.prev = seg;
          }
        }
      }
      return this;
    }
    /**
    * @callback module:path.PathEachSegCallback
    * @this module:path.Segment
    * @param {Integer} i The index of the seg being iterated
    * @returns {boolean|void} Will stop execution of `eachSeg` if returns `false`
    */
    /**
    * @param {module:path.PathEachSegCallback} fn
    * @returns {void}
    */
    eachSeg(fn) {
      const len = this.segs.length;
      for (let i2 = 0; i2 < len; i2++) {
        const ret = fn.call(this.segs[i2], i2);
        if (ret === false) {
          break;
        }
      }
    }
    /**
    * @param {Integer} index
    * @returns {void}
    */
    addSeg(index2) {
      const seg = this.segs[index2];
      if (!seg.prev) {
        return;
      }
      const {
        prev
      } = seg;
      let newseg;
      let newX;
      let newY;
      switch (seg.item.pathSegType) {
        case 4: {
          newX = (seg.item.x + prev.item.x) / 2;
          newY = (seg.item.y + prev.item.y) / 2;
          newseg = this.elem.createSVGPathSegLinetoAbs(newX, newY);
          break;
        }
        case 6: {
          const p0x = (prev.item.x + seg.item.x1) / 2;
          const p1x = (seg.item.x1 + seg.item.x2) / 2;
          const p2x = (seg.item.x2 + seg.item.x) / 2;
          const p01x = (p0x + p1x) / 2;
          const p12x = (p1x + p2x) / 2;
          newX = (p01x + p12x) / 2;
          const p0y = (prev.item.y + seg.item.y1) / 2;
          const p1y = (seg.item.y1 + seg.item.y2) / 2;
          const p2y = (seg.item.y2 + seg.item.y) / 2;
          const p01y = (p0y + p1y) / 2;
          const p12y = (p1y + p2y) / 2;
          newY = (p01y + p12y) / 2;
          newseg = this.elem.createSVGPathSegCurvetoCubicAbs(newX, newY, p0x, p0y, p01x, p01y);
          const pts = [seg.item.x, seg.item.y, p12x, p12y, p2x, p2y];
          replacePathSegMethod(seg.type, index2, pts);
          break;
        }
      }
      const list = this.elem.pathSegList;
      list.insertItemBefore(newseg, index2);
    }
    /**
    * @param {Integer} index
    * @returns {void}
    */
    deleteSeg(index2) {
      const seg = this.segs[index2];
      const list = this.elem.pathSegList;
      seg.show(false);
      const {
        next
      } = seg;
      if (seg.mate) {
        const pt2 = [next.item.x, next.item.y];
        replacePathSegMethod(2, next.index, pt2);
        replacePathSegMethod(4, seg.index, pt2);
        list.removeItem(seg.mate.index);
      } else if (!seg.prev) {
        const pt2 = [next.item.x, next.item.y];
        replacePathSegMethod(2, seg.next.index, pt2);
        list.removeItem(index2);
      } else {
        list.removeItem(index2);
      }
    }
    /**
    * @param {Integer} index
    * @returns {void}
    */
    removePtFromSelection(index2) {
      const pos = this.selected_pts.indexOf(index2);
      if (pos === -1) {
        return;
      }
      this.segs[index2].select(false);
      this.selected_pts.splice(pos, 1);
    }
    /**
    * @returns {void}
    */
    clearSelection() {
      this.eachSeg(function() {
        this.select(false);
      });
      this.selected_pts = [];
    }
    /**
    * @returns {void}
    */
    storeD() {
      this.last_d = this.elem.getAttribute("d");
    }
    /**
    * @param {Integer} y
    * @returns {Path}
    */
    show(y2) {
      this.eachSeg(function() {
        this.show(y2);
      });
      if (y2) {
        this.selectPt(this.first_seg.index);
      }
      return this;
    }
    /**
    * Move selected points.
    * @param {Integer} dx
    * @param {Integer} dy
    * @returns {void}
    */
    movePts(dx, dy) {
      let i2 = this.selected_pts.length;
      while (i2--) {
        const seg = this.segs[this.selected_pts[i2]];
        seg.move(dx, dy);
      }
    }
    /**
    * @param {Integer} dx
    * @param {Integer} dy
    * @returns {void}
    */
    moveCtrl(dx, dy) {
      const seg = this.segs[this.selected_pts[0]];
      seg.moveCtrl(this.dragctrl, dx, dy);
      if (svgCanvas$h.getLinkControlPts()) {
        seg.setLinked(this.dragctrl);
      }
    }
    /**
    * @param {?Integer} newType See {@link https://www.w3.org/TR/SVG/single-page.html#paths-InterfaceSVGPathSeg}
    * @returns {void}
    */
    setSegType(newType) {
      this.storeD();
      let i2 = this.selected_pts.length;
      let text2;
      while (i2--) {
        const selPt = this.selected_pts[i2];
        const cur = this.segs[selPt];
        const {
          prev
        } = cur;
        if (!prev) {
          continue;
        }
        if (!newType) {
          text2 = "Toggle Path Segment Type";
          const oldType = cur.type;
          newType = oldType === 6 ? 4 : 6;
        }
        newType = Number(newType);
        const curX = cur.item.x;
        const curY = cur.item.y;
        const prevX = prev.item.x;
        const prevY = prev.item.y;
        let points;
        switch (newType) {
          case 6: {
            if (cur.olditem) {
              const old = cur.olditem;
              points = [curX, curY, old.x1, old.y1, old.x2, old.y2];
            } else {
              const diffX = curX - prevX;
              const diffY = curY - prevY;
              const ct1x = prevX + diffX / 3;
              const ct1y = prevY + diffY / 3;
              const ct2x = curX - diffX / 3;
              const ct2y = curY - diffY / 3;
              points = [curX, curY, ct1x, ct1y, ct2x, ct2y];
            }
            break;
          }
          case 4: {
            points = [curX, curY];
            cur.olditem = cur.item;
            break;
          }
        }
        cur.setType(newType, points);
      }
      const path2 = svgCanvas$h.getPathObj();
      path2.endChanges(text2);
    }
    /**
    * @param {Integer} pt
    * @param {Integer} ctrlNum
    * @returns {void}
    */
    selectPt(pt2, ctrlNum) {
      this.clearSelection();
      if (!pt2) {
        this.eachSeg(function(i2) {
          if (this.prev) {
            pt2 = i2;
          }
        });
      }
      this.addPtsToSelection(pt2);
      if (ctrlNum) {
        this.dragctrl = ctrlNum;
        if (svgCanvas$h.getLinkControlPts()) {
          this.segs[pt2].setLinked(ctrlNum);
        }
      }
    }
    /**
    * Update position of all points.
    * @returns {Path}
    */
    update() {
      const {
        elem
      } = this;
      if (getRotationAngle(elem)) {
        this.matrix = getMatrix(elem);
        this.imatrix = this.matrix.inverse();
      } else {
        this.matrix = null;
        this.imatrix = null;
      }
      this.eachSeg(function(i2) {
        this.item = elem.pathSegList.getItem(i2);
        this.update();
      });
      return this;
    }
    /**
    * @param {string} text
    * @returns {void}
    */
    endChanges(text2) {
      const cmd = new ChangeElementCommand$2(this.elem, {
        d: this.last_d
      }, text2);
      svgCanvas$h.endChanges({
        cmd,
        elem: this.elem
      });
    }
    /**
    * @param {Integer|Integer[]} indexes
    * @returns {void}
    */
    addPtsToSelection(indexes) {
      if (!Array.isArray(indexes)) {
        indexes = [indexes];
      }
      indexes.forEach((index2) => {
        const seg = this.segs[index2];
        if (seg.ptgrip && !this.selected_pts.includes(index2) && index2 >= 0) {
          this.selected_pts.push(index2);
        }
      });
      this.selected_pts.sort();
      let i2 = this.selected_pts.length;
      const grips = [];
      grips.length = i2;
      while (i2--) {
        const pt2 = this.selected_pts[i2];
        const seg = this.segs[pt2];
        seg.select(true);
        grips[i2] = seg.ptgrip;
      }
      const closedSubpath = _Path.subpathIsClosed(this.selected_pts[0]);
      svgCanvas$h.addPtsToSelection({
        grips,
        closedSubpath
      });
    }
    // STATIC
    /**
    * @param {Integer} index
    * @returns {boolean}
    */
    static subpathIsClosed(index2) {
      let clsd = false;
      const path2 = svgCanvas$h.getPathObj();
      path2.eachSeg(function(i2) {
        if (i2 <= index2) {
          return true;
        }
        if (this.type === 2) {
          return false;
        }
        if (this.type === 1) {
          clsd = true;
          return false;
        }
        return true;
      });
      return clsd;
    }
  };
  var svgCanvas$g = null;
  var path$2 = null;
  var init$h = (canvas) => {
    svgCanvas$g = canvas;
  };
  var convertPath$1 = function(pth, toRel) {
    const {
      pathSegList
    } = pth;
    const len = pathSegList.numberOfItems;
    let curx = 0;
    let cury = 0;
    let d2 = "";
    let lastM = null;
    for (let i2 = 0; i2 < len; ++i2) {
      const seg = pathSegList.getItem(i2);
      let x2 = seg.x || 0;
      let y2 = seg.y || 0;
      let x1 = seg.x1 || 0;
      let y1 = seg.y1 || 0;
      let x22 = seg.x2 || 0;
      let y22 = seg.y2 || 0;
      let letter = seg.pathSegTypeAsLetter;
      switch (letter) {
        case "z":
        // z,Z closepath (Z/z)
        case "Z":
          d2 += "z";
          if (lastM && !toRel) {
            curx = lastM[0];
            cury = lastM[1];
          }
          break;
        case "H":
          x2 -= curx;
        // Fallthrough
        case "h":
          if (toRel) {
            y2 = 0;
            curx += x2;
            letter = "l";
          } else {
            y2 = cury;
            x2 += curx;
            curx = x2;
            letter = "L";
          }
          d2 += pathDSegment$1(letter, [[x2, y2]]);
          break;
        case "V":
          y2 -= cury;
        // Fallthrough
        case "v":
          if (toRel) {
            x2 = 0;
            cury += y2;
            letter = "l";
          } else {
            x2 = curx;
            y2 += cury;
            cury = y2;
            letter = "L";
          }
          d2 += pathDSegment$1(letter, [[x2, y2]]);
          break;
        case "M":
        // absolute move (M)
        case "L":
        // absolute line (L)
        case "T":
          x2 -= curx;
          y2 -= cury;
        // Fallthrough
        case "l":
        // relative line (l)
        case "m":
        // relative move (m)
        case "t":
          if (toRel) {
            curx += x2;
            cury += y2;
            letter = letter.toLowerCase();
          } else {
            x2 += curx;
            y2 += cury;
            curx = x2;
            cury = y2;
            letter = letter.toUpperCase();
          }
          if (letter === "m" || letter === "M") {
            lastM = [curx, cury];
          }
          d2 += pathDSegment$1(letter, [[x2, y2]]);
          break;
        case "C":
          x2 -= curx;
          x1 -= curx;
          x22 -= curx;
          y2 -= cury;
          y1 -= cury;
          y22 -= cury;
        // Fallthrough
        case "c":
          if (toRel) {
            curx += x2;
            cury += y2;
            letter = "c";
          } else {
            x2 += curx;
            x1 += curx;
            x22 += curx;
            y2 += cury;
            y1 += cury;
            y22 += cury;
            curx = x2;
            cury = y2;
            letter = "C";
          }
          d2 += pathDSegment$1(letter, [[x1, y1], [x22, y22], [x2, y2]]);
          break;
        case "Q":
          x2 -= curx;
          x1 -= curx;
          y2 -= cury;
          y1 -= cury;
        // Fallthrough
        case "q":
          if (toRel) {
            curx += x2;
            cury += y2;
            letter = "q";
          } else {
            x2 += curx;
            x1 += curx;
            y2 += cury;
            y1 += cury;
            curx = x2;
            cury = y2;
            letter = "Q";
          }
          d2 += pathDSegment$1(letter, [[x1, y1], [x2, y2]]);
          break;
        case "A":
          x2 -= curx;
          y2 -= cury;
        // fallthrough
        case "a":
          if (toRel) {
            curx += x2;
            cury += y2;
            letter = "a";
          } else {
            x2 += curx;
            y2 += cury;
            curx = x2;
            cury = y2;
            letter = "A";
          }
          d2 += pathDSegment$1(letter, [[seg.r1, seg.r2]], [seg.angle, seg.largeArcFlag ? 1 : 0, seg.sweepFlag ? 1 : 0], [x2, y2]);
          break;
        case "S":
          x2 -= curx;
          x22 -= curx;
          y2 -= cury;
          y22 -= cury;
        // Fallthrough
        case "s":
          if (toRel) {
            curx += x2;
            cury += y2;
            letter = "s";
          } else {
            x2 += curx;
            x22 += curx;
            y2 += cury;
            y22 += cury;
            curx = x2;
            cury = y2;
            letter = "S";
          }
          d2 += pathDSegment$1(letter, [[x22, y22], [x2, y2]]);
          break;
      }
    }
    return d2;
  };
  function pathDSegment$1(letter, points, morePoints, lastPoint) {
    points.forEach(function(pnt, i2) {
      points[i2] = shortFloat(pnt);
    });
    let segment = letter + points.join(" ");
    if (morePoints) {
      segment += " " + morePoints.join(" ");
    }
    if (lastPoint) {
      segment += " " + shortFloat(lastPoint);
    }
    return segment;
  }
  var pathActionsMethod = /* @__PURE__ */ (function() {
    let subpath = false;
    let newPoint;
    let firstCtrl;
    let currentPath = null;
    let hasMoved = false;
    const smoothPolylineIntoPath = function(element) {
      let i2;
      const {
        points
      } = element;
      const N2 = points.numberOfItems;
      if (N2 >= 4) {
        let curpos = points.getItem(0);
        let prevCtlPt = null;
        let d2 = [];
        d2.push(["M", curpos.x, ",", curpos.y, " C"].join(""));
        for (i2 = 1; i2 <= N2 - 4; i2 += 3) {
          let ct1 = points.getItem(i2);
          const ct2 = points.getItem(i2 + 1);
          const end = points.getItem(i2 + 2);
          if (prevCtlPt) {
            const newpts = svgCanvas$g.smoothControlPoints(prevCtlPt, ct1, curpos);
            if (newpts?.length === 2) {
              const prevArr = d2[d2.length - 1].split(",");
              prevArr[2] = newpts[0].x;
              prevArr[3] = newpts[0].y;
              d2[d2.length - 1] = prevArr.join(",");
              ct1 = newpts[1];
            }
          }
          d2.push([ct1.x, ct1.y, ct2.x, ct2.y, end.x, end.y].join(","));
          curpos = end;
          prevCtlPt = ct2;
        }
        d2.push("L");
        while (i2 < N2) {
          const pt2 = points.getItem(i2);
          d2.push([pt2.x, pt2.y].join(","));
          i2++;
        }
        d2 = d2.join(" ");
        element = svgCanvas$g.addSVGElementsFromJson({
          element: "path",
          curStyles: true,
          attr: {
            id: svgCanvas$g.getId(),
            d: d2,
            fill: "none"
          }
        });
      }
      return element;
    };
    return (
      /** @lends module:path.pathActions */
      {
        /**
        * @param {MouseEvent} evt
        * @param {Element} mouseTarget
        * @param {Float} startX
        * @param {Float} startY
        * @returns {boolean|void}
        */
        mouseDown(evt, mouseTarget, startX, startY) {
          let id;
          if (svgCanvas$g.getCurrentMode() === "path") {
            let mouseX = startX;
            let mouseY = startY;
            const zoom = svgCanvas$g.getZoom();
            let x2 = mouseX / zoom;
            let y2 = mouseY / zoom;
            let stretchy = getElement("path_stretch_line");
            newPoint = [x2, y2];
            if (svgCanvas$g.getGridSnapping()) {
              x2 = snapToGrid(x2);
              y2 = snapToGrid(y2);
              mouseX = snapToGrid(mouseX);
              mouseY = snapToGrid(mouseY);
            }
            if (!stretchy) {
              stretchy = document.createElementNS(NS.SVG, "path");
              assignAttributes(stretchy, {
                id: "path_stretch_line",
                stroke: "#22C",
                "stroke-width": "0.5",
                fill: "none"
              });
              getElement("selectorParentGroup").append(stretchy);
            }
            stretchy.setAttribute("display", "inline");
            let keep = null;
            let index2;
            const drawnPath = svgCanvas$g.getDrawnPath();
            if (!drawnPath) {
              const dAttr = "M" + x2 + "," + y2 + " ";
              svgCanvas$g.setDrawnPath(svgCanvas$g.addSVGElementsFromJson({
                element: "path",
                curStyles: true,
                attr: {
                  d: dAttr,
                  id: svgCanvas$g.getNextId(),
                  opacity: svgCanvas$g.getOpacity() / 2
                }
              }));
              stretchy.setAttribute("d", ["M", mouseX, mouseY, mouseX, mouseY].join(" "));
              index2 = subpath ? path$2.segs.length : 0;
              svgCanvas$g.addPointGrip(index2, mouseX, mouseY);
            } else {
              const seglist = drawnPath.pathSegList;
              let i2 = seglist.numberOfItems;
              const FUZZ = 6 / zoom;
              let clickOnPoint = false;
              while (i2) {
                i2--;
                const item = seglist.getItem(i2);
                const px = item.x;
                const py = item.y;
                if (x2 >= px - FUZZ && x2 <= px + FUZZ && y2 >= py - FUZZ && y2 <= py + FUZZ) {
                  clickOnPoint = true;
                  break;
                }
              }
              id = svgCanvas$g.getId();
              svgCanvas$g.removePath_(id);
              const newpath = getElement(id);
              let newseg;
              let sSeg;
              const len = seglist.numberOfItems;
              if (clickOnPoint) {
                if (i2 <= 1 && len >= 2) {
                  const absX = seglist.getItem(0).x;
                  const absY = seglist.getItem(0).y;
                  sSeg = stretchy.pathSegList.getItem(1);
                  newseg = sSeg.pathSegType === 4 ? drawnPath.createSVGPathSegLinetoAbs(absX, absY) : drawnPath.createSVGPathSegCurvetoCubicAbs(absX, absY, sSeg.x1 / zoom, sSeg.y1 / zoom, absX, absY);
                  const endseg = drawnPath.createSVGPathSegClosePath();
                  seglist.appendItem(newseg);
                  seglist.appendItem(endseg);
                } else if (len < 3) {
                  keep = false;
                  return keep;
                }
                stretchy.remove();
                svgCanvas$g.setDrawnPath(null);
                svgCanvas$g.setStarted(false);
                if (subpath) {
                  if (path$2.matrix) {
                    svgCanvas$g.remapElement(newpath, {}, path$2.matrix.inverse());
                  }
                  const newD = newpath.getAttribute("d");
                  const origD = path$2.elem.getAttribute("d");
                  path$2.elem.setAttribute("d", origD + newD);
                  newpath.parentNode.removeChild(newpath);
                  if (path$2.matrix) {
                    svgCanvas$g.recalcRotatedPath();
                  }
                  pathActionsMethod.toEditMode(path$2.elem);
                  path$2.selectPt();
                  return false;
                }
              } else {
                if (!(svgCanvas$g.getContainer() !== svgCanvas$g.getMouseTarget(evt) && svgCanvas$g.getContainer().contains(svgCanvas$g.getMouseTarget(evt)))) {
                  return false;
                }
                const num = drawnPath.pathSegList.numberOfItems;
                const last = drawnPath.pathSegList.getItem(num - 1);
                const lastx = last.x;
                const lasty = last.y;
                if (evt.shiftKey) {
                  const xya = snapToAngle(lastx, lasty, x2, y2);
                  ({
                    x: x2,
                    y: y2
                  } = xya);
                }
                sSeg = stretchy.pathSegList.getItem(1);
                newseg = sSeg.pathSegType === 4 ? drawnPath.createSVGPathSegLinetoAbs(svgCanvas$g.round(x2), svgCanvas$g.round(y2)) : drawnPath.createSVGPathSegCurvetoCubicAbs(svgCanvas$g.round(x2), svgCanvas$g.round(y2), sSeg.x1 / zoom, sSeg.y1 / zoom, sSeg.x2 / zoom, sSeg.y2 / zoom);
                drawnPath.pathSegList.appendItem(newseg);
                x2 *= zoom;
                y2 *= zoom;
                stretchy.setAttribute("d", ["M", x2, y2, x2, y2].join(" "));
                index2 = num;
                if (subpath) {
                  index2 += path$2.segs.length;
                }
                svgCanvas$g.addPointGrip(index2, x2, y2);
              }
            }
            return void 0;
          }
          if (!path$2) {
            return void 0;
          }
          path$2.storeD();
          ({
            id
          } = evt.target);
          let curPt;
          if (id.substr(0, 14) === "pathpointgrip_") {
            curPt = path$2.cur_pt = Number.parseInt(id.substr(14));
            path$2.dragging = [startX, startY];
            const seg = path$2.segs[curPt];
            if (!evt.shiftKey) {
              if (path$2.selected_pts.length <= 1 || !seg.selected) {
                path$2.clearSelection();
              }
              path$2.addPtsToSelection(curPt);
            } else if (seg.selected) {
              path$2.removePtFromSelection(curPt);
            } else {
              path$2.addPtsToSelection(curPt);
            }
          } else if (id.startsWith("ctrlpointgrip_")) {
            path$2.dragging = [startX, startY];
            const parts = id.split("_")[1].split("c");
            curPt = Number(parts[0]);
            const ctrlNum = Number(parts[1]);
            path$2.selectPt(curPt, ctrlNum);
          }
          if (!path$2.dragging) {
            let rubberBox = svgCanvas$g.getRubberBox();
            if (!rubberBox) {
              rubberBox = svgCanvas$g.setRubberBox(svgCanvas$g.selectorManager.getRubberBandBox());
            }
            const zoom = svgCanvas$g.getZoom();
            assignAttributes(rubberBox, {
              x: startX * zoom,
              y: startY * zoom,
              width: 0,
              height: 0,
              display: "inline"
            });
          }
          return void 0;
        },
        /**
        * @param {Float} mouseX
        * @param {Float} mouseY
        * @returns {void}
        */
        mouseMove(mouseX, mouseY) {
          const zoom = svgCanvas$g.getZoom();
          hasMoved = true;
          const drawnPath = svgCanvas$g.getDrawnPath();
          if (svgCanvas$g.getCurrentMode() === "path") {
            if (!drawnPath) {
              return;
            }
            const seglist = drawnPath.pathSegList;
            const index2 = seglist.numberOfItems - 1;
            if (newPoint) {
              const pointGrip1 = svgCanvas$g.addCtrlGrip("1c1");
              const pointGrip2 = svgCanvas$g.addCtrlGrip("0c2");
              pointGrip1.setAttribute("cx", mouseX);
              pointGrip1.setAttribute("cy", mouseY);
              pointGrip1.setAttribute("display", "inline");
              const ptX = newPoint[0];
              const ptY = newPoint[1];
              const curX = mouseX / zoom;
              const curY = mouseY / zoom;
              const altX = ptX + (ptX - curX);
              const altY = ptY + (ptY - curY);
              pointGrip2.setAttribute("cx", altX * zoom);
              pointGrip2.setAttribute("cy", altY * zoom);
              pointGrip2.setAttribute("display", "inline");
              const ctrlLine = svgCanvas$g.getCtrlLine(1);
              assignAttributes(ctrlLine, {
                x1: mouseX,
                y1: mouseY,
                x2: altX * zoom,
                y2: altY * zoom,
                display: "inline"
              });
              if (index2 === 0) {
                firstCtrl = [mouseX, mouseY];
              } else {
                const last = seglist.getItem(index2 - 1);
                let lastX = last.x;
                let lastY = last.y;
                if (last.pathSegType === 6) {
                  lastX += lastX - last.x2;
                  lastY += lastY - last.y2;
                } else if (firstCtrl) {
                  lastX = firstCtrl[0] / zoom;
                  lastY = firstCtrl[1] / zoom;
                }
                svgCanvas$g.replacePathSeg(6, index2, [ptX, ptY, lastX, lastY, altX, altY], drawnPath);
              }
            } else {
              const stretchy = getElement("path_stretch_line");
              if (stretchy) {
                const prev = seglist.getItem(index2);
                if (prev.pathSegType === 6) {
                  const prevX = prev.x + (prev.x - prev.x2);
                  const prevY = prev.y + (prev.y - prev.y2);
                  svgCanvas$g.replacePathSeg(6, 1, [mouseX, mouseY, prevX * zoom, prevY * zoom, mouseX, mouseY], stretchy);
                } else if (firstCtrl) {
                  svgCanvas$g.replacePathSeg(6, 1, [mouseX, mouseY, firstCtrl[0], firstCtrl[1], mouseX, mouseY], stretchy);
                } else {
                  svgCanvas$g.replacePathSeg(4, 1, [mouseX, mouseY], stretchy);
                }
              }
            }
            return;
          }
          if (path$2.dragging) {
            const pt2 = svgCanvas$g.getPointFromGrip({
              x: path$2.dragging[0],
              y: path$2.dragging[1]
            }, path$2);
            const mpt = svgCanvas$g.getPointFromGrip({
              x: mouseX,
              y: mouseY
            }, path$2);
            const diffX = mpt.x - pt2.x;
            const diffY = mpt.y - pt2.y;
            path$2.dragging = [mouseX, mouseY];
            if (path$2.dragctrl) {
              path$2.moveCtrl(diffX, diffY);
            } else {
              path$2.movePts(diffX, diffY);
            }
          } else {
            path$2.selected_pts = [];
            path$2.eachSeg(function(_i) {
              const seg = this;
              if (!seg.next && !seg.prev) {
                return;
              }
              const rubberBox = svgCanvas$g.getRubberBox();
              const rbb = getBBox(rubberBox);
              const pt2 = svgCanvas$g.getGripPt(seg);
              const ptBb = {
                x: pt2.x,
                y: pt2.y,
                width: 0,
                height: 0
              };
              const sel = rectsIntersect(rbb, ptBb);
              this.select(sel);
              if (sel) {
                path$2.selected_pts.push(seg.index);
              }
            });
          }
        },
        /**
         * @typedef module:path.keepElement
         * @type {PlainObject}
         * @property {boolean} keep
         * @property {Element} element
         */
        /**
        * @param {Event} evt
        * @param {Element} element
        * @param {Float} _mouseX
        * @param {Float} _mouseY
        * @returns {module:path.keepElement|void}
        */
        mouseUp(evt, element, _mouseX, _mouseY) {
          const drawnPath = svgCanvas$g.getDrawnPath();
          if (svgCanvas$g.getCurrentMode() === "path") {
            newPoint = null;
            if (!drawnPath) {
              element = getElement(svgCanvas$g.getId());
              svgCanvas$g.setStarted(false);
              firstCtrl = null;
            }
            return {
              keep: true,
              element
            };
          }
          const rubberBox = svgCanvas$g.getRubberBox();
          if (path$2.dragging) {
            const lastPt = path$2.cur_pt;
            path$2.dragging = false;
            path$2.dragctrl = false;
            path$2.update();
            if (hasMoved) {
              path$2.endChanges("Move path point(s)");
            }
            if (!evt.shiftKey && !hasMoved) {
              path$2.selectPt(lastPt);
            }
          } else if (rubberBox?.getAttribute("display") !== "none") {
            rubberBox.setAttribute("display", "none");
            if (rubberBox.getAttribute("width") <= 2 && rubberBox.getAttribute("height") <= 2) {
              pathActionsMethod.toSelectMode(evt.target);
            }
          } else {
            pathActionsMethod.toSelectMode(evt.target);
          }
          hasMoved = false;
          return void 0;
        },
        /**
        * @param {Element} element
        * @returns {void}
        */
        toEditMode(element) {
          path$2 = svgCanvas$g.getPath_(element);
          svgCanvas$g.setCurrentMode("pathedit");
          svgCanvas$g.clearSelection();
          path$2.setPathContext();
          path$2.show(true).update();
          path$2.oldbbox = getBBox(path$2.elem);
          subpath = false;
        },
        /**
        * @param {Element} elem
        * @fires module:svgcanvas.SvgCanvas#event:selected
        * @returns {void}
        */
        toSelectMode(elem) {
          const selPath = elem === path$2.elem;
          svgCanvas$g.setCurrentMode("select");
          path$2.setPathContext();
          path$2.show(false);
          currentPath = false;
          svgCanvas$g.clearSelection();
          if (path$2.matrix) {
            svgCanvas$g.recalcRotatedPath();
          }
          if (selPath) {
            svgCanvas$g.call("selected", [elem]);
            svgCanvas$g.addToSelection([elem], true);
          }
        },
        /**
        * @param {boolean} on
        * @returns {void}
        */
        addSubPath(on) {
          if (on) {
            svgCanvas$g.setCurrentMode("path");
            subpath = true;
          } else {
            pathActionsMethod.clear(true);
            pathActionsMethod.toEditMode(path$2.elem);
          }
        },
        /**
        * @param {Element} target
        * @returns {void}
        */
        select(target) {
          if (currentPath === target) {
            pathActionsMethod.toEditMode(target);
            svgCanvas$g.setCurrentMode("pathedit");
          } else {
            currentPath = target;
          }
        },
        /**
        * @fires module:svgcanvas.SvgCanvas#event:changed
        * @returns {void}
        */
        reorient() {
          const elem = svgCanvas$g.getSelectedElements()[0];
          if (!elem) {
            return;
          }
          const angl = getRotationAngle(elem);
          if (angl === 0) {
            return;
          }
          const batchCmd = new BatchCommand$4("Reorient path");
          const changes = {
            d: elem.getAttribute("d"),
            transform: elem.getAttribute("transform")
          };
          batchCmd.addSubCommand(new ChangeElementCommand$2(elem, changes));
          svgCanvas$g.clearSelection();
          this.resetOrientation(elem);
          svgCanvas$g.addCommandToHistory(batchCmd);
          svgCanvas$g.getPath_(elem).show(false).matrix = null;
          this.clear();
          svgCanvas$g.addToSelection([elem], true);
          svgCanvas$g.call("changed", svgCanvas$g.getSelectedElements());
        },
        /**
        * @param {boolean} remove Not in use
        * @returns {void}
        */
        clear() {
          const drawnPath = svgCanvas$g.getDrawnPath();
          currentPath = null;
          if (drawnPath) {
            const elem = getElement(svgCanvas$g.getId());
            const psl = getElement("path_stretch_line");
            psl.parentNode.removeChild(psl);
            elem.parentNode.removeChild(elem);
            const pathpointgripContainer = getElement("pathpointgrip_container");
            const elements2 = pathpointgripContainer.querySelectorAll("*");
            Array.prototype.forEach.call(elements2, function(el) {
              el.setAttribute("display", "none");
            });
            firstCtrl = null;
            svgCanvas$g.setDrawnPath(null);
            svgCanvas$g.setStarted(false);
          } else if (svgCanvas$g.getCurrentMode() === "pathedit") {
            this.toSelectMode();
          }
          if (path$2) {
            path$2.init().show(false);
          }
        },
        /**
        * @param {?(Element|SVGPathElement)} pth
        * @returns {false|void}
        */
        resetOrientation(pth) {
          if (pth?.nodeName !== "path") {
            return false;
          }
          const tlist = getTransformList(pth);
          const m2 = transformListToTransform(tlist).matrix;
          tlist.clear();
          pth.removeAttribute("transform");
          const segList = pth.pathSegList;
          const len = segList.numberOfItems;
          for (let i2 = 0; i2 < len; ++i2) {
            const seg = segList.getItem(i2);
            const type = seg.pathSegType;
            if (type === 1) {
              continue;
            }
            const pts = [];
            ["", 1, 2].forEach(function(n2) {
              const x2 = seg["x" + n2];
              const y2 = seg["y" + n2];
              if (x2 !== void 0 && y2 !== void 0) {
                const pt2 = transformPoint(x2, y2, m2);
                pts.splice(pts.length, 0, pt2.x, pt2.y);
              }
            });
            svgCanvas$g.replacePathSeg(type, i2, pts, pth);
          }
          svgCanvas$g.reorientGrads(pth, m2);
          return void 0;
        },
        /**
        * @returns {void}
        */
        zoomChange() {
          if (svgCanvas$g.getCurrentMode() === "pathedit") {
            path$2.update();
          }
        },
        /**
        * @typedef {PlainObject} module:path.NodePoint
        * @property {Float} x
        * @property {Float} y
        * @property {Integer} type
        */
        /**
        * @returns {module:path.NodePoint}
        */
        getNodePoint() {
          const selPt = path$2.selected_pts.length ? path$2.selected_pts[0] : 1;
          const seg = path$2.segs[selPt];
          return {
            x: seg.item.x,
            y: seg.item.y,
            type: seg.type
          };
        },
        /**
        * @param {boolean} linkPoints
        * @returns {void}
        */
        linkControlPoints(linkPoints) {
          svgCanvas$g.setLinkControlPoints(linkPoints);
        },
        /**
        * @returns {void}
        */
        clonePathNode() {
          path$2.storeD();
          const selPts = path$2.selected_pts;
          let i2 = selPts.length;
          const nums = [];
          while (i2--) {
            const pt2 = selPts[i2];
            path$2.addSeg(pt2);
            nums.push(pt2 + i2);
            nums.push(pt2 + i2 + 1);
          }
          path$2.init().addPtsToSelection(nums);
          path$2.endChanges("Clone path node(s)");
        },
        /**
        * @returns {void}
        */
        opencloseSubPath() {
          const selPts = path$2.selected_pts;
          if (selPts.length !== 1) {
            return;
          }
          const {
            elem
          } = path$2;
          const list = elem.pathSegList;
          const index2 = selPts[0];
          let openPt = null;
          let startItem = null;
          path$2.eachSeg(function(i2) {
            if (this.type === 2 && i2 <= index2) {
              startItem = this.item;
            }
            if (i2 <= index2) {
              return true;
            }
            if (this.type === 2) {
              openPt = i2;
              return false;
            }
            if (this.type === 1) {
              openPt = false;
              return false;
            }
            return true;
          });
          if (!openPt) {
            openPt = path$2.segs.length - 1;
          }
          if (openPt !== false) {
            const newseg = elem.createSVGPathSegLinetoAbs(startItem.x, startItem.y);
            const closer = elem.createSVGPathSegClosePath();
            if (openPt === path$2.segs.length - 1) {
              list.appendItem(newseg);
              list.appendItem(closer);
            } else {
              list.insertItemBefore(closer, openPt);
              list.insertItemBefore(newseg, openPt);
            }
            path$2.init().selectPt(openPt + 1);
            return;
          }
          const seg = path$2.segs[index2];
          if (seg.mate) {
            list.removeItem(index2);
            list.removeItem(index2);
            path$2.init().selectPt(index2 - 1);
            return;
          }
          let lastM;
          let zSeg;
          for (let i2 = 0; i2 < list.numberOfItems; i2++) {
            const item = list.getItem(i2);
            if (item.pathSegType === 2) {
              lastM = i2;
            } else if (i2 === index2) {
              list.removeItem(lastM);
            } else if (item.pathSegType === 1 && index2 < i2) {
              zSeg = i2 - 1;
              list.removeItem(i2);
              break;
            }
          }
          let num = index2 - lastM - 1;
          while (num--) {
            list.insertItemBefore(list.getItem(lastM), zSeg);
          }
          const pt2 = list.getItem(lastM);
          svgCanvas$g.replacePathSeg(2, lastM, [pt2.x, pt2.y]);
          path$2.init().selectPt(0);
        },
        /**
        * @returns {void}
        */
        deletePathNode() {
          if (!pathActionsMethod.canDeleteNodes) {
            return;
          }
          path$2.storeD();
          const selPts = path$2.selected_pts;
          let i2 = selPts.length;
          while (i2--) {
            const pt2 = selPts[i2];
            path$2.deleteSeg(pt2);
          }
          const cleanup = function() {
            const segList = path$2.elem.pathSegList;
            let len = segList.numberOfItems;
            const remItems = function(pos, count) {
              while (count--) {
                segList.removeItem(pos);
              }
            };
            if (len <= 1) {
              return true;
            }
            while (len--) {
              const item = segList.getItem(len);
              if (item.pathSegType === 1) {
                const prev = segList.getItem(len - 1);
                const nprev = segList.getItem(len - 2);
                if (prev.pathSegType === 2) {
                  remItems(len - 1, 2);
                  cleanup();
                  break;
                } else if (nprev.pathSegType === 2) {
                  remItems(len - 2, 3);
                  cleanup();
                  break;
                }
              } else if (item.pathSegType === 2 && len > 0) {
                const prevType = segList.getItem(len - 1).pathSegType;
                if (prevType === 2) {
                  remItems(len - 1, 1);
                  cleanup();
                  break;
                } else if (prevType === 1 && segList.numberOfItems - 1 === len) {
                  remItems(len, 1);
                  cleanup();
                  break;
                }
              }
            }
            return false;
          };
          cleanup();
          if (path$2.elem.pathSegList.numberOfItems <= 1) {
            pathActionsMethod.toSelectMode(path$2.elem);
            svgCanvas$g.canvas.deleteSelectedElements();
            return;
          }
          path$2.init();
          path$2.clearSelection();
          if (window.opera) {
            path$2.elem.setAttribute("d", path$2.elem.getAttribute("d"));
          }
          path$2.endChanges("Delete path node(s)");
        },
        // Can't seem to use `@borrows` here, so using `@see`
        /**
        * Smooth polyline into path.
        * @function module:path.pathActions.smoothPolylineIntoPath
        * @see module:path~smoothPolylineIntoPath
        */
        smoothPolylineIntoPath,
        /* eslint-enable  */
        /**
        * @param {?Integer} v See {@link https://www.w3.org/TR/SVG/single-page.html#paths-InterfaceSVGPathSeg}
        * @returns {void}
        */
        setSegType(v2) {
          path$2?.setSegType(v2);
        },
        /**
        * @param {string} attr
        * @param {Float} newValue
        * @returns {void}
        */
        moveNode(attr, newValue) {
          const selPts = path$2.selected_pts;
          if (!selPts.length) {
            return;
          }
          path$2.storeD();
          const seg = path$2.segs[selPts[0]];
          const diff = {
            x: 0,
            y: 0
          };
          diff[attr] = newValue - seg.item[attr];
          seg.move(diff.x, diff.y);
          path$2.endChanges("Move path point");
        },
        /**
        * @param {Element} elem
        * @returns {void}
        */
        fixEnd(elem) {
          const segList = elem.pathSegList;
          const len = segList.numberOfItems;
          let lastM;
          for (let i2 = 0; i2 < len; ++i2) {
            const item = segList.getItem(i2);
            if (item.pathSegType === 2) {
              lastM = item;
            }
            if (item.pathSegType === 1) {
              const prev = segList.getItem(i2 - 1);
              if (prev.x !== lastM.x || prev.y !== lastM.y) {
                const newseg = elem.createSVGPathSegLinetoAbs(lastM.x, lastM.y);
                segList.insertItemBefore(newseg, i2);
                pathActionsMethod.fixEnd(elem);
                break;
              }
            }
          }
        },
        // Can't seem to use `@borrows` here, so using `@see`
        /**
        * Convert a path to one with only absolute or relative values.
        * @function module:path.pathActions.convertPath
        * @see module:path.convertPath
        */
        convertPath: convertPath$1
      }
    );
  })();
  var segData = {
    2: ["x", "y"],
    // PATHSEG_MOVETO_ABS
    4: ["x", "y"],
    // PATHSEG_LINETO_ABS
    6: ["x", "y", "x1", "y1", "x2", "y2"],
    // PATHSEG_CURVETO_CUBIC_ABS
    8: ["x", "y", "x1", "y1"],
    // PATHSEG_CURVETO_QUADRATIC_ABS
    10: ["x", "y", "r1", "r2", "angle", "largeArcFlag", "sweepFlag"],
    // PATHSEG_ARC_ABS
    12: ["x"],
    // PATHSEG_LINETO_HORIZONTAL_ABS
    14: ["y"],
    // PATHSEG_LINETO_VERTICAL_ABS
    16: ["x", "y", "x2", "y2"],
    // PATHSEG_CURVETO_CUBIC_SMOOTH_ABS
    18: ["x", "y"]
    // PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS
  };
  var svgCanvas$f;
  var uiStrings = {};
  var setUiStrings = (strs) => {
    Object.assign(uiStrings, strs.ui);
  };
  var pathFuncs = [];
  var linkControlPts = true;
  var pathData = {};
  var setLinkControlPoints = (lcp) => {
    linkControlPts = lcp;
  };
  var path$1 = null;
  var init$g = (canvas) => {
    svgCanvas$f = canvas;
    svgCanvas$f.replacePathSeg = replacePathSegMethod;
    svgCanvas$f.addPointGrip = addPointGripMethod;
    svgCanvas$f.removePath_ = removePath_;
    svgCanvas$f.getPath_ = getPath_;
    svgCanvas$f.addCtrlGrip = addCtrlGripMethod;
    svgCanvas$f.getCtrlLine = getCtrlLineMethod;
    svgCanvas$f.getGripPt = getGripPt;
    svgCanvas$f.getPointFromGrip = getPointFromGripMethod;
    svgCanvas$f.setLinkControlPoints = setLinkControlPoints;
    svgCanvas$f.reorientGrads = reorientGrads;
    svgCanvas$f.getSegData = () => {
      return segData;
    };
    svgCanvas$f.getUIStrings = () => {
      return uiStrings;
    };
    svgCanvas$f.getPathObj = () => {
      return path$1;
    };
    svgCanvas$f.setPathObj = (obj) => {
      path$1 = obj;
    };
    svgCanvas$f.getPathFuncs = () => {
      return pathFuncs;
    };
    svgCanvas$f.getLinkControlPts = () => {
      return linkControlPts;
    };
    pathFuncs = [0, "ClosePath"];
    const pathFuncsStrs = ["Moveto", "Lineto", "CurvetoCubic", "CurvetoQuadratic", "Arc", "LinetoHorizontal", "LinetoVertical", "CurvetoCubicSmooth", "CurvetoQuadraticSmooth"];
    pathFuncsStrs.forEach((s2) => {
      pathFuncs.push(s2 + "Abs");
      pathFuncs.push(s2 + "Rel");
    });
    init$h(svgCanvas$f);
    init$i(svgCanvas$f);
  };
  var ptObjToArr = ptObjToArrMethod;
  var getGripPt = getGripPtMethod;
  var getPointFromGrip = getPointFromGripMethod;
  var addPointGrip = addPointGripMethod;
  var getGripContainer = getGripContainerMethod;
  var addCtrlGrip = addCtrlGripMethod;
  var getCtrlLine = getCtrlLineMethod;
  var getPointGrip = getPointGripMethod;
  var getControlPoints = getControlPointsMethod;
  var replacePathSeg = replacePathSegMethod;
  var getSegSelector = getSegSelectorMethod;
  var smoothControlPoints = (ct1, ct2, pt2) => {
    const x1 = ct1.x - pt2.x;
    const y1 = ct1.y - pt2.y;
    const x2 = ct2.x - pt2.x;
    const y2 = ct2.y - pt2.y;
    if ((x1 !== 0 || y1 !== 0) && (x2 !== 0 || y2 !== 0)) {
      const r1 = Math.sqrt(x1 * x1 + y1 * y1);
      const r2 = Math.sqrt(x2 * x2 + y2 * y2);
      const nct1 = svgCanvas$f.getSvgRoot().createSVGPoint();
      const nct2 = svgCanvas$f.getSvgRoot().createSVGPoint();
      let anglea = Math.atan2(y1, x1);
      let angleb = Math.atan2(y2, x2);
      if (anglea < 0) {
        anglea += 2 * Math.PI;
      }
      if (angleb < 0) {
        angleb += 2 * Math.PI;
      }
      const angleBetween = Math.abs(anglea - angleb);
      const angleDiff = Math.abs(Math.PI - angleBetween) / 2;
      let newAnglea;
      let newAngleb;
      if (anglea - angleb > 0) {
        newAnglea = angleBetween < Math.PI ? anglea + angleDiff : anglea - angleDiff;
        newAngleb = angleBetween < Math.PI ? angleb - angleDiff : angleb + angleDiff;
      } else {
        newAnglea = angleBetween < Math.PI ? anglea - angleDiff : anglea + angleDiff;
        newAngleb = angleBetween < Math.PI ? angleb + angleDiff : angleb - angleDiff;
      }
      nct1.x = r1 * Math.cos(newAnglea) + pt2.x;
      nct1.y = r1 * Math.sin(newAnglea) + pt2.y;
      nct2.x = r2 * Math.cos(newAngleb) + pt2.x;
      nct2.y = r2 * Math.sin(newAngleb) + pt2.y;
      return [nct1, nct2];
    }
    return void 0;
  };
  var getPath_ = (elem) => {
    let p2 = pathData[elem.id];
    if (!p2) {
      p2 = pathData[elem.id] = new Path(elem);
    }
    return p2;
  };
  var removePath_ = (id) => {
    if (id in pathData) {
      delete pathData[id];
    }
  };
  var newcx;
  var newcy;
  var oldcx;
  var oldcy;
  var angle;
  var getRotVals = (x2, y2) => {
    let dx = x2 - oldcx;
    let dy = y2 - oldcy;
    let r2 = Math.sqrt(dx * dx + dy * dy);
    let theta = Math.atan2(dy, dx) + angle;
    dx = r2 * Math.cos(theta) + oldcx;
    dy = r2 * Math.sin(theta) + oldcy;
    dx -= newcx;
    dy -= newcy;
    r2 = Math.sqrt(dx * dx + dy * dy);
    theta = Math.atan2(dy, dx) - angle;
    return {
      x: r2 * Math.cos(theta) + newcx,
      y: r2 * Math.sin(theta) + newcy
    };
  };
  var recalcRotatedPath = () => {
    const currentPath = path$1.elem;
    angle = getRotationAngle(currentPath, true);
    if (!angle) {
      return;
    }
    const oldbox = path$1.oldbbox;
    oldcx = oldbox.x + oldbox.width / 2;
    oldcy = oldbox.y + oldbox.height / 2;
    const box = getBBox(currentPath);
    newcx = box.x + box.width / 2;
    newcy = box.y + box.height / 2;
    const dx = newcx - oldcx;
    const dy = newcy - oldcy;
    const r2 = Math.sqrt(dx * dx + dy * dy);
    const theta = Math.atan2(dy, dx) + angle;
    newcx = r2 * Math.cos(theta) + oldcx;
    newcy = r2 * Math.sin(theta) + oldcy;
    const list = currentPath.pathSegList;
    let i2 = list.numberOfItems;
    while (i2) {
      i2 -= 1;
      const seg = list.getItem(i2);
      const type = seg.pathSegType;
      if (type === 1) {
        continue;
      }
      const rvals = getRotVals(seg.x, seg.y);
      const points = [rvals.x, rvals.y];
      if (seg.x1 && seg.x2) {
        const cVals1 = getRotVals(seg.x1, seg.y1);
        const cVals2 = getRotVals(seg.x2, seg.y2);
        points.splice(points.length, 0, cVals1.x, cVals1.y, cVals2.x, cVals2.y);
      }
      replacePathSeg(type, i2, points);
    }
    getBBox(currentPath);
    const Rnc = svgCanvas$f.getSvgRoot().createSVGTransform();
    const tlist = getTransformList(currentPath);
    Rnc.setRotate(angle * 180 / Math.PI, newcx, newcy);
    tlist.replaceItem(Rnc, 0);
  };
  var clearData = () => {
    pathData = {};
  };
  var reorientGrads = (elem, m2) => {
    const bb = getBBox(elem);
    for (let i2 = 0; i2 < 2; i2++) {
      const type = i2 === 0 ? "fill" : "stroke";
      const attrVal = elem.getAttribute(type);
      if (attrVal && attrVal.startsWith("url(")) {
        const grad = getRefElem(attrVal);
        if (grad.tagName === "linearGradient") {
          let x1 = grad.getAttribute("x1") || 0;
          let y1 = grad.getAttribute("y1") || 0;
          let x2 = grad.getAttribute("x2") || 1;
          let y2 = grad.getAttribute("y2") || 0;
          x1 = bb.width * x1 + bb.x;
          y1 = bb.height * y1 + bb.y;
          x2 = bb.width * x2 + bb.x;
          y2 = bb.height * y2 + bb.y;
          const pt1 = transformPoint(x1, y1, m2);
          const pt2 = transformPoint(x2, y2, m2);
          const gCoords = {
            x1: (pt1.x - bb.x) / bb.width,
            y1: (pt1.y - bb.y) / bb.height,
            x2: (pt2.x - bb.x) / bb.width,
            y2: (pt2.y - bb.y) / bb.height
          };
          const newgrad = grad.cloneNode(true);
          for (const [key, value] of Object.entries(gCoords)) {
            newgrad.setAttribute(key, value);
          }
          newgrad.id = svgCanvas$f.getNextId();
          findDefs().append(newgrad);
          elem.setAttribute(type, "url(#" + newgrad.id + ")");
        }
      }
    }
  };
  var pathMap$1 = [0, "z", "M", "m", "L", "l", "C", "c", "Q", "q", "A", "a", "H", "h", "V", "v", "S", "s", "T", "t"];
  var convertPath = (pth, toRel) => {
    const {
      pathSegList
    } = pth;
    const len = pathSegList.numberOfItems;
    let curx = 0;
    let cury = 0;
    let d2 = "";
    let lastM = null;
    for (let i2 = 0; i2 < len; ++i2) {
      const seg = pathSegList.getItem(i2);
      let x2 = seg.x || 0;
      let y2 = seg.y || 0;
      let x1 = seg.x1 || 0;
      let y1 = seg.y1 || 0;
      let x22 = seg.x2 || 0;
      let y22 = seg.y2 || 0;
      const type = seg.pathSegType;
      let letter = pathMap$1[type][toRel ? "toLowerCase" : "toUpperCase"]();
      switch (type) {
        case 1:
          d2 += "z";
          if (lastM && !toRel) {
            curx = lastM[0];
            cury = lastM[1];
          }
          break;
        case 12:
          x2 -= curx;
        // Fallthrough
        case 13:
          if (toRel) {
            y2 = 0;
            curx += x2;
            letter = "l";
          } else {
            y2 = cury;
            x2 += curx;
            curx = x2;
            letter = "L";
          }
          d2 += pathDSegment(letter, [[x2, y2]]);
          break;
        case 14:
          y2 -= cury;
        // Fallthrough
        case 15:
          if (toRel) {
            x2 = 0;
            cury += y2;
            letter = "l";
          } else {
            x2 = curx;
            y2 += cury;
            cury = y2;
            letter = "L";
          }
          d2 += pathDSegment(letter, [[x2, y2]]);
          break;
        case 2:
        // absolute move (M)
        case 4:
        // absolute line (L)
        case 18:
        // absolute smooth quad (T)
        case 10:
          x2 -= curx;
          y2 -= cury;
        // Fallthrough
        case 5:
        // relative line (l)
        case 3:
        // relative move (m)
        case 19:
          if (toRel) {
            curx += x2;
            cury += y2;
          } else {
            x2 += curx;
            y2 += cury;
            curx = x2;
            cury = y2;
          }
          if (type === 2 || type === 3) {
            lastM = [curx, cury];
          }
          d2 += pathDSegment(letter, [[x2, y2]]);
          break;
        case 6:
          x2 -= curx;
          x1 -= curx;
          x22 -= curx;
          y2 -= cury;
          y1 -= cury;
          y22 -= cury;
        // Fallthrough
        case 7:
          if (toRel) {
            curx += x2;
            cury += y2;
          } else {
            x2 += curx;
            x1 += curx;
            x22 += curx;
            y2 += cury;
            y1 += cury;
            y22 += cury;
            curx = x2;
            cury = y2;
          }
          d2 += pathDSegment(letter, [[x1, y1], [x22, y22], [x2, y2]]);
          break;
        case 8:
          x2 -= curx;
          x1 -= curx;
          y2 -= cury;
          y1 -= cury;
        // Fallthrough
        case 9:
          if (toRel) {
            curx += x2;
            cury += y2;
          } else {
            x2 += curx;
            x1 += curx;
            y2 += cury;
            y1 += cury;
            curx = x2;
            cury = y2;
          }
          d2 += pathDSegment(letter, [[x1, y1], [x2, y2]]);
          break;
        // Fallthrough
        case 11:
          if (toRel) {
            curx += x2;
            cury += y2;
          } else {
            x2 += curx;
            y2 += cury;
            curx = x2;
            cury = y2;
          }
          d2 += pathDSegment(letter, [[seg.r1, seg.r2]], [seg.angle, seg.largeArcFlag ? 1 : 0, seg.sweepFlag ? 1 : 0], [x2, y2]);
          break;
        case 16:
          x2 -= curx;
          x22 -= curx;
          y2 -= cury;
          y22 -= cury;
        // Fallthrough
        case 17:
          if (toRel) {
            curx += x2;
            cury += y2;
          } else {
            x2 += curx;
            x22 += curx;
            y2 += cury;
            y22 += cury;
            curx = x2;
            cury = y2;
          }
          d2 += pathDSegment(letter, [[x22, y22], [x2, y2]]);
          break;
      }
    }
    return d2;
  };
  var pathDSegment = (letter, points, morePoints, lastPoint) => {
    points.forEach((pnt, i2) => {
      points[i2] = shortFloat(pnt);
    });
    let segment = letter + points.join(" ");
    if (morePoints) {
      segment += " " + morePoints.join(" ");
    }
    if (lastPoint) {
      segment += " " + shortFloat(lastPoint);
    }
    return segment;
  };
  var pathActions = pathActionsMethod;
  var pathModule = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    addCtrlGrip,
    addPointGrip,
    clearData,
    convertPath,
    getControlPoints,
    getCtrlLine,
    getGripContainer,
    getGripPt,
    getPath_,
    getPointFromGrip,
    getPointGrip,
    getSegSelector,
    init: init$g,
    get path() {
      return path$1;
    },
    pathActions,
    ptObjToArr,
    recalcRotatedPath,
    removePath_,
    reorientGrads,
    replacePathSeg,
    setLinkControlPoints,
    setUiStrings,
    smoothControlPoints
  });
  var Layer = class _Layer {
    /**
    * @param {string} name - Layer name
    * @param {SVGGElement|null} group - An existing SVG group element or null.
    *     If group and no svgElem, use group for this layer.
    *     If group and svgElem, create a new group element and insert it in the DOM after group.
    *     If no group and svgElem, create a new group element and insert it in the DOM as the last layer.
    * @param {SVGGElement} [svgElem] - The SVG DOM element. If defined, use this to add
    *     a new layer to the document.
    */
    constructor(name, group, svgElem) {
      this.name_ = name;
      this.group_ = svgElem ? null : group;
      if (svgElem) {
        const svgdoc = svgElem.ownerDocument;
        this.group_ = svgdoc.createElementNS(NS.SVG, "g");
        const layerTitle = svgdoc.createElementNS(NS.SVG, "title");
        layerTitle.textContent = name;
        this.group_.append(layerTitle);
        if (group) {
          group.insertAdjacentElement("afterend", this.group_);
        } else {
          svgElem.append(this.group_);
        }
      }
      addLayerClass(this.group_);
      walkTree(this.group_, function(e2) {
        e2.setAttribute("style", "pointer-events:inherit");
      });
      this.group_.setAttribute("style", svgElem ? "pointer-events:all" : "pointer-events:none");
    }
    /**
     * Get the layer's name.
     * @returns {string} The layer name
     */
    getName() {
      return this.name_;
    }
    /**
     * Get the group element for this layer.
     * @returns {SVGGElement} The layer SVG group
     */
    getGroup() {
      return this.group_;
    }
    /**
     * Active this layer so it takes pointer events.
     * @returns {void}
     */
    activate() {
      this.group_.setAttribute("style", "pointer-events:all");
    }
    /**
     * Deactive this layer so it does NOT take pointer events.
     * @returns {void}
     */
    deactivate() {
      this.group_.setAttribute("style", "pointer-events:none");
    }
    /**
     * Set this layer visible or hidden based on 'visible' parameter.
     * @param {boolean} visible - If true, make visible; otherwise, hide it.
     * @returns {void}
     */
    setVisible(visible) {
      const expected = visible === void 0 || visible ? "inline" : "none";
      const oldDisplay = this.group_.getAttribute("display");
      if (oldDisplay !== expected) {
        this.group_.setAttribute("display", expected);
      }
    }
    /**
     * Is this layer visible?
     * @returns {boolean} True if visible.
     */
    isVisible() {
      return this.group_.getAttribute("display") !== "none";
    }
    /**
     * Get layer opacity.
     * @returns {Float} Opacity value.
     */
    getOpacity() {
      const opacity = this.group_.getAttribute("opacity");
      if (!opacity) {
        return 1;
      }
      return Number.parseFloat(opacity);
    }
    /**
     * Sets the opacity of this layer. If opacity is not a value between 0.0 and 1.0,
     * nothing happens.
     * @param {Float} opacity - A float value in the range 0.0-1.0
     * @returns {void}
     */
    setOpacity(opacity) {
      if (typeof opacity === "number" && opacity >= 0 && opacity <= 1) {
        this.group_.setAttribute("opacity", opacity);
      }
    }
    /**
     * Append children to this layer.
     * @param {SVGGElement} children - The children to append to this layer.
     * @returns {void}
     */
    appendChildren(children) {
      for (const child of children) {
        this.group_.append(child);
      }
    }
    /**
    * @returns {SVGTitleElement|null}
    */
    getTitleElement() {
      const len = this.group_.childNodes.length;
      for (let i2 = 0; i2 < len; ++i2) {
        const child = this.group_.childNodes.item(i2);
        if (child?.tagName === "title") {
          return child;
        }
      }
      return null;
    }
    /**
     * Set the name of this layer.
     * @param {string} name - The new name.
     * @param {module:history.HistoryRecordingService} hrService - History recording service
     * @returns {string|null} The new name if changed; otherwise, null.
     */
    setName(name, hrService) {
      const previousName = this.name_;
      name = toXml(name);
      const title = this.getTitleElement();
      if (title) {
        while (title.firstChild) {
          title.removeChild(title.firstChild);
        }
        title.textContent = name;
        this.name_ = name;
        if (hrService) {
          hrService.changeElement(title, {
            "#text": previousName
          });
        }
        return this.name_;
      }
      return null;
    }
    /**
     * Remove this layer's group from the DOM. No more functions on group can be called after this.
     * @returns {SVGGElement} The layer SVG group that was just removed.
     */
    removeGroup() {
      const group = this.group_;
      this.group_.remove();
      this.group_ = void 0;
      return group;
    }
    /**
     * Test whether an element is a layer or not.
     * @param {SVGGElement} elem - The SVGGElement to test.
     * @returns {boolean} True if the element is a layer
     */
    static isLayer(elem) {
      return elem && elem.tagName === "g" && _Layer.CLASS_REGEX.test(elem.getAttribute("class"));
    }
  };
  Layer.CLASS_NAME = "layer";
  Layer.CLASS_REGEX = new RegExp("(\\s|^)" + Layer.CLASS_NAME + "(\\s|$)");
  function addLayerClass(elem) {
    const classes = elem.getAttribute("class");
    if (!classes || !classes.length) {
      elem.setAttribute("class", Layer.CLASS_NAME);
    } else if (!Layer.CLASS_REGEX.test(classes)) {
      elem.setAttribute("class", classes + " " + Layer.CLASS_NAME);
    }
  }
  var HistoryRecordingService = class {
    /**
    * @param {history.UndoManager|null} undoManager - The undo manager.
    *     A value of `null` is valid for cases where no history recording is required.
    *     See singleton: {@link module:history.HistoryRecordingService.HistoryRecordingService.NO_HISTORY}
    */
    constructor(undoManager) {
      this.undoManager_ = undoManager;
      this.currentBatchCommand_ = null;
      this.batchCommandStack_ = [];
    }
    /**
     * Start a batch command so multiple commands can recorded as a single history command.
     * Requires a corresponding call to endBatchCommand. Start and end commands can be nested.
     *
     * @param {string} text - Optional string describing the batch command.
     * @returns {module:history.HistoryRecordingService}
     */
    startBatchCommand(text2) {
      if (!this.undoManager_) {
        return this;
      }
      this.currentBatchCommand_ = new BatchCommand$4(text2);
      this.batchCommandStack_.push(this.currentBatchCommand_);
      return this;
    }
    /**
     * End a batch command and add it to the history or a parent batch command.
     * @returns {module:history.HistoryRecordingService}
     */
    endBatchCommand() {
      if (!this.undoManager_) {
        return this;
      }
      if (this.currentBatchCommand_) {
        const batchCommand = this.currentBatchCommand_;
        this.batchCommandStack_.pop();
        const {
          length: len
        } = this.batchCommandStack_;
        this.currentBatchCommand_ = len ? this.batchCommandStack_[len - 1] : null;
        this.addCommand_(batchCommand);
      }
      return this;
    }
    /**
     * Add a `MoveElementCommand` to the history or current batch command.
     * @param {Element} elem - The DOM element that was moved
     * @param {Element} oldNextSibling - The element's next sibling before it was moved
     * @param {Element} oldParent - The element's parent before it was moved
     * @param {string} [text] - An optional string visible to user related to this change
     * @returns {module:history.HistoryRecordingService}
     */
    moveElement(elem, oldNextSibling, oldParent, text2) {
      if (!this.undoManager_) {
        return this;
      }
      this.addCommand_(new MoveElementCommand$1(elem, oldNextSibling, oldParent, text2));
      return this;
    }
    /**
     * Add an `InsertElementCommand` to the history or current batch command.
     * @param {Element} elem - The DOM element that was added
     * @param {string} [text] - An optional string visible to user related to this change
     * @returns {module:history.HistoryRecordingService}
     */
    insertElement(elem, text2) {
      if (!this.undoManager_) {
        return this;
      }
      this.addCommand_(new InsertElementCommand$4(elem, text2));
      return this;
    }
    /**
     * Add a `RemoveElementCommand` to the history or current batch command.
     * @param {Element} elem - The DOM element that was removed
     * @param {Element} oldNextSibling - The element's next sibling before it was removed
     * @param {Element} oldParent - The element's parent before it was removed
     * @param {string} [text] - An optional string visible to user related to this change
     * @returns {module:history.HistoryRecordingService}
     */
    removeElement(elem, oldNextSibling, oldParent, text2) {
      if (!this.undoManager_) {
        return this;
      }
      this.addCommand_(new RemoveElementCommand$2(elem, oldNextSibling, oldParent, text2));
      return this;
    }
    /**
     * Add a `ChangeElementCommand` to the history or current batch command.
     * @param {Element} elem - The DOM element that was changed
     * @param {module:history.CommandAttributes} attrs - An object with the attributes to be changed and the values they had *before* the change
     * @param {string} [text] - An optional string visible to user related to this change
     * @returns {module:history.HistoryRecordingService}
     */
    changeElement(elem, attrs, text2) {
      if (!this.undoManager_) {
        return this;
      }
      this.addCommand_(new ChangeElementCommand$2(elem, attrs, text2));
      return this;
    }
    /**
     * Private function to add a command to the history or current batch command.
     * @private
     * @param {Command} cmd
     * @returns {module:history.HistoryRecordingService|void}
     */
    addCommand_(cmd) {
      if (!this.undoManager_) {
        return this;
      }
      if (this.currentBatchCommand_) {
        this.currentBatchCommand_.addSubCommand(cmd);
      } else {
        this.undoManager_.addCommandToHistory(cmd);
      }
      return void 0;
    }
  };
  HistoryRecordingService.NO_HISTORY = new HistoryRecordingService();
  var copyElem = function(el, getNextId) {
    const newEl = document.createElementNS(el.namespaceURI, el.nodeName);
    Object.values(el.attributes).forEach((attr) => {
      newEl.setAttributeNS(attr.namespaceURI, attr.nodeName, attr.value);
    });
    newEl.removeAttribute("id");
    newEl.id = getNextId();
    el.childNodes.forEach(function(child) {
      switch (child.nodeType) {
        case 1:
          newEl.append(copyElem(child, getNextId));
          break;
        case 3:
          newEl.textContent = child.nodeValue;
          break;
      }
    });
    if (el.dataset.gsvg) {
      newEl.dataset.gsvg = newEl.firstChild;
    } else if (el.dataset.symbol) {
      const ref = el.dataset.symbol;
      newEl.dataset.ref = ref;
      newEl.dataset.symbol = ref;
    } else if (newEl.tagName === "image") {
      preventClickDefault(newEl);
    }
    return newEl;
  };
  var visElems$1 = "a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use".split(",");
  var RandomizeModes = {
    LET_DOCUMENT_DECIDE: 0,
    ALWAYS_RANDOMIZE: 1,
    NEVER_RANDOMIZE: 2
  };
  var randIds = RandomizeModes.LET_DOCUMENT_DECIDE;
  var disabledElems = [];
  function historyRecordingService(hrService) {
    return hrService || new HistoryRecordingService(svgCanvas$e.undoMgr);
  }
  function findLayerNameInGroup(group) {
    const sel = group.querySelector("title");
    return sel ? sel.textContent : "";
  }
  function isLayerElement(element) {
    return element.classList.contains("layer");
  }
  function getNewLayerName(existingLayerNames) {
    let i2 = 1;
    while (existingLayerNames.includes(`Layer ${i2}`)) {
      i2++;
    }
    return `Layer ${i2}`;
  }
  var Drawing = class {
    /**
     * @param {SVGSVGElement} svgElem - The SVG DOM Element that this JS object
     *     encapsulates.  If the svgElem has a se:nonce attribute on it, then
     *     IDs will use the nonce as they are generated.
     * @param {string} [optIdPrefix=svg_] - The ID prefix to use.
     * @throws {Error} If not initialized with an SVG element
     */
    constructor(svgElem, optIdPrefix) {
      if (!svgElem || !svgElem.tagName || !svgElem.namespaceURI || svgElem.tagName !== "svg" || svgElem.namespaceURI !== NS.SVG) {
        throw new Error("Error: svgedit.draw.Drawing instance initialized without a <svg> element");
      }
      this.svgElem_ = svgElem;
      this.obj_num = 0;
      this.idPrefix = optIdPrefix || "svg_";
      this.releasedNums = [];
      this.all_layers = [];
      this.layer_map = {};
      this.current_layer = null;
      this.nonce_ = "";
      const n2 = this.svgElem_.getAttributeNS(NS.SE, "nonce");
      if (n2 && randIds !== RandomizeModes.NEVER_RANDOMIZE) {
        this.nonce_ = n2;
      } else if (randIds === RandomizeModes.ALWAYS_RANDOMIZE) {
        this.setNonce(Math.floor(Math.random() * 100001));
      }
    }
    /**
     * @param {string} id Element ID to retrieve
     * @returns {Element} SVG element within the root SVGSVGElement
     */
    getElem_(id) {
      if (this.svgElem_.querySelector) {
        return this.svgElem_.querySelector("#" + id);
      }
      return this.svgElem_.querySelector("[id=" + id + "]");
    }
    /**
     * @returns {SVGSVGElement}
     */
    getSvgElem() {
      return this.svgElem_;
    }
    /**
     * @returns {!(string|Integer)} The previously set nonce
     */
    getNonce() {
      return this.nonce_;
    }
    /**
     * @param {!(string|Integer)} n The nonce to set
     * @returns {void}
     */
    setNonce(n2) {
      this.svgElem_.setAttributeNS(NS.XMLNS, "xmlns:se", NS.SE);
      this.svgElem_.setAttributeNS(NS.SE, "se:nonce", n2);
      this.nonce_ = n2;
    }
    /**
     * Clears any previously set nonce.
     * @returns {void}
     */
    clearNonce() {
      this.nonce_ = "";
    }
    /**
     * Returns the latest object id as a string.
     * @returns {string} The latest object Id.
     */
    getId() {
      return this.nonce_ ? this.idPrefix + this.nonce_ + "_" + this.obj_num : this.idPrefix + this.obj_num;
    }
    /**
     * Returns the next object Id as a string.
     * @returns {string} The next object Id to use.
     */
    getNextId() {
      const oldObjNum = this.obj_num;
      let restoreOldObjNum = false;
      if (this.releasedNums.length > 0) {
        this.obj_num = this.releasedNums.pop();
        restoreOldObjNum = true;
      } else {
        this.obj_num++;
      }
      let id = this.getId();
      while (this.getElem_(id)) {
        if (restoreOldObjNum) {
          this.obj_num = oldObjNum;
          restoreOldObjNum = false;
        }
        this.obj_num++;
        id = this.getId();
      }
      if (restoreOldObjNum) {
        this.obj_num = oldObjNum;
      }
      return id;
    }
    /**
     * Releases the object Id, letting it be used as the next id in getNextId().
     * This method DOES NOT remove any elements from the DOM, it is expected
     * that client code will do this.
     * @param {string} id - The id to release.
     * @returns {boolean} True if the id was valid to be released, false otherwise.
     */
    releaseId(id) {
      const front = this.idPrefix + (this.nonce_ ? this.nonce_ + "_" : "");
      if (typeof id !== "string" || !id.startsWith(front)) {
        return false;
      }
      const num = Number.parseInt(id.substr(front.length));
      if (typeof num !== "number" || num <= 0 || this.releasedNums.includes(num)) {
        return false;
      }
      this.releasedNums.push(num);
      return true;
    }
    /**
     * Returns the number of layers in the current drawing.
     * @returns {Integer} The number of layers in the current drawing.
     */
    getNumLayers() {
      return this.all_layers.length;
    }
    /**
     * Check if layer with given name already exists.
     * @param {string} name - The layer name to check
     * @returns {boolean}
     */
    hasLayer(name) {
      return this.layer_map[name] !== void 0;
    }
    /**
     * Returns the name of the ith layer. If the index is out of range, an empty string is returned.
     * @param {Integer} i - The zero-based index of the layer you are querying.
     * @returns {string} The name of the ith layer (or the empty string if none found)
     */
    getLayerName(i2) {
      return i2 >= 0 && i2 < this.getNumLayers() ? this.all_layers[i2].getName() : "";
    }
    /**
     * @returns {SVGGElement|null} The SVGGElement representing the current layer.
     */
    getCurrentLayer() {
      return this.current_layer ? this.current_layer.getGroup() : null;
    }
    /**
     * Get a layer by name.
     * @param {string} name
     * @returns {SVGGElement} The SVGGElement representing the named layer or null.
     */
    getLayerByName(name) {
      const layer = this.layer_map[name];
      return layer ? layer.getGroup() : null;
    }
    /**
     * Returns the name of the currently selected layer. If an error occurs, an empty string
     * is returned.
     * @returns {string} The name of the currently active layer (or the empty string if none found).
     */
    getCurrentLayerName() {
      return this.current_layer ? this.current_layer.getName() : "";
    }
    /**
     * Set the current layer's name.
     * @param {string} name - The new name.
     * @param {module:history.HistoryRecordingService} hrService - History recording service
     * @returns {string|null} The new name if changed; otherwise, null.
     */
    setCurrentLayerName(name, hrService) {
      let finalName = null;
      if (this.current_layer) {
        const oldName = this.current_layer.getName();
        finalName = this.current_layer.setName(name, hrService);
        if (finalName) {
          delete this.layer_map[oldName];
          this.layer_map[finalName] = this.current_layer;
        }
      }
      return finalName;
    }
    /**
     * Set the current layer's position.
     * @param {Integer} newpos - The zero-based index of the new position of the layer. Range should be 0 to layers-1
     * @returns {{title: SVGGElement, previousName: string}|null} If the name was changed, returns {title:SVGGElement, previousName:string}; otherwise null.
     */
    setCurrentLayerPosition(newpos) {
      const layerCount = this.getNumLayers();
      if (!this.current_layer || newpos < 0 || newpos >= layerCount) {
        return null;
      }
      const oldpos = this.indexCurrentLayer();
      if (oldpos === -1 || oldpos === newpos) {
        return null;
      }
      const currentGroup = this.current_layer.getGroup();
      const oldNextSibling = currentGroup.nextSibling;
      let refGroup = null;
      if (newpos > oldpos) {
        if (newpos < layerCount - 1) {
          refGroup = this.all_layers[newpos + 1].getGroup();
        }
      } else {
        refGroup = this.all_layers[newpos].getGroup();
      }
      this.svgElem_.insertBefore(currentGroup, refGroup);
      this.identifyLayers();
      this.setCurrentLayer(this.getLayerName(newpos));
      return {
        currentGroup,
        oldNextSibling
      };
    }
    /**
     * @param {module:history.HistoryRecordingService} hrService
     * @returns {void}
     */
    mergeLayer(hrService) {
      const currentGroup = this.current_layer.getGroup();
      const prevGroup = currentGroup.previousElementSibling;
      if (!prevGroup) {
        return;
      }
      hrService.startBatchCommand("Merge Layer");
      const layerNextSibling = currentGroup.nextSibling;
      hrService.removeElement(currentGroup, layerNextSibling, this.svgElem_);
      while (currentGroup.firstChild) {
        const child = currentGroup.firstChild;
        if (child.localName === "title") {
          hrService.removeElement(child, child.nextSibling, currentGroup);
          child.remove();
          continue;
        }
        const oldNextSibling = child.nextSibling;
        prevGroup.append(child);
        hrService.moveElement(child, oldNextSibling, currentGroup);
      }
      this.current_layer.removeGroup();
      const index2 = this.indexCurrentLayer();
      if (index2 > 0) {
        const name = this.current_layer.getName();
        this.current_layer = this.all_layers[index2 - 1];
        this.all_layers.splice(index2, 1);
        delete this.layer_map[name];
      }
      hrService.endBatchCommand();
    }
    /**
     * @param {module:history.HistoryRecordingService} hrService
     * @returns {void}
     */
    mergeAllLayers(hrService) {
      this.current_layer = this.all_layers[this.all_layers.length - 1];
      hrService.startBatchCommand("Merge all Layers");
      while (this.all_layers.length > 1) {
        this.mergeLayer(hrService);
      }
      hrService.endBatchCommand();
    }
    /**
     * Sets the current layer. If the name is not a valid layer name, then this
     * function returns `false`. Otherwise it returns `true`. This is not an
     * undo-able action.
     * @param {string} name - The name of the layer you want to switch to.
     * @returns {boolean} `true` if the current layer was switched, otherwise `false`
     */
    setCurrentLayer(name) {
      const layer = this.layer_map[name];
      if (layer) {
        if (this.current_layer) {
          this.current_layer.deactivate();
        }
        this.current_layer = layer;
        this.current_layer.activate();
        return true;
      }
      return false;
    }
    /**
     * Sets the current layer. If the name is not a valid layer name, then this
     * function returns `false`. Otherwise it returns `true`. This is not an
     * undo-able action.
     * @param {string} name - The name of the layer you want to switch to.
     * @returns {boolean} `true` if the current layer was switched, otherwise `false`
     */
    indexCurrentLayer() {
      return this.all_layers.indexOf(this.current_layer);
    }
    /**
     * Deletes the current layer from the drawing and then clears the selection.
     * This function then calls the 'changed' handler.  This is an undoable action.
     * @todo Does this actually call the 'changed' handler?
     * @returns {SVGGElement} The SVGGElement of the layer removed or null.
     */
    deleteCurrentLayer() {
      if (this.current_layer && this.getNumLayers() > 1) {
        const oldLayerGroup = this.current_layer.removeGroup();
        this.identifyLayers();
        return oldLayerGroup;
      }
      return null;
    }
    /**
     * Updates layer system and sets the current layer to the
     * top-most layer (last `<g>` child of this drawing).
     * @returns {void}
     */
    identifyLayers() {
      this.all_layers = [];
      this.layer_map = {};
      const numchildren = this.svgElem_.childNodes.length;
      const orphans = [];
      const layernames = [];
      let layer = null;
      let childgroups = false;
      for (let i2 = 0; i2 < numchildren; ++i2) {
        const child = this.svgElem_.childNodes.item(i2);
        if (child?.nodeType === 1) {
          if (child.tagName === "g") {
            childgroups = true;
            if (isLayerElement(child)) {
              const name = findLayerNameInGroup(child);
              layernames.push(name);
              layer = new Layer(name, child);
              this.all_layers.push(layer);
              this.layer_map[name] = layer;
            } else {
              orphans.push(child);
            }
          } else if (visElems$1.includes(child.nodeName)) {
            orphans.push(child);
          }
        }
      }
      if (orphans.length > 0 || !childgroups) {
        const name = getNewLayerName(layernames);
        layer = new Layer(name, null, this.svgElem_);
        layer.appendChildren(orphans);
        this.all_layers.push(layer);
        this.layer_map[name] = layer;
      } else {
        layer.activate();
      }
      this.current_layer = layer;
    }
    /**
     * Creates a new top-level layer in the drawing with the given name and
     * makes it the current layer.
     * @param {string} name - The given name. If the layer name exists, a new name will be generated.
     * @param {module:history.HistoryRecordingService} hrService - History recording service
     * @returns {SVGGElement} The SVGGElement of the new layer, which is
     *     also the current layer of this drawing.
     */
    createLayer(name, hrService) {
      if (this.current_layer) {
        this.current_layer.deactivate();
      }
      if (name === void 0 || name === null || name === "" || this.layer_map[name]) {
        name = getNewLayerName(Object.keys(this.layer_map));
      }
      const layer = new Layer(name, null, this.svgElem_);
      if (hrService) {
        hrService.startBatchCommand("Create Layer");
        hrService.insertElement(layer.getGroup());
        hrService.endBatchCommand();
      }
      this.all_layers.push(layer);
      this.layer_map[name] = layer;
      this.current_layer = layer;
      return layer.getGroup();
    }
    /**
     * Creates a copy of the current layer with the given name and makes it the current layer.
     * @param {string} name - The given name. If the layer name exists, a new name will be generated.
     * @param {module:history.HistoryRecordingService} hrService - History recording service
     * @returns {SVGGElement} The SVGGElement of the new layer, which is
     *     also the current layer of this drawing.
     */
    cloneLayer(name, hrService) {
      if (!this.current_layer) {
        return null;
      }
      this.current_layer.deactivate();
      if (name === void 0 || name === null || name === "" || this.layer_map[name]) {
        name = getNewLayerName(Object.keys(this.layer_map));
      }
      const currentGroup = this.current_layer.getGroup();
      const layer = new Layer(name, currentGroup, this.svgElem_);
      const group = layer.getGroup();
      const children = [...currentGroup.childNodes];
      children.forEach((child) => {
        if (child.localName === "title") {
          return;
        }
        group.append(this.copyElem(child));
      });
      if (hrService) {
        hrService.startBatchCommand("Duplicate Layer");
        hrService.insertElement(group);
        hrService.endBatchCommand();
      }
      const index2 = this.indexCurrentLayer();
      if (index2 >= 0) {
        this.all_layers.splice(index2 + 1, 0, layer);
      } else {
        this.all_layers.push(layer);
      }
      this.layer_map[name] = layer;
      this.current_layer = layer;
      return group;
    }
    /**
     * Returns whether the layer is visible.  If the layer name is not valid,
     * then this function returns `false`.
     * @param {string} layerName - The name of the layer which you want to query.
     * @returns {boolean} The visibility state of the layer, or `false` if the layer name was invalid.
     */
    getLayerVisibility(layerName) {
      const layer = this.layer_map[layerName];
      return layer ? layer.isVisible() : false;
    }
    /**
     * Sets the visibility of the layer. If the layer name is not valid, this
     * function returns `null`, otherwise it returns the `SVGElement` representing
     * the layer. This is an undo-able action.
     * @param {string} layerName - The name of the layer to change the visibility
     * @param {boolean} bVisible - Whether the layer should be visible
     * @returns {?SVGGElement} The SVGGElement representing the layer if the
     *   `layerName` was valid, otherwise `null`.
     */
    setLayerVisibility(layerName, bVisible) {
      if (typeof bVisible !== "boolean") {
        return null;
      }
      const layer = this.layer_map[layerName];
      if (!layer) {
        return null;
      }
      layer.setVisible(bVisible);
      return layer.getGroup();
    }
    /**
     * Returns the opacity of the given layer.  If the input name is not a layer, `null` is returned.
     * @param {string} layerName - name of the layer on which to get the opacity
     * @returns {?Float} The opacity value of the given layer.  This will be a value between 0.0 and 1.0, or `null`
     * if `layerName` is not a valid layer
     */
    getLayerOpacity(layerName) {
      const layer = this.layer_map[layerName];
      if (!layer) {
        return null;
      }
      return layer.getOpacity();
    }
    /**
     * Sets the opacity of the given layer.  If the input name is not a layer,
     * nothing happens. If opacity is not a value between 0.0 and 1.0, then
     * nothing happens.
     * NOTE: this function exists solely to apply a highlighting/de-emphasis
     * effect to a layer. When it is possible for a user to affect the opacity
     * of a layer, we will need to allow this function to produce an undo-able
     * action.
     * @param {string} layerName - Name of the layer on which to set the opacity
     * @param {Float} opacity - A float value in the range 0.0-1.0
     * @returns {void}
     */
    setLayerOpacity(layerName, opacity) {
      if (typeof opacity !== "number" || opacity < 0 || opacity > 1) {
        return;
      }
      const layer = this.layer_map[layerName];
      if (layer) {
        layer.setOpacity(opacity);
      }
    }
    /**
     * Create a clone of an element, updating its ID and its children's IDs when needed.
     * @param {Element} el - DOM element to clone
     * @returns {Element}
     */
    copyElem(el) {
      const that = this;
      const getNextIdClosure = function() {
        return that.getNextId();
      };
      return copyElem(el, getNextIdClosure);
    }
  };
  var randomizeIds = function(enableRandomization, currentDrawing) {
    randIds = enableRandomization === false ? RandomizeModes.NEVER_RANDOMIZE : RandomizeModes.ALWAYS_RANDOMIZE;
    if (randIds === RandomizeModes.ALWAYS_RANDOMIZE && !currentDrawing.getNonce()) {
      currentDrawing.setNonce(Math.floor(Math.random() * 100001));
    } else if (randIds === RandomizeModes.NEVER_RANDOMIZE && currentDrawing.getNonce()) {
      currentDrawing.clearNonce();
    }
  };
  var svgCanvas$e;
  var init$f = (canvas) => {
    svgCanvas$e = canvas;
  };
  var identifyLayers = () => {
    leaveContext();
    svgCanvas$e.getCurrentDrawing().identifyLayers();
  };
  var indexCurrentLayer = () => {
    return svgCanvas$e.getCurrentDrawing().indexCurrentLayer();
  };
  var createLayer = (name, hrService) => {
    const newLayer = svgCanvas$e.getCurrentDrawing().createLayer(name, historyRecordingService(hrService));
    svgCanvas$e.clearSelection();
    svgCanvas$e.call("changed", [newLayer]);
  };
  var cloneLayer = (name, hrService) => {
    const newLayer = svgCanvas$e.getCurrentDrawing().cloneLayer(name, historyRecordingService(hrService));
    svgCanvas$e.clearSelection();
    leaveContext();
    svgCanvas$e.call("changed", [newLayer]);
  };
  var deleteCurrentLayer = () => {
    const {
      BatchCommand: BatchCommand3,
      RemoveElementCommand: RemoveElementCommand3
    } = svgCanvas$e.history;
    let currentLayer = svgCanvas$e.getCurrentDrawing().getCurrentLayer();
    const {
      nextSibling
    } = currentLayer;
    const parent = currentLayer.parentNode;
    currentLayer = svgCanvas$e.getCurrentDrawing().deleteCurrentLayer();
    if (currentLayer) {
      const batchCmd = new BatchCommand3("Delete Layer");
      batchCmd.addSubCommand(new RemoveElementCommand3(currentLayer, nextSibling, parent));
      svgCanvas$e.addCommandToHistory(batchCmd);
      svgCanvas$e.clearSelection();
      svgCanvas$e.call("changed", [parent]);
      return true;
    }
    return false;
  };
  var setCurrentLayer = (name) => {
    const result = svgCanvas$e.getCurrentDrawing().setCurrentLayer(toXml(name));
    if (result) {
      svgCanvas$e.clearSelection();
    }
    return result;
  };
  var renameCurrentLayer = (newName) => {
    const drawing = svgCanvas$e.getCurrentDrawing();
    const layer = drawing.getCurrentLayer();
    if (layer) {
      const result = drawing.setCurrentLayerName(newName, historyRecordingService());
      if (result) {
        svgCanvas$e.call("changed", [layer]);
        return true;
      }
    }
    return false;
  };
  var setCurrentLayerPosition = (newPos) => {
    const {
      MoveElementCommand: MoveElementCommand3
    } = svgCanvas$e.history;
    const drawing = svgCanvas$e.getCurrentDrawing();
    const result = drawing.setCurrentLayerPosition(newPos);
    if (result) {
      svgCanvas$e.addCommandToHistory(new MoveElementCommand3(result.currentGroup, result.oldNextSibling, svgCanvas$e.getSvgContent()));
      return true;
    }
    return false;
  };
  var setLayerVisibility = (layerName, bVisible) => {
    const {
      ChangeElementCommand: ChangeElementCommand3
    } = svgCanvas$e.history;
    const drawing = svgCanvas$e.getCurrentDrawing();
    const prevVisibility = drawing.getLayerVisibility(layerName);
    const layer = drawing.setLayerVisibility(layerName, bVisible);
    if (layer) {
      const oldDisplay = prevVisibility ? "inline" : "none";
      svgCanvas$e.addCommandToHistory(new ChangeElementCommand3(layer, {
        display: oldDisplay
      }, "Layer Visibility"));
    } else {
      return false;
    }
    if (layer === drawing.getCurrentLayer()) {
      svgCanvas$e.clearSelection();
      svgCanvas$e.pathActions.clear();
    }
    return true;
  };
  var moveSelectedToLayer = (layerName) => {
    const {
      BatchCommand: BatchCommand3,
      MoveElementCommand: MoveElementCommand3
    } = svgCanvas$e.history;
    const drawing = svgCanvas$e.getCurrentDrawing();
    const layer = drawing.getLayerByName(layerName);
    if (!layer) {
      return false;
    }
    const batchCmd = new BatchCommand3("Move Elements to Layer");
    const selElems = svgCanvas$e.getSelectedElements();
    let i2 = selElems.length;
    while (i2--) {
      const elem = selElems[i2];
      if (!elem) {
        continue;
      }
      const oldNextSibling = elem.nextSibling;
      const oldLayer = elem.parentNode;
      layer.append(elem);
      batchCmd.addSubCommand(new MoveElementCommand3(elem, oldNextSibling, oldLayer));
    }
    svgCanvas$e.addCommandToHistory(batchCmd);
    return true;
  };
  var mergeLayer = (hrService) => {
    svgCanvas$e.getCurrentDrawing().mergeLayer(historyRecordingService(hrService));
    svgCanvas$e.clearSelection();
    leaveContext();
    svgCanvas$e.changeSvgContent();
  };
  var mergeAllLayers = (hrService) => {
    svgCanvas$e.getCurrentDrawing().mergeAllLayers(historyRecordingService(hrService));
    svgCanvas$e.clearSelection();
    leaveContext();
    svgCanvas$e.changeSvgContent();
  };
  var leaveContext = () => {
    const len = disabledElems.length;
    const dataStorage2 = svgCanvas$e.getDataStorage();
    if (len) {
      for (let i2 = 0; i2 < len; i2++) {
        const elem = disabledElems[i2];
        const orig = dataStorage2.get(elem, "orig_opac");
        if (orig !== 1) {
          elem.setAttribute("opacity", orig);
        } else {
          elem.removeAttribute("opacity");
        }
        elem.setAttribute("style", "pointer-events: inherit");
      }
      disabledElems = [];
      svgCanvas$e.clearSelection(true);
      svgCanvas$e.call("contextset", null);
    }
    svgCanvas$e.setCurrentGroup(null);
  };
  var setContext = (elem) => {
    const dataStorage2 = svgCanvas$e.getDataStorage();
    leaveContext();
    if (typeof elem === "string") {
      elem = getElement(elem);
    }
    svgCanvas$e.setCurrentGroup(elem);
    const parentsUntil = getParentsUntil(elem, "#svgcontent");
    const siblings = [];
    parentsUntil.forEach(function(parent) {
      const elements2 = Array.prototype.filter.call(parent.parentNode.children, function(child) {
        return child !== parent;
      });
      elements2.forEach(function(element) {
        siblings.push(element);
      });
    });
    siblings.forEach(function(curthis) {
      const opac = curthis.getAttribute("opacity") || 1;
      dataStorage2.put(curthis, "orig_opac", opac);
      curthis.setAttribute("opacity", opac * 0.33);
      curthis.setAttribute("style", "pointer-events: none");
      disabledElems.push(curthis);
    });
    svgCanvas$e.clearSelection();
    svgCanvas$e.call("contextset", svgCanvas$e.getCurrentGroup());
  };
  var {
    InsertElementCommand: InsertElementCommand$3,
    BatchCommand: BatchCommand$3
  } = history;
  var svgCanvas$d = null;
  var init$e = (canvas) => {
    svgCanvas$d = canvas;
  };
  var pasteElementsMethod = function(type, x2, y2) {
    let clipb = JSON.parse(sessionStorage.getItem(svgCanvas$d.getClipboardID()));
    if (!clipb) return;
    let len = clipb.length;
    if (!len) return;
    const pasted = [];
    const batchCmd = new BatchCommand$3("Paste elements");
    const changedIDs = {};
    function checkIDs(elem) {
      if (elem.attr?.id) {
        changedIDs[elem.attr.id] = svgCanvas$d.getNextId();
        elem.attr.id = changedIDs[elem.attr.id];
      }
      if (elem.children) elem.children.forEach((child) => checkIDs(child));
    }
    clipb.forEach((elem) => checkIDs(elem));
    svgCanvas$d.runExtensions(
      "IDsUpdated",
      /** @type {module:svgcanvas.SvgCanvas#event:ext_IDsUpdated} */
      {
        elems: clipb,
        changes: changedIDs
      },
      true
    ).forEach(function(extChanges) {
      if (!extChanges || !("remove" in extChanges)) return;
      extChanges.remove.forEach(function(removeID) {
        clipb = clipb.filter(function(clipBoardItem) {
          return clipBoardItem.attr.id !== removeID;
        });
      });
    });
    while (len--) {
      const elem = clipb[len];
      if (!elem) {
        continue;
      }
      const copy = svgCanvas$d.addSVGElementsFromJson(elem);
      pasted.push(copy);
      batchCmd.addSubCommand(new InsertElementCommand$3(copy));
      svgCanvas$d.restoreRefElements(copy);
    }
    svgCanvas$d.selectOnly(pasted);
    if (type !== "in_place") {
      let ctrX;
      let ctrY;
      if (!type) {
        ctrX = svgCanvas$d.getLastClickPoint("x");
        ctrY = svgCanvas$d.getLastClickPoint("y");
      } else if (type === "point") {
        ctrX = x2;
        ctrY = y2;
      }
      const bbox = getStrokedBBoxDefaultVisible(pasted);
      const cx = ctrX - (bbox.x + bbox.width / 2);
      const cy = ctrY - (bbox.y + bbox.height / 2);
      const dx = [];
      const dy = [];
      pasted.forEach(function(_item) {
        dx.push(cx);
        dy.push(cy);
      });
      const cmd = svgCanvas$d.moveSelectedElements(dx, dy, false);
      if (cmd) batchCmd.addSubCommand(cmd);
    }
    svgCanvas$d.addCommandToHistory(batchCmd);
    svgCanvas$d.call("changed", pasted);
  };
  var touchHandler = (ev) => {
    ev.preventDefault();
    const {
      changedTouches
    } = ev;
    const first = changedTouches[0];
    let type = "";
    switch (ev.type) {
      case "touchstart":
        type = "mousedown";
        break;
      case "touchmove":
        type = "mousemove";
        break;
      case "touchend":
        type = "mouseup";
        break;
      default:
        return;
    }
    const {
      screenX,
      screenY,
      clientX,
      clientY
    } = first;
    const simulatedEvent = new MouseEvent(type, {
      // Event interface
      bubbles: true,
      cancelable: true,
      // UIEvent interface
      view: window,
      detail: 1,
      // click count
      // MouseEvent interface (customized)
      screenX,
      screenY,
      clientX,
      clientY,
      // MouseEvent interface (defaults) - these could be removed
      ctrlKey: false,
      altKey: false,
      shiftKey: false,
      metaKey: false,
      button: 0,
      // main button (usually left)
      relatedTarget: null
    });
    if (changedTouches.length < 2) {
      first.target.dispatchEvent(simulatedEvent);
    }
  };
  var init$d = (svgCanvas2) => {
    svgCanvas2.svgroot.addEventListener("touchstart", touchHandler);
    svgCanvas2.svgroot.addEventListener("touchmove", touchHandler);
    svgCanvas2.svgroot.addEventListener("touchend", touchHandler);
    svgCanvas2.svgroot.addEventListener("touchcancel", touchHandler);
  };
  var svgRootElement = function(svgdoc, dimensions) {
    return svgdoc.importNode(text2xml(`<svg id="svgroot" xmlns="${NS.SVG}" xlinkns="${NS.XLINK}" width="${dimensions[0]}" 
        height="${dimensions[1]}" x="${dimensions[0]}" y="${dimensions[1]}" overflow="visible">
        <defs>
          <filter id="canvashadow" filterUnits="objectBoundingBox">
            <feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur"/>
            <feOffset in="blur" dx="5" dy="5" result="offsetBlur"/>
            <feMerge>
              <feMergeNode in="offsetBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
      </svg>`).documentElement, true);
  };
  var NSSVG = "http://www.w3.org/2000/svg";
  var {
    userAgent
  } = navigator;
  var isWebkit_ = userAgent.includes("AppleWebKit");
  var isGecko_ = userAgent.includes("Gecko/");
  var isChrome_ = userAgent.includes("Chrome/");
  userAgent.includes("Macintosh");
  var supportsGoodTextCharPos_ = (function() {
    const svgroot = document.createElementNS(NSSVG, "svg");
    const svgContent = document.createElementNS(NSSVG, "svg");
    document.documentElement.append(svgroot);
    svgContent.setAttribute("x", 5);
    svgroot.append(svgContent);
    const text2 = document.createElementNS(NSSVG, "text");
    text2.textContent = "a";
    svgContent.append(text2);
    try {
      const pos = text2.getStartPositionOfChar(0).x;
      return pos === 0;
    } catch (err2) {
      return false;
    } finally {
      svgroot.remove();
    }
  })();
  var isWebkit = () => isWebkit_;
  var isGecko = () => isGecko_;
  var isChrome = () => isChrome_;
  var supportsGoodTextCharPos = () => supportsGoodTextCharPos_;
  var {
    UndoManager: UndoManager2,
    HistoryEventTypes
  } = history;
  var svgCanvas$c = null;
  var init$c = (canvas) => {
    svgCanvas$c = canvas;
    canvas.undoMgr = getUndoManager();
  };
  var getUndoManager = () => {
    return new UndoManager2({
      /**
       * @param {string} eventType One of the HistoryEvent types
       * @param {module:history.HistoryCommand} cmd Fulfills the HistoryCommand interface
       * @fires module:undo.SvgCanvas#event:changed
       * @returns {void}
       */
      handleHistoryEvent(eventType, cmd) {
        const EventTypes = HistoryEventTypes;
        if (eventType === EventTypes.BEFORE_UNAPPLY || eventType === EventTypes.BEFORE_APPLY) {
          svgCanvas$c.clearSelection();
        } else if (eventType === EventTypes.AFTER_APPLY || eventType === EventTypes.AFTER_UNAPPLY) {
          const elems = cmd.elements();
          svgCanvas$c.pathActions.clear();
          svgCanvas$c.call("changed", elems);
          const cmdType = cmd.type();
          const isApply = eventType === EventTypes.AFTER_APPLY;
          if (cmdType === "MoveElementCommand") {
            const parent = isApply ? cmd.newParent : cmd.oldParent;
            if (parent === svgCanvas$c.getSvgContent()) {
              identifyLayers();
            }
          } else if (cmdType === "InsertElementCommand" || cmdType === "RemoveElementCommand") {
            if (cmd.parent === svgCanvas$c.getSvgContent()) {
              identifyLayers();
            }
            if (cmdType === "InsertElementCommand") {
              if (isApply) {
                svgCanvas$c.restoreRefElements(cmd.elem);
              }
            } else if (!isApply) {
              svgCanvas$c.restoreRefElements(cmd.elem);
            }
            if (cmd.elem?.tagName === "use") {
              svgCanvas$c.setUseData(cmd.elem);
            }
          } else if (cmdType === "ChangeElementCommand") {
            if (cmd.elem.tagName === "title" && cmd.elem.parentNode.parentNode === svgCanvas$c.getSvgContent()) {
              identifyLayers();
            }
            const values = isApply ? cmd.newValues : cmd.oldValues;
            if (values.stdDeviation) {
              svgCanvas$c.setBlurOffsets(cmd.elem.parentNode, values.stdDeviation);
            }
            if (cmd.elem.tagName === "text") {
              const [dx, dy] = [cmd.newValues.x - cmd.oldValues.x, cmd.newValues.y - cmd.oldValues.y];
              const tspans = cmd.elem.children;
              for (let i2 = 0; i2 < tspans.length; i2++) {
                let x2 = Number(tspans[i2].getAttribute("x"));
                let y2 = Number(tspans[i2].getAttribute("y"));
                const unapply2 = eventType === EventTypes.AFTER_UNAPPLY;
                x2 = unapply2 ? x2 - dx : x2 + dx;
                y2 = unapply2 ? y2 - dy : y2 + dy;
                tspans[i2].setAttribute("x", x2);
                tspans[i2].setAttribute("y", y2);
              }
            }
          }
        }
      }
    });
  };
  var ffClone = function(elem) {
    if (!isGecko()) {
      return elem;
    }
    const clone2 = elem.cloneNode(true);
    elem.before(clone2);
    elem.remove();
    svgCanvas$c.selectorManager.releaseSelector(elem);
    svgCanvas$c.setSelectedElements(0, clone2);
    svgCanvas$c.selectorManager.requestSelector(clone2).showGrips(true);
    return clone2;
  };
  var changeSelectedAttributeNoUndoMethod = (attr, newValue, elems) => {
    if (attr === "id") {
      const elem = elems[0];
      const oldId = elem.id;
      if (oldId !== newValue) {
        svgCanvas$c.clearSelection();
        elem.id = newValue;
        svgCanvas$c.addToSelection([elem], true);
        svgCanvas$c.call("elementRenamed", {
          elem,
          oldId,
          newId: newValue
        });
      }
      return;
    }
    const selectedElements = svgCanvas$c.getSelectedElements();
    const zoom = svgCanvas$c.getZoom();
    if (svgCanvas$c.getCurrentMode() === "pathedit") {
      svgCanvas$c.pathActions.moveNode(attr, newValue);
    }
    elems = elems ?? selectedElements;
    let i2 = elems.length;
    const noXYElems = ["g", "polyline", "path"];
    while (i2--) {
      let elem = elems[i2];
      if (!elem) {
        continue;
      }
      if ((attr === "x" || attr === "y") && noXYElems.includes(elem.tagName)) {
        const bbox = getStrokedBBoxDefaultVisible([elem]);
        const diffX = attr === "x" ? parseFloat(newValue) - bbox.x : 0;
        const diffY = attr === "y" ? parseFloat(newValue) - bbox.y : 0;
        svgCanvas$c.moveSelectedElements(diffX * zoom, diffY * zoom, true);
        continue;
      }
      let oldval = attr === "#text" ? elem.textContent : elem.getAttribute(attr);
      if (!oldval) {
        oldval = "";
      }
      if (oldval !== String(newValue)) {
        if (attr === "#text") {
          elem.textContent = newValue;
          if (/rotate/.test(elem.getAttribute("transform"))) {
            elem = ffClone(elem);
          }
        } else if (attr === "#href") {
          setHref(elem, newValue);
        } else if (newValue) {
          elem.setAttribute(attr, isNaN(parseFloat(newValue)) ? newValue : parseFloat(newValue));
        } else if (typeof newValue === "number") {
          elem.setAttribute(attr, newValue);
        } else {
          elem.removeAttribute(attr);
        }
        if (svgCanvas$c.getCurrentMode() === "textedit" && attr !== "#text" && elem.textContent.length) {
          svgCanvas$c.textActions.toSelectMode(elem);
        }
        if (isGecko() && elem.nodeName === "text" && /rotate/.test(elem.getAttribute("transform")) && (String(newValue).startsWith("url") || ["font-size", "font-family", "x", "y"].includes(attr) && elem.textContent)) {
          elem = ffClone(elem);
        }
        if (selectedElements.includes(elem)) {
          setTimeout(function() {
            if (!elem.parentNode) {
              return;
            }
            svgCanvas$c.selectorManager.requestSelector(elem).resize();
          }, 0);
        }
        const angle2 = getRotationAngle(elem);
        if (angle2 !== 0 && attr !== "transform") {
          const tlist = getTransformList(elem);
          let n2 = tlist.numberOfItems;
          while (n2--) {
            const xform = tlist.getItem(n2);
            if (xform.type === 4) {
              tlist.removeItem(n2);
              const box = getBBox(elem);
              const center = transformPoint(box.x + box.width / 2, box.y + box.height / 2, transformListToTransform(tlist).matrix);
              const cx = center.x;
              const cy = center.y;
              const newrot = svgCanvas$c.getSvgRoot().createSVGTransform();
              newrot.setRotate(angle2, cx, cy);
              tlist.insertItemBefore(newrot, n2);
              break;
            }
          }
        }
      }
    }
  };
  var changeSelectedAttributeMethod = function(attr, val, elems) {
    const selectedElements = svgCanvas$c.getSelectedElements();
    elems = elems || selectedElements;
    svgCanvas$c.undoMgr.beginUndoableChange(attr, elems);
    changeSelectedAttributeNoUndoMethod(attr, val, elems);
    const batchCmd = svgCanvas$c.undoMgr.finishUndoableChange();
    if (!batchCmd.isEmpty()) {
      svgCanvas$c.undoMgr.addCommandToHistory(batchCmd);
    }
  };
  var {
    BatchCommand: BatchCommand$2
  } = history;
  var svgCanvas$b = null;
  var init$b = (canvas) => {
    svgCanvas$b = canvas;
    svgCanvas$b.getMouseTarget = getMouseTargetMethod;
    svgCanvas$b.clearSelection = clearSelectionMethod;
    svgCanvas$b.addToSelection = addToSelectionMethod;
    svgCanvas$b.getIntersectionList = getIntersectionListMethod;
    svgCanvas$b.runExtensions = runExtensionsMethod;
    svgCanvas$b.groupSvgElem = groupSvgElem;
    svgCanvas$b.prepareSvg = prepareSvg;
    svgCanvas$b.recalculateAllSelectedDimensions = recalculateAllSelectedDimensions;
    svgCanvas$b.setRotationAngle = setRotationAngle;
  };
  var clearSelectionMethod = (noCall) => {
    const selectedElements = svgCanvas$b.getSelectedElements();
    selectedElements.forEach((elem) => {
      if (!elem) {
        return;
      }
      svgCanvas$b.selectorManager.releaseSelector(elem);
    });
    svgCanvas$b?.setEmptySelectedElements();
    if (!noCall) {
      svgCanvas$b.call("selected", svgCanvas$b.getSelectedElements());
    }
  };
  var addToSelectionMethod = (elemsToAdd, showGrips) => {
    const selectedElements = svgCanvas$b.getSelectedElements();
    if (!elemsToAdd.length) {
      return;
    }
    let firstNull = 0;
    while (firstNull < selectedElements.length) {
      if (selectedElements[firstNull] === null) {
        break;
      }
      ++firstNull;
    }
    let i2 = elemsToAdd.length;
    while (i2--) {
      let elem = elemsToAdd[i2];
      if (!elem || !elem.getBBox) {
        continue;
      }
      if (elem.tagName === "a" && elem.childNodes.length === 1) {
        elem = elem.firstChild;
      }
      if (!selectedElements.includes(elem)) {
        selectedElements[firstNull] = elem;
        firstNull++;
        const sel = svgCanvas$b.selectorManager.requestSelector(elem);
        if (selectedElements.length > 1) {
          sel.showGrips(false);
        }
      }
    }
    if (!selectedElements.length) {
      return;
    }
    svgCanvas$b.call("selected", selectedElements);
    if (selectedElements.length === 1) {
      svgCanvas$b.selectorManager.requestSelector(selectedElements[0]).showGrips(showGrips);
    }
    selectedElements.sort((a2, b2) => {
      if (a2 && b2 && a2.compareDocumentPosition) {
        return 3 - (b2.compareDocumentPosition(a2) & 6);
      }
      if (!a2) {
        return 1;
      }
      return 0;
    });
    while (!selectedElements[0]) {
      selectedElements.shift(0);
    }
  };
  var getMouseTargetMethod = (evt) => {
    if (!evt) {
      return null;
    }
    let mouseTarget = evt.target;
    if (mouseTarget.correspondingUseElement) {
      mouseTarget = mouseTarget.correspondingUseElement;
    }
    if ([NS.MATH, NS.HTML].includes(mouseTarget.namespaceURI) && mouseTarget.id !== "svgcanvas") {
      while (mouseTarget.nodeName !== "foreignObject") {
        mouseTarget = mouseTarget.parentNode;
        if (!mouseTarget) {
          return svgCanvas$b.getSvgRoot();
        }
      }
    }
    const currentLayer = svgCanvas$b.getCurrentDrawing().getCurrentLayer();
    const svgRoot = svgCanvas$b.getSvgRoot();
    const container = svgCanvas$b.getDOMContainer();
    const content = svgCanvas$b.getSvgContent();
    if ([svgRoot, container, content, currentLayer].includes(mouseTarget)) {
      return svgCanvas$b.getSvgRoot();
    }
    if (getClosest(mouseTarget.parentNode, "#selectorParentGroup")) {
      return svgCanvas$b.selectorManager.selectorParentGroup;
    }
    while (!mouseTarget?.parentNode?.isSameNode(svgCanvas$b.getCurrentGroup() || currentLayer)) {
      mouseTarget = mouseTarget.parentNode;
    }
    return mouseTarget;
  };
  var runExtensionsMethod = (action, vars, returnArray) => {
    let result = returnArray ? [] : false;
    for (const [name, ext] of Object.entries(svgCanvas$b.getExtensions())) {
      if (typeof vars === "function") {
        vars = vars(name);
      }
      if (ext.eventBased) {
        const event = new CustomEvent("svgedit", {
          detail: {
            action,
            vars
          }
        });
        document.dispatchEvent(event);
      } else if (ext[action]) {
        if (returnArray) {
          result.push(ext[action](vars));
        } else {
          result = ext[action](vars);
        }
      }
    }
    return result;
  };
  var getVisibleElementsAndBBoxes = (parent) => {
    if (!parent) {
      const svgContent = svgCanvas$b.getSvgContent();
      parent = svgContent.children;
    }
    const contentElems = [];
    const elements2 = parent.children;
    Array.from(elements2).forEach((elem) => {
      if (elem.getBBox) {
        contentElems.push({
          elem,
          bbox: getStrokedBBoxDefaultVisible([elem])
        });
      }
    });
    return contentElems.reverse();
  };
  var getIntersectionListMethod = (rect) => {
    const zoom = svgCanvas$b.getZoom();
    if (!svgCanvas$b.getRubberBox()) {
      return null;
    }
    const parent = svgCanvas$b.getCurrentGroup() || svgCanvas$b.getCurrentDrawing().getCurrentLayer();
    let rubberBBox;
    if (!rect) {
      rubberBBox = getBBox(svgCanvas$b.getRubberBox());
      const bb = svgCanvas$b.getSvgContent().createSVGRect();
      ["x", "y", "width", "height", "top", "right", "bottom", "left"].forEach((o2) => {
        bb[o2] = rubberBBox[o2] / zoom;
      });
      rubberBBox = bb;
    } else {
      rubberBBox = svgCanvas$b.getSvgContent().createSVGRect();
      rubberBBox.x = rect.x;
      rubberBBox.y = rect.y;
      rubberBBox.width = rect.width;
      rubberBBox.height = rect.height;
    }
    const resultList = [];
    if (svgCanvas$b.getCurBBoxes().length === 0) {
      svgCanvas$b.setCurBBoxes(getVisibleElementsAndBBoxes(parent));
    }
    let i2 = svgCanvas$b.getCurBBoxes().length;
    while (i2--) {
      const curBBoxes = svgCanvas$b.getCurBBoxes();
      if (!rubberBBox.width) {
        continue;
      }
      if (curBBoxes[i2].bbox && rectsIntersect(rubberBBox, curBBoxes[i2].bbox)) {
        resultList.push(curBBoxes[i2].elem);
      }
    }
    return resultList;
  };
  var groupSvgElem = (elem) => {
    const dataStorage2 = svgCanvas$b.getDataStorage();
    const g2 = document.createElementNS(NS.SVG, "g");
    elem.replaceWith(g2);
    g2.appendChild(elem);
    dataStorage2.put(g2, "gsvg", elem);
    g2.id = svgCanvas$b.getNextId();
  };
  var prepareSvg = (newDoc) => {
    svgCanvas$b.sanitizeSvg(newDoc.documentElement);
    const paths = [...newDoc.getElementsByTagNameNS(NS.SVG, "path")];
    paths.forEach((path2) => {
      const convertedPath = svgCanvas$b.pathActions.convertPath(path2);
      path2.setAttribute("d", convertedPath);
      svgCanvas$b.pathActions.fixEnd(path2);
    });
  };
  var setRotationAngle = (val, preventUndo) => {
    const selectedElements = svgCanvas$b.getSelectedElements();
    val = Number.parseFloat(val);
    const elem = selectedElements[0];
    const oldTransform = elem.getAttribute("transform");
    const bbox = getBBox(elem);
    const cx = bbox.x + bbox.width / 2;
    const cy = bbox.y + bbox.height / 2;
    const tlist = getTransformList(elem);
    if (tlist.numberOfItems > 0) {
      const xform = tlist.getItem(0);
      if (xform.type === 4) {
        tlist.removeItem(0);
      }
    }
    if (val !== 0) {
      const center = transformPoint(cx, cy, transformListToTransform(tlist).matrix);
      const Rnc = svgCanvas$b.getSvgRoot().createSVGTransform();
      Rnc.setRotate(val, center.x, center.y);
      if (tlist.numberOfItems) {
        tlist.insertItemBefore(Rnc, 0);
      } else {
        tlist.appendItem(Rnc);
      }
    } else if (tlist.numberOfItems === 0) {
      elem.removeAttribute("transform");
    }
    if (!preventUndo) {
      let newTransform = elem.getAttribute("transform");
      if (newTransform) {
        const newTransformArray = newTransform.split(/[ ,]+/);
        const round = (num) => Math.round(Number(num) + Number.EPSILON);
        const x2 = round(newTransformArray[1]);
        newTransform = `${newTransformArray[0]} ${x2} ${newTransformArray[2]}`;
      }
      if (oldTransform) {
        elem.setAttribute("transform", oldTransform);
      } else {
        elem.removeAttribute("transform");
      }
      svgCanvas$b.changeSelectedAttribute("transform", newTransform, selectedElements);
      svgCanvas$b.call("changed", selectedElements);
    }
    const selector = svgCanvas$b.selectorManager.requestSelector(selectedElements[0]);
    selector.resize();
    svgCanvas$b.getSelector().updateGripCursors(val);
  };
  var recalculateAllSelectedDimensions = () => {
    const text2 = svgCanvas$b.getCurrentResizeMode() === "none" ? "position" : "size";
    const batchCmd = new BatchCommand$2(text2);
    const selectedElements = svgCanvas$b.getSelectedElements();
    selectedElements.forEach((elem) => {
      const cmd = svgCanvas$b.recalculateDimensions(elem);
      if (cmd) {
        batchCmd.addSubCommand(cmd);
      }
    });
    if (!batchCmd.isEmpty()) {
      svgCanvas$b.addCommandToHistory(batchCmd);
      svgCanvas$b.call("changed", selectedElements);
    }
  };
  var svgCanvas$a = null;
  var init$a = (canvas) => {
    svgCanvas$a = canvas;
  };
  var textActionsMethod = /* @__PURE__ */ (function() {
    let curtext;
    let textinput;
    let cursor;
    let selblock;
    let blinker;
    let chardata = [];
    let textbb;
    let matrix2;
    let lastX;
    let lastY;
    let allowDbl;
    function setCursor(index2) {
      const empty = textinput.value === "";
      textinput.focus();
      if (!arguments.length) {
        if (empty) {
          index2 = 0;
        } else {
          if (textinput.selectionEnd !== textinput.selectionStart) {
            return;
          }
          index2 = textinput.selectionEnd;
        }
      }
      const charbb = chardata[index2];
      if (!empty) {
        textinput.setSelectionRange(index2, index2);
      }
      cursor = getElement("text_cursor");
      if (!cursor) {
        cursor = document.createElementNS(NS.SVG, "line");
        assignAttributes(cursor, {
          id: "text_cursor",
          stroke: "#333",
          "stroke-width": 1
        });
        getElement("selectorParentGroup").append(cursor);
      }
      if (!blinker) {
        blinker = setInterval(function() {
          const show = cursor.getAttribute("display") === "none";
          cursor.setAttribute("display", show ? "inline" : "none");
        }, 600);
      }
      const startPt = ptToScreen(charbb.x, textbb.y);
      const endPt = ptToScreen(charbb.x, textbb.y + textbb.height);
      assignAttributes(cursor, {
        x1: startPt.x,
        y1: startPt.y,
        x2: endPt.x,
        y2: endPt.y,
        visibility: "visible",
        display: "inline"
      });
      if (selblock) {
        selblock.setAttribute("d", "");
      }
    }
    function setSelection(start, end, skipInput) {
      if (start === end) {
        setCursor(end);
        return;
      }
      if (!skipInput) {
        textinput.setSelectionRange(start, end);
      }
      selblock = getElement("text_selectblock");
      if (!selblock) {
        selblock = document.createElementNS(NS.SVG, "path");
        assignAttributes(selblock, {
          id: "text_selectblock",
          fill: "green",
          opacity: 0.5,
          style: "pointer-events:none"
        });
        getElement("selectorParentGroup").append(selblock);
      }
      const startbb = chardata[start];
      const endbb = chardata[end];
      cursor.setAttribute("visibility", "hidden");
      const tl = ptToScreen(startbb.x, textbb.y);
      const tr = ptToScreen(startbb.x + (endbb.x - startbb.x), textbb.y);
      const bl = ptToScreen(startbb.x, textbb.y + textbb.height);
      const br = ptToScreen(startbb.x + (endbb.x - startbb.x), textbb.y + textbb.height);
      const dstr = "M" + tl.x + "," + tl.y + " L" + tr.x + "," + tr.y + " " + br.x + "," + br.y + " " + bl.x + "," + bl.y + "z";
      assignAttributes(selblock, {
        d: dstr,
        display: "inline"
      });
    }
    function getIndexFromPoint(mouseX, mouseY) {
      const pt2 = svgCanvas$a.getSvgRoot().createSVGPoint();
      pt2.x = mouseX;
      pt2.y = mouseY;
      if (chardata.length === 1) {
        return 0;
      }
      let charpos = curtext.getCharNumAtPosition(pt2);
      if (charpos < 0) {
        charpos = chardata.length - 2;
        if (mouseX <= chardata[0].x) {
          charpos = 0;
        }
      } else if (charpos >= chardata.length - 2) {
        charpos = chardata.length - 2;
      }
      const charbb = chardata[charpos];
      const mid = charbb.x + charbb.width / 2;
      if (mouseX > mid) {
        charpos++;
      }
      return charpos;
    }
    function setCursorFromPoint(mouseX, mouseY) {
      setCursor(getIndexFromPoint(mouseX, mouseY));
    }
    function setEndSelectionFromPoint(x2, y2, apply2) {
      const i1 = textinput.selectionStart;
      const i2 = getIndexFromPoint(x2, y2);
      const start = Math.min(i1, i2);
      const end = Math.max(i1, i2);
      setSelection(start, end, !apply2);
    }
    function screenToPt(xIn, yIn) {
      const out = {
        x: xIn,
        y: yIn
      };
      const zoom = svgCanvas$a.getZoom();
      out.x /= zoom;
      out.y /= zoom;
      if (matrix2) {
        const pt2 = transformPoint(out.x, out.y, matrix2.inverse());
        out.x = pt2.x;
        out.y = pt2.y;
      }
      return out;
    }
    function ptToScreen(xIn, yIn) {
      const out = {
        x: xIn,
        y: yIn
      };
      if (matrix2) {
        const pt2 = transformPoint(out.x, out.y, matrix2);
        out.x = pt2.x;
        out.y = pt2.y;
      }
      const zoom = svgCanvas$a.getZoom();
      out.x *= zoom;
      out.y *= zoom;
      return out;
    }
    function selectAll(evt) {
      setSelection(0, curtext.textContent.length);
      evt.target.removeEventListener("click", selectAll);
    }
    function selectWord(evt) {
      if (!allowDbl || !curtext) {
        return;
      }
      const zoom = svgCanvas$a.getZoom();
      const ept = transformPoint(evt.pageX, evt.pageY, svgCanvas$a.getrootSctm());
      const mouseX = ept.x * zoom;
      const mouseY = ept.y * zoom;
      const pt2 = screenToPt(mouseX, mouseY);
      const index2 = getIndexFromPoint(pt2.x, pt2.y);
      const str = curtext.textContent;
      const first = str.substr(0, index2).replace(/[a-z\d]+$/i, "").length;
      const m2 = str.substr(index2).match(/^[a-z\d]+/i);
      const last = (m2 ? m2[0].length : 0) + index2;
      setSelection(first, last);
      svgCanvas$a.$click(evt.target, selectAll);
      setTimeout(function() {
        evt.target.removeEventListener("click", selectAll);
      }, 300);
    }
    return (
      /** @lends module:svgcanvas.SvgCanvas#textActions */
      {
        /**
         * @param {Element} target
         * @param {Float} x
         * @param {Float} y
         * @returns {void}
         */
        select(target, x2, y2) {
          curtext = target;
          svgCanvas$a.textActions.toEditMode(x2, y2);
        },
        /**
         * @param {Element} elem
         * @returns {void}
         */
        start(elem) {
          curtext = elem;
          svgCanvas$a.textActions.toEditMode();
        },
        /**
         * @param {external:MouseEvent} evt
         * @param {Element} mouseTarget
         * @param {Float} startX
         * @param {Float} startY
         * @returns {void}
         */
        mouseDown(evt, mouseTarget, startX, startY) {
          const pt2 = screenToPt(startX, startY);
          textinput.focus();
          setCursorFromPoint(pt2.x, pt2.y);
          lastX = startX;
          lastY = startY;
        },
        /**
         * @param {Float} mouseX
         * @param {Float} mouseY
         * @returns {void}
         */
        mouseMove(mouseX, mouseY) {
          const pt2 = screenToPt(mouseX, mouseY);
          setEndSelectionFromPoint(pt2.x, pt2.y);
        },
        /**
         * @param {external:MouseEvent} evt
         * @param {Float} mouseX
         * @param {Float} mouseY
         * @returns {void}
         */
        mouseUp(evt, mouseX, mouseY) {
          const pt2 = screenToPt(mouseX, mouseY);
          setEndSelectionFromPoint(pt2.x, pt2.y, true);
          if (evt.target !== curtext && mouseX < lastX + 2 && mouseX > lastX - 2 && mouseY < lastY + 2 && mouseY > lastY - 2) {
            svgCanvas$a.textActions.toSelectMode(true);
          }
        },
        /**
         * @function
         * @param {Integer} index
         * @returns {void}
         */
        setCursor,
        /**
         * @param {Float} x
         * @param {Float} y
         * @returns {void}
         */
        toEditMode(x2, y2) {
          allowDbl = false;
          svgCanvas$a.setCurrentMode("textedit");
          svgCanvas$a.selectorManager.requestSelector(curtext).showGrips(false);
          svgCanvas$a.selectorManager.requestSelector(curtext);
          svgCanvas$a.textActions.init();
          curtext.style.cursor = "text";
          if (!arguments.length) {
            setCursor();
          } else {
            const pt2 = screenToPt(x2, y2);
            setCursorFromPoint(pt2.x, pt2.y);
          }
          setTimeout(function() {
            allowDbl = true;
          }, 300);
        },
        /**
         * @param {boolean|Element} selectElem
         * @fires module:svgcanvas.SvgCanvas#event:selected
         * @returns {void}
         */
        toSelectMode(selectElem) {
          svgCanvas$a.setCurrentMode("select");
          clearInterval(blinker);
          blinker = null;
          if (selblock) {
            selblock.setAttribute("display", "none");
          }
          if (cursor) {
            cursor.setAttribute("visibility", "hidden");
          }
          curtext.style.cursor = "move";
          if (selectElem) {
            svgCanvas$a.clearSelection();
            curtext.style.cursor = "move";
            svgCanvas$a.call("selected", [curtext]);
            svgCanvas$a.addToSelection([curtext], true);
          }
          if (!curtext?.textContent.length) {
            svgCanvas$a.deleteSelectedElements();
          }
          textinput.blur();
          curtext = false;
        },
        /**
         * @param {Element} elem
         * @returns {void}
         */
        setInputElem(elem) {
          textinput = elem;
        },
        /**
         * @returns {void}
         */
        clear() {
          if (svgCanvas$a.getCurrentMode() === "textedit") {
            svgCanvas$a.textActions.toSelectMode();
          }
        },
        /**
         * @param {Element} _inputElem Not in use
         * @returns {void}
         */
        init(_inputElem) {
          if (!curtext) {
            return;
          }
          let i2;
          let end;
          if (!curtext.parentNode) {
            const selectedElements = svgCanvas$a.getSelectedElements();
            curtext = selectedElements[0];
            svgCanvas$a.selectorManager.requestSelector(curtext).showGrips(false);
          }
          const str = curtext.textContent;
          const len = str.length;
          const xform = curtext.getAttribute("transform");
          textbb = getBBox(curtext);
          matrix2 = xform ? getMatrix(curtext) : null;
          chardata = [];
          chardata.length = len;
          textinput.focus();
          curtext.removeEventListener("dblclick", selectWord);
          curtext.addEventListener("dblclick", selectWord);
          if (!len) {
            end = {
              x: textbb.x + textbb.width / 2,
              width: 0
            };
          }
          for (i2 = 0; i2 < len; i2++) {
            const start = curtext.getStartPositionOfChar(i2);
            end = curtext.getEndPositionOfChar(i2);
            if (!supportsGoodTextCharPos()) {
              const zoom = svgCanvas$a.getZoom();
              const offset = svgCanvas$a.contentW * zoom;
              start.x -= offset;
              end.x -= offset;
              start.x /= zoom;
              end.x /= zoom;
            }
            chardata[i2] = {
              x: start.x,
              y: textbb.y,
              // start.y?
              width: end.x - start.x,
              height: textbb.height
            };
          }
          chardata.push({
            x: end.x,
            width: 0
          });
          setSelection(textinput.selectionStart, textinput.selectionEnd, true);
        }
      }
    );
  })();
  var {
    InsertElementCommand: InsertElementCommand$2
  } = history;
  var svgCanvas$9 = null;
  var moveSelectionThresholdReached = false;
  var init$9 = (canvas) => {
    svgCanvas$9 = canvas;
    svgCanvas$9.mouseDownEvent = mouseDownEvent;
    svgCanvas$9.mouseMoveEvent = mouseMoveEvent;
    svgCanvas$9.dblClickEvent = dblClickEvent;
    svgCanvas$9.mouseUpEvent = mouseUpEvent;
    svgCanvas$9.mouseOutEvent = mouseOutEvent;
    svgCanvas$9.DOMMouseScrollEvent = DOMMouseScrollEvent;
  };
  var getBsplinePoint = (t3) => {
    const spline = {
      x: 0,
      y: 0
    };
    const p0 = {
      x: svgCanvas$9.getControllPoint2("x"),
      y: svgCanvas$9.getControllPoint2("y")
    };
    const p1 = {
      x: svgCanvas$9.getControllPoint1("x"),
      y: svgCanvas$9.getControllPoint1("y")
    };
    const p2 = {
      x: svgCanvas$9.getStart("x"),
      y: svgCanvas$9.getStart("y")
    };
    const p3 = {
      x: svgCanvas$9.getEnd("x"),
      y: svgCanvas$9.getEnd("y")
    };
    const S2 = 1 / 6;
    const t22 = t3 * t3;
    const t32 = t22 * t3;
    const m2 = [[-1, 3, -3, 1], [3, -6, 3, 0], [-3, 0, 3, 0], [1, 4, 1, 0]];
    spline.x = S2 * ((p0.x * m2[0][0] + p1.x * m2[0][1] + p2.x * m2[0][2] + p3.x * m2[0][3]) * t32 + (p0.x * m2[1][0] + p1.x * m2[1][1] + p2.x * m2[1][2] + p3.x * m2[1][3]) * t22 + (p0.x * m2[2][0] + p1.x * m2[2][1] + p2.x * m2[2][2] + p3.x * m2[2][3]) * t3 + (p0.x * m2[3][0] + p1.x * m2[3][1] + p2.x * m2[3][2] + p3.x * m2[3][3]));
    spline.y = S2 * ((p0.y * m2[0][0] + p1.y * m2[0][1] + p2.y * m2[0][2] + p3.y * m2[0][3]) * t32 + (p0.y * m2[1][0] + p1.y * m2[1][1] + p2.y * m2[1][2] + p3.y * m2[1][3]) * t22 + (p0.y * m2[2][0] + p1.y * m2[2][1] + p2.y * m2[2][2] + p3.y * m2[2][3]) * t3 + (p0.y * m2[3][0] + p1.y * m2[3][1] + p2.y * m2[3][2] + p3.y * m2[3][3]));
    return {
      x: spline.x,
      y: spline.y
    };
  };
  var updateTransformList = (svgRoot, element, dx, dy) => {
    const xform = svgRoot.createSVGTransform();
    xform.setTranslate(dx, dy);
    const tlist = getTransformList(element);
    if (tlist.numberOfItems) {
      const firstItem = tlist.getItem(0);
      if (firstItem.type === 2) {
        tlist.replaceItem(xform, 0);
      } else {
        tlist.insertItemBefore(xform, 0);
      }
    } else {
      tlist.appendItem(xform);
    }
  };
  var mouseMoveEvent = (evt) => {
    if (!svgCanvas$9.getStarted()) {
      return;
    }
    if (evt.button === 1 || svgCanvas$9.spaceKey) {
      return;
    }
    svgCanvas$9.textActions.init();
    evt.preventDefault();
    const selectedElements = svgCanvas$9.getSelectedElements();
    const zoom = svgCanvas$9.getZoom();
    const svgRoot = svgCanvas$9.getSvgRoot();
    const selected = selectedElements[0];
    let i2;
    let xya;
    let cx;
    let cy;
    let dx;
    let dy;
    let len;
    let angle2;
    let box;
    const pt2 = transformPoint(evt.clientX, evt.clientY, svgCanvas$9.getrootSctm());
    const mouseX = pt2.x * zoom;
    const mouseY = pt2.y * zoom;
    const shape = getElement(svgCanvas$9.getId());
    let realX = mouseX / zoom;
    let x2 = realX;
    let realY = mouseY / zoom;
    let y2 = realY;
    if (svgCanvas$9.getCurConfig().gridSnapping) {
      x2 = snapToGrid(x2);
      y2 = snapToGrid(y2);
    }
    let tlist;
    switch (svgCanvas$9.getCurrentMode()) {
      case "select": {
        if (selected) {
          dx = x2 - svgCanvas$9.getStartX();
          dy = y2 - svgCanvas$9.getStartY();
          if (svgCanvas$9.getCurConfig().gridSnapping) {
            dx = snapToGrid(dx);
            dy = snapToGrid(dy);
          }
          const deltaThreshold = 4;
          const deltaThresholdReached = Math.abs(dx) > deltaThreshold || Math.abs(dy) > deltaThreshold;
          moveSelectionThresholdReached = moveSelectionThresholdReached || deltaThresholdReached;
          if (moveSelectionThresholdReached) {
            selectedElements.forEach((el) => {
              if (el) {
                updateTransformList(svgRoot, el, dx, dy);
                svgCanvas$9.selectorManager.requestSelector(el).resize();
              }
            });
            svgCanvas$9.call("transition", selectedElements);
          }
        }
        break;
      }
      case "multiselect": {
        realX *= zoom;
        realY *= zoom;
        assignAttributes(svgCanvas$9.getRubberBox(), {
          x: Math.min(svgCanvas$9.getRStartX(), realX),
          y: Math.min(svgCanvas$9.getRStartY(), realY),
          width: Math.abs(realX - svgCanvas$9.getRStartX()),
          height: Math.abs(realY - svgCanvas$9.getRStartY())
        });
        const elemsToRemove = selectedElements.slice();
        const elemsToAdd = [];
        const newList = svgCanvas$9.getIntersectionList();
        len = newList.length;
        for (i2 = 0; i2 < len; ++i2) {
          const intElem = newList[i2];
          if (!selectedElements.includes(intElem)) {
            elemsToAdd.push(intElem);
          }
          const foundInd = elemsToRemove.indexOf(intElem);
          if (foundInd !== -1) {
            elemsToRemove.splice(foundInd, 1);
          }
        }
        if (elemsToRemove.length > 0) {
          svgCanvas$9.removeFromSelection(elemsToRemove);
        }
        if (elemsToAdd.length > 0) {
          svgCanvas$9.addToSelection(elemsToAdd);
        }
        break;
      }
      case "resize": {
        tlist = getTransformList(selected);
        const hasMatrix = hasMatrixTransform(tlist);
        box = hasMatrix ? svgCanvas$9.getInitBbox() : getBBox(selected);
        let left = box.x;
        let top = box.y;
        let {
          width,
          height
        } = box;
        dx = x2 - svgCanvas$9.getStartX();
        dy = y2 - svgCanvas$9.getStartY();
        if (svgCanvas$9.getCurConfig().gridSnapping) {
          dx = snapToGrid(dx);
          dy = snapToGrid(dy);
          height = snapToGrid(height);
          width = snapToGrid(width);
        }
        angle2 = getRotationAngle(selected);
        if (angle2) {
          const r2 = Math.sqrt(dx * dx + dy * dy);
          const theta = Math.atan2(dy, dx) - angle2 * Math.PI / 180;
          dx = r2 * Math.cos(theta);
          dy = r2 * Math.sin(theta);
        }
        if (!svgCanvas$9.getCurrentResizeMode().includes("n") && !svgCanvas$9.getCurrentResizeMode().includes("s")) {
          dy = 0;
        }
        if (!svgCanvas$9.getCurrentResizeMode().includes("e") && !svgCanvas$9.getCurrentResizeMode().includes("w")) {
          dx = 0;
        }
        let tx = 0;
        let ty = 0;
        let sy = height ? (height + dy) / height : 1;
        let sx = width ? (width + dx) / width : 1;
        if (svgCanvas$9.getCurrentResizeMode().includes("n")) {
          sy = height ? (height - dy) / height : 1;
          ty = height;
        }
        if (svgCanvas$9.getCurrentResizeMode().includes("w")) {
          sx = width ? (width - dx) / width : 1;
          tx = width;
        }
        const translateOrigin = svgRoot.createSVGTransform();
        const scale = svgRoot.createSVGTransform();
        const translateBack = svgRoot.createSVGTransform();
        if (svgCanvas$9.getCurConfig().gridSnapping) {
          left = snapToGrid(left);
          tx = snapToGrid(tx);
          top = snapToGrid(top);
          ty = snapToGrid(ty);
        }
        translateOrigin.setTranslate(-(left + tx), -(top + ty));
        const maintainAspectRatio = selected.tagName !== "image" && evt.shiftKey || selected.tagName === "image" && !evt.shiftKey;
        if (maintainAspectRatio) {
          if (sx === 1) {
            sx = sy;
          } else {
            sy = sx;
          }
        }
        scale.setScale(sx, sy);
        translateBack.setTranslate(left + tx, top + ty);
        if (hasMatrix) {
          const diff = angle2 ? 1 : 0;
          tlist.replaceItem(translateOrigin, 2 + diff);
          tlist.replaceItem(scale, 1 + diff);
          tlist.replaceItem(translateBack, Number(diff));
        } else {
          const N2 = tlist.numberOfItems;
          tlist.replaceItem(translateBack, N2 - 3);
          tlist.replaceItem(scale, N2 - 2);
          tlist.replaceItem(translateOrigin, N2 - 1);
        }
        svgCanvas$9.selectorManager.requestSelector(selected).resize();
        svgCanvas$9.call("transition", selectedElements);
        break;
      }
      case "zoom": {
        realX *= zoom;
        realY *= zoom;
        assignAttributes(svgCanvas$9.getRubberBox(), {
          x: Math.min(svgCanvas$9.getRStartX() * zoom, realX),
          y: Math.min(svgCanvas$9.getRStartY() * zoom, realY),
          width: Math.abs(realX - svgCanvas$9.getRStartX() * zoom),
          height: Math.abs(realY - svgCanvas$9.getRStartY() * zoom)
        });
        break;
      }
      case "text": {
        assignAttributes(shape, {
          x: x2,
          y: y2
        });
        break;
      }
      case "line": {
        if (svgCanvas$9.getCurConfig().gridSnapping) {
          x2 = snapToGrid(x2);
          y2 = snapToGrid(y2);
        }
        let x22 = x2;
        let y22 = y2;
        if (evt.shiftKey) {
          xya = snapToAngle(svgCanvas$9.getStartX(), svgCanvas$9.getStartY(), x22, y22);
          x22 = xya.x;
          y22 = xya.y;
        }
        shape.setAttribute("x2", x22);
        shape.setAttribute("y2", y22);
        break;
      }
      case "foreignObject":
      // fall through
      case "square":
      case "rect":
      case "image": {
        const maintainAspectRatio = svgCanvas$9.getCurrentMode() === "square" || svgCanvas$9.getCurrentMode() === "image" && !evt.shiftKey || svgCanvas$9.getCurrentMode() !== "image" && evt.shiftKey;
        let w2 = Math.abs(x2 - svgCanvas$9.getStartX());
        let h2 = Math.abs(y2 - svgCanvas$9.getStartY());
        let newX;
        let newY;
        if (maintainAspectRatio) {
          w2 = h2 = Math.max(w2, h2);
          newX = svgCanvas$9.getStartX() < x2 ? svgCanvas$9.getStartX() : svgCanvas$9.getStartX() - w2;
          newY = svgCanvas$9.getStartY() < y2 ? svgCanvas$9.getStartY() : svgCanvas$9.getStartY() - h2;
        } else {
          newX = Math.min(svgCanvas$9.getStartX(), x2);
          newY = Math.min(svgCanvas$9.getStartY(), y2);
        }
        if (svgCanvas$9.getCurConfig().gridSnapping) {
          w2 = snapToGrid(w2);
          h2 = snapToGrid(h2);
          newX = snapToGrid(newX);
          newY = snapToGrid(newY);
        }
        assignAttributes(shape, {
          width: w2,
          height: h2,
          x: newX,
          y: newY
        });
        break;
      }
      case "circle": {
        cx = Number(shape.getAttribute("cx"));
        cy = Number(shape.getAttribute("cy"));
        let rad = Math.sqrt((x2 - cx) * (x2 - cx) + (y2 - cy) * (y2 - cy));
        if (svgCanvas$9.getCurConfig().gridSnapping) {
          rad = snapToGrid(rad);
        }
        shape.setAttribute("r", rad);
        break;
      }
      case "ellipse": {
        cx = Number(shape.getAttribute("cx"));
        cy = Number(shape.getAttribute("cy"));
        if (svgCanvas$9.getCurConfig().gridSnapping) {
          x2 = snapToGrid(x2);
          cx = snapToGrid(cx);
          y2 = snapToGrid(y2);
          cy = snapToGrid(cy);
        }
        shape.setAttribute("rx", Math.abs(x2 - cx));
        const ry = Math.abs(evt.shiftKey ? x2 - cx : y2 - cy);
        shape.setAttribute("ry", ry);
        break;
      }
      case "fhellipse":
      case "fhrect": {
        svgCanvas$9.setFreehand("minx", Math.min(realX, svgCanvas$9.getFreehand("minx")));
        svgCanvas$9.setFreehand("maxx", Math.max(realX, svgCanvas$9.getFreehand("maxx")));
        svgCanvas$9.setFreehand("miny", Math.min(realY, svgCanvas$9.getFreehand("miny")));
        svgCanvas$9.setFreehand("maxy", Math.max(realY, svgCanvas$9.getFreehand("maxy")));
      }
      // Fallthrough
      case "fhpath": {
        svgCanvas$9.setEnd("x", realX);
        svgCanvas$9.setEnd("y", realY);
        if (svgCanvas$9.getControllPoint2("x") && svgCanvas$9.getControllPoint2("y")) {
          for (i2 = 0; i2 < svgCanvas$9.getStepCount() - 1; i2++) {
            svgCanvas$9.setParameter(i2 / svgCanvas$9.getStepCount());
            svgCanvas$9.setNextParameter((i2 + 1) / svgCanvas$9.getStepCount());
            svgCanvas$9.setbSpline(getBsplinePoint(svgCanvas$9.getNextParameter()));
            svgCanvas$9.setNextPos({
              x: svgCanvas$9.getbSpline("x"),
              y: svgCanvas$9.getbSpline("y")
            });
            svgCanvas$9.setbSpline(getBsplinePoint(svgCanvas$9.getParameter()));
            svgCanvas$9.setSumDistance(svgCanvas$9.getSumDistance() + Math.sqrt((svgCanvas$9.getNextPos("x") - svgCanvas$9.getbSpline("x")) * (svgCanvas$9.getNextPos("x") - svgCanvas$9.getbSpline("x")) + (svgCanvas$9.getNextPos("y") - svgCanvas$9.getbSpline("y")) * (svgCanvas$9.getNextPos("y") - svgCanvas$9.getbSpline("y"))));
            if (svgCanvas$9.getSumDistance() > svgCanvas$9.getThreSholdDist()) {
              svgCanvas$9.setSumDistance(svgCanvas$9.getSumDistance() - svgCanvas$9.getThreSholdDist());
              const point = svgCanvas$9.getSvgContent().createSVGPoint();
              point.x = svgCanvas$9.getbSpline("x");
              point.y = svgCanvas$9.getbSpline("y");
              shape.points.appendItem(point);
            }
          }
        }
        svgCanvas$9.setControllPoint2("x", svgCanvas$9.getControllPoint1("x"));
        svgCanvas$9.setControllPoint2("y", svgCanvas$9.getControllPoint1("y"));
        svgCanvas$9.setControllPoint1("x", svgCanvas$9.getStart("x"));
        svgCanvas$9.setControllPoint1("y", svgCanvas$9.getStart("y"));
        svgCanvas$9.setStart({
          x: svgCanvas$9.getEnd("x"),
          y: svgCanvas$9.getEnd("y")
        });
        break;
      }
      case "path":
      // fall through
      case "pathedit": {
        x2 *= zoom;
        y2 *= zoom;
        if (svgCanvas$9.getCurConfig().gridSnapping) {
          x2 = snapToGrid(x2);
          y2 = snapToGrid(y2);
          svgCanvas$9.setStartX(snapToGrid(svgCanvas$9.getStartX()));
          svgCanvas$9.setStartY(snapToGrid(svgCanvas$9.getStartY()));
        }
        if (evt.shiftKey) {
          const {
            path: path2
          } = pathModule;
          let x1;
          let y1;
          if (path2) {
            x1 = path2.dragging ? path2.dragging[0] : svgCanvas$9.getStartX();
            y1 = path2.dragging ? path2.dragging[1] : svgCanvas$9.getStartY();
          } else {
            x1 = svgCanvas$9.getStartX();
            y1 = svgCanvas$9.getStartY();
          }
          xya = snapToAngle(x1, y1, x2, y2);
          ({
            x: x2,
            y: y2
          } = xya);
        }
        if (svgCanvas$9.getRubberBox()?.getAttribute("display") !== "none") {
          realX *= zoom;
          realY *= zoom;
          assignAttributes(svgCanvas$9.getRubberBox(), {
            x: Math.min(svgCanvas$9.getRStartX() * zoom, realX),
            y: Math.min(svgCanvas$9.getRStartY() * zoom, realY),
            width: Math.abs(realX - svgCanvas$9.getRStartX() * zoom),
            height: Math.abs(realY - svgCanvas$9.getRStartY() * zoom)
          });
        }
        svgCanvas$9.pathActions.mouseMove(x2, y2);
        break;
      }
      case "textedit": {
        x2 *= zoom;
        y2 *= zoom;
        svgCanvas$9.textActions.mouseMove(mouseX, mouseY);
        break;
      }
      case "rotate": {
        box = getBBox(selected);
        cx = box.x + box.width / 2;
        cy = box.y + box.height / 2;
        const m2 = getMatrix(selected);
        const center = transformPoint(cx, cy, m2);
        cx = center.x;
        cy = center.y;
        angle2 = (Math.atan2(cy - y2, cx - x2) * (180 / Math.PI) - 90) % 360;
        if (svgCanvas$9.getCurConfig().gridSnapping) {
          angle2 = snapToGrid(angle2);
        }
        if (evt.shiftKey) {
          const snap = 45;
          angle2 = Math.round(angle2 / snap) * snap;
        }
        svgCanvas$9.setRotationAngle(angle2 < -180 ? 360 + angle2 : angle2, true);
        svgCanvas$9.call("transition", selectedElements);
        break;
      }
    }
    svgCanvas$9.runExtensions(
      "mouseMove",
      /** @type {module:svgcanvas.SvgCanvas#event:ext_mouseMove} */
      {
        event: evt,
        mouse_x: mouseX,
        mouse_y: mouseY,
        selected
      }
    );
  };
  var mouseOutEvent = () => {
    const {
      $id: $id2
    } = svgCanvas$9;
    if (svgCanvas$9.getCurrentMode() !== "select" && svgCanvas$9.getStarted()) {
      const event = new Event("mouseup");
      $id2("svgcanvas").dispatchEvent(event);
    }
  };
  var mouseUpEvent = (evt) => {
    evt.preventDefault();
    moveSelectionThresholdReached = false;
    if (evt.button === 2) {
      return;
    }
    if (!svgCanvas$9.getStarted()) {
      return;
    }
    svgCanvas$9.textActions.init();
    const selectedElements = svgCanvas$9.getSelectedElements();
    const zoom = svgCanvas$9.getZoom();
    const tempJustSelected = svgCanvas$9.getJustSelected();
    svgCanvas$9.setJustSelected(null);
    const pt2 = transformPoint(evt.clientX, evt.clientY, svgCanvas$9.getrootSctm());
    const mouseX = pt2.x * zoom;
    const mouseY = pt2.y * zoom;
    const x2 = mouseX / zoom;
    const y2 = mouseY / zoom;
    let element = getElement(svgCanvas$9.getId());
    let keep = false;
    const realX = x2;
    const realY = y2;
    svgCanvas$9.setStarted(false);
    let t3;
    switch (svgCanvas$9.getCurrentMode()) {
      // intentionally fall-through to select here
      case "resize":
      case "multiselect":
        if (svgCanvas$9.getRubberBox()) {
          svgCanvas$9.getRubberBox().setAttribute("display", "none");
          svgCanvas$9.setCurBBoxes([]);
        }
        svgCanvas$9.setCurrentMode("select");
      // Fallthrough
      case "select":
        if (selectedElements[0]) {
          if (!selectedElements[1]) {
            const selected = selectedElements[0];
            switch (selected.tagName) {
              case "g":
              case "use":
              case "image":
              case "foreignObject":
                break;
              case "text":
                svgCanvas$9.setCurText("font_size", selected.getAttribute("font-size"));
                svgCanvas$9.setCurText("font_family", selected.getAttribute("font-family"));
              // fallthrough
              default:
                svgCanvas$9.setCurProperties("fill", selected.getAttribute("fill"));
                svgCanvas$9.setCurProperties("fill_opacity", selected.getAttribute("fill-opacity"));
                svgCanvas$9.setCurProperties("stroke", selected.getAttribute("stroke"));
                svgCanvas$9.setCurProperties("stroke_opacity", selected.getAttribute("stroke-opacity"));
                svgCanvas$9.setCurProperties("stroke_width", selected.getAttribute("stroke-width"));
                svgCanvas$9.setCurProperties("stroke_dasharray", selected.getAttribute("stroke-dasharray"));
                svgCanvas$9.setCurProperties("stroke_linejoin", selected.getAttribute("stroke-linejoin"));
                svgCanvas$9.setCurProperties("stroke_linecap", selected.getAttribute("stroke-linecap"));
            }
            svgCanvas$9.selectorManager.requestSelector(selected).showGrips(true);
          }
          svgCanvas$9.recalculateAllSelectedDimensions();
          if (realX !== svgCanvas$9.getRStartX() || realY !== svgCanvas$9.getRStartY()) {
            const len = selectedElements.length;
            for (let i2 = 0; i2 < len; ++i2) {
              if (!selectedElements[i2]) {
                break;
              }
              svgCanvas$9.selectorManager.requestSelector(selectedElements[i2]).resize();
            }
          } else {
            t3 = evt.target;
            if (selectedElements[0].nodeName === "path" && !selectedElements[1]) {
              svgCanvas$9.pathActions.select(selectedElements[0]);
            } else if (evt.shiftKey && tempJustSelected !== t3) {
              svgCanvas$9.removeFromSelection([t3]);
            }
          }
          const elem = selectedElements[0];
          if (elem) {
            elem.removeAttribute("style");
            if (elem.localName === "foreignObject") {
              walkTree(elem, (el) => {
                el.style.removeProperty("pointer-events");
              });
            } else {
              walkTree(elem, (el) => {
                el.removeAttribute("style");
              });
            }
          }
        }
        return;
      case "zoom": {
        svgCanvas$9.getRubberBox()?.setAttribute("display", "none");
        const factor = evt.shiftKey ? 0.5 : 2;
        svgCanvas$9.call("zoomed", {
          x: Math.min(svgCanvas$9.getRStartX(), realX),
          y: Math.min(svgCanvas$9.getRStartY(), realY),
          width: Math.abs(realX - svgCanvas$9.getRStartX()),
          height: Math.abs(realY - svgCanvas$9.getRStartY()),
          factor
        });
        return;
      }
      case "fhpath": {
        svgCanvas$9.setSumDistance(0);
        svgCanvas$9.setControllPoint2("x", 0);
        svgCanvas$9.setControllPoint2("y", 0);
        svgCanvas$9.setControllPoint1("x", 0);
        svgCanvas$9.setControllPoint1("y", 0);
        svgCanvas$9.setStart({
          x: 0,
          y: 0
        });
        svgCanvas$9.setEnd("x", 0);
        svgCanvas$9.setEnd("y", 0);
        const coords = element.getAttribute("points");
        const commaIndex = coords.indexOf(",");
        keep = commaIndex >= 0 ? coords.includes(",", commaIndex + 1) : coords.includes(" ", coords.indexOf(" ") + 1);
        if (keep) {
          element = svgCanvas$9.pathActions.smoothPolylineIntoPath(element);
        }
        break;
      }
      case "line":
        {
          const x1 = element.getAttribute("x1");
          const y1 = element.getAttribute("y1");
          const x22 = element.getAttribute("x2");
          const y22 = element.getAttribute("y2");
          keep = x1 !== x22 || y1 !== y22;
        }
        break;
      case "foreignObject":
      case "square":
      case "rect":
      case "image":
        {
          const width = element.getAttribute("width");
          const height = element.getAttribute("height");
          const widthNum = Number(width);
          const heightNum = Number(height);
          keep = widthNum >= 1 || heightNum >= 1 || svgCanvas$9.getCurrentMode() === "image";
        }
        break;
      case "circle":
        keep = element.getAttribute("r") !== "0";
        break;
      case "ellipse":
        {
          const rx = Number(element.getAttribute("rx"));
          const ry = Number(element.getAttribute("ry"));
          keep = rx || ry;
        }
        break;
      case "fhellipse":
        if (svgCanvas$9.getFreehand("maxx") - svgCanvas$9.getFreehand("minx") > 0 && svgCanvas$9.getFreehand("maxy") - svgCanvas$9.getFreehand("miny") > 0) {
          element = svgCanvas$9.addSVGElementsFromJson({
            element: "ellipse",
            curStyles: true,
            attr: {
              cx: (svgCanvas$9.getFreehand("minx") + svgCanvas$9.getFreehand("maxx")) / 2,
              cy: (svgCanvas$9.getFreehand("miny") + svgCanvas$9.getFreehand("maxy")) / 2,
              rx: (svgCanvas$9.getFreehand("maxx") - svgCanvas$9.getFreehand("minx")) / 2,
              ry: (svgCanvas$9.getFreehand("maxy") - svgCanvas$9.getFreehand("miny")) / 2,
              id: svgCanvas$9.getId()
            }
          });
          svgCanvas$9.call("changed", [element]);
          keep = true;
        }
        break;
      case "fhrect":
        if (svgCanvas$9.getFreehand("maxx") - svgCanvas$9.getFreehand("minx") > 0 && svgCanvas$9.getFreehand("maxy") - svgCanvas$9.getFreehand("miny") > 0) {
          element = svgCanvas$9.addSVGElementsFromJson({
            element: "rect",
            curStyles: true,
            attr: {
              x: svgCanvas$9.getFreehand("minx"),
              y: svgCanvas$9.getFreehand("miny"),
              width: svgCanvas$9.getFreehand("maxx") - svgCanvas$9.getFreehand("minx"),
              height: svgCanvas$9.getFreehand("maxy") - svgCanvas$9.getFreehand("miny"),
              id: svgCanvas$9.getId()
            }
          });
          svgCanvas$9.call("changed", [element]);
          keep = true;
        }
        break;
      case "text":
        keep = true;
        svgCanvas$9.selectOnly([element]);
        svgCanvas$9.textActions.start(element);
        break;
      case "path": {
        element = null;
        svgCanvas$9.setStarted(true);
        const res = svgCanvas$9.pathActions.mouseUp(evt, element, mouseX, mouseY);
        ({
          element
        } = res);
        ({
          keep
        } = res);
        break;
      }
      case "pathedit":
        keep = true;
        element = null;
        svgCanvas$9.pathActions.mouseUp(evt);
        break;
      case "textedit":
        keep = false;
        element = null;
        svgCanvas$9.textActions.mouseUp(evt, mouseX, mouseY);
        break;
      case "rotate": {
        keep = true;
        element = null;
        svgCanvas$9.setCurrentMode("select");
        const batchCmd = svgCanvas$9.undoMgr.finishUndoableChange();
        if (!batchCmd.isEmpty()) {
          svgCanvas$9.addCommandToHistory(batchCmd);
        }
        svgCanvas$9.recalculateAllSelectedDimensions();
        svgCanvas$9.call("changed", selectedElements);
        break;
      }
    }
    const extResult = svgCanvas$9.runExtensions("mouseUp", {
      event: evt,
      mouse_x: mouseX,
      mouse_y: mouseY
    }, true);
    extResult.forEach((r2) => {
      if (r2) {
        keep = r2.keep || keep;
        ({
          element
        } = r2);
        svgCanvas$9.setStarted(r2.started || svgCanvas$9.getStarted());
      }
    });
    if (!keep && element) {
      svgCanvas$9.getCurrentDrawing().releaseId(svgCanvas$9.getId());
      element.remove();
      element = null;
      t3 = evt.target;
      while (t3?.parentNode?.parentNode?.tagName === "g") {
        t3 = t3.parentNode;
      }
      if ((svgCanvas$9.getCurrentMode() !== "path" || !svgCanvas$9.getDrawnPath()) && t3 && t3.parentNode?.id !== "selectorParentGroup" && t3.id !== "svgcanvas" && t3.id !== "svgroot") {
        svgCanvas$9.setMode("select");
        svgCanvas$9.selectOnly([t3], true);
      }
    } else if (element) {
      svgCanvas$9.addedNew = true;
      let aniDur = 0.2;
      let cAni;
      const curShape = svgCanvas$9.getStyle();
      const opacAni = svgCanvas$9.getOpacAni();
      if (opacAni.beginElement && Number.parseFloat(element.getAttribute("opacity")) !== curShape.opacity) {
        cAni = opacAni.cloneNode(true);
        cAni.setAttribute("to", curShape.opacity);
        cAni.setAttribute("dur", aniDur);
        element.appendChild(cAni);
        try {
          cAni.beginElement();
        } catch (e2) {
        }
      } else {
        aniDur = 0;
      }
      setTimeout(() => {
        if (cAni) {
          cAni.remove();
        }
        element.setAttribute("opacity", curShape.opacity);
        element.setAttribute("style", "pointer-events:inherit");
        cleanupElement(element);
        if (svgCanvas$9.getCurrentMode() === "path") {
          svgCanvas$9.pathActions.toEditMode(element);
        } else if (svgCanvas$9.getCurConfig().selectNew) {
          const modes = ["circle", "ellipse", "square", "rect", "fhpath", "line", "fhellipse", "fhrect", "star", "polygon", "shapelib"];
          if (modes.indexOf(svgCanvas$9.getCurrentMode()) !== -1 && !evt.altKey) {
            svgCanvas$9.setMode("select");
          }
          svgCanvas$9.selectOnly([element], true);
        }
        svgCanvas$9.addCommandToHistory(new InsertElementCommand$2(element));
        svgCanvas$9.call("changed", [element]);
      }, aniDur * 1e3);
    }
    svgCanvas$9.setStartTransform(null);
  };
  var dblClickEvent = (evt) => {
    const selectedElements = svgCanvas$9.getSelectedElements();
    const evtTarget = evt.target;
    const parent = evtTarget.parentNode;
    let mouseTarget = svgCanvas$9.getMouseTarget(evt);
    const {
      tagName
    } = mouseTarget;
    if (tagName === "text" && svgCanvas$9.getCurrentMode() !== "textedit") {
      const pt2 = transformPoint(evt.clientX, evt.clientY, svgCanvas$9.getrootSctm());
      svgCanvas$9.textActions.select(mouseTarget, pt2.x, pt2.y);
    }
    if (parent === svgCanvas$9.getCurrentGroup()) {
      return;
    }
    if ((tagName === "g" || tagName === "a") && getRotationAngle(mouseTarget)) {
      svgCanvas$9.pushGroupProperties(mouseTarget);
      mouseTarget = selectedElements[0];
      svgCanvas$9.clearSelection(true);
    }
    if (svgCanvas$9.getCurrentGroup()) {
      leaveContext();
    }
    if (parent.tagName !== "g" && parent.tagName !== "a" || parent === svgCanvas$9.getCurrentDrawing().getCurrentLayer() || mouseTarget === svgCanvas$9.selectorManager.selectorParentGroup) {
      return;
    }
    setContext(mouseTarget);
  };
  var mouseDownEvent = (evt) => {
    const dataStorage2 = svgCanvas$9.getDataStorage();
    const selectedElements = svgCanvas$9.getSelectedElements();
    const zoom = svgCanvas$9.getZoom();
    const curShape = svgCanvas$9.getStyle();
    const svgRoot = svgCanvas$9.getSvgRoot();
    const {
      $id: $id2
    } = svgCanvas$9;
    if (svgCanvas$9.spaceKey || evt.button === 1) {
      return;
    }
    const rightClick = evt.button === 2;
    if (evt.altKey) {
      svgCanvas$9.cloneSelectedElements(0, 0);
    }
    svgCanvas$9.setRootSctm($id2("svgcontent").querySelector("g").getScreenCTM().inverse());
    const pt2 = transformPoint(evt.clientX, evt.clientY, svgCanvas$9.getrootSctm());
    const mouseX = pt2.x * zoom;
    const mouseY = pt2.y * zoom;
    evt.preventDefault();
    if (rightClick) {
      if (svgCanvas$9.getCurrentMode() === "path") {
        return;
      }
      svgCanvas$9.setCurrentMode("select");
      svgCanvas$9.setLastClickPoint(pt2);
    }
    let x2 = mouseX / zoom;
    let y2 = mouseY / zoom;
    let mouseTarget = svgCanvas$9.getMouseTarget(evt);
    if (mouseTarget.tagName === "a" && mouseTarget.childNodes.length === 1) {
      mouseTarget = mouseTarget.firstChild;
    }
    const realX = x2;
    svgCanvas$9.setStartX(x2);
    svgCanvas$9.setRStartX(x2);
    const realY = y2;
    svgCanvas$9.setStartY(y2);
    svgCanvas$9.setRStartY(y2);
    if (svgCanvas$9.getCurConfig().gridSnapping) {
      x2 = snapToGrid(x2);
      y2 = snapToGrid(y2);
      svgCanvas$9.setStartX(snapToGrid(svgCanvas$9.getStartX()));
      svgCanvas$9.setStartY(snapToGrid(svgCanvas$9.getStartY()));
    }
    if (mouseTarget === svgCanvas$9.selectorManager.selectorParentGroup && selectedElements[0]) {
      const grip = evt.target;
      const griptype = dataStorage2.get(grip, "type");
      if (griptype === "rotate") {
        svgCanvas$9.setCurrentMode("rotate");
      } else if (griptype === "resize") {
        svgCanvas$9.setCurrentMode("resize");
        svgCanvas$9.setCurrentResizeMode(dataStorage2.get(grip, "dir"));
      }
      mouseTarget = selectedElements[0];
    }
    svgCanvas$9.setStartTransform(mouseTarget.getAttribute("transform"));
    const tlist = getTransformList(mouseTarget);
    if (tlist.numberOfItems > 1) {
      const firstTransform = tlist.getItem(0);
      tlist.removeItem(0);
      tlist.consolidate();
      tlist.insertItemBefore(firstTransform, 0);
    }
    switch (svgCanvas$9.getCurrentMode()) {
      case "select":
        svgCanvas$9.setStarted(true);
        svgCanvas$9.setCurrentResizeMode("none");
        if (rightClick) {
          svgCanvas$9.setStarted(false);
        }
        if (mouseTarget !== svgRoot) {
          if (!selectedElements.includes(mouseTarget)) {
            if (!evt.shiftKey) {
              svgCanvas$9.clearSelection(true);
            }
            svgCanvas$9.addToSelection([mouseTarget]);
            svgCanvas$9.setJustSelected(mouseTarget);
            svgCanvas$9.pathActions.clear();
          }
          if (!rightClick) {
            for (const selectedElement of selectedElements) {
              if (!selectedElement) {
                continue;
              }
              const slist = getTransformList(selectedElement);
              if (slist.numberOfItems) {
                slist.insertItemBefore(svgRoot.createSVGTransform(), 0);
              } else {
                slist.appendItem(svgRoot.createSVGTransform());
              }
            }
          }
        } else if (!rightClick) {
          svgCanvas$9.clearSelection();
          svgCanvas$9.setCurrentMode("multiselect");
          if (!svgCanvas$9.getRubberBox()) {
            svgCanvas$9.setRubberBox(svgCanvas$9.selectorManager.getRubberBandBox());
          }
          svgCanvas$9.setRStartX(svgCanvas$9.getRStartX() * zoom);
          svgCanvas$9.setRStartY(svgCanvas$9.getRStartY() * zoom);
          assignAttributes(svgCanvas$9.getRubberBox(), {
            x: svgCanvas$9.getRStartX(),
            y: svgCanvas$9.getRStartY(),
            width: 0,
            height: 0,
            display: "inline"
          });
        }
        break;
      case "zoom":
        svgCanvas$9.setStarted(true);
        if (!svgCanvas$9.getRubberBox()) {
          svgCanvas$9.setRubberBox(svgCanvas$9.selectorManager.getRubberBandBox());
        }
        assignAttributes(svgCanvas$9.getRubberBox(), {
          x: realX * zoom,
          y: realX * zoom,
          width: 0,
          height: 0,
          display: "inline"
        });
        break;
      case "resize": {
        svgCanvas$9.setStarted(true);
        svgCanvas$9.setStartX(x2);
        svgCanvas$9.setStartY(y2);
        svgCanvas$9.setInitBbox(getBBox($id2("selectedBox0")));
        const bb = {};
        for (const [key, val] of Object.entries(svgCanvas$9.getInitBbox())) {
          bb[key] = val / zoom;
        }
        svgCanvas$9.setInitBbox(bb);
        const pos = getRotationAngle(mouseTarget) ? 1 : 0;
        if (hasMatrixTransform(tlist)) {
          tlist.insertItemBefore(svgRoot.createSVGTransform(), pos);
          tlist.insertItemBefore(svgRoot.createSVGTransform(), pos);
          tlist.insertItemBefore(svgRoot.createSVGTransform(), pos);
        } else {
          tlist.appendItem(svgRoot.createSVGTransform());
          tlist.appendItem(svgRoot.createSVGTransform());
          tlist.appendItem(svgRoot.createSVGTransform());
        }
        break;
      }
      case "fhellipse":
      case "fhrect":
      case "fhpath":
        svgCanvas$9.setStart({
          x: realX,
          y: realY
        });
        svgCanvas$9.setControllPoint1("x", 0);
        svgCanvas$9.setControllPoint1("y", 0);
        svgCanvas$9.setControllPoint2("x", 0);
        svgCanvas$9.setControllPoint2("y", 0);
        svgCanvas$9.setStarted(true);
        svgCanvas$9.setDAttr(realX + "," + realY + " ");
        svgCanvas$9.addSVGElementsFromJson({
          element: "polyline",
          curStyles: true,
          attr: {
            points: svgCanvas$9.getDAttr(),
            id: svgCanvas$9.getNextId(),
            fill: "none",
            opacity: curShape.opacity / 2,
            "stroke-linecap": "round",
            style: "pointer-events:none"
          }
        });
        svgCanvas$9.setFreehand("minx", realX);
        svgCanvas$9.setFreehand("maxx", realX);
        svgCanvas$9.setFreehand("miny", realY);
        svgCanvas$9.setFreehand("maxy", realY);
        break;
      case "image": {
        svgCanvas$9.setStarted(true);
        const newImage = svgCanvas$9.addSVGElementsFromJson({
          element: "image",
          attr: {
            x: x2,
            y: y2,
            width: 0,
            height: 0,
            id: svgCanvas$9.getNextId(),
            opacity: curShape.opacity / 2,
            style: "pointer-events:inherit"
          }
        });
        setHref(newImage, svgCanvas$9.getLastGoodImgUrl());
        preventClickDefault(newImage);
        break;
      }
      case "square":
      // TODO: once we create the rect, we lose information that this was a square
      // (for resizing purposes this could be important)
      // Fallthrough
      case "rect":
        svgCanvas$9.setStarted(true);
        svgCanvas$9.setStartX(x2);
        svgCanvas$9.setStartY(y2);
        svgCanvas$9.addSVGElementsFromJson({
          element: "rect",
          curStyles: true,
          attr: {
            x: x2,
            y: y2,
            width: 0,
            height: 0,
            id: svgCanvas$9.getNextId(),
            opacity: curShape.opacity / 2
          }
        });
        break;
      case "line": {
        svgCanvas$9.setStarted(true);
        const strokeW = Number(curShape.stroke_width) === 0 ? 1 : curShape.stroke_width;
        svgCanvas$9.addSVGElementsFromJson({
          element: "line",
          curStyles: true,
          attr: {
            x1: x2,
            y1: y2,
            x2,
            y2,
            id: svgCanvas$9.getNextId(),
            stroke: curShape.stroke,
            "stroke-width": strokeW,
            "stroke-dasharray": curShape.stroke_dasharray,
            "stroke-linejoin": curShape.stroke_linejoin,
            "stroke-linecap": curShape.stroke_linecap,
            "stroke-opacity": curShape.stroke_opacity,
            fill: "none",
            opacity: curShape.opacity / 2,
            style: "pointer-events:none"
          }
        });
        break;
      }
      case "circle":
        svgCanvas$9.setStarted(true);
        svgCanvas$9.addSVGElementsFromJson({
          element: "circle",
          curStyles: true,
          attr: {
            cx: x2,
            cy: y2,
            r: 0,
            id: svgCanvas$9.getNextId(),
            opacity: curShape.opacity / 2
          }
        });
        break;
      case "ellipse":
        svgCanvas$9.setStarted(true);
        svgCanvas$9.addSVGElementsFromJson({
          element: "ellipse",
          curStyles: true,
          attr: {
            cx: x2,
            cy: y2,
            rx: 0,
            ry: 0,
            id: svgCanvas$9.getNextId(),
            opacity: curShape.opacity / 2
          }
        });
        break;
      case "text":
        svgCanvas$9.setStarted(true);
        svgCanvas$9.addSVGElementsFromJson({
          element: "text",
          curStyles: true,
          attr: {
            x: x2,
            y: y2,
            id: svgCanvas$9.getNextId(),
            fill: svgCanvas$9.getCurText("fill"),
            "stroke-width": svgCanvas$9.getCurText("stroke_width"),
            "font-size": svgCanvas$9.getCurText("font_size"),
            "font-family": svgCanvas$9.getCurText("font_family"),
            "text-anchor": "middle",
            "xml:space": "preserve",
            opacity: curShape.opacity
          }
        });
        break;
      case "path":
      // Fall through
      case "pathedit":
        svgCanvas$9.setStartX(svgCanvas$9.getStartX() * zoom);
        svgCanvas$9.setStartY(svgCanvas$9.getStartY() * zoom);
        svgCanvas$9.pathActions.mouseDown(evt, mouseTarget, svgCanvas$9.getStartX(), svgCanvas$9.getStartY());
        svgCanvas$9.setStarted(true);
        break;
      case "textedit":
        svgCanvas$9.setStartX(svgCanvas$9.getStartX() * zoom);
        svgCanvas$9.setStartY(svgCanvas$9.getStartY() * zoom);
        svgCanvas$9.textActions.mouseDown(evt, mouseTarget, svgCanvas$9.getStartX(), svgCanvas$9.getStartY());
        svgCanvas$9.setStarted(true);
        break;
      case "rotate":
        svgCanvas$9.setStarted(true);
        svgCanvas$9.undoMgr.beginUndoableChange("transform", selectedElements);
        break;
    }
    const extResult = svgCanvas$9.runExtensions("mouseDown", {
      event: evt,
      start_x: svgCanvas$9.getStartX(),
      start_y: svgCanvas$9.getStartY(),
      selectedElements
    }, true);
    extResult.forEach((r2) => {
      if (r2?.started) {
        svgCanvas$9.setStarted(true);
      }
    });
  };
  var DOMMouseScrollEvent = (e2) => {
    const zoom = svgCanvas$9.getZoom();
    const {
      $id: $id2
    } = svgCanvas$9;
    if (!e2.shiftKey) {
      return;
    }
    e2.preventDefault();
    svgCanvas$9.setRootSctm($id2("svgcontent").querySelector("g").getScreenCTM().inverse());
    const workarea = document.getElementById("workarea");
    const scrbar = 15;
    const rulerwidth = svgCanvas$9.getCurConfig().showRulers ? 16 : 0;
    const pt2 = transformPoint(e2.clientX, e2.clientY, svgCanvas$9.getrootSctm());
    const editorFullW = parseFloat(getComputedStyle(workarea, null).width.replace("px", ""));
    const editorFullH = parseFloat(getComputedStyle(workarea, null).height.replace("px", ""));
    const editorW = editorFullW - scrbar - rulerwidth;
    const editorH = editorFullH - scrbar - rulerwidth;
    const workareaViewW = editorW * svgCanvas$9.getrootSctm().a;
    const workareaViewH = editorH * svgCanvas$9.getrootSctm().d;
    const wOffset = findPos(workarea);
    const wOffsetLeft = wOffset.left + rulerwidth;
    const wOffsetTop = wOffset.top + rulerwidth;
    const delta = e2.wheelDelta ? e2.wheelDelta : e2.detail ? -e2.detail : 0;
    if (!delta) {
      return;
    }
    let factor = Math.max(3 / 4, Math.min(4 / 3, delta));
    let wZoom;
    let hZoom;
    if (factor > 1) {
      wZoom = Math.ceil(editorW / workareaViewW * factor * 100) / 100;
      hZoom = Math.ceil(editorH / workareaViewH * factor * 100) / 100;
    } else {
      wZoom = Math.floor(editorW / workareaViewW * factor * 100) / 100;
      hZoom = Math.floor(editorH / workareaViewH * factor * 100) / 100;
    }
    let zoomlevel = Math.min(wZoom, hZoom);
    zoomlevel = Math.min(10, Math.max(0.01, zoomlevel));
    if (zoomlevel === zoom) {
      return;
    }
    factor = zoomlevel / zoom;
    const topLeftOld = transformPoint(wOffsetLeft, wOffsetTop, svgCanvas$9.getrootSctm());
    const topLeftNew = {
      x: pt2.x - (pt2.x - topLeftOld.x) / factor,
      y: pt2.y - (pt2.y - topLeftOld.y) / factor
    };
    const topLeftNewCanvas = {
      x: topLeftNew.x * zoomlevel,
      y: topLeftNew.y * zoomlevel
    };
    const newCtr = {
      x: topLeftNewCanvas.x - rulerwidth + editorFullW / 2,
      y: topLeftNewCanvas.y - rulerwidth + editorFullH / 2
    };
    svgCanvas$9.setZoom(zoomlevel);
    document.getElementById("zoom").value = (zoomlevel * 100).toFixed(1);
    svgCanvas$9.call("updateCanvas", {
      center: false,
      newCtr
    });
    svgCanvas$9.call("zoomDone");
  };
  var svgCanvas$8 = null;
  var svgdoc_ = null;
  var init$8 = (canvas) => {
    svgCanvas$8 = canvas;
    svgdoc_ = canvas.getDOMDocument();
  };
  var getJsonFromSvgElements = (data) => {
    if (data.nodeType === 3) return data.nodeValue;
    const retval = {
      element: data.tagName,
      // namespace: nsMap[data.namespaceURI],
      attr: {},
      children: []
    };
    for (let i2 = 0, attr; attr = data.attributes[i2]; i2++) {
      retval.attr[attr.name] = attr.value;
    }
    for (let i2 = 0, node2; node2 = data.childNodes[i2]; i2++) {
      retval.children[i2] = getJsonFromSvgElements(node2);
    }
    return retval;
  };
  var addSVGElementsFromJson = (data) => {
    if (typeof data === "string") return svgdoc_.createTextNode(data);
    let shape = getElement(data.attr.id);
    const currentLayer = svgCanvas$8.getDrawing().getCurrentLayer();
    if (shape && data.element !== shape.tagName) {
      shape.remove();
      shape = null;
    }
    if (!shape) {
      const ns = data.namespace || NS.SVG;
      shape = svgdoc_.createElementNS(ns, data.element);
      if (currentLayer) {
        (svgCanvas$8.getCurrentGroup() || currentLayer).append(shape);
      }
    }
    const curShape = svgCanvas$8.getCurShape();
    if (data.curStyles) {
      assignAttributes(shape, {
        fill: curShape.fill,
        stroke: curShape.stroke,
        "stroke-width": curShape.stroke_width,
        "stroke-dasharray": curShape.stroke_dasharray,
        "stroke-linejoin": curShape.stroke_linejoin,
        "stroke-linecap": curShape.stroke_linecap,
        "stroke-opacity": curShape.stroke_opacity,
        "fill-opacity": curShape.fill_opacity,
        opacity: curShape.opacity / 2,
        style: "pointer-events:inherit"
      });
    }
    assignAttributes(shape, data.attr);
    cleanupElement(shape);
    if (data.children) {
      data.children.forEach((child) => {
        shape.append(addSVGElementsFromJson(child));
      });
    }
    return shape;
  };
  var svgCanvas$7 = null;
  var init$7 = (canvas) => {
    svgCanvas$7 = canvas;
    svgCanvas$7.getBold = getBoldMethod;
    svgCanvas$7.setBold = setBoldMethod;
    svgCanvas$7.getItalic = getItalicMethod;
    svgCanvas$7.setItalic = setItalicMethod;
    svgCanvas$7.hasTextDecoration = hasTextDecorationMethod;
    svgCanvas$7.addTextDecoration = addTextDecorationMethod;
    svgCanvas$7.removeTextDecoration = removeTextDecorationMethod;
    svgCanvas$7.setTextAnchor = setTextAnchorMethod;
    svgCanvas$7.setLetterSpacing = setLetterSpacingMethod;
    svgCanvas$7.setWordSpacing = setWordSpacingMethod;
    svgCanvas$7.setTextLength = setTextLengthMethod;
    svgCanvas$7.setLengthAdjust = setLengthAdjustMethod;
    svgCanvas$7.getFontFamily = getFontFamilyMethod;
    svgCanvas$7.setFontFamily = setFontFamilyMethod;
    svgCanvas$7.setFontColor = setFontColorMethod;
    svgCanvas$7.getFontColor = getFontColorMethod;
    svgCanvas$7.getFontSize = getFontSizeMethod;
    svgCanvas$7.setFontSize = setFontSizeMethod;
    svgCanvas$7.getText = getTextMethod;
    svgCanvas$7.setTextContent = setTextContentMethod;
    svgCanvas$7.setImageURL = setImageURLMethod;
    svgCanvas$7.setLinkURL = setLinkURLMethod;
    svgCanvas$7.setRectRadius = setRectRadiusMethod;
    svgCanvas$7.makeHyperlink = makeHyperlinkMethod;
    svgCanvas$7.removeHyperlink = removeHyperlinkMethod;
    svgCanvas$7.setSegType = setSegTypeMethod;
    svgCanvas$7.setStrokeWidth = setStrokeWidthMethod;
    svgCanvas$7.getResolution = getResolutionMethod;
    svgCanvas$7.getTitle = getTitleMethod;
    svgCanvas$7.setGroupTitle = setGroupTitleMethod;
    svgCanvas$7.setStrokeAttr = setStrokeAttrMethod;
    svgCanvas$7.setBackground = setBackgroundMethod;
    svgCanvas$7.setDocumentTitle = setDocumentTitleMethod;
    svgCanvas$7.getEditorNS = getEditorNSMethod;
    svgCanvas$7.setResolution = setResolutionMethod;
    svgCanvas$7.setBBoxZoom = setBBoxZoomMethod;
    svgCanvas$7.setCurrentZoom = setZoomMethod;
    svgCanvas$7.setColor = setColorMethod;
    svgCanvas$7.setGradient = setGradientMethod;
    svgCanvas$7.setPaint = setPaintMethod;
  };
  var getResolutionMethod = () => {
    const zoom = svgCanvas$7.getZoom();
    const w2 = svgCanvas$7.getSvgContent().getAttribute("width") / zoom;
    const h2 = svgCanvas$7.getSvgContent().getAttribute("height") / zoom;
    return {
      w: w2,
      h: h2,
      zoom
    };
  };
  var getTitleMethod = (elem) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const dataStorage2 = svgCanvas$7.getDataStorage();
    elem = elem || selectedElements[0];
    if (!elem) {
      return void 0;
    }
    if (dataStorage2.has(elem, "gsvg")) {
      elem = dataStorage2.get(elem, "gsvg");
    } else if (dataStorage2.has(elem, "symbol")) {
      elem = dataStorage2.get(elem, "symbol");
    }
    const childs = elem.childNodes;
    for (const child of childs) {
      if (child.nodeName === "title") {
        return child.textContent;
      }
    }
    return "";
  };
  var setGroupTitleMethod = (val) => {
    const {
      InsertElementCommand: InsertElementCommand3,
      RemoveElementCommand: RemoveElementCommand3,
      ChangeElementCommand: ChangeElementCommand3,
      BatchCommand: BatchCommand3
    } = svgCanvas$7.history;
    const selectedElements = svgCanvas$7.getSelectedElements();
    const dataStorage2 = svgCanvas$7.getDataStorage();
    let elem = selectedElements[0];
    if (dataStorage2.has(elem, "gsvg")) {
      elem = dataStorage2.get(elem, "gsvg");
    }
    const ts = elem.querySelectorAll("title");
    const batchCmd = new BatchCommand3("Set Label");
    let title;
    if (val.length === 0) {
      const tsNextSibling = ts.nextSibling;
      batchCmd.addSubCommand(new RemoveElementCommand3(ts[0], tsNextSibling, elem));
      ts.remove();
    } else if (ts.length) {
      title = ts[0];
      batchCmd.addSubCommand(new ChangeElementCommand3(title, {
        "#text": title.textContent
      }));
      title.textContent = val;
    } else {
      title = svgCanvas$7.getDOMDocument().createElementNS(NS.SVG, "title");
      title.textContent = val;
      elem.insertBefore(title, elem.firstChild);
      batchCmd.addSubCommand(new InsertElementCommand3(title));
    }
    svgCanvas$7.addCommandToHistory(batchCmd);
  };
  var setDocumentTitleMethod = (newTitle) => {
    const {
      ChangeElementCommand: ChangeElementCommand3,
      BatchCommand: BatchCommand3
    } = svgCanvas$7.history;
    const childs = svgCanvas$7.getSvgContent().childNodes;
    let docTitle = false;
    let oldTitle = "";
    const batchCmd = new BatchCommand3("Change Image Title");
    for (const child of childs) {
      if (child.nodeName === "title") {
        docTitle = child;
        oldTitle = docTitle.textContent;
        break;
      }
    }
    if (!docTitle) {
      docTitle = svgCanvas$7.getDOMDocument().createElementNS(NS.SVG, "title");
      svgCanvas$7.getSvgContent().insertBefore(docTitle, svgCanvas$7.getSvgContent().firstChild);
    }
    if (newTitle.length) {
      docTitle.textContent = newTitle;
    } else {
      docTitle.remove();
    }
    batchCmd.addSubCommand(new ChangeElementCommand3(docTitle, {
      "#text": oldTitle
    }));
    svgCanvas$7.addCommandToHistory(batchCmd);
  };
  var setResolutionMethod = (x2, y2) => {
    const {
      ChangeElementCommand: ChangeElementCommand3,
      BatchCommand: BatchCommand3
    } = svgCanvas$7.history;
    const zoom = svgCanvas$7.getZoom();
    const res = svgCanvas$7.getResolution();
    const {
      w: w2,
      h: h2
    } = res;
    let batchCmd;
    if (x2 === "fit") {
      const bbox = getStrokedBBoxDefaultVisible();
      if (bbox) {
        batchCmd = new BatchCommand3("Fit Canvas to Content");
        const visEls = getVisibleElements();
        svgCanvas$7.addToSelection(visEls);
        const dx = [];
        const dy = [];
        visEls.forEach((_item, _i) => {
          dx.push(bbox.x * -1);
          dy.push(bbox.y * -1);
        });
        const cmd = svgCanvas$7.moveSelectedElements(dx, dy, true);
        batchCmd.addSubCommand(cmd);
        svgCanvas$7.clearSelection();
        x2 = Math.round(bbox.width);
        y2 = Math.round(bbox.height);
      } else {
        return false;
      }
    }
    if (x2 !== w2 || y2 !== h2) {
      if (!batchCmd) {
        batchCmd = new BatchCommand3("Change Image Dimensions");
      }
      x2 = convertToNum("width", x2);
      y2 = convertToNum("height", y2);
      svgCanvas$7.getSvgContent().setAttribute("width", x2);
      svgCanvas$7.getSvgContent().setAttribute("height", y2);
      svgCanvas$7.contentW = x2;
      svgCanvas$7.contentH = y2;
      batchCmd.addSubCommand(new ChangeElementCommand3(svgCanvas$7.getSvgContent(), {
        width: w2,
        height: h2
      }));
      svgCanvas$7.getSvgContent().setAttribute("viewBox", [0, 0, x2 / zoom, y2 / zoom].join(" "));
      batchCmd.addSubCommand(new ChangeElementCommand3(svgCanvas$7.getSvgContent(), {
        viewBox: ["0 0", w2, h2].join(" ")
      }));
      svgCanvas$7.addCommandToHistory(batchCmd);
      svgCanvas$7.call("changed", [svgCanvas$7.getSvgContent()]);
    }
    return true;
  };
  var getEditorNSMethod = (add) => {
    if (add) {
      svgCanvas$7.getSvgContent().setAttribute("xmlns:se", NS.SE);
    }
    return NS.SE;
  };
  var setBBoxZoomMethod = (val, editorW, editorH) => {
    const zoom = svgCanvas$7.getZoom();
    const selectedElements = svgCanvas$7.getSelectedElements();
    let spacer = 0.85;
    let bb;
    const calcZoom = (bb2) => {
      if (!bb2) {
        return false;
      }
      const wZoom = Math.round(editorW / bb2.width * 100 * spacer) / 100;
      const hZoom = Math.round(editorH / bb2.height * 100 * spacer) / 100;
      const zoom2 = Math.min(wZoom, hZoom);
      svgCanvas$7.setZoom(zoom2);
      return {
        zoom: zoom2,
        bbox: bb2
      };
    };
    if (typeof val === "object") {
      bb = val;
      if (bb.width === 0 || bb.height === 0) {
        const newzoom = bb.zoom ? bb.zoom : zoom * bb.factor;
        svgCanvas$7.setZoom(newzoom);
        return {
          zoom,
          bbox: bb
        };
      }
      return calcZoom(bb);
    }
    switch (val) {
      case "selection": {
        if (!selectedElements[0]) {
          return void 0;
        }
        const selectedElems = selectedElements.map((n2, _2) => {
          if (n2) {
            return n2;
          }
          return void 0;
        });
        bb = getStrokedBBoxDefaultVisible(selectedElems);
        break;
      }
      case "canvas": {
        const res = svgCanvas$7.getResolution();
        spacer = 0.95;
        bb = {
          width: res.w,
          height: res.h,
          x: 0,
          y: 0
        };
        break;
      }
      case "content":
        bb = getStrokedBBoxDefaultVisible();
        break;
      case "layer":
        bb = getStrokedBBoxDefaultVisible(getVisibleElements(svgCanvas$7.getCurrentDrawing().getCurrentLayer()));
        break;
      default:
        return void 0;
    }
    return calcZoom(bb);
  };
  var setZoomMethod = (zoomLevel) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const res = svgCanvas$7.getResolution();
    svgCanvas$7.getSvgContent().setAttribute("viewBox", "0 0 " + res.w / zoomLevel + " " + res.h / zoomLevel);
    svgCanvas$7.setZoom(zoomLevel);
    selectedElements.forEach((elem) => {
      if (!elem) {
        return;
      }
      svgCanvas$7.selectorManager.requestSelector(elem).resize();
    });
    svgCanvas$7.pathActions.zoomChange();
    svgCanvas$7.runExtensions("zoomChanged", zoomLevel);
  };
  var setColorMethod = (type, val, preventUndo) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    svgCanvas$7.setCurShape(type, val);
    svgCanvas$7.setCurProperties(type + "_paint", {
      type: "solidColor"
    });
    const elems = [];
    const addNonG = (e2) => {
      if (e2.nodeName !== "g") {
        elems.push(e2);
      }
    };
    let i2 = selectedElements.length;
    while (i2--) {
      const elem = selectedElements[i2];
      if (elem) {
        if (elem.tagName === "g") {
          walkTree(elem, addNonG);
        } else if (type === "fill") {
          if (elem.tagName !== "polyline" && elem.tagName !== "line") {
            elems.push(elem);
          }
        } else {
          elems.push(elem);
        }
      }
    }
    if (elems.length > 0) {
      if (!preventUndo) {
        svgCanvas$7.changeSelectedAttribute(type, val, elems);
        svgCanvas$7.call("changed", elems);
      } else {
        svgCanvas$7.changeSelectedAttributeNoUndo(type, val, elems);
      }
    }
  };
  var setGradientMethod = (type) => {
    if (!svgCanvas$7.getCurProperties(type + "_paint") || svgCanvas$7.getCurProperties(type + "_paint").type === "solidColor") {
      return;
    }
    const canvas = svgCanvas$7;
    let grad = canvas[type + "Grad"];
    const duplicateGrad = findDuplicateGradient(grad);
    const defs = findDefs();
    if (!duplicateGrad) {
      grad = svgCanvas$7.getDOMDocument().importNode(grad, true);
      defs.append(grad);
      grad.id = svgCanvas$7.getNextId();
    } else {
      grad = duplicateGrad;
    }
    svgCanvas$7.setColor(type, "url(#" + grad.id + ")");
  };
  var findDuplicateGradient = (grad) => {
    const defs = findDefs();
    const existingGrads = defs.querySelectorAll("linearGradient, radialGradient");
    let i2 = existingGrads.length;
    const radAttrs = ["r", "cx", "cy", "fx", "fy"];
    while (i2--) {
      const og = existingGrads[i2];
      if (grad.tagName === "linearGradient") {
        if (grad.getAttribute("x1") !== og.getAttribute("x1") || grad.getAttribute("y1") !== og.getAttribute("y1") || grad.getAttribute("x2") !== og.getAttribute("x2") || grad.getAttribute("y2") !== og.getAttribute("y2")) {
          continue;
        }
      } else {
        const gradAttrs = {
          r: Number(grad.getAttribute("r")),
          cx: Number(grad.getAttribute("cx")),
          cy: Number(grad.getAttribute("cy")),
          fx: Number(grad.getAttribute("fx")),
          fy: Number(grad.getAttribute("fy"))
        };
        const ogAttrs = {
          r: Number(og.getAttribute("r")),
          cx: Number(og.getAttribute("cx")),
          cy: Number(og.getAttribute("cy")),
          fx: Number(og.getAttribute("fx")),
          fy: Number(og.getAttribute("fy"))
        };
        let diff = false;
        radAttrs.forEach((attr) => {
          if (gradAttrs[attr] !== ogAttrs[attr]) {
            diff = true;
          }
        });
        if (diff) {
          continue;
        }
      }
      const stops = grad.getElementsByTagNameNS(NS.SVG, "stop");
      const ostops = og.getElementsByTagNameNS(NS.SVG, "stop");
      if (stops.length !== ostops.length) {
        continue;
      }
      let j2 = stops.length;
      while (j2--) {
        const stop = stops[j2];
        const ostop = ostops[j2];
        if (stop.getAttribute("offset") !== ostop.getAttribute("offset") || stop.getAttribute("stop-opacity") !== ostop.getAttribute("stop-opacity") || stop.getAttribute("stop-color") !== ostop.getAttribute("stop-color")) {
          break;
        }
      }
      if (j2 === -1) {
        return og;
      }
    }
    return null;
  };
  var setPaintMethod = (type, paint) => {
    const p2 = new Paint(paint);
    svgCanvas$7.setPaintOpacity(type, p2.alpha / 100, true);
    svgCanvas$7.setCurProperties(type + "_paint", p2);
    switch (p2.type) {
      case "solidColor":
        svgCanvas$7.setColor(type, p2.solidColor !== "none" ? "#" + p2.solidColor : "none");
        break;
      case "linearGradient":
      case "radialGradient":
        svgCanvas$7.setCanvas(type + "Grad", p2[p2.type]);
        svgCanvas$7.setGradient(type);
        break;
    }
  };
  var setStrokeWidthMethod = (val) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    if (val === 0 && ["line", "path"].includes(svgCanvas$7.getMode())) {
      svgCanvas$7.setStrokeWidth(1);
      return;
    }
    svgCanvas$7.setCurProperties("stroke_width", val);
    const elems = [];
    const addNonG = (e2) => {
      if (e2.nodeName !== "g") {
        elems.push(e2);
      }
    };
    let i2 = selectedElements.length;
    while (i2--) {
      const elem = selectedElements[i2];
      if (elem) {
        if (elem.tagName === "g") {
          walkTree(elem, addNonG);
        } else {
          elems.push(elem);
        }
      }
    }
    if (elems.length > 0) {
      svgCanvas$7.changeSelectedAttribute("stroke-width", val, elems);
      svgCanvas$7.call("changed", selectedElements);
    }
  };
  var setStrokeAttrMethod = (attr, val) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    svgCanvas$7.setCurShape(attr.replace("-", "_"), val);
    const elems = [];
    let i2 = selectedElements.length;
    while (i2--) {
      const elem = selectedElements[i2];
      if (elem) {
        if (elem.tagName === "g") {
          walkTree(elem, (e2) => {
            if (e2.nodeName !== "g") {
              elems.push(e2);
            }
          });
        } else {
          elems.push(elem);
        }
      }
    }
    if (elems.length > 0) {
      svgCanvas$7.changeSelectedAttribute(attr, val, elems);
      svgCanvas$7.call("changed", selectedElements);
    }
  };
  var getBoldMethod = () => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    return textElements.every((el) => el.getAttribute("font-weight") === "bold");
  };
  var setBoldMethod = (b2) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    svgCanvas$7.changeSelectedAttribute("font-weight", b2 ? "bold" : "normal", textElements);
    if (!textElements.some((el) => el.textContent)) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var hasTextDecorationMethod = (value) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    return textElements.every((el) => (el.getAttribute("text-decoration") || "").includes(value));
  };
  var addTextDecorationMethod = (value) => {
    const {
      ChangeElementCommand: ChangeElementCommand3,
      BatchCommand: BatchCommand3
    } = svgCanvas$7.history;
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    const batchCmd = new BatchCommand3();
    textElements.forEach((elem) => {
      const oldValue = elem.getAttribute("text-decoration") || "";
      if (!oldValue.includes(value)) {
        batchCmd.addSubCommand(new ChangeElementCommand3(elem, {
          "text-decoration": oldValue
        }));
        svgCanvas$7.changeSelectedAttributeNoUndo("text-decoration", (oldValue + " " + value).trim(), [elem]);
      }
    });
    if (!batchCmd.isEmpty()) {
      svgCanvas$7.undoMgr.addCommandToHistory(batchCmd);
    }
    if (!textElements.some((el) => el.textContent)) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var removeTextDecorationMethod = (value) => {
    const {
      ChangeElementCommand: ChangeElementCommand3,
      BatchCommand: BatchCommand3
    } = svgCanvas$7.history;
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    const batchCmd = new BatchCommand3();
    textElements.forEach((elem) => {
      const actualValues = elem.getAttribute("text-decoration") || "";
      batchCmd.addSubCommand(new ChangeElementCommand3(elem, {
        "text-decoration": actualValues
      }));
      svgCanvas$7.changeSelectedAttributeNoUndo("text-decoration", actualValues.replace(value, "").trim(), [elem]);
    });
    if (!batchCmd.isEmpty()) {
      svgCanvas$7.undoMgr.addCommandToHistory(batchCmd);
    }
    if (!textElements.some((el) => el.textContent)) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var getItalicMethod = () => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    return textElements.every((el) => el.getAttribute("font-style") === "italic");
  };
  var setItalicMethod = (i2) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    svgCanvas$7.changeSelectedAttribute("font-style", i2 ? "italic" : "normal", textElements);
    if (!textElements.some((el) => el.textContent)) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var setTextAnchorMethod = (value) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    svgCanvas$7.changeSelectedAttribute("text-anchor", value, textElements);
  };
  var setLetterSpacingMethod = (value) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    svgCanvas$7.changeSelectedAttribute("letter-spacing", value, textElements);
    if (!textElements.some((el) => el.textContent)) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var setWordSpacingMethod = (value) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    svgCanvas$7.changeSelectedAttribute("word-spacing", value, textElements);
    if (!textElements.some((el) => el.textContent)) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var setTextLengthMethod = (value) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    svgCanvas$7.changeSelectedAttribute("textLength", value, textElements);
    if (!textElements.some((el) => el.textContent)) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var setLengthAdjustMethod = (value) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    svgCanvas$7.changeSelectedAttribute("lengthAdjust", value, textElements);
    if (!textElements.some((el) => el.textContent)) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var getFontFamilyMethod = () => {
    return svgCanvas$7.getCurText("font_family");
  };
  var setFontFamilyMethod = (val) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const textElements = selectedElements.filter((el) => el?.tagName === "text");
    svgCanvas$7.setCurText("font_family", val);
    svgCanvas$7.changeSelectedAttribute("font-family", val, textElements);
    if (!textElements.some((el) => el.textContent)) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var setFontColorMethod = (val) => {
    svgCanvas$7.setCurText("fill", val);
    svgCanvas$7.changeSelectedAttribute("fill", val);
  };
  var getFontColorMethod = () => {
    return svgCanvas$7.getCurText("fill");
  };
  var getFontSizeMethod = () => {
    return svgCanvas$7.getCurText("font_size");
  };
  var setFontSizeMethod = (val) => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    svgCanvas$7.setCurText("font_size", val);
    svgCanvas$7.changeSelectedAttribute("font-size", val);
    if (!selectedElements[0]?.textContent) {
      svgCanvas$7.textActions.setCursor();
    }
  };
  var getTextMethod = () => {
    const selectedElements = svgCanvas$7.getSelectedElements();
    const selected = selectedElements[0];
    return selected ? selected.textContent : "";
  };
  var setTextContentMethod = (val) => {
    svgCanvas$7.changeSelectedAttribute("#text", val);
    svgCanvas$7.textActions.init(val);
    svgCanvas$7.textActions.setCursor();
  };
  var setImageURLMethod = (val) => {
    const {
      ChangeElementCommand: ChangeElementCommand3,
      BatchCommand: BatchCommand3
    } = svgCanvas$7.history;
    const selectedElements = svgCanvas$7.getSelectedElements();
    const elem = selectedElements[0];
    if (!elem) {
      return;
    }
    const attrs = {
      width: elem.getAttribute("width"),
      height: elem.getAttribute("height")
    };
    const setsize = !attrs.width || !attrs.height;
    const curHref = getHref(elem);
    if (curHref === val && !setsize) {
      return;
    }
    const batchCmd = new BatchCommand3("Change Image URL");
    setHref(elem, val);
    batchCmd.addSubCommand(new ChangeElementCommand3(elem, {
      "#href": curHref
    }));
    const img = new Image();
    img.onload = function() {
      const changes = {
        width: elem.getAttribute("width"),
        height: elem.getAttribute("height")
      };
      elem.setAttribute("width", this.width);
      elem.setAttribute("height", this.height);
      svgCanvas$7.selectorManager.requestSelector(elem).resize();
      batchCmd.addSubCommand(new ChangeElementCommand3(elem, changes));
      svgCanvas$7.addCommandToHistory(batchCmd);
      svgCanvas$7.call("changed", [elem]);
    };
    img.src = val;
  };
  var setLinkURLMethod = (val) => {
    const {
      ChangeElementCommand: ChangeElementCommand3,
      BatchCommand: BatchCommand3
    } = svgCanvas$7.history;
    const selectedElements = svgCanvas$7.getSelectedElements();
    let elem = selectedElements[0];
    if (!elem) {
      return;
    }
    if (elem.tagName !== "a") {
      const parentsA = getParents(elem.parentNode, "a");
      if (parentsA?.length) {
        elem = parentsA[0];
      } else {
        return;
      }
    }
    const curHref = getHref(elem);
    if (curHref === val) {
      return;
    }
    const batchCmd = new BatchCommand3("Change Link URL");
    setHref(elem, val);
    batchCmd.addSubCommand(new ChangeElementCommand3(elem, {
      "#href": curHref
    }));
    svgCanvas$7.addCommandToHistory(batchCmd);
  };
  var setRectRadiusMethod = (val) => {
    const {
      ChangeElementCommand: ChangeElementCommand3
    } = svgCanvas$7.history;
    const selectedElements = svgCanvas$7.getSelectedElements();
    const selected = selectedElements[0];
    if (selected?.tagName === "rect") {
      const r2 = Number(selected.getAttribute("rx"));
      if (r2 !== val) {
        selected.setAttribute("rx", val);
        selected.setAttribute("ry", val);
        svgCanvas$7.addCommandToHistory(new ChangeElementCommand3(selected, {
          rx: r2,
          ry: r2
        }, "Radius"));
        svgCanvas$7.call("changed", [selected]);
      }
    }
  };
  var makeHyperlinkMethod = (url) => {
    svgCanvas$7.groupSelectedElements("a", url);
  };
  var removeHyperlinkMethod = () => {
    svgCanvas$7.ungroupSelectedElement();
  };
  var setSegTypeMethod = (newType) => {
    svgCanvas$7.pathActions.setSegType(newType);
  };
  var setBackgroundMethod = (color, url) => {
    const bg = getElement("canvasBackground");
    const border = bg.querySelector("rect");
    let bgImg = getElement("background_image");
    let bgPattern = getElement("background_pattern");
    border.setAttribute("fill", color === "chessboard" ? "#fff" : color);
    if (color === "chessboard") {
      if (!bgPattern) {
        bgPattern = svgCanvas$7.getDOMDocument().createElementNS(NS.SVG, "foreignObject");
        svgCanvas$7.assignAttributes(bgPattern, {
          id: "background_pattern",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMinYMin",
          style: "pointer-events:none"
        });
        const div = document.createElement("div");
        svgCanvas$7.assignAttributes(div, {
          style: "pointer-events:none;width:100%;height:100%;background-image:url(data:image/gif;base64,R0lGODlhEAAQAIAAAP///9bW1iH5BAAAAAAALAAAAAAQABAAAAIfjG+gq4jM3IFLJgpswNly/XkcBpIiVaInlLJr9FZWAQA7);"
        });
        bgPattern.append(div);
        bg.append(bgPattern);
      }
    } else if (bgPattern) {
      bgPattern.remove();
    }
    if (url) {
      if (!bgImg) {
        bgImg = svgCanvas$7.getDOMDocument().createElementNS(NS.SVG, "image");
        svgCanvas$7.assignAttributes(bgImg, {
          id: "background_image",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMinYMin",
          style: "pointer-events:none"
        });
      }
      setHref(bgImg, url);
      bg.append(bgImg);
    } else if (bgImg) {
      bgImg.remove();
    }
  };
  var svgCanvas$6 = null;
  var init$6 = (canvas) => {
    svgCanvas$6 = canvas;
  };
  var pathMap = [0, "z", "M", "m", "L", "l", "C", "c", "Q", "q", "A", "a", "H", "h", "V", "v", "S", "s", "T", "t"];
  var remapElement = (selected, changes, m2) => {
    const remap = (x2, y2) => transformPoint(x2, y2, m2);
    const scalew = (w2) => m2.a * w2;
    const scaleh = (h2) => m2.d * h2;
    const doSnapping = svgCanvas$6.getGridSnapping() && selected.parentNode.parentNode.localName === "svg";
    const finishUp = () => {
      if (doSnapping) {
        Object.entries(changes).forEach(([attr, value]) => {
          changes[attr] = snapToGrid(value);
        });
      }
      assignAttributes(selected, changes, 1e3, true);
    };
    const box = getBBox(selected);
    ["fill", "stroke"].forEach((type) => {
      const attrVal = selected.getAttribute(type);
      if (attrVal?.startsWith("url(") && (m2.a < 0 || m2.d < 0)) {
        const grad = getRefElem(attrVal);
        const newgrad = grad.cloneNode(true);
        if (m2.a < 0) {
          const x1 = newgrad.getAttribute("x1");
          const x2 = newgrad.getAttribute("x2");
          newgrad.setAttribute("x1", -(x1 - 1));
          newgrad.setAttribute("x2", -(x2 - 1));
        }
        if (m2.d < 0) {
          const y1 = newgrad.getAttribute("y1");
          const y2 = newgrad.getAttribute("y2");
          newgrad.setAttribute("y1", -(y1 - 1));
          newgrad.setAttribute("y2", -(y2 - 1));
        }
        newgrad.id = svgCanvas$6.getCurrentDrawing().getNextId();
        findDefs().append(newgrad);
        selected.setAttribute(type, "url(#" + newgrad.id + ")");
      }
    });
    const elName = selected.tagName;
    if (elName === "use") {
      return;
    }
    switch (elName) {
      case "foreignObject":
      case "rect":
      case "image": {
        if (elName === "image" && (m2.a < 0 || m2.d < 0)) {
          const chlist = getTransformList(selected);
          const mt2 = svgCanvas$6.getSvgRoot().createSVGTransform();
          mt2.setMatrix(matrixMultiply(transformListToTransform(chlist).matrix, m2));
          chlist.clear();
          chlist.appendItem(mt2);
        } else {
          const pt1 = remap(changes.x, changes.y);
          changes.width = scalew(changes.width);
          changes.height = scaleh(changes.height);
          changes.x = pt1.x + Math.min(0, changes.width);
          changes.y = pt1.y + Math.min(0, changes.height);
          changes.width = Math.abs(changes.width);
          changes.height = Math.abs(changes.height);
        }
        finishUp();
        break;
      }
      case "ellipse": {
        const c2 = remap(changes.cx, changes.cy);
        changes.cx = c2.x;
        changes.cy = c2.y;
        changes.rx = Math.abs(scalew(changes.rx));
        changes.ry = Math.abs(scaleh(changes.ry));
        finishUp();
        break;
      }
      case "circle": {
        const c2 = remap(changes.cx, changes.cy);
        changes.cx = c2.x;
        changes.cy = c2.y;
        const tbox = transformBox(box.x, box.y, box.width, box.height, m2);
        const w2 = tbox.tr.x - tbox.tl.x;
        const h2 = tbox.bl.y - tbox.tl.y;
        changes.r = Math.min(Math.abs(w2 / 2), Math.abs(h2 / 2));
        finishUp();
        break;
      }
      case "line": {
        const pt1 = remap(changes.x1, changes.y1);
        const pt2 = remap(changes.x2, changes.y2);
        changes.x1 = pt1.x;
        changes.y1 = pt1.y;
        changes.x2 = pt2.x;
        changes.y2 = pt2.y;
        finishUp();
        break;
      }
      case "text": {
        const pt2 = remap(changes.x, changes.y);
        changes.x = pt2.x;
        changes.y = pt2.y;
        let fontSize = selected.getAttribute("font-size");
        if (!fontSize) {
          fontSize = window.getComputedStyle(selected).fontSize;
        }
        const fontSizeNum = parseFloat(fontSize);
        if (!isNaN(fontSizeNum)) {
          changes["font-size"] = fontSizeNum * Math.abs(m2.a);
        }
        finishUp();
        const childNodes = selected.childNodes;
        for (let i2 = 0; i2 < childNodes.length; i2++) {
          const child = childNodes[i2];
          if (child.nodeType === 1 && child.tagName === "tspan") {
            const childChanges = {};
            const hasX = child.hasAttribute("x");
            const hasY = child.hasAttribute("y");
            if (hasX) {
              const childX = convertToNum("x", child.getAttribute("x"));
              const childPtX = remap(childX, changes.y).x;
              childChanges.x = childPtX;
            }
            if (hasY) {
              const childY = convertToNum("y", child.getAttribute("y"));
              const childPtY = remap(changes.x, childY).y;
              childChanges.y = childPtY;
            }
            let tspanFS = child.getAttribute("font-size");
            if (!tspanFS) {
              tspanFS = window.getComputedStyle(child).fontSize;
            }
            const tspanFSNum = parseFloat(tspanFS);
            if (!isNaN(tspanFSNum)) {
              childChanges["font-size"] = tspanFSNum * Math.abs(m2.a);
            }
            if (hasX || hasY || childChanges["font-size"]) {
              assignAttributes(child, childChanges, 1e3, true);
            }
          }
        }
        break;
      }
      case "tspan": {
        const pt2 = remap(changes.x, changes.y);
        changes.x = pt2.x;
        changes.y = pt2.y;
        let tspanFS = selected.getAttribute("font-size");
        if (!tspanFS) {
          tspanFS = window.getComputedStyle(selected).fontSize;
        }
        const tspanFSNum = parseFloat(tspanFS);
        if (!isNaN(tspanFSNum)) {
          changes["font-size"] = tspanFSNum * Math.abs(m2.a);
        }
        finishUp();
        break;
      }
      case "g": {
        const dataStorage2 = svgCanvas$6.getDataStorage();
        const gsvg = dataStorage2.get(selected, "gsvg");
        if (gsvg) {
          assignAttributes(gsvg, changes, 1e3, true);
        }
        break;
      }
      case "polyline":
      case "polygon": {
        changes.points.forEach((pt2) => {
          const {
            x: x2,
            y: y2
          } = remap(pt2.x, pt2.y);
          pt2.x = x2;
          pt2.y = y2;
        });
        const pstr = changes.points.map((pt2) => `${pt2.x},${pt2.y}`).join(" ");
        selected.setAttribute("points", pstr);
        break;
      }
      case "path": {
        const segList = selected.pathSegList;
        const len = segList.numberOfItems;
        changes.d = [];
        for (let i2 = 0; i2 < len; ++i2) {
          const seg = segList.getItem(i2);
          changes.d[i2] = {
            type: seg.pathSegType,
            x: seg.x,
            y: seg.y,
            x1: seg.x1,
            y1: seg.y1,
            x2: seg.x2,
            y2: seg.y2,
            r1: seg.r1,
            r2: seg.r2,
            angle: seg.angle,
            largeArcFlag: seg.largeArcFlag,
            sweepFlag: seg.sweepFlag
          };
        }
        const firstseg = changes.d[0];
        let currentpt;
        if (len > 0) {
          currentpt = remap(firstseg.x, firstseg.y);
          changes.d[0].x = currentpt.x;
          changes.d[0].y = currentpt.y;
        }
        for (let i2 = 1; i2 < len; ++i2) {
          const seg = changes.d[i2];
          const {
            type
          } = seg;
          if (type % 2 === 0) {
            const thisx = seg.x !== void 0 ? seg.x : currentpt.x;
            const thisy = seg.y !== void 0 ? seg.y : currentpt.y;
            const pt2 = remap(thisx, thisy);
            const pt1 = remap(seg.x1, seg.y1);
            const pt22 = remap(seg.x2, seg.y2);
            seg.x = pt2.x;
            seg.y = pt2.y;
            seg.x1 = pt1.x;
            seg.y1 = pt1.y;
            seg.x2 = pt22.x;
            seg.y2 = pt22.y;
            seg.r1 = scalew(seg.r1);
            seg.r2 = scaleh(seg.r2);
          } else {
            seg.x = scalew(seg.x);
            seg.y = scaleh(seg.y);
            seg.x1 = scalew(seg.x1);
            seg.y1 = scaleh(seg.y1);
            seg.x2 = scalew(seg.x2);
            seg.y2 = scaleh(seg.y2);
            seg.r1 = scalew(seg.r1);
            seg.r2 = scaleh(seg.r2);
          }
        }
        let dstr = "";
        changes.d.forEach((seg) => {
          const {
            type
          } = seg;
          dstr += pathMap[type];
          switch (type) {
            case 13:
            // relative horizontal line (h)
            case 12:
              dstr += seg.x + " ";
              break;
            case 15:
            // relative vertical line (v)
            case 14:
              dstr += seg.y + " ";
              break;
            case 3:
            // relative move (m)
            case 5:
            // relative line (l)
            case 19:
            // relative smooth quad (t)
            case 2:
            // absolute move (M)
            case 4:
            // absolute line (L)
            case 18:
              dstr += seg.x + "," + seg.y + " ";
              break;
            case 7:
            // relative cubic (c)
            case 6:
              dstr += seg.x1 + "," + seg.y1 + " " + seg.x2 + "," + seg.y2 + " " + seg.x + "," + seg.y + " ";
              break;
            case 9:
            // relative quad (q)
            case 8:
              dstr += seg.x1 + "," + seg.y1 + " " + seg.x + "," + seg.y + " ";
              break;
            case 11:
            // relative elliptical arc (a)
            case 10:
              dstr += seg.r1 + "," + seg.r2 + " " + seg.angle + " " + Number(seg.largeArcFlag) + " " + Number(seg.sweepFlag) + " " + seg.x + "," + seg.y + " ";
              break;
            case 17:
            // relative smooth cubic (s)
            case 16:
              dstr += seg.x2 + "," + seg.y2 + " " + seg.x + "," + seg.y + " ";
              break;
          }
        });
        selected.setAttribute("d", dstr.trim());
        break;
      }
    }
  };
  var svgCanvas$5;
  var init$5 = (canvas) => {
    svgCanvas$5 = canvas;
  };
  var recalculateDimensions = (selected) => {
    if (!selected) return null;
    const svgroot = svgCanvas$5.getSvgRoot();
    const dataStorage2 = svgCanvas$5.getDataStorage();
    const tlist = getTransformList(selected);
    if (tlist?.numberOfItems > 0) {
      let k2 = tlist.numberOfItems;
      const noi = k2;
      while (k2--) {
        const xform = tlist.getItem(k2);
        if (xform.type === SVGTransform.SVG_TRANSFORM_MATRIX) {
          if (isIdentity(xform.matrix)) {
            if (noi === 1) {
              selected.removeAttribute("transform");
              return null;
            }
            tlist.removeItem(k2);
          }
        } else if (xform.type === SVGTransform.SVG_TRANSFORM_ROTATE && xform.angle === 0) {
          tlist.removeItem(k2);
        } else if (xform.type === SVGTransform.SVG_TRANSFORM_TRANSLATE && xform.matrix.e === 0 && xform.matrix.f === 0) {
          tlist.removeItem(k2);
        }
      }
      if (tlist.numberOfItems === 1 && getRotationAngle(selected)) {
        return null;
      }
    }
    if (!tlist || tlist.numberOfItems === 0) {
      selected.removeAttribute("transform");
      return null;
    }
    const batchCmd = new BatchCommand$4("Transform");
    switch (selected.tagName) {
      // Ignore these elements, as they can absorb the [M] transformation
      case "line":
      case "polyline":
      case "polygon":
      case "path":
        break;
      default:
        if (tlist.numberOfItems === 1 && tlist.getItem(0).type === SVGTransform.SVG_TRANSFORM_MATRIX || tlist.numberOfItems === 2 && tlist.getItem(0).type === SVGTransform.SVG_TRANSFORM_MATRIX && tlist.getItem(1).type === SVGTransform.SVG_TRANSFORM_ROTATE) {
          return null;
        }
    }
    const gsvg = dataStorage2.has(selected, "gsvg") ? dataStorage2.get(selected, "gsvg") : void 0;
    let changes = {};
    let initial = null;
    let attrs = [];
    switch (selected.tagName) {
      case "line":
        attrs = ["x1", "y1", "x2", "y2"];
        break;
      case "circle":
        attrs = ["cx", "cy", "r"];
        break;
      case "ellipse":
        attrs = ["cx", "cy", "rx", "ry"];
        break;
      case "foreignObject":
      case "rect":
      case "image":
        attrs = ["width", "height", "x", "y"];
        break;
      case "text":
      case "tspan":
        attrs = ["x", "y"];
        break;
      case "polygon":
      case "polyline": {
        initial = {};
        initial.points = selected.getAttribute("points");
        const list = selected.points;
        const len = list.numberOfItems;
        changes.points = new Array(len);
        for (let i2 = 0; i2 < len; ++i2) {
          const pt2 = list.getItem(i2);
          changes.points[i2] = {
            x: pt2.x,
            y: pt2.y
          };
        }
        break;
      }
      case "path":
        initial = {};
        initial.d = selected.getAttribute("d");
        changes.d = selected.getAttribute("d");
        break;
    }
    if (attrs.length) {
      attrs.forEach((attr) => {
        changes[attr] = convertToNum(attr, selected.getAttribute(attr));
      });
    } else if (gsvg) {
      changes = {
        x: Number(gsvg.getAttribute("x")) || 0,
        y: Number(gsvg.getAttribute("y")) || 0
      };
    }
    if (!initial) {
      initial = mergeDeep({}, changes);
      for (const [attr, val] of Object.entries(initial)) {
        initial[attr] = convertToNum(attr, val);
      }
    }
    initial.transform = svgCanvas$5.getStartTransform() || "";
    let oldcenter, newcenter;
    if (selected.tagName === "g" && !gsvg || selected.tagName === "a") ;
    else {
      const box = getBBox(selected);
      if (!box && selected.tagName !== "path") return null;
      let m2;
      let x2 = 0;
      let y2 = 0;
      if (["use", "image", "text", "tspan"].includes(selected.tagName)) {
        x2 = convertToNum("x", selected.getAttribute("x") || "0");
        y2 = convertToNum("y", selected.getAttribute("y") || "0");
      }
      const angle2 = getRotationAngle(selected);
      if (angle2) {
        if (selected.localName === "image") {
          const xAttr = convertToNum("x", selected.getAttribute("x") || "0");
          const yAttr = convertToNum("y", selected.getAttribute("y") || "0");
          const width = convertToNum("width", selected.getAttribute("width") || "0");
          const height = convertToNum("height", selected.getAttribute("height") || "0");
          const cx = xAttr + width / 2;
          const cy = yAttr + height / 2;
          oldcenter = {
            x: cx,
            y: cy
          };
          const transform = transformListToTransform(tlist).matrix;
          newcenter = transformPoint(cx, cy, transform);
        } else if (selected.localName === "text") {
          const cx = box.x + box.width / 2;
          const cy = box.y + box.height / 2;
          oldcenter = {
            x: cx,
            y: cy
          };
          newcenter = transformPoint(cx, cy, transformListToTransform(tlist).matrix);
        } else {
          oldcenter = {
            x: box.x + box.width / 2 + x2,
            y: box.y + box.height / 2 + y2
          };
          newcenter = transformPoint(box.x + box.width / 2 + x2, box.y + box.height / 2 + y2, transformListToTransform(tlist).matrix);
        }
        for (let i2 = 0; i2 < tlist.numberOfItems; ++i2) {
          const xform = tlist.getItem(i2);
          if (xform.type === SVGTransform.SVG_TRANSFORM_ROTATE) {
            tlist.removeItem(i2);
            break;
          }
        }
      }
      const N2 = tlist.numberOfItems;
      if (N2 >= 3 && tlist.getItem(N2 - 3).type === SVGTransform.SVG_TRANSFORM_TRANSLATE && tlist.getItem(N2 - 2).type === SVGTransform.SVG_TRANSFORM_SCALE && tlist.getItem(N2 - 1).type === SVGTransform.SVG_TRANSFORM_TRANSLATE) {
        m2 = transformListToTransform(tlist, N2 - 3, N2 - 1).matrix;
        tlist.removeItem(N2 - 1);
        tlist.removeItem(N2 - 2);
        tlist.removeItem(N2 - 3);
        if (selected.tagName === "use") {
          const mExisting = transformListToTransform(getTransformList(selected)).matrix;
          const mNew = matrixMultiply(mExisting, m2);
          tlist.clear();
          const newTransform = svgroot.createSVGTransform();
          newTransform.setMatrix(mNew);
          tlist.appendItem(newTransform);
        } else {
          remapElement(selected, changes, m2);
        }
        if (angle2) {
          const matrix2 = transformListToTransform(tlist).matrix;
          const oldRotation = svgroot.createSVGTransform();
          oldRotation.setRotate(angle2, oldcenter.x, oldcenter.y);
          const oldRotMatrix = oldRotation.matrix;
          const newRotation = svgroot.createSVGTransform();
          newRotation.setRotate(angle2, newcenter.x, newcenter.y);
          const newRotInvMatrix = newRotation.matrix.inverse();
          const matrixInv = matrix2.inverse();
          const extraTransform = matrixMultiply(matrixInv, newRotInvMatrix, oldRotMatrix, matrix2);
          remapElement(selected, changes, extraTransform);
          if (tlist.numberOfItems) {
            tlist.insertItemBefore(newRotation, 0);
          } else {
            tlist.appendItem(newRotation);
          }
        }
      } else if ((N2 === 1 || N2 > 1 && tlist.getItem(1).type !== SVGTransform.SVG_TRANSFORM_SCALE) && tlist.getItem(0).type === SVGTransform.SVG_TRANSFORM_TRANSLATE) {
        const oldTranslate = tlist.getItem(0).matrix;
        const remainingTransforms = transformListToTransform(tlist, 1).matrix;
        const remainingTransformsInv = remainingTransforms.inverse();
        m2 = matrixMultiply(remainingTransformsInv, oldTranslate, remainingTransforms);
        tlist.removeItem(0);
        if (selected.tagName === "use") {
          const mExisting = transformListToTransform(getTransformList(selected)).matrix;
          const mNew = matrixMultiply(mExisting, m2);
          tlist.clear();
          const newTransform = svgroot.createSVGTransform();
          newTransform.setMatrix(mNew);
          tlist.appendItem(newTransform);
        } else {
          remapElement(selected, changes, m2);
        }
        if (angle2) {
          if (!hasMatrixTransform(tlist)) {
            newcenter = {
              x: oldcenter.x + m2.e,
              y: oldcenter.y + m2.f
            };
          }
          const newRot = svgroot.createSVGTransform();
          newRot.setRotate(angle2, newcenter.x, newcenter.y);
          if (tlist.numberOfItems) {
            tlist.insertItemBefore(newRot, 0);
          } else {
            tlist.appendItem(newRot);
          }
        }
      } else if (N2 === 1 && tlist.getItem(0).type === SVGTransform.SVG_TRANSFORM_MATRIX && !angle2) {
        m2 = transformListToTransform(tlist).matrix;
        tlist.clear();
        if (selected.tagName === "use") {
          const mExisting = transformListToTransform(getTransformList(selected)).matrix;
          const mNew = matrixMultiply(mExisting, m2);
          tlist.clear();
          const newTransform = svgroot.createSVGTransform();
          newTransform.setMatrix(mNew);
          tlist.appendItem(newTransform);
        } else {
          remapElement(selected, changes, m2);
        }
      } else {
        if (angle2) {
          const newRot = svgroot.createSVGTransform();
          newRot.setRotate(angle2, newcenter.x, newcenter.y);
          if (tlist.numberOfItems) {
            tlist.insertItemBefore(newRot, 0);
          } else {
            tlist.appendItem(newRot);
          }
        }
        if (tlist.numberOfItems === 0) {
          selected.removeAttribute("transform");
        }
        return null;
      }
    }
    if (tlist.numberOfItems === 0) {
      selected.removeAttribute("transform");
    }
    batchCmd.addSubCommand(new ChangeElementCommand$2(selected, initial));
    return batchCmd;
  };
  var {
    MoveElementCommand: MoveElementCommand2,
    BatchCommand: BatchCommand$1,
    InsertElementCommand: InsertElementCommand$1,
    RemoveElementCommand: RemoveElementCommand$1,
    ChangeElementCommand: ChangeElementCommand$1
  } = history;
  var svgCanvas$4 = null;
  var init$4 = (canvas) => {
    svgCanvas$4 = canvas;
    svgCanvas$4.copySelectedElements = copySelectedElements;
    svgCanvas$4.groupSelectedElements = groupSelectedElements;
    svgCanvas$4.pushGroupProperties = pushGroupProperty;
    svgCanvas$4.ungroupSelectedElement = ungroupSelectedElement;
    svgCanvas$4.moveToTopSelectedElement = moveToTopSelectedElem;
    svgCanvas$4.moveToBottomSelectedElement = moveToBottomSelectedElem;
    svgCanvas$4.moveUpDownSelected = moveUpDownSelected;
    svgCanvas$4.moveSelectedElements = moveSelectedElements;
    svgCanvas$4.cloneSelectedElements = cloneSelectedElements;
    svgCanvas$4.alignSelectedElements = alignSelectedElements;
    svgCanvas$4.updateCanvas = updateCanvas;
    svgCanvas$4.cycleElement = cycleElement;
    svgCanvas$4.deleteSelectedElements = deleteSelectedElements;
  };
  var moveToTopSelectedElem = () => {
    const [selected] = svgCanvas$4.getSelectedElements();
    if (selected) {
      const t3 = selected;
      const oldParent = t3.parentNode;
      const oldNextSibling = t3.nextSibling;
      t3.parentNode.append(t3);
      if (oldNextSibling !== t3.nextSibling) {
        svgCanvas$4.addCommandToHistory(new MoveElementCommand2(t3, oldNextSibling, oldParent, "top"));
        svgCanvas$4.call("changed", [t3]);
      }
    }
  };
  var moveToBottomSelectedElem = () => {
    const [selected] = svgCanvas$4.getSelectedElements();
    if (selected) {
      let t3 = selected;
      const oldParent = t3.parentNode;
      const oldNextSibling = t3.nextSibling;
      let {
        firstChild
      } = t3.parentNode;
      if (firstChild.tagName === "title") {
        firstChild = firstChild.nextSibling;
      }
      if (firstChild.tagName === "defs") {
        firstChild = firstChild.nextSibling;
      }
      t3 = t3.parentNode.insertBefore(t3, firstChild);
      if (oldNextSibling !== t3.nextSibling) {
        svgCanvas$4.addCommandToHistory(new MoveElementCommand2(t3, oldNextSibling, oldParent, "bottom"));
        svgCanvas$4.call("changed", [t3]);
      }
    }
  };
  var moveUpDownSelected = (dir) => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    const selected = selectedElements[0];
    if (!selected) {
      return;
    }
    svgCanvas$4.setCurBBoxes([]);
    let closest;
    let foundCur;
    const list = svgCanvas$4.getIntersectionList(getStrokedBBoxDefaultVisible([selected]));
    if (dir === "Down") {
      list.reverse();
    }
    Array.prototype.forEach.call(list, (el) => {
      if (!foundCur) {
        if (el === selected) {
          foundCur = true;
        }
        return true;
      }
      if (closest === void 0) {
        closest = el;
      }
      return false;
    });
    if (!closest) {
      return;
    }
    const t3 = selected;
    const oldParent = t3.parentNode;
    const oldNextSibling = t3.nextSibling;
    if (dir === "Down") {
      closest.insertAdjacentElement("beforebegin", t3);
    } else {
      closest.insertAdjacentElement("afterend", t3);
    }
    if (oldNextSibling !== t3.nextSibling) {
      svgCanvas$4.addCommandToHistory(new MoveElementCommand2(t3, oldNextSibling, oldParent, "Move " + dir));
      svgCanvas$4.call("changed", [t3]);
    }
  };
  var moveSelectedElements = (dx, dy, undoable = true) => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    const zoom = svgCanvas$4.getZoom();
    if (!Array.isArray(dx)) {
      dx /= zoom;
      dy /= zoom;
    }
    const batchCmd = new BatchCommand$1("position");
    selectedElements.forEach((selected, i2) => {
      if (selected) {
        const xform = svgCanvas$4.getSvgRoot().createSVGTransform();
        const tlist = getTransformList(selected);
        if (Array.isArray(dx)) {
          xform.setTranslate(dx[i2], dy[i2]);
        } else {
          xform.setTranslate(dx, dy);
        }
        if (tlist.numberOfItems) {
          tlist.insertItemBefore(xform, 0);
        } else {
          tlist.appendItem(xform);
        }
        const cmd = recalculateDimensions(selected);
        if (cmd) {
          batchCmd.addSubCommand(cmd);
        }
        svgCanvas$4.gettingSelectorManager().requestSelector(selected).resize();
      }
    });
    if (!batchCmd.isEmpty()) {
      if (undoable) {
        svgCanvas$4.addCommandToHistory(batchCmd);
      }
      svgCanvas$4.call("changed", selectedElements);
      return batchCmd;
    }
    return void 0;
  };
  var cloneSelectedElements = (x2, y2) => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    const currentGroup = svgCanvas$4.getCurrentGroup();
    let i2;
    let elem;
    const batchCmd = new BatchCommand$1("Clone Elements");
    const len = selectedElements.length;
    const index2 = (el) => {
      if (!el) return -1;
      let i3 = 0;
      do {
        i3++;
      } while (el === el.previousElementSibling);
      return i3;
    };
    const sortfunction = (a2, b2) => {
      return index2(b2) - index2(a2);
    };
    selectedElements.sort(sortfunction);
    for (i2 = 0; i2 < len; ++i2) {
      elem = selectedElements[i2];
      if (!elem) {
        break;
      }
    }
    const copiedElements = selectedElements.slice(0, i2);
    svgCanvas$4.clearSelection(true);
    const drawing = svgCanvas$4.getDrawing();
    i2 = copiedElements.length;
    while (i2--) {
      elem = copiedElements[i2] = drawing.copyElem(copiedElements[i2]);
      (currentGroup || drawing.getCurrentLayer()).append(elem);
      batchCmd.addSubCommand(new InsertElementCommand$1(elem));
    }
    if (!batchCmd.isEmpty()) {
      svgCanvas$4.addToSelection(copiedElements.reverse());
      moveSelectedElements(x2, y2, false);
      svgCanvas$4.addCommandToHistory(batchCmd);
    }
  };
  var alignSelectedElements = (type, relativeTo) => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    const bboxes = [];
    const len = selectedElements.length;
    if (!len) {
      return;
    }
    let minx = Number.MAX_VALUE;
    let maxx = Number.MIN_VALUE;
    let miny = Number.MAX_VALUE;
    let maxy = Number.MIN_VALUE;
    const isHorizontalAlign = (type2) => ["l", "c", "r", "left", "center", "right"].includes(type2);
    const isVerticalAlign = (type2) => ["t", "m", "b", "top", "middle", "bottom"].includes(type2);
    for (let i2 = 0; i2 < len; ++i2) {
      if (!selectedElements[i2]) {
        break;
      }
      const elem = selectedElements[i2];
      bboxes[i2] = getStrokedBBoxDefaultVisible([elem]);
    }
    if (["smallest", "largest"].includes(relativeTo) && ["dh", "distrib_horiz", "dv", "distrib_verti"].includes(type)) {
      relativeTo = "selected";
    }
    switch (relativeTo) {
      case "smallest":
        if (isHorizontalAlign(type) || isVerticalAlign(type)) {
          const sortedBboxes = bboxes.slice().sort((a2, b2) => a2.width - b2.width);
          const minBbox = sortedBboxes[0];
          minx = minBbox.x;
          miny = minBbox.y;
          maxx = minBbox.x + minBbox.width;
          maxy = minBbox.y + minBbox.height;
        }
        break;
      case "largest":
        if (isHorizontalAlign(type) || isVerticalAlign(type)) {
          const sortedBboxes = bboxes.slice().sort((a2, b2) => a2.width - b2.width);
          const maxBbox = sortedBboxes[bboxes.length - 1];
          minx = maxBbox.x;
          miny = maxBbox.y;
          maxx = maxBbox.x + maxBbox.width;
          maxy = maxBbox.y + maxBbox.height;
        }
        break;
      case "page":
        minx = 0;
        miny = 0;
        maxx = svgCanvas$4.getContentW();
        maxy = svgCanvas$4.getContentH();
        break;
      default:
        minx = Math.min(...bboxes.map((box) => box.x));
        miny = Math.min(...bboxes.map((box) => box.y));
        maxx = Math.max(...bboxes.map((box) => box.x + box.width));
        maxy = Math.max(...bboxes.map((box) => box.y + box.height));
        break;
    }
    let dx = [];
    let dy = [];
    if (["dh", "distrib_horiz"].includes(type)) {
      [dx, dy] = _getDistributeHorizontalDistances(relativeTo, selectedElements, bboxes, minx, maxx, miny, maxy);
    } else if (["dv", "distrib_verti"].includes(type)) {
      [dx, dy] = _getDistributeVerticalDistances(relativeTo, selectedElements, bboxes, minx, maxx, miny, maxy);
    } else {
      [dx, dy] = _getNormalDistances(type, selectedElements, bboxes, minx, maxx, miny, maxy);
    }
    moveSelectedElements(dx, dy);
  };
  var _getDistributeHorizontalDistances = (relativeTo, selectedElements, bboxes, minx, maxx, miny, maxy) => {
    const dx = [];
    const dy = [];
    for (let i2 = 0; i2 < selectedElements.length; i2++) {
      dy[i2] = 0;
    }
    const bboxesSortedClone = bboxes.slice().sort((firstBox, secondBox) => {
      const firstMaxX = firstBox.x + firstBox.width;
      const secondMaxX = secondBox.x + secondBox.width;
      if (firstMaxX === secondMaxX) {
        return 0;
      } else if (firstMaxX > secondMaxX) {
        return 1;
      } else {
        return -1;
      }
    });
    if (relativeTo === "page") {
      bboxesSortedClone.unshift({
        x: 0,
        y: 0,
        width: 0,
        height: maxy
      });
      bboxesSortedClone.push({
        x: maxx,
        y: 0,
        width: 0,
        height: maxy
      });
    }
    const totalWidth = maxx - minx;
    const totalBoxWidth = bboxesSortedClone.map((b2) => b2.width).reduce((w1, w2) => w1 + w2, 0);
    const space = (totalWidth - totalBoxWidth) / (bboxesSortedClone.length - 1);
    const _dx = [];
    for (let i2 = 0; i2 < bboxesSortedClone.length; ++i2) {
      _dx[i2] = 0;
      if (i2 === 0) {
        continue;
      }
      const orgX = bboxesSortedClone[i2].x;
      bboxesSortedClone[i2].x = bboxesSortedClone[i2 - 1].x + bboxesSortedClone[i2 - 1].width + space;
      _dx[i2] = bboxesSortedClone[i2].x - orgX;
    }
    bboxesSortedClone.forEach((boxClone, idx) => {
      const orgIdx = bboxes.findIndex((box) => box === boxClone);
      if (orgIdx !== -1) {
        dx[orgIdx] = _dx[idx];
      }
    });
    return [dx, dy];
  };
  var _getDistributeVerticalDistances = (relativeTo, selectedElements, bboxes, minx, maxx, miny, maxy) => {
    const dx = [];
    const dy = [];
    for (let i2 = 0; i2 < selectedElements.length; i2++) {
      dx[i2] = 0;
    }
    const bboxesSortedClone = bboxes.slice().sort((firstBox, secondBox) => {
      const firstMaxY = firstBox.y + firstBox.height;
      const secondMaxY = secondBox.y + secondBox.height;
      if (firstMaxY === secondMaxY) {
        return 0;
      } else if (firstMaxY > secondMaxY) {
        return 1;
      } else {
        return -1;
      }
    });
    if (relativeTo === "page") {
      bboxesSortedClone.unshift({
        x: 0,
        y: 0,
        width: maxx,
        height: 0
      });
      bboxesSortedClone.push({
        x: 0,
        y: maxy,
        width: maxx,
        height: 0
      });
    }
    const totalHeight = maxy - miny;
    const totalBoxHeight = bboxesSortedClone.map((b2) => b2.height).reduce((h1, h2) => h1 + h2, 0);
    const space = (totalHeight - totalBoxHeight) / (bboxesSortedClone.length - 1);
    const _dy = [];
    for (let i2 = 0; i2 < bboxesSortedClone.length; ++i2) {
      _dy[i2] = 0;
      if (i2 === 0) {
        continue;
      }
      const orgY = bboxesSortedClone[i2].y;
      bboxesSortedClone[i2].y = bboxesSortedClone[i2 - 1].y + bboxesSortedClone[i2 - 1].height + space;
      _dy[i2] = bboxesSortedClone[i2].y - orgY;
    }
    bboxesSortedClone.forEach((boxClone, idx) => {
      const orgIdx = bboxes.findIndex((box) => box === boxClone);
      if (orgIdx !== -1) {
        dy[orgIdx] = _dy[idx];
      }
    });
    return [dx, dy];
  };
  var _getNormalDistances = (type, selectedElements, bboxes, minx, maxx, miny, maxy) => {
    const len = selectedElements.length;
    const dx = new Array(len);
    const dy = new Array(len);
    for (let i2 = 0; i2 < len; ++i2) {
      if (!selectedElements[i2]) {
        break;
      }
      const bbox = bboxes[i2];
      dx[i2] = 0;
      dy[i2] = 0;
      switch (type) {
        case "l":
        // left (horizontal)
        case "left":
          dx[i2] = minx - bbox.x;
          break;
        case "c":
        // center (horizontal)
        case "center":
          dx[i2] = (minx + maxx) / 2 - (bbox.x + bbox.width / 2);
          break;
        case "r":
        // right (horizontal)
        case "right":
          dx[i2] = maxx - (bbox.x + bbox.width);
          break;
        case "t":
        // top (vertical)
        case "top":
          dy[i2] = miny - bbox.y;
          break;
        case "m":
        // middle (vertical)
        case "middle":
          dy[i2] = (miny + maxy) / 2 - (bbox.y + bbox.height / 2);
          break;
        case "b":
        // bottom (vertical)
        case "bottom":
          dy[i2] = maxy - (bbox.y + bbox.height);
          break;
      }
    }
    return [dx, dy];
  };
  var deleteSelectedElements = () => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    const batchCmd = new BatchCommand$1("Delete Elements");
    const selectedCopy = [];
    selectedElements.forEach((selected) => {
      if (selected) {
        let parent = selected.parentNode;
        let t3 = selected;
        svgCanvas$4.gettingSelectorManager().releaseSelector(t3);
        removePath_(t3.id);
        if (parent.tagName === "a" && parent.childNodes.length === 1) {
          t3 = parent;
          parent = parent.parentNode;
        }
        const {
          nextSibling
        } = t3;
        t3.remove();
        const elem = t3;
        selectedCopy.push(selected);
        batchCmd.addSubCommand(new RemoveElementCommand$1(elem, nextSibling, parent));
      }
    });
    svgCanvas$4.setEmptySelectedElements();
    if (!batchCmd.isEmpty()) {
      svgCanvas$4.addCommandToHistory(batchCmd);
    }
    svgCanvas$4.call("changed", selectedCopy);
    svgCanvas$4.clearSelection();
  };
  var copySelectedElements = () => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    const data = JSON.stringify(selectedElements.map((x2) => svgCanvas$4.getJsonFromSvgElements(x2)));
    sessionStorage.setItem(svgCanvas$4.getClipboardID(), data);
    svgCanvas$4.flashStorage();
    const canvMenu = document.getElementById("se-cmenu_canvas");
    canvMenu.setAttribute("enablemenuitems", "#paste,#paste_in_place");
  };
  var groupSelectedElements = (type, urlArg) => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    if (!type) {
      type = "g";
    }
    let cmdStr = "";
    let url;
    switch (type) {
      case "a": {
        cmdStr = "Make hyperlink";
        url = urlArg || "";
        break;
      }
      default: {
        type = "g";
        cmdStr = "Group Elements";
        break;
      }
    }
    const batchCmd = new BatchCommand$1(cmdStr);
    const g2 = svgCanvas$4.addSVGElementsFromJson({
      element: type,
      attr: {
        id: svgCanvas$4.getNextId()
      }
    });
    if (type === "a") {
      setHref(g2, url);
    }
    batchCmd.addSubCommand(new InsertElementCommand$1(g2));
    let i2 = selectedElements.length;
    while (i2--) {
      let elem = selectedElements[i2];
      if (!elem) {
        continue;
      }
      if (elem.parentNode.tagName === "a" && elem.parentNode.childNodes.length === 1) {
        elem = elem.parentNode;
      }
      const oldNextSibling = elem.nextSibling;
      const oldParent = elem.parentNode;
      g2.append(elem);
      batchCmd.addSubCommand(new MoveElementCommand2(elem, oldNextSibling, oldParent));
    }
    if (!batchCmd.isEmpty()) {
      svgCanvas$4.addCommandToHistory(batchCmd);
    }
    svgCanvas$4.selectOnly([g2], true);
  };
  var pushGroupProperty = (g2, undoable) => {
    const children = g2.childNodes;
    const len = children.length;
    const xform = g2.getAttribute("transform");
    const glist = getTransformList(g2);
    const m2 = transformListToTransform(glist).matrix;
    const batchCmd = new BatchCommand$1("Push group properties");
    const gangle = getRotationAngle(g2);
    const gattrs = {
      filter: g2.getAttribute("filter"),
      opacity: g2.getAttribute("opacity")
    };
    let gfilter;
    let gblur;
    let changes;
    const drawing = svgCanvas$4.getDrawing();
    for (let i2 = 0; i2 < len; i2++) {
      const elem = children[i2];
      if (elem.nodeType !== 1) {
        continue;
      }
      if (gattrs.opacity !== null && gattrs.opacity !== 1) {
        const newOpac = Math.round((elem.getAttribute("opacity") || 1) * gattrs.opacity * 100) / 100;
        svgCanvas$4.changeSelectedAttribute("opacity", newOpac, [elem]);
      }
      if (gattrs.filter) {
        let cblur = svgCanvas$4.getBlur(elem);
        const origCblur = cblur;
        if (!gblur) {
          gblur = svgCanvas$4.getBlur(g2);
        }
        if (cblur) {
          cblur = Number(gblur) + Number(cblur);
        } else if (cblur === 0) {
          cblur = gblur;
        }
        if (!origCblur) {
          if (!gfilter) {
            gfilter = getRefElem(gattrs.filter);
          } else {
            gfilter = drawing.copyElem(gfilter);
            findDefs().append(gfilter);
            const blurElem2 = getFeGaussianBlur(gfilter);
            const suffix = blurElem2?.tagName === "feGaussianBlur" ? "blur" : "filter";
            gfilter.id = elem.id + "_" + suffix;
            svgCanvas$4.changeSelectedAttribute("filter", "url(#" + gfilter.id + ")", [elem]);
          }
        } else {
          gfilter = getRefElem(elem.getAttribute("filter"));
        }
        const blurElem = getFeGaussianBlur(gfilter);
        if (cblur) {
          svgCanvas$4.changeSelectedAttribute("stdDeviation", cblur, [blurElem]);
          svgCanvas$4.setBlurOffsets(gfilter, cblur);
        }
      }
      let chtlist = getTransformList(elem);
      if (elem.tagName.includes("Gradient")) {
        chtlist = null;
      }
      if (!chtlist) {
        continue;
      }
      if (elem.tagName === "defs") {
        continue;
      }
      if (glist.numberOfItems) {
        if (gangle && glist.numberOfItems === 1) {
          const rgm = glist.getItem(0).matrix;
          let rcm = svgCanvas$4.getSvgRoot().createSVGMatrix();
          const cangle = getRotationAngle(elem);
          if (cangle) {
            rcm = chtlist.getItem(0).matrix;
          }
          const cbox = getBBox(elem);
          const ceqm = transformListToTransform(chtlist).matrix;
          const coldc = transformPoint(cbox.x + cbox.width / 2, cbox.y + cbox.height / 2, ceqm);
          const sangle = gangle + cangle;
          const r2 = svgCanvas$4.getSvgRoot().createSVGTransform();
          r2.setRotate(sangle, coldc.x, coldc.y);
          const trm = matrixMultiply(rgm, rcm, r2.matrix.inverse());
          if (cangle) {
            chtlist.removeItem(0);
          }
          if (sangle) {
            if (chtlist.numberOfItems) {
              chtlist.insertItemBefore(r2, 0);
            } else {
              chtlist.appendItem(r2);
            }
          }
          if (trm.e || trm.f) {
            const tr = svgCanvas$4.getSvgRoot().createSVGTransform();
            tr.setTranslate(trm.e, trm.f);
            if (chtlist.numberOfItems) {
              chtlist.insertItemBefore(tr, 0);
            } else {
              chtlist.appendItem(tr);
            }
          }
        } else {
          const oldxform = elem.getAttribute("transform");
          changes = {};
          changes.transform = oldxform || "";
          const newxform = svgCanvas$4.getSvgRoot().createSVGTransform();
          const chm = transformListToTransform(chtlist).matrix;
          const chmInv = chm.inverse();
          const gm = matrixMultiply(chmInv, m2, chm);
          newxform.setMatrix(gm);
          chtlist.appendItem(newxform);
        }
        const cmd = recalculateDimensions(elem);
        if (cmd) {
          batchCmd.addSubCommand(cmd);
        }
      }
    }
    if (xform) {
      changes = {};
      changes.transform = xform;
      g2.setAttribute("transform", "");
      g2.removeAttribute("transform");
      batchCmd.addSubCommand(new ChangeElementCommand$1(g2, changes));
    }
    if (undoable && !batchCmd.isEmpty()) {
      return batchCmd;
    }
    return void 0;
  };
  var convertToGroup = (elem) => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    if (!elem) {
      elem = selectedElements[0];
    }
    const $elem = elem;
    const batchCmd = new BatchCommand$1();
    let ts;
    const dataStorage2 = svgCanvas$4.getDataStorage();
    if (dataStorage2.has($elem, "gsvg")) {
      const svg2 = elem.firstChild;
      const pt2 = {
        x: Number(svg2.getAttribute("x")),
        y: Number(svg2.getAttribute("y"))
      };
      const firstChild = elem.firstChild.firstChild;
      if (firstChild) {
        firstChild.outerHTML = firstChild.innerHTML;
      }
      dataStorage2.remove(elem, "gsvg");
      const tlist = getTransformList(elem);
      const xform = svgCanvas$4.getSvgRoot().createSVGTransform();
      xform.setTranslate(pt2.x, pt2.y);
      tlist.appendItem(xform);
      recalculateDimensions(elem);
      svgCanvas$4.call("selected", [elem]);
    } else if (dataStorage2.has($elem, "symbol")) {
      elem = dataStorage2.get($elem, "symbol");
      ts = $elem.getAttribute("transform") || "";
      const pos = {
        x: Number($elem.getAttribute("x")),
        y: Number($elem.getAttribute("y"))
      };
      const vb = elem.getAttribute("viewBox");
      if (vb) {
        const nums = vb.split(/[ ,]+/);
        pos.x -= Number(nums[0]);
        pos.y -= Number(nums[1]);
      }
      ts += " translate(" + (pos.x || 0) + "," + (pos.y || 0) + ")";
      const prev = $elem.previousElementSibling;
      batchCmd.addSubCommand(new RemoveElementCommand$1($elem, $elem.nextElementSibling, $elem.parentNode));
      $elem.remove();
      const svgContent = svgCanvas$4.getSvgContent();
      const hasMore = svgContent.querySelectorAll("use").length;
      const g2 = svgCanvas$4.getDOMDocument().createElementNS(NS.SVG, "g");
      const childs = elem.childNodes;
      let i2;
      for (i2 = 0; i2 < childs.length; i2++) {
        g2.append(childs[i2].cloneNode(true));
      }
      if (isGecko()) {
        const svgElement = findDefs();
        const gradients = svgElement.querySelectorAll("linearGradient,radialGradient,pattern");
        for (let i3 = 0, im = gradients.length; im > i3; i3++) {
          g2.appendChild(gradients[i3].cloneNode(true));
        }
      }
      if (ts) {
        g2.setAttribute("transform", ts);
      }
      const parent = elem.parentNode;
      svgCanvas$4.uniquifyElems(g2);
      if (isGecko()) {
        const svgElement = findDefs();
        const elements2 = g2.querySelectorAll("linearGradient,radialGradient,pattern");
        for (let i3 = 0, im = elements2.length; im > i3; i3++) {
          svgElement.appendChild(elements2[i3]);
        }
      }
      g2.id = svgCanvas$4.getNextId();
      prev.after(g2);
      if (parent) {
        if (!hasMore) {
          const {
            nextSibling
          } = elem;
          elem.remove();
          batchCmd.addSubCommand(new RemoveElementCommand$1(elem, nextSibling, parent));
        }
        batchCmd.addSubCommand(new InsertElementCommand$1(g2));
      }
      svgCanvas$4.setUseData(g2);
      if (isGecko()) {
        svgCanvas$4.convertGradients(findDefs());
      } else {
        svgCanvas$4.convertGradients(g2);
      }
      walkTreePost(g2, (n2) => {
        try {
          recalculateDimensions(n2);
        } catch (e2) {
          console.error(e2);
        }
      });
      const visElems2 = g2.querySelectorAll(svgCanvas$4.getVisElems());
      Array.prototype.forEach.call(visElems2, (el) => {
        if (!el.id) {
          el.id = svgCanvas$4.getNextId();
        }
      });
      svgCanvas$4.selectOnly([g2]);
      const cm = pushGroupProperty(g2, true);
      if (cm) {
        batchCmd.addSubCommand(cm);
      }
      svgCanvas$4.addCommandToHistory(batchCmd);
    } else {
      console.warn("Unexpected element to ungroup:", elem);
    }
  };
  var ungroupSelectedElement = () => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    const dataStorage2 = svgCanvas$4.getDataStorage();
    let g2 = selectedElements[0];
    if (!g2) {
      return;
    }
    if (dataStorage2.has(g2, "gsvg") || dataStorage2.has(g2, "symbol")) {
      convertToGroup(g2);
      return;
    }
    if (g2.tagName === "use") {
      const symbol = getElement(getHref(g2).substr(1));
      dataStorage2.put(g2, "symbol", symbol);
      dataStorage2.put(g2, "ref", symbol);
      convertToGroup(g2);
      return;
    }
    const parentsA = getParents(g2.parentNode, "a");
    if (parentsA?.length) {
      g2 = parentsA[0];
    }
    if (g2.tagName === "g" || g2.tagName === "a") {
      const batchCmd = new BatchCommand$1("Ungroup Elements");
      const cmd = pushGroupProperty(g2, true);
      if (cmd) {
        batchCmd.addSubCommand(cmd);
      }
      const parent = g2.parentNode;
      const anchor = g2.nextSibling;
      const children = new Array(g2.childNodes.length);
      let i2 = 0;
      while (g2.firstChild) {
        const elem = g2.firstChild;
        const oldNextSibling = elem.nextSibling;
        const oldParent = elem.parentNode;
        if (elem.tagName === "title") {
          const {
            nextSibling
          } = elem;
          batchCmd.addSubCommand(new RemoveElementCommand$1(elem, nextSibling, oldParent));
          elem.remove();
          continue;
        }
        children[i2++] = parent.insertBefore(elem, anchor);
        batchCmd.addSubCommand(new MoveElementCommand2(elem, oldNextSibling, oldParent));
      }
      svgCanvas$4.clearSelection();
      const gNextSibling = g2.nextSibling;
      g2.remove();
      batchCmd.addSubCommand(new RemoveElementCommand$1(g2, gNextSibling, parent));
      if (!batchCmd.isEmpty()) {
        svgCanvas$4.addCommandToHistory(batchCmd);
      }
      svgCanvas$4.addToSelection(children);
    }
  };
  var updateCanvas = (w2, h2) => {
    svgCanvas$4.getSvgRoot().setAttribute("width", w2);
    svgCanvas$4.getSvgRoot().setAttribute("height", h2);
    const zoom = svgCanvas$4.getZoom();
    const bg = document.getElementById("canvasBackground");
    const oldX = Number(svgCanvas$4.getSvgContent().getAttribute("x"));
    const oldY = Number(svgCanvas$4.getSvgContent().getAttribute("y"));
    const x2 = (w2 - svgCanvas$4.contentW * zoom) / 2;
    const y2 = (h2 - svgCanvas$4.contentH * zoom) / 2;
    assignAttributes(svgCanvas$4.getSvgContent(), {
      width: svgCanvas$4.contentW * zoom,
      height: svgCanvas$4.contentH * zoom,
      x: x2,
      y: y2,
      viewBox: "0 0 " + svgCanvas$4.contentW + " " + svgCanvas$4.contentH
    });
    assignAttributes(bg, {
      width: svgCanvas$4.getSvgContent().getAttribute("width"),
      height: svgCanvas$4.getSvgContent().getAttribute("height"),
      x: x2,
      y: y2
    });
    const bgImg = getElement("background_image");
    if (bgImg) {
      assignAttributes(bgImg, {
        width: "100%",
        height: "100%"
      });
    }
    svgCanvas$4.selectorManager.selectorParentGroup.setAttribute("transform", "translate(" + x2 + "," + y2 + ")");
    svgCanvas$4.runExtensions(
      "canvasUpdated",
      /**
       * @type {module:svgcanvas.SvgCanvas#event:ext_canvasUpdated}
       */
      {
        new_x: x2,
        new_y: y2,
        old_x: oldX,
        old_y: oldY,
        d_x: x2 - oldX,
        d_y: y2 - oldY
      }
    );
    return {
      x: x2,
      y: y2,
      old_x: oldX,
      old_y: oldY,
      d_x: x2 - oldX,
      d_y: y2 - oldY
    };
  };
  var cycleElement = (next) => {
    const selectedElements = svgCanvas$4.getSelectedElements();
    const currentGroup = svgCanvas$4.getCurrentGroup();
    let num;
    const curElem = selectedElements[0];
    let elem = false;
    const allElems = getVisibleElements(currentGroup || svgCanvas$4.getCurrentDrawing().getCurrentLayer());
    if (!allElems.length) {
      return;
    }
    if (!curElem) {
      num = next ? allElems.length - 1 : 0;
      elem = allElems[num];
    } else {
      let i2 = allElems.length;
      while (i2--) {
        if (allElems[i2] === curElem) {
          num = next ? i2 - 1 : i2 + 1;
          if (num >= allElems.length) {
            num = 0;
          } else if (num < 0) {
            num = allElems.length - 1;
          }
          elem = allElems[num];
          break;
        }
      }
    }
    svgCanvas$4.selectOnly([elem], true);
    svgCanvas$4.call("selected", selectedElements);
  };
  var svgCanvas$3 = null;
  var init$3 = (canvas) => {
    svgCanvas$3 = canvas;
  };
  var setBlurNoUndo = function(val) {
    const selectedElements = svgCanvas$3.getSelectedElements();
    if (!svgCanvas$3.getFilter()) {
      svgCanvas$3.setBlur(val);
      return;
    }
    if (val === 0) {
      svgCanvas$3.changeSelectedAttributeNoUndo("filter", "");
      svgCanvas$3.setFilterHidden(true);
    } else {
      const elem = selectedElements[0];
      if (svgCanvas$3.getFilterHidden()) {
        svgCanvas$3.changeSelectedAttributeNoUndo("filter", "url(#" + elem.id + "_blur)");
      }
      const filter = svgCanvas$3.getFilter();
      svgCanvas$3.changeSelectedAttributeNoUndo("stdDeviation", val, [filter.firstChild]);
      svgCanvas$3.setBlurOffsets(filter, val);
    }
  };
  function finishChange() {
    const bCmd = svgCanvas$3.undoMgr.finishUndoableChange();
    svgCanvas$3.getCurCommand().addSubCommand(bCmd);
    svgCanvas$3.addCommandToHistory(svgCanvas$3.getCurCommand());
    svgCanvas$3.setCurCommand(null);
    svgCanvas$3.setFilter(null);
  }
  var setBlurOffsets = function(filterElem, stdDev) {
    if (stdDev > 3) {
      svgCanvas$3.assignAttributes(filterElem, {
        x: "-50%",
        y: "-50%",
        width: "200%",
        height: "200%"
      }, 100);
    } else {
      filterElem.removeAttribute("x");
      filterElem.removeAttribute("y");
      filterElem.removeAttribute("width");
      filterElem.removeAttribute("height");
    }
  };
  var setBlur = function(val, complete) {
    const {
      InsertElementCommand: InsertElementCommand3,
      ChangeElementCommand: ChangeElementCommand3,
      BatchCommand: BatchCommand3
    } = svgCanvas$3.history;
    const selectedElements = svgCanvas$3.getSelectedElements();
    if (svgCanvas$3.getCurCommand()) {
      finishChange();
      return;
    }
    const elem = selectedElements[0];
    const elemId = elem.id;
    svgCanvas$3.setFilter(svgCanvas$3.getElement(elemId + "_blur"));
    val -= 0;
    const batchCmd = new BatchCommand3();
    if (svgCanvas$3.getFilter()) {
      if (val === 0) {
        svgCanvas$3.setFilter(null);
      }
    } else {
      const newblur = svgCanvas$3.addSVGElementsFromJson({
        element: "feGaussianBlur",
        attr: {
          in: "SourceGraphic",
          stdDeviation: val
        }
      });
      svgCanvas$3.setFilter(svgCanvas$3.addSVGElementsFromJson({
        element: "filter",
        attr: {
          id: elemId + "_blur"
        }
      }));
      svgCanvas$3.getFilter().append(newblur);
      svgCanvas$3.findDefs().append(svgCanvas$3.getFilter());
      batchCmd.addSubCommand(new InsertElementCommand3(svgCanvas$3.getFilter()));
    }
    const changes = {
      filter: elem.getAttribute("filter")
    };
    if (val === 0) {
      elem.removeAttribute("filter");
      batchCmd.addSubCommand(new ChangeElementCommand3(elem, changes));
      return;
    }
    svgCanvas$3.changeSelectedAttribute("filter", "url(#" + elemId + "_blur)");
    batchCmd.addSubCommand(new ChangeElementCommand3(elem, changes));
    svgCanvas$3.setBlurOffsets(svgCanvas$3.getFilter(), val);
    const filter = svgCanvas$3.getFilter();
    svgCanvas$3.setCurCommand(batchCmd);
    svgCanvas$3.undoMgr.beginUndoableChange("stdDeviation", [filter ? filter.firstChild : null]);
    if (complete) {
      svgCanvas$3.setBlurNoUndo(val);
      finishChange();
    }
  };
  var REVERSE_NS = getReverseNS();
  var svgGenericWhiteList = ["class", "id", "display", "transform", "style"];
  var svgWhiteList_ = {
    // SVG Elements
    a: ["clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "href", "mask", "opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage", "xlink:href", "xlink:title"],
    circle: ["clip-path", "clip-rule", "cx", "cy", "enable-background", "fill", "fill-opacity", "fill-rule", "filter", "mask", "opacity", "r", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage"],
    clipPath: ["clipPathUnits"],
    defs: [],
    desc: [],
    ellipse: ["clip-path", "clip-rule", "cx", "cy", "fill", "fill-opacity", "fill-rule", "filter", "mask", "opacity", "requiredFeatures", "rx", "ry", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage"],
    feBlend: ["in", "in2"],
    feColorMatrix: ["in", "type", "value", "result", "values"],
    feComposite: ["in", "operator", "result", "in2"],
    feFlood: ["flood-color", "in", "result", "flood-opacity"],
    feGaussianBlur: ["color-interpolation-filters", "in", "requiredFeatures", "stdDeviation", "result"],
    feMerge: [],
    feMergeNode: ["in"],
    feMorphology: ["in", "operator", "radius"],
    feOffset: ["dx", "in", "dy", "result"],
    filter: ["color-interpolation-filters", "filterRes", "filterUnits", "height", "href", "primitiveUnits", "requiredFeatures", "width", "x", "xlink:href", "y"],
    foreignObject: ["font-size", "height", "opacity", "requiredFeatures", "width", "x", "y"],
    g: ["clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "mask", "opacity", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage", "font-family", "font-size", "font-style", "font-weight", "text-anchor"],
    image: ["clip-path", "clip-rule", "filter", "height", "mask", "opacity", "requiredFeatures", "systemLanguage", "width", "x", "href", "xlink:href", "xlink:title", "y"],
    line: ["clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage", "x1", "x2", "y1", "y2"],
    linearGradient: ["gradientTransform", "gradientUnits", "requiredFeatures", "spreadMethod", "systemLanguage", "x1", "x2", "href", "xlink:href", "y1", "y2"],
    marker: ["markerHeight", "markerUnits", "markerWidth", "orient", "preserveAspectRatio", "refX", "refY", "se_type", "systemLanguage", "viewBox"],
    mask: ["height", "maskContentUnits", "maskUnits", "width", "x", "y"],
    metadata: [],
    path: ["clip-path", "clip-rule", "d", "enable-background", "fill", "fill-opacity", "fill-rule", "filter", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage"],
    pattern: ["height", "patternContentUnits", "patternTransform", "patternUnits", "requiredFeatures", "systemLanguage", "viewBox", "width", "x", "href", "xlink:href", "y"],
    polygon: ["clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "points", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage", "sides", "shape", "edge", "point", "starRadiusMultiplier", "r", "radialshift", "r2", "orient", "cx", "cy"],
    polyline: ["clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "points", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage", "se:connector"],
    radialGradient: ["cx", "cy", "fx", "fy", "gradientTransform", "gradientUnits", "r", "requiredFeatures", "spreadMethod", "systemLanguage", "href", "xlink:href"],
    rect: ["clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "height", "mask", "opacity", "requiredFeatures", "rx", "ry", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage", "width", "x", "y"],
    stop: ["offset", "requiredFeatures", "stop-opacity", "systemLanguage", "stop-color", "gradientUnits", "gradientTransform"],
    style: ["type"],
    svg: ["clip-path", "clip-rule", "enable-background", "filter", "height", "mask", "preserveAspectRatio", "requiredFeatures", "systemLanguage", "version", "viewBox", "width", "x", "xmlns", "xmlns:se", "xmlns:xlink", "xmlns:oi", "oi:animations", "y", "stroke-linejoin", "fill-rule", "aria-label", "stroke-width", "fill-rule", "xml:space"],
    switch: ["requiredFeatures", "systemLanguage"],
    symbol: ["fill", "fill-opacity", "fill-rule", "filter", "font-family", "font-size", "font-style", "font-weight", "opacity", "overflow", "preserveAspectRatio", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage", "viewBox", "width", "height"],
    text: ["clip-path", "clip-rule", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "font-family", "font-size", "font-style", "font-weight", "mask", "opacity", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage", "text-anchor", "letter-spacing", "word-spacing", "text-decoration", "textLength", "lengthAdjust", "x", "xml:space", "y"],
    textPath: ["dominant-baseline", "href", "method", "requiredFeatures", "spacing", "startOffset", "systemLanguage", "xlink:href"],
    title: [],
    tspan: ["clip-path", "clip-rule", "dx", "dy", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "font-family", "font-size", "font-style", "font-weight", "mask", "opacity", "requiredFeatures", "rotate", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "systemLanguage", "text-anchor", "textLength", "x", "xml:space", "y"],
    use: ["clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "height", "href", "mask", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "width", "x", "xlink:href", "y", "overflow"],
    // Filter Primitives
    feComponentTransfer: ["in", "result"],
    feFuncR: ["type", "tableValues", "slope", "intercept", "amplitude", "exponent", "offset"],
    feFuncG: ["type", "tableValues", "slope", "intercept", "amplitude", "exponent", "offset"],
    feFuncB: ["type", "tableValues", "slope", "intercept", "amplitude", "exponent", "offset"],
    feFuncA: ["type", "tableValues", "slope", "intercept", "amplitude", "exponent", "offset"],
    feConvolveMatrix: ["in", "order", "kernelMatrix", "divisor", "bias", "targetX", "targetY", "edgeMode", "kernelUnitLength", "preserveAlpha"],
    feDiffuseLighting: ["in", "surfaceScale", "diffuseConstant", "kernelUnitLength", "lighting-color"],
    feSpecularLighting: ["in", "surfaceScale", "specularConstant", "specularExponent", "kernelUnitLength", "lighting-color"],
    feDisplacementMap: ["in", "in2", "scale", "xChannelSelector", "yChannelSelector"],
    feTurbulence: ["baseFrequency", "numOctaves", "result", "seed", "stitchTiles", "type"],
    feTile: ["in"],
    // MathML Elements
    annotation: ["encoding"],
    "annotation-xml": ["encoding"],
    maction: ["actiontype", "other", "selection"],
    math: ["xmlns"],
    menclose: ["notation"],
    merror: [],
    mfrac: ["linethickness"],
    mi: ["mathvariant"],
    mmultiscripts: [],
    mn: [],
    mo: ["fence", "lspace", "maxsize", "minsize", "rspace", "stretchy"],
    mover: [],
    mpadded: ["lspace", "width", "height", "depth", "voffset"],
    mphantom: [],
    mprescripts: [],
    mroot: [],
    mrow: ["href", "xlink:href", "xlink:type", "xmlns:xlink"],
    mspace: ["depth", "height", "width"],
    msqrt: [],
    mstyle: ["displaystyle", "mathbackground", "mathcolor", "mathvariant", "scriptlevel"],
    msub: [],
    msubsup: [],
    msup: [],
    mtable: ["align", "columnalign", "columnlines", "columnspacing", "displaystyle", "equalcolumns", "equalrows", "frame", "rowalign", "rowlines", "rowspacing", "width"],
    mtd: ["columnalign", "columnspan", "rowalign", "rowspan"],
    mtext: [],
    mtr: ["columnalign", "rowalign"],
    munder: [],
    munderover: [],
    none: [],
    semantics: [],
    // HTML Elements for use in a foreignObject
    div: [],
    p: [],
    li: [],
    pre: [],
    ol: [],
    ul: [],
    span: [],
    hr: [],
    br: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: []
  };
  Object.keys(svgWhiteList_).forEach((element) => {
    svgWhiteList_[element] = [...svgWhiteList_[element], ...svgGenericWhiteList];
  });
  var svgWhiteListNS_ = {};
  Object.entries(svgWhiteList_).forEach(([elt, atts]) => {
    const attNS = {};
    Object.entries(atts).forEach(([_i, att]) => {
      if (att.includes(":")) {
        const v2 = att.split(":");
        attNS[v2[1]] = NS[v2[0].toUpperCase()];
      } else {
        attNS[att] = att === "xmlns" ? NS.XMLNS : null;
      }
    });
    svgWhiteListNS_[elt] = attNS;
  });
  var sanitizeSvg = (node2) => {
    if (node2.nodeType === 3) {
      node2.nodeValue = node2.nodeValue.trim();
      if (!node2.nodeValue.length) {
        node2.remove();
      }
    }
    if (node2.nodeType !== 1) {
      return;
    }
    const doc = node2.ownerDocument;
    const parent = node2.parentNode;
    if (!doc || !parent) {
      return;
    }
    const allowedAttrs = svgWhiteList_[node2.nodeName];
    const allowedAttrsNS = svgWhiteListNS_[node2.nodeName];
    if (typeof allowedAttrs !== "undefined") {
      const seAttrs = [];
      let i2 = node2.attributes.length;
      while (i2--) {
        const attr = node2.attributes.item(i2);
        const attrName = attr.nodeName;
        const attrLocalName = attr.localName;
        const attrNsURI = attr.namespaceURI;
        if (attrNsURI !== allowedAttrsNS[attrLocalName] && attrNsURI !== NS.XMLNS && !(attrNsURI === NS.XMLNS && REVERSE_NS[attr.value])) {
          const isHrefAttribute = attrLocalName === "href" && allowedAttrs.includes("href");
          if (!isHrefAttribute) {
            if (attrName.startsWith("se:") || attrName.startsWith("oi:") || attrName.startsWith("data-")) {
              const seAttrNS = attrName.startsWith("se:") ? NS.SE : attrName.startsWith("oi:") ? NS.OI : null;
              seAttrs.push([attrName, attr.value, seAttrNS]);
            } else {
              console.warn(`sanitizeSvg: attribute ${attrName} in element ${node2.nodeName} not in whitelist is removed: ${node2.outerHTML}`);
              node2.removeAttributeNS(attrNsURI, attrLocalName);
            }
          }
        }
        if (attrName === "style") {
          const props = attr.value.split(";");
          let p2 = props.length;
          while (p2--) {
            const [name, val] = props[p2].split(":");
            const styleAttrName = (name || "").trim();
            const styleAttrVal = (val || "").trim();
            if (allowedAttrs.includes(styleAttrName)) {
              node2.setAttribute(styleAttrName, styleAttrVal);
            }
          }
          node2.removeAttribute("style");
        }
      }
      Object.values(seAttrs).forEach(([att, val, ns]) => {
        node2.setAttributeNS(ns, att, val);
      });
      const href = getHref(node2);
      if (href && ["filter", "linearGradient", "pattern", "radialGradient", "textPath", "use"].includes(node2.nodeName) && href[0] !== "#") {
        setHref(node2, "");
        console.warn(`sanitizeSvg: attribute href in element ${node2.nodeName} pointing to a non-local reference (${href}) is removed: ${node2.outerHTML}`);
        node2.removeAttributeNS(NS.XLINK, "href");
        node2.removeAttribute("href");
      }
      if (node2.nodeName === "use" && !getHref(node2)) {
        console.warn(`sanitizeSvg: element ${node2.nodeName} without a xlink:href or href is removed: ${node2.outerHTML}`);
        node2.remove();
        return;
      }
      ["clip-path", "fill", "filter", "marker-end", "marker-mid", "marker-start", "mask", "stroke"].forEach((attr) => {
        let val = node2.getAttribute(attr);
        if (val) {
          val = getUrlFromAttr(val);
          if (val && val[0] !== "#") {
            node2.setAttribute(attr, "");
            console.warn(`sanitizeSvg: attribute ${attr} in element ${node2.nodeName} pointing to a non-local reference (${val}) is removed: ${node2.outerHTML}`);
            node2.removeAttribute(attr);
          }
        }
      });
      i2 = node2.childNodes.length;
      while (i2--) {
        sanitizeSvg(node2.childNodes.item(i2));
      }
    } else {
      console.warn(`sanitizeSvg: element ${node2.nodeName} not supported is removed: ${node2.outerHTML}`);
      const children = [];
      while (node2.hasChildNodes()) {
        children.push(parent.insertBefore(node2.firstChild, node2));
      }
      node2.remove();
      let i2 = children.length;
      while (i2--) {
        sanitizeSvg(children[i2]);
      }
    }
  };
  function _typeof$1(o2) {
    "@babel/helpers - typeof";
    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof$1(o2);
  }
  var u8 = Uint8Array;
  var u16 = Uint16Array;
  var i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b2 = new u16(31);
    for (var i2 = 0; i2 < 31; ++i2) {
      b2[i2] = start += 1 << eb[i2 - 1];
    }
    var r2 = new i32(b2[30]);
    for (var i2 = 1; i2 < 30; ++i2) {
      for (var j2 = b2[i2]; j2 < b2[i2 + 1]; ++j2) {
        r2[j2] = j2 - b2[i2] << 5 | i2;
      }
    }
    return {
      b: b2,
      r: r2
    };
  };
  var _a = freb(fleb, 2);
  var fl = _a.b;
  var revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0);
  var fd = _b.b;
  var revfd = _b.r;
  var rev = new u16(32768);
  for (i$2 = 0; i$2 < 32768; ++i$2) {
    x$2 = (i$2 & 43690) >> 1 | (i$2 & 21845) << 1;
    x$2 = (x$2 & 52428) >> 2 | (x$2 & 13107) << 2;
    x$2 = (x$2 & 61680) >> 4 | (x$2 & 3855) << 4;
    rev[i$2] = ((x$2 & 65280) >> 8 | (x$2 & 255) << 8) >> 1;
  }
  var x$2;
  var i$2;
  var hMap = function(cd, mb, r2) {
    var s2 = cd.length;
    var i2 = 0;
    var l2 = new u16(mb);
    for (; i2 < s2; ++i2) {
      if (cd[i2]) ++l2[cd[i2] - 1];
    }
    var le2 = new u16(mb);
    for (i2 = 1; i2 < mb; ++i2) {
      le2[i2] = le2[i2 - 1] + l2[i2 - 1] << 1;
    }
    var co;
    if (r2) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i2 = 0; i2 < s2; ++i2) {
        if (cd[i2]) {
          var sv = i2 << 4 | cd[i2];
          var r_1 = mb - cd[i2];
          var v2 = le2[cd[i2] - 1]++ << r_1;
          for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
            co[rev[v2] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s2);
      for (i2 = 0; i2 < s2; ++i2) {
        if (cd[i2]) {
          co[i2] = rev[le2[cd[i2] - 1]++] >> 15 - cd[i2];
        }
      }
    }
    return co;
  };
  var flt = new u8(288);
  for (i$2 = 0; i$2 < 144; ++i$2) flt[i$2] = 8;
  var i$2;
  for (i$2 = 144; i$2 < 256; ++i$2) flt[i$2] = 9;
  var i$2;
  for (i$2 = 256; i$2 < 280; ++i$2) flt[i$2] = 7;
  var i$2;
  for (i$2 = 280; i$2 < 288; ++i$2) flt[i$2] = 8;
  var i$2;
  var fdt = new u8(32);
  for (i$2 = 0; i$2 < 32; ++i$2) fdt[i$2] = 5;
  var i$2;
  var flm = /* @__PURE__ */ hMap(flt, 9, 0);
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a2) {
    var m2 = a2[0];
    for (var i2 = 1; i2 < a2.length; ++i2) {
      if (a2[i2] > m2) m2 = a2[i2];
    }
    return m2;
  };
  var bits = function(d2, p2, m2) {
    var o2 = p2 / 8 | 0;
    return (d2[o2] | d2[o2 + 1] << 8) >> (p2 & 7) & m2;
  };
  var bits16 = function(d2, p2) {
    var o2 = p2 / 8 | 0;
    return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >> (p2 & 7);
  };
  var shft = function(p2) {
    return (p2 + 7) / 8 | 0;
  };
  var slc = function(v2, s2, e2) {
    if (e2 == null || e2 > v2.length) e2 = v2.length;
    return new u8(v2.subarray(s2, e2));
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt2) {
    var e2 = new Error(msg || ec[ind]);
    e2.code = ind;
    if (Error.captureStackTrace) Error.captureStackTrace(e2, err);
    if (!nt2) throw e2;
    return e2;
  };
  var inflt = function(dat, st2, buf, dict) {
    var sl = dat.length, dl = 0;
    if (!sl || st2.f && !st2.l) return buf || new u8(0);
    var noBuf = !buf;
    var resize = noBuf || st2.i != 2;
    var noSt = st2.i;
    if (noBuf) buf = new u8(sl * 3);
    var cbuf = function(l3) {
      var bl = buf.length;
      if (l3 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l3));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t3 = s2 + l2;
          if (t3 > sl) {
            if (noSt) err(0);
            break;
          }
          if (resize) cbuf(bt2 + l2);
          buf.set(dat.subarray(s2, t3), bt2);
          st2.b = bt2 += l2, st2.p = pos = t3 * 8, st2.f = final;
          continue;
        } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i2 = 0; i2 < hcLen; ++i2) {
            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i2 = 0; i2 < tl; ) {
            var r2 = clm[bits(dat, pos, clbmsk)];
            pos += r2 & 15;
            var s2 = r2 >> 4;
            if (s2 < 16) {
              ldt[i2++] = s2;
            } else {
              var c2 = 0, n2 = 0;
              if (s2 == 16) n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i2 - 1];
              else if (s2 == 17) n2 = 3 + bits(dat, pos, 7), pos += 3;
              else if (s2 == 18) n2 = 11 + bits(dat, pos, 127), pos += 7;
              while (n2--) ldt[i2++] = c2;
            }
          }
          var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
          lbt = max(lt2);
          dbt = max(dt2);
          lm = hMap(lt2, lbt, 1);
          dm = hMap(dt2, dbt, 1);
        } else err(1);
        if (pos > tbts) {
          if (noSt) err(0);
          break;
        }
      }
      if (resize) cbuf(bt2 + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c2 = lm[bits16(dat, pos) & lms], sym = c2 >> 4;
        pos += c2 & 15;
        if (pos > tbts) {
          if (noSt) err(0);
          break;
        }
        if (!c2) err(2);
        if (sym < 256) buf[bt2++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i2 = sym - 257, b2 = fleb[i2];
            add = bits(dat, pos, (1 << b2) - 1) + fl[i2];
            pos += b2;
          }
          var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
          if (!d2) err(3);
          pos += d2 & 15;
          var dt2 = fd[dsym];
          if (dsym > 3) {
            var b2 = fdeb[dsym];
            dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
          }
          if (pos > tbts) {
            if (noSt) err(0);
            break;
          }
          if (resize) cbuf(bt2 + 131072);
          var end = bt2 + add;
          if (bt2 < dt2) {
            var shift = dl - dt2, dend = Math.min(dt2, end);
            if (shift + bt2 < 0) err(3);
            for (; bt2 < dend; ++bt2) buf[bt2] = dict[shift + bt2];
          }
          for (; bt2 < end; ++bt2) buf[bt2] = buf[bt2 - dt2];
        }
      }
      st2.l = lm, st2.p = lpos, st2.b = bt2, st2.f = final;
      if (lm) final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
    } while (!final);
    return bt2 != buf.length && noBuf ? slc(buf, 0, bt2) : buf.subarray(0, bt2);
  };
  var wbits = function(d2, p2, v2) {
    v2 <<= p2 & 7;
    var o2 = p2 / 8 | 0;
    d2[o2] |= v2;
    d2[o2 + 1] |= v2 >> 8;
  };
  var wbits16 = function(d2, p2, v2) {
    v2 <<= p2 & 7;
    var o2 = p2 / 8 | 0;
    d2[o2] |= v2;
    d2[o2 + 1] |= v2 >> 8;
    d2[o2 + 2] |= v2 >> 16;
  };
  var hTree = function(d2, mb) {
    var t3 = [];
    for (var i2 = 0; i2 < d2.length; ++i2) {
      if (d2[i2]) t3.push({
        s: i2,
        f: d2[i2]
      });
    }
    var s2 = t3.length;
    var t22 = t3.slice();
    if (!s2) return {
      t: et$2,
      l: 0
    };
    if (s2 == 1) {
      var v2 = new u8(t3[0].s + 1);
      v2[t3[0].s] = 1;
      return {
        t: v2,
        l: 1
      };
    }
    t3.sort(function(a2, b2) {
      return a2.f - b2.f;
    });
    t3.push({
      s: -1,
      f: 25001
    });
    var l2 = t3[0], r2 = t3[1], i0 = 0, i1 = 1, i22 = 2;
    t3[0] = {
      s: -1,
      f: l2.f + r2.f,
      l: l2,
      r: r2
    };
    while (i1 != s2 - 1) {
      l2 = t3[t3[i0].f < t3[i22].f ? i0++ : i22++];
      r2 = t3[i0 != i1 && t3[i0].f < t3[i22].f ? i0++ : i22++];
      t3[i1++] = {
        s: -1,
        f: l2.f + r2.f,
        l: l2,
        r: r2
      };
    }
    var maxSym = t22[0].s;
    for (var i2 = 1; i2 < s2; ++i2) {
      if (t22[i2].s > maxSym) maxSym = t22[i2].s;
    }
    var tr = new u16(maxSym + 1);
    var mbt = ln(t3[i1 - 1], tr, 0);
    if (mbt > mb) {
      var i2 = 0, dt2 = 0;
      var lft = mbt - mb, cst = 1 << lft;
      t22.sort(function(a2, b2) {
        return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
      });
      for (; i2 < s2; ++i2) {
        var i2_1 = t22[i2].s;
        if (tr[i2_1] > mb) {
          dt2 += cst - (1 << mbt - tr[i2_1]);
          tr[i2_1] = mb;
        } else break;
      }
      dt2 >>= lft;
      while (dt2 > 0) {
        var i2_2 = t22[i2].s;
        if (tr[i2_2] < mb) dt2 -= 1 << mb - tr[i2_2]++ - 1;
        else ++i2;
      }
      for (; i2 >= 0 && dt2; --i2) {
        var i2_3 = t22[i2].s;
        if (tr[i2_3] == mb) {
          --tr[i2_3];
          ++dt2;
        }
      }
      mbt = mb;
    }
    return {
      t: new u8(tr),
      l: mbt
    };
  };
  var ln = function(n2, l2, d2) {
    return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
  };
  var lc = function(c2) {
    var s2 = c2.length;
    while (s2 && !c2[--s2]) ;
    var cl = new u16(++s2);
    var cli = 0, cln = c2[0], cls = 1;
    var w2 = function(v2) {
      cl[cli++] = v2;
    };
    for (var i2 = 1; i2 <= s2; ++i2) {
      if (c2[i2] == cln && i2 != s2) ++cls;
      else {
        if (!cln && cls > 2) {
          for (; cls > 138; cls -= 138) w2(32754);
          if (cls > 2) {
            w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
            cls = 0;
          }
        } else if (cls > 3) {
          w2(cln), --cls;
          for (; cls > 6; cls -= 6) w2(8304);
          if (cls > 2) w2(cls - 3 << 5 | 8208), cls = 0;
        }
        while (cls--) w2(cln);
        cls = 1;
        cln = c2[i2];
      }
    }
    return {
      c: cl.subarray(0, cli),
      n: s2
    };
  };
  var clen = function(cf, cl) {
    var l2 = 0;
    for (var i2 = 0; i2 < cl.length; ++i2) l2 += cf[i2] * cl[i2];
    return l2;
  };
  var wfblk = function(out, pos, dat) {
    var s2 = dat.length;
    var o2 = shft(pos + 2);
    out[o2] = s2 & 255;
    out[o2 + 1] = s2 >> 8;
    out[o2 + 2] = out[o2] ^ 255;
    out[o2 + 3] = out[o2 + 1] ^ 255;
    for (var i2 = 0; i2 < s2; ++i2) out[o2 + i2 + 4] = dat[i2];
    return (o2 + 4 + s2) * 8;
  };
  var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
    wbits(out, p2++, final);
    ++lf[256];
    var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
    var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
    var lcfreq = new u16(19);
    for (var i2 = 0; i2 < lclt.length; ++i2) ++lcfreq[lclt[i2] & 31];
    for (var i2 = 0; i2 < lcdt.length; ++i2) ++lcfreq[lcdt[i2] & 31];
    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
    var nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc) ;
    var flen = bl + 5 << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p2, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
    if (dtlen < ftlen) {
      lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
      var llm = hMap(lct, mlcb, 0);
      wbits(out, p2, nlc - 257);
      wbits(out, p2 + 5, ndc - 1);
      wbits(out, p2 + 10, nlcc - 4);
      p2 += 14;
      for (var i2 = 0; i2 < nlcc; ++i2) wbits(out, p2 + 3 * i2, lct[clim[i2]]);
      p2 += 3 * nlcc;
      var lcts = [lclt, lcdt];
      for (var it2 = 0; it2 < 2; ++it2) {
        var clct = lcts[it2];
        for (var i2 = 0; i2 < clct.length; ++i2) {
          var len = clct[i2] & 31;
          wbits(out, p2, llm[len]), p2 += lct[len];
          if (len > 15) wbits(out, p2, clct[i2] >> 5 & 127), p2 += clct[i2] >> 12;
        }
      }
    } else {
      lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (var i2 = 0; i2 < li; ++i2) {
      var sym = syms[i2];
      if (sym > 255) {
        var len = sym >> 18 & 31;
        wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
        if (len > 7) wbits(out, p2, sym >> 23 & 31), p2 += fleb[len];
        var dst = sym & 31;
        wbits16(out, p2, dm[dst]), p2 += dl[dst];
        if (dst > 3) wbits16(out, p2, sym >> 5 & 8191), p2 += fdeb[dst];
      } else {
        wbits16(out, p2, lm[sym]), p2 += ll[sym];
      }
    }
    wbits16(out, p2, lm[256]);
    return p2 + ll[256];
  };
  var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  var et$2 = /* @__PURE__ */ new u8(0);
  var dflt = function(dat, lvl, plvl, pre, post, st2) {
    var s2 = st2.z || dat.length;
    var o2 = new u8(pre + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + post);
    var w2 = o2.subarray(pre, o2.length - post);
    var lst = st2.l;
    var pos = (st2.r || 0) & 7;
    if (lvl) {
      if (pos) w2[0] = st2.r >> 3;
      var opt = deo[lvl - 1];
      var n2 = opt >> 13, c2 = opt & 8191;
      var msk_1 = (1 << plvl) - 1;
      var prev = st2.p || new u16(32768), head = st2.h || new u16(msk_1 + 1);
      var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
      var hsh = function(i3) {
        return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
      };
      var syms = new i32(25e3);
      var lf = new u16(288), df = new u16(32);
      var lc_1 = 0, eb = 0, i2 = st2.i || 0, li = 0, wi = st2.w || 0, bs = 0;
      for (; i2 + 2 < s2; ++i2) {
        var hv = hsh(i2);
        var imod = i2 & 32767, pimod = head[hv];
        prev[imod] = pimod;
        head[hv] = imod;
        if (wi <= i2) {
          var rem = s2 - i2;
          if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
            pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
            li = lc_1 = eb = 0, bs = i2;
            for (var j2 = 0; j2 < 286; ++j2) lf[j2] = 0;
            for (var j2 = 0; j2 < 30; ++j2) df[j2] = 0;
          }
          var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
          if (rem > 2 && hv == hsh(i2 - dif)) {
            var maxn = Math.min(n2, rem) - 1;
            var maxd = Math.min(32767, i2);
            var ml = Math.min(258, rem);
            while (dif <= maxd && --ch_1 && imod != pimod) {
              if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
                var nl = 0;
                for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl) ;
                if (nl > l2) {
                  l2 = nl, d2 = dif;
                  if (nl > maxn) break;
                  var mmd = Math.min(dif, nl - 2);
                  var md = 0;
                  for (var j2 = 0; j2 < mmd; ++j2) {
                    var ti = i2 - dif + j2 & 32767;
                    var pti = prev[ti];
                    var cd = ti - pti & 32767;
                    if (cd > md) md = cd, pimod = ti;
                  }
                }
              }
              imod = pimod, pimod = prev[imod];
              dif += imod - pimod & 32767;
            }
          }
          if (d2) {
            syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
            var lin = revfl[l2] & 31, din = revfd[d2] & 31;
            eb += fleb[lin] + fdeb[din];
            ++lf[257 + lin];
            ++df[din];
            wi = i2 + l2;
            ++lc_1;
          } else {
            syms[li++] = dat[i2];
            ++lf[dat[i2]];
          }
        }
      }
      for (i2 = Math.max(i2, wi); i2 < s2; ++i2) {
        syms[li++] = dat[i2];
        ++lf[dat[i2]];
      }
      pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
      if (!lst) {
        st2.r = pos & 7 | w2[pos / 8 | 0] << 3;
        pos -= 7;
        st2.h = head, st2.p = prev, st2.i = i2, st2.w = wi;
      }
    } else {
      for (var i2 = st2.w || 0; i2 < s2 + lst; i2 += 65535) {
        var e2 = i2 + 65535;
        if (e2 >= s2) {
          w2[pos / 8 | 0] = lst;
          e2 = s2;
        }
        pos = wfblk(w2, pos + 1, dat.subarray(i2, e2));
      }
      st2.i = s2;
    }
    return slc(o2, 0, pre + shft(pos) + post);
  };
  var adler = function() {
    var a2 = 1, b2 = 0;
    return {
      p: function(d2) {
        var n2 = a2, m2 = b2;
        var l2 = d2.length | 0;
        for (var i2 = 0; i2 != l2; ) {
          var e2 = Math.min(i2 + 2655, l2);
          for (; i2 < e2; ++i2) m2 += n2 += d2[i2];
          n2 = (n2 & 65535) + 15 * (n2 >> 16), m2 = (m2 & 65535) + 15 * (m2 >> 16);
        }
        a2 = n2, b2 = m2;
      },
      d: function() {
        a2 %= 65521, b2 %= 65521;
        return (a2 & 255) << 24 | (a2 & 65280) << 8 | (b2 & 255) << 8 | b2 >> 8;
      }
    };
  };
  var dopt = function(dat, opt, pre, post, st2) {
    if (!st2) {
      st2 = {
        l: 1
      };
      if (opt.dictionary) {
        var dict = opt.dictionary.subarray(-32768);
        var newDat = new u8(dict.length + dat.length);
        newDat.set(dict);
        newDat.set(dat, dict.length);
        dat = newDat;
        st2.w = dict.length;
      }
    }
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st2.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st2);
  };
  var wbytes = function(d2, b2, v2) {
    for (; v2; ++b2) d2[b2] = v2, v2 >>>= 8;
  };
  var zlh = function(c2, o2) {
    var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
    c2[0] = 120, c2[1] = fl2 << 6 | (o2.dictionary && 32);
    c2[1] |= 31 - (c2[0] << 8 | c2[1]) % 31;
    if (o2.dictionary) {
      var h2 = adler();
      h2.p(o2.dictionary);
      wbytes(c2, 2, h2.d());
    }
  };
  var zls = function(d2, dict) {
    if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31) err(6, "invalid zlib data");
    if ((d2[1] >> 5 & 1) == 1) err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
    return (d2[1] >> 3 & 4) + 2;
  };
  function zlibSync(data, opts) {
    if (!opts) opts = {};
    var a2 = adler();
    a2.p(data);
    var d2 = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
    return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
  }
  function unzlibSync(data, opts) {
    return inflt(data.subarray(zls(data), -4), {
      i: 2
    }, opts, opts);
  }
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et$2, {
      stream: true
    });
    tds = 1;
  } catch (e2) {
  }
  var n$1 = /* @__PURE__ */ (function() {
    return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
  })();
  function i$1() {
    n$1.console && "function" == typeof n$1.console.log && n$1.console.log.apply(n$1.console, arguments);
  }
  var a$1 = {
    log: i$1,
    warn: function(t3) {
      n$1.console && ("function" == typeof n$1.console.warn ? n$1.console.warn.apply(n$1.console, arguments) : i$1.call(null, arguments));
    },
    error: function(t3) {
      n$1.console && ("function" == typeof n$1.console.error ? n$1.console.error.apply(n$1.console, arguments) : i$1(t3));
    }
  };
  function o$1(t3, e2, r2) {
    var n2 = new XMLHttpRequest();
    n2.open("GET", t3), n2.responseType = "blob", n2.onload = function() {
      l$2(n2.response, e2, r2);
    }, n2.onerror = function() {
      a$1.error("could not download file");
    }, n2.send();
  }
  function s$2(t3) {
    var e2 = new XMLHttpRequest();
    e2.open("HEAD", t3, false);
    try {
      e2.send();
    } catch (t4) {
    }
    return e2.status >= 200 && e2.status <= 299;
  }
  function c$3(t3) {
    try {
      t3.dispatchEvent(new MouseEvent("click"));
    } catch (r2) {
      var e2 = document.createEvent("MouseEvents");
      e2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t3.dispatchEvent(e2);
    }
  }
  var u$2;
  var h$2;
  var l$2 = n$1.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof$1(window)) || window !== n$1 ? function() {
  } : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t3, e2, r2) {
    var i2 = n$1.URL || n$1.webkitURL, a2 = document.createElement("a");
    e2 = e2 || t3.name || "download", a2.download = e2, a2.rel = "noopener", "string" == typeof t3 ? (a2.href = t3, a2.origin !== location.origin ? s$2(a2.href) ? o$1(t3, e2, r2) : c$3(a2, a2.target = "_blank") : c$3(a2)) : (a2.href = i2.createObjectURL(t3), setTimeout(function() {
      i2.revokeObjectURL(a2.href);
    }, 4e4), setTimeout(function() {
      c$3(a2);
    }, 0));
  } : "msSaveOrOpenBlob" in navigator ? function(e2, r2, n2) {
    if (r2 = r2 || e2.name || "download", "string" == typeof e2) {
      if (s$2(e2)) o$1(e2, r2, n2);
      else {
        var i2 = document.createElement("a");
        i2.href = e2, i2.target = "_blank", setTimeout(function() {
          c$3(i2);
        });
      }
    } else navigator.msSaveOrOpenBlob((function(e3, r3) {
      return void 0 === r3 ? r3 = {
        autoBom: false
      } : "object" !== _typeof$1(r3) && (a$1.warn("Deprecated: Expected third argument to be a object"), r3 = {
        autoBom: !r3
      }), r3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], {
        type: e3.type
      }) : e3;
    })(e2, n2), r2);
  } : function(e2, r2, i2, a2) {
    if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), "string" == typeof e2) return o$1(e2, r2, i2);
    var s2 = "application/octet-stream" === e2.type, c2 = /constructor/i.test(n$1.HTMLElement) || n$1.safari, u2 = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((u2 || s2 && c2) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof$1(FileReader))) {
      var h2 = new FileReader();
      h2.onloadend = function() {
        var t3 = h2.result;
        t3 = u2 ? t3 : t3.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t3 : location = t3, a2 = null;
      }, h2.readAsDataURL(e2);
    } else {
      var l2 = n$1.URL || n$1.webkitURL, f2 = l2.createObjectURL(e2);
      a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
        l2.revokeObjectURL(f2);
      }, 4e4);
    }
  });
  function f$2(t3) {
    var e2;
    t3 = t3 || "", this.ok = false, "#" == t3.charAt(0) && (t3 = t3.substr(1, 6));
    t3 = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dodgerblue: "1e90ff",
      feldspar: "d19275",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgrey: "d3d3d3",
      lightgreen: "90ee90",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslateblue: "8470ff",
      lightslategray: "778899",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "00ff00",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "ff00ff",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370d8",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "d87093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      red: "ff0000",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      violetred: "d02090",
      wheat: "f5deb3",
      white: "ffffff",
      whitesmoke: "f5f5f5",
      yellow: "ffff00",
      yellowgreen: "9acd32"
    }[t3 = (t3 = t3.replace(/ /g, "")).toLowerCase()] || t3;
    for (var r2 = [{
      re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
      example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
      process: function(t4) {
        return [parseInt(t4[1]), parseInt(t4[2]), parseInt(t4[3])];
      }
    }, {
      re: /^(\w{2})(\w{2})(\w{2})$/,
      example: ["#00ff00", "336699"],
      process: function(t4) {
        return [parseInt(t4[1], 16), parseInt(t4[2], 16), parseInt(t4[3], 16)];
      }
    }, {
      re: /^(\w{1})(\w{1})(\w{1})$/,
      example: ["#fb0", "f0f"],
      process: function(t4) {
        return [parseInt(t4[1] + t4[1], 16), parseInt(t4[2] + t4[2], 16), parseInt(t4[3] + t4[3], 16)];
      }
    }], n2 = 0; n2 < r2.length; n2++) {
      var i2 = r2[n2].re, a2 = r2[n2].process, o2 = i2.exec(t3);
      o2 && (e2 = a2(o2), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
      return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    }, this.toHex = function() {
      var t4 = this.r.toString(16), e3 = this.g.toString(16), r3 = this.b.toString(16);
      return 1 == t4.length && (t4 = "0" + t4), 1 == e3.length && (e3 = "0" + e3), 1 == r3.length && (r3 = "0" + r3), "#" + t4 + e3 + r3;
    };
  }
  function d$1(t3, e2) {
    var r2 = t3[0], n2 = t3[1], i2 = t3[2], a2 = t3[3];
    r2 = g$1(r2, n2, i2, a2, e2[0], 7, -680876936), a2 = g$1(a2, r2, n2, i2, e2[1], 12, -389564586), i2 = g$1(i2, a2, r2, n2, e2[2], 17, 606105819), n2 = g$1(n2, i2, a2, r2, e2[3], 22, -1044525330), r2 = g$1(r2, n2, i2, a2, e2[4], 7, -176418897), a2 = g$1(a2, r2, n2, i2, e2[5], 12, 1200080426), i2 = g$1(i2, a2, r2, n2, e2[6], 17, -1473231341), n2 = g$1(n2, i2, a2, r2, e2[7], 22, -45705983), r2 = g$1(r2, n2, i2, a2, e2[8], 7, 1770035416), a2 = g$1(a2, r2, n2, i2, e2[9], 12, -1958414417), i2 = g$1(i2, a2, r2, n2, e2[10], 17, -42063), n2 = g$1(n2, i2, a2, r2, e2[11], 22, -1990404162), r2 = g$1(r2, n2, i2, a2, e2[12], 7, 1804603682), a2 = g$1(a2, r2, n2, i2, e2[13], 12, -40341101), i2 = g$1(i2, a2, r2, n2, e2[14], 17, -1502002290), r2 = m$3(r2, n2 = g$1(n2, i2, a2, r2, e2[15], 22, 1236535329), i2, a2, e2[1], 5, -165796510), a2 = m$3(a2, r2, n2, i2, e2[6], 9, -1069501632), i2 = m$3(i2, a2, r2, n2, e2[11], 14, 643717713), n2 = m$3(n2, i2, a2, r2, e2[0], 20, -373897302), r2 = m$3(r2, n2, i2, a2, e2[5], 5, -701558691), a2 = m$3(a2, r2, n2, i2, e2[10], 9, 38016083), i2 = m$3(i2, a2, r2, n2, e2[15], 14, -660478335), n2 = m$3(n2, i2, a2, r2, e2[4], 20, -405537848), r2 = m$3(r2, n2, i2, a2, e2[9], 5, 568446438), a2 = m$3(a2, r2, n2, i2, e2[14], 9, -1019803690), i2 = m$3(i2, a2, r2, n2, e2[3], 14, -187363961), n2 = m$3(n2, i2, a2, r2, e2[8], 20, 1163531501), r2 = m$3(r2, n2, i2, a2, e2[13], 5, -1444681467), a2 = m$3(a2, r2, n2, i2, e2[2], 9, -51403784), i2 = m$3(i2, a2, r2, n2, e2[7], 14, 1735328473), r2 = v$2(r2, n2 = m$3(n2, i2, a2, r2, e2[12], 20, -1926607734), i2, a2, e2[5], 4, -378558), a2 = v$2(a2, r2, n2, i2, e2[8], 11, -2022574463), i2 = v$2(i2, a2, r2, n2, e2[11], 16, 1839030562), n2 = v$2(n2, i2, a2, r2, e2[14], 23, -35309556), r2 = v$2(r2, n2, i2, a2, e2[1], 4, -1530992060), a2 = v$2(a2, r2, n2, i2, e2[4], 11, 1272893353), i2 = v$2(i2, a2, r2, n2, e2[7], 16, -155497632), n2 = v$2(n2, i2, a2, r2, e2[10], 23, -1094730640), r2 = v$2(r2, n2, i2, a2, e2[13], 4, 681279174), a2 = v$2(a2, r2, n2, i2, e2[0], 11, -358537222), i2 = v$2(i2, a2, r2, n2, e2[3], 16, -722521979), n2 = v$2(n2, i2, a2, r2, e2[6], 23, 76029189), r2 = v$2(r2, n2, i2, a2, e2[9], 4, -640364487), a2 = v$2(a2, r2, n2, i2, e2[12], 11, -421815835), i2 = v$2(i2, a2, r2, n2, e2[15], 16, 530742520), r2 = b$1(r2, n2 = v$2(n2, i2, a2, r2, e2[2], 23, -995338651), i2, a2, e2[0], 6, -198630844), a2 = b$1(a2, r2, n2, i2, e2[7], 10, 1126891415), i2 = b$1(i2, a2, r2, n2, e2[14], 15, -1416354905), n2 = b$1(n2, i2, a2, r2, e2[5], 21, -57434055), r2 = b$1(r2, n2, i2, a2, e2[12], 6, 1700485571), a2 = b$1(a2, r2, n2, i2, e2[3], 10, -1894986606), i2 = b$1(i2, a2, r2, n2, e2[10], 15, -1051523), n2 = b$1(n2, i2, a2, r2, e2[1], 21, -2054922799), r2 = b$1(r2, n2, i2, a2, e2[8], 6, 1873313359), a2 = b$1(a2, r2, n2, i2, e2[15], 10, -30611744), i2 = b$1(i2, a2, r2, n2, e2[6], 15, -1560198380), n2 = b$1(n2, i2, a2, r2, e2[13], 21, 1309151649), r2 = b$1(r2, n2, i2, a2, e2[4], 6, -145523070), a2 = b$1(a2, r2, n2, i2, e2[11], 10, -1120210379), i2 = b$1(i2, a2, r2, n2, e2[2], 15, 718787259), n2 = b$1(n2, i2, a2, r2, e2[9], 21, -343485551), t3[0] = _$2(r2, t3[0]), t3[1] = _$2(n2, t3[1]), t3[2] = _$2(i2, t3[2]), t3[3] = _$2(a2, t3[3]);
  }
  function p$2(t3, e2, r2, n2, i2, a2) {
    return e2 = _$2(_$2(e2, t3), _$2(n2, a2)), _$2(e2 << i2 | e2 >>> 32 - i2, r2);
  }
  function g$1(t3, e2, r2, n2, i2, a2, o2) {
    return p$2(e2 & r2 | ~e2 & n2, t3, e2, i2, a2, o2);
  }
  function m$3(t3, e2, r2, n2, i2, a2, o2) {
    return p$2(e2 & n2 | r2 & ~n2, t3, e2, i2, a2, o2);
  }
  function v$2(t3, e2, r2, n2, i2, a2, o2) {
    return p$2(e2 ^ r2 ^ n2, t3, e2, i2, a2, o2);
  }
  function b$1(t3, e2, r2, n2, i2, a2, o2) {
    return p$2(r2 ^ (e2 | ~n2), t3, e2, i2, a2, o2);
  }
  function y$2(t3) {
    var e2, r2 = t3.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
    for (e2 = 64; e2 <= t3.length; e2 += 64) d$1(n2, w$1(t3.substring(e2 - 64, e2)));
    t3 = t3.substring(e2 - 64);
    var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (e2 = 0; e2 < t3.length; e2++) i2[e2 >> 2] |= t3.charCodeAt(e2) << (e2 % 4 << 3);
    if (i2[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55) for (d$1(n2, i2), e2 = 0; e2 < 16; e2++) i2[e2] = 0;
    return i2[14] = 8 * r2, d$1(n2, i2), n2;
  }
  function w$1(t3) {
    var e2, r2 = [];
    for (e2 = 0; e2 < 64; e2 += 4) r2[e2 >> 2] = t3.charCodeAt(e2) + (t3.charCodeAt(e2 + 1) << 8) + (t3.charCodeAt(e2 + 2) << 16) + (t3.charCodeAt(e2 + 3) << 24);
    return r2;
  }
  u$2 = n$1.atob.bind(n$1), h$2 = n$1.btoa.bind(n$1);
  var N$2 = "0123456789abcdef".split("");
  function L$1(t3) {
    for (var e2 = "", r2 = 0; r2 < 4; r2++) e2 += N$2[t3 >> 8 * r2 + 4 & 15] + N$2[t3 >> 8 * r2 & 15];
    return e2;
  }
  function A$1(t3) {
    return String.fromCharCode((255 & t3) >> 0, (65280 & t3) >> 8, (16711680 & t3) >> 16, (4278190080 & t3) >> 24);
  }
  function x$1(t3) {
    return y$2(t3).map(A$1).join("");
  }
  var S$1 = "5d41402abc4b2a76b9719d911017c592" != (function(t3) {
    for (var e2 = 0; e2 < t3.length; e2++) t3[e2] = L$1(t3[e2]);
    return t3.join("");
  })(y$2("hello"));
  function _$2(t3, e2) {
    if (S$1) {
      var r2 = (65535 & t3) + (65535 & e2);
      return (t3 >> 16) + (e2 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
    }
    return t3 + e2 & 4294967295;
  }
  function P$1(t3, e2) {
    var r2, n2, i2, a2;
    if (t3 !== r2) {
      for (var o2 = (i2 = t3, a2 = 1 + (256 / t3.length >> 0), new Array(a2 + 1).join(i2)), s2 = [], c2 = 0; c2 < 256; c2++) s2[c2] = c2;
      var u2 = 0;
      for (c2 = 0; c2 < 256; c2++) {
        var h2 = s2[c2];
        u2 = (u2 + h2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h2;
      }
      r2 = t3, n2 = s2;
    } else s2 = n2;
    var l2 = e2.length, f2 = 0, d2 = 0, p2 = "";
    for (c2 = 0; c2 < l2; c2++) d2 = (d2 + (h2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h2, o2 = s2[(s2[f2] + s2[d2]) % 256], p2 += String.fromCharCode(e2.charCodeAt(c2) ^ o2);
    return p2;
  }
  var k$1 = {
    print: 4,
    modify: 8,
    copy: 16,
    "annot-forms": 32
  };
  function I$1(t3, e2, r2, n2) {
    this.v = 1, this.r = 2;
    var i2 = 192;
    t3.forEach(function(t4) {
      if (void 0 !== k$1.perm) throw new Error("Invalid permission: " + t4);
      i2 += k$1[t4];
    }), this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
    var a2 = (e2 + this.padding).substr(0, 32), o2 = (r2 + this.padding).substr(0, 32);
    this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = x$1(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P$1(this.encryptionKey, this.padding);
  }
  function F$1(t3) {
    if (/[^\u0000-\u00ff]/.test(t3)) throw new Error("Invalid PDF Name Object: " + t3 + ", Only accept ASCII characters.");
    for (var e2 = "", r2 = t3.length, n2 = 0; n2 < r2; n2++) {
      var i2 = t3.charCodeAt(n2);
      if (i2 < 33 || 35 === i2 || 37 === i2 || 40 === i2 || 41 === i2 || 47 === i2 || 60 === i2 || 62 === i2 || 91 === i2 || 93 === i2 || 123 === i2 || 125 === i2 || i2 > 126) e2 += "#" + ("0" + i2.toString(16)).slice(-2);
      else e2 += t3[n2];
    }
    return e2;
  }
  function C$1(e2) {
    if ("object" !== _typeof$1(e2)) throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
    var r2 = {};
    this.subscribe = function(t3, e3, n2) {
      if (n2 = n2 || false, "string" != typeof t3 || "function" != typeof e3 || "boolean" != typeof n2) throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
      r2.hasOwnProperty(t3) || (r2[t3] = {});
      var i2 = Math.random().toString(35);
      return r2[t3][i2] = [e3, !!n2], i2;
    }, this.unsubscribe = function(t3) {
      for (var e3 in r2) if (r2[e3][t3]) return delete r2[e3][t3], 0 === Object.keys(r2[e3]).length && delete r2[e3], true;
      return false;
    }, this.publish = function(t3) {
      if (r2.hasOwnProperty(t3)) {
        var i2 = Array.prototype.slice.call(arguments, 1), o2 = [];
        for (var s2 in r2[t3]) {
          var c2 = r2[t3][s2];
          try {
            c2[0].apply(e2, i2);
          } catch (t4) {
            n$1.console && a$1.error("jsPDF PubSub Error", t4.message, t4);
          }
          c2[1] && o2.push(s2);
        }
        o2.length && o2.forEach(this.unsubscribe);
      }
    }, this.getTopics = function() {
      return r2;
    };
  }
  function j$1(t3) {
    if (!(this instanceof j$1)) return new j$1(t3);
    var e2 = "opacity,stroke-opacity".split(",");
    for (var r2 in t3) t3.hasOwnProperty(r2) && e2.indexOf(r2) >= 0 && (this[r2] = t3[r2]);
    this.id = "", this.objectNumber = -1;
  }
  function O$2(t3, e2) {
    this.gState = t3, this.matrix = e2, this.id = "", this.objectNumber = -1;
  }
  function B$1(t3, e2, r2, n2, i2) {
    if (!(this instanceof B$1)) return new B$1(t3, e2, r2, n2, i2);
    this.type = "axial" === t3 ? 2 : 3, this.coords = e2, this.colors = r2, O$2.call(this, n2, i2);
  }
  function M$1(t3, e2, r2, n2, i2) {
    if (!(this instanceof M$1)) return new M$1(t3, e2, r2, n2, i2);
    this.boundingBox = t3, this.xStep = e2, this.yStep = r2, this.stream = "", this.cloneIndex = 0, O$2.call(this, n2, i2);
  }
  function E$1(e2) {
    var r2, i2 = "string" == typeof arguments[0] ? arguments[0] : "p", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p2 = 16, g2 = "S", m2 = null;
    "object" === _typeof$1(e2 = e2 || {}) && (i2 = e2.orientation, o2 = e2.unit || o2, s2 = e2.format || s2, c2 = e2.compress || e2.compressPdf || c2, null !== (m2 = e2.encryption || null) && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), d2 = "number" == typeof e2.userUnit ? Math.abs(e2.userUnit) : 1, void 0 !== e2.precision && (r2 = e2.precision), void 0 !== e2.floatPrecision && (p2 = e2.floatPrecision), g2 = e2.defaultPathOperation || "S"), u2 = e2.filters || (true === c2 ? ["FlateEncode"] : u2), o2 = o2 || "mm", i2 = ("" + (i2 || "P")).toLowerCase();
    var v2 = e2.putOnlyUsedFonts || false, b2 = {}, y2 = {
      internal: {},
      __private__: {}
    };
    y2.__private__.PubSub = C$1;
    var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
      return w2;
    };
    y2.__private__.setPdfVersion = function(t3) {
      w2 = t3;
    };
    var L2 = {
      a0: [2383.94, 3370.39],
      a1: [1683.78, 2383.94],
      a2: [1190.55, 1683.78],
      a3: [841.89, 1190.55],
      a4: [595.28, 841.89],
      a5: [419.53, 595.28],
      a6: [297.64, 419.53],
      a7: [209.76, 297.64],
      a8: [147.4, 209.76],
      a9: [104.88, 147.4],
      a10: [73.7, 104.88],
      b0: [2834.65, 4008.19],
      b1: [2004.09, 2834.65],
      b2: [1417.32, 2004.09],
      b3: [1000.63, 1417.32],
      b4: [708.66, 1000.63],
      b5: [498.9, 708.66],
      b6: [354.33, 498.9],
      b7: [249.45, 354.33],
      b8: [175.75, 249.45],
      b9: [124.72, 175.75],
      b10: [87.87, 124.72],
      c0: [2599.37, 3676.54],
      c1: [1836.85, 2599.37],
      c2: [1298.27, 1836.85],
      c3: [918.43, 1298.27],
      c4: [649.13, 918.43],
      c5: [459.21, 649.13],
      c6: [323.15, 459.21],
      c7: [229.61, 323.15],
      c8: [161.57, 229.61],
      c9: [113.39, 161.57],
      c10: [79.37, 113.39],
      dl: [311.81, 623.62],
      letter: [612, 792],
      "government-letter": [576, 756],
      legal: [612, 1008],
      "junior-legal": [576, 360],
      ledger: [1224, 792],
      tabloid: [792, 1224],
      "credit-card": [153, 243]
    };
    y2.__private__.getPageFormats = function() {
      return L2;
    };
    var A2 = y2.__private__.getPageFormat = function(t3) {
      return L2[t3];
    };
    s2 = s2 || "a4";
    var x2 = {
      COMPAT: "compat",
      ADVANCED: "advanced"
    }, S2 = x2.COMPAT;
    function _2() {
      this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g2 = "n", S2 = x2.ADVANCED;
    }
    function P2() {
      this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
    }
    var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t3, e3) {
      if ("bold" == t3 && "normal" == e3 || "bold" == t3 && 400 == e3 || "normal" == t3 && "italic" == e3 || "bold" == t3 && "italic" == e3) throw new Error("Invalid Combination of fontweight and fontstyle");
      return e3 && (t3 = 400 == e3 || "normal" === e3 ? "italic" === t3 ? "italic" : "normal" : 700 != e3 && "bold" !== e3 || "normal" !== t3 ? (700 == e3 ? "bold" : e3) + "" + t3 : "bold"), t3;
    };
    y2.advancedAPI = function(t3) {
      var e3 = S2 === x2.COMPAT;
      return e3 && _2.call(this), "function" != typeof t3 || (t3(this), e3 && P2.call(this)), this;
    }, y2.compatAPI = function(t3) {
      var e3 = S2 === x2.ADVANCED;
      return e3 && P2.call(this), "function" != typeof t3 || (t3(this), e3 && _2.call(this)), this;
    }, y2.isAdvancedAPI = function() {
      return S2 === x2.ADVANCED;
    };
    var O2, q2 = function(t3) {
      if (S2 !== x2.ADVANCED) throw new Error(t3 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
    }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t3, e3) {
      var n2 = r2 || e3;
      if (isNaN(t3) || isNaN(n2)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
      return t3.toFixed(n2).replace(/0+$/, "");
    };
    O2 = y2.hpf = y2.__private__.hpf = "number" == typeof p2 ? function(t3) {
      if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.hpf");
      return D2(t3, p2);
    } : "smart" === p2 ? function(t3) {
      if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.hpf");
      return D2(t3, t3 > -1 && t3 < 1 ? 16 : 5);
    } : function(t3) {
      if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.hpf");
      return D2(t3, 16);
    };
    var R2 = y2.f2 = y2.__private__.f2 = function(t3) {
      if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.f2");
      return D2(t3, 2);
    }, T2 = y2.__private__.f3 = function(t3) {
      if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.f3");
      return D2(t3, 3);
    }, U2 = y2.scale = y2.__private__.scale = function(t3) {
      if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.scale");
      return S2 === x2.COMPAT ? t3 * _t2 : S2 === x2.ADVANCED ? t3 : void 0;
    }, z2 = function(t3) {
      return S2 === x2.COMPAT ? Rr() - t3 : S2 === x2.ADVANCED ? t3 : void 0;
    }, H2 = function(t3) {
      return U2(z2(t3));
    };
    y2.__private__.setPrecision = y2.setPrecision = function(t3) {
      "number" == typeof parseInt(t3, 10) && (r2 = parseInt(t3, 10));
    };
    var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
      return V2;
    }, Y2 = y2.__private__.setFileId = function(t3) {
      return V2 = void 0 !== t3 && /^[a-fA-F0-9]{32}$/.test(t3) ? t3.toUpperCase() : V2.split("").map(function() {
        return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
      }).join(""), null !== m2 && (Ye = new I$1(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
    };
    y2.setFileId = function(t3) {
      return Y2(t3), this;
    }, y2.getFileId = function() {
      return G2();
    };
    var J2 = y2.__private__.convertDateToPDFDate = function(t3) {
      var e3 = t3.getTimezoneOffset(), r3 = e3 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e3 / 60)), i3 = Math.abs(e3 % 60), a2 = [r3, Q2(n2), "'", Q2(i3), "'"].join("");
      return ["D:", t3.getFullYear(), Q2(t3.getMonth() + 1), Q2(t3.getDate()), Q2(t3.getHours()), Q2(t3.getMinutes()), Q2(t3.getSeconds()), a2].join("");
    }, X2 = y2.__private__.convertPDFDateToDate = function(t3) {
      var e3 = parseInt(t3.substr(2, 4), 10), r3 = parseInt(t3.substr(6, 2), 10) - 1, n2 = parseInt(t3.substr(8, 2), 10), i3 = parseInt(t3.substr(10, 2), 10), a2 = parseInt(t3.substr(12, 2), 10), o3 = parseInt(t3.substr(14, 2), 10);
      return new Date(e3, r3, n2, i3, a2, o3, 0);
    }, K2 = y2.__private__.setCreationDate = function(t3) {
      var e3;
      if (void 0 === t3 && (t3 = /* @__PURE__ */ new Date()), t3 instanceof Date) e3 = J2(t3);
      else {
        if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t3)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
        e3 = t3;
      }
      return W2 = e3;
    }, Z2 = y2.__private__.getCreationDate = function(t3) {
      var e3 = W2;
      return "jsDate" === t3 && (e3 = X2(W2)), e3;
    };
    y2.setCreationDate = function(t3) {
      return K2(t3), this;
    }, y2.getCreationDate = function(t3) {
      return Z2(t3);
    };
    var $2, Q2 = y2.__private__.padd2 = function(t3) {
      return ("0" + parseInt(t3)).slice(-2);
    }, tt2 = y2.__private__.padd2Hex = function(t3) {
      return ("00" + (t3 = t3.toString())).substr(t3.length);
    }, et2 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
      et2 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
    };
    y2.__private__.setCustomOutputDestination = function(t3) {
      st2 = true, ct2 = t3;
    };
    var ht2 = function(t3) {
      st2 || (ct2 = t3);
    };
    y2.__private__.resetCustomOutputDestination = function() {
      st2 = false, ct2 = nt2;
    };
    var lt2 = y2.__private__.out = function(t3) {
      return t3 = t3.toString(), it2 += t3.length + 1, ct2.push(t3), ct2;
    }, ft2 = y2.__private__.write = function(t3) {
      return lt2(1 === arguments.length ? t3.toString() : Array.prototype.join.call(arguments, " "));
    }, dt2 = y2.__private__.getArrayBuffer = function(t3) {
      for (var e3 = t3.length, r3 = new ArrayBuffer(e3), n2 = new Uint8Array(r3); e3--; ) n2[e3] = t3.charCodeAt(e3);
      return r3;
    }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
    y2.__private__.getStandardFonts = function() {
      return pt2;
    };
    var gt2 = e2.fontSize || 16;
    y2.__private__.setFontSize = y2.setFontSize = function(t3) {
      return gt2 = S2 === x2.ADVANCED ? t3 / _t2 : t3, this;
    };
    var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
      return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
    }, bt2 = e2.R2L || false;
    y2.__private__.setR2L = y2.setR2L = function(t3) {
      return bt2 = t3, this;
    }, y2.__private__.getR2L = y2.getR2L = function() {
      return bt2;
    };
    var yt2, wt2 = y2.__private__.setZoomMode = function(t3) {
      var e3 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
      if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t3)) mt2 = t3;
      else if (isNaN(t3)) {
        if (-1 === e3.indexOf(t3)) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t3 + '" is not recognized.');
        mt2 = t3;
      } else mt2 = parseInt(t3, 10);
    };
    y2.__private__.getZoomMode = function() {
      return mt2;
    };
    var Nt2, Lt2 = y2.__private__.setPageMode = function(t3) {
      if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t3)) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t3 + '" is not recognized.');
      yt2 = t3;
    };
    y2.__private__.getPageMode = function() {
      return yt2;
    };
    var At2 = y2.__private__.setLayoutMode = function(t3) {
      if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t3)) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t3 + '" is not recognized.');
      Nt2 = t3;
    };
    y2.__private__.getLayoutMode = function() {
      return Nt2;
    }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t3, e3, r3) {
      return wt2(t3), At2(e3), Lt2(r3), this;
    };
    var xt2 = {
      title: "",
      subject: "",
      author: "",
      keywords: "",
      creator: ""
    };
    y2.__private__.getDocumentProperty = function(t3) {
      if (-1 === Object.keys(xt2).indexOf(t3)) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
      return xt2[t3];
    }, y2.__private__.getDocumentProperties = function() {
      return xt2;
    }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t3) {
      for (var e3 in xt2) xt2.hasOwnProperty(e3) && t3[e3] && (xt2[e3] = t3[e3]);
      return this;
    }, y2.__private__.setDocumentProperty = function(t3, e3) {
      if (-1 === Object.keys(xt2).indexOf(t3)) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
      return xt2[t3] = e3;
    };
    var St2, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C$1(y2), Ut2 = e2.hotfixes || [], zt2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t3(e3, r3, n2, i3, a2, o3) {
      if (!(this instanceof t3)) return new t3(e3, r3, n2, i3, a2, o3);
      isNaN(e3) && (e3 = 1), isNaN(r3) && (r3 = 0), isNaN(n2) && (n2 = 0), isNaN(i3) && (i3 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e3, r3, n2, i3, a2, o3];
    };
    Object.defineProperty(Vt2.prototype, "sx", {
      get: function() {
        return this._matrix[0];
      },
      set: function(t3) {
        this._matrix[0] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "shy", {
      get: function() {
        return this._matrix[1];
      },
      set: function(t3) {
        this._matrix[1] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "shx", {
      get: function() {
        return this._matrix[2];
      },
      set: function(t3) {
        this._matrix[2] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "sy", {
      get: function() {
        return this._matrix[3];
      },
      set: function(t3) {
        this._matrix[3] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "tx", {
      get: function() {
        return this._matrix[4];
      },
      set: function(t3) {
        this._matrix[4] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "ty", {
      get: function() {
        return this._matrix[5];
      },
      set: function(t3) {
        this._matrix[5] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "a", {
      get: function() {
        return this._matrix[0];
      },
      set: function(t3) {
        this._matrix[0] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "b", {
      get: function() {
        return this._matrix[1];
      },
      set: function(t3) {
        this._matrix[1] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "c", {
      get: function() {
        return this._matrix[2];
      },
      set: function(t3) {
        this._matrix[2] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "d", {
      get: function() {
        return this._matrix[3];
      },
      set: function(t3) {
        this._matrix[3] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "e", {
      get: function() {
        return this._matrix[4];
      },
      set: function(t3) {
        this._matrix[4] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "f", {
      get: function() {
        return this._matrix[5];
      },
      set: function(t3) {
        this._matrix[5] = t3;
      }
    }), Object.defineProperty(Vt2.prototype, "rotation", {
      get: function() {
        return Math.atan2(this.shx, this.sx);
      }
    }), Object.defineProperty(Vt2.prototype, "scaleX", {
      get: function() {
        return this.decompose().scale.sx;
      }
    }), Object.defineProperty(Vt2.prototype, "scaleY", {
      get: function() {
        return this.decompose().scale.sy;
      }
    }), Object.defineProperty(Vt2.prototype, "isIdentity", {
      get: function() {
        return 1 === this.sx && 0 === this.shy && 0 === this.shx && 1 === this.sy && 0 === this.tx && 0 === this.ty;
      }
    }), Vt2.prototype.join = function(t3) {
      return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t3);
    }, Vt2.prototype.multiply = function(t3) {
      var e3 = t3.sx * this.sx + t3.shy * this.shx, r3 = t3.sx * this.shy + t3.shy * this.sy, n2 = t3.shx * this.sx + t3.sy * this.shx, i3 = t3.shx * this.shy + t3.sy * this.sy, a2 = t3.tx * this.sx + t3.ty * this.shx + this.tx, o3 = t3.tx * this.shy + t3.ty * this.sy + this.ty;
      return new Vt2(e3, r3, n2, i3, a2, o3);
    }, Vt2.prototype.decompose = function() {
      var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = Math.sqrt(t3 * t3 + e3 * e3), s3 = (t3 /= o3) * r3 + (e3 /= o3) * n2;
      r3 -= t3 * s3, n2 -= e3 * s3;
      var c3 = Math.sqrt(r3 * r3 + n2 * n2);
      return s3 /= c3, t3 * (n2 /= c3) < e3 * (r3 /= c3) && (t3 = -t3, e3 = -e3, s3 = -s3, o3 = -o3), {
        scale: new Vt2(o3, 0, 0, c3, 0, 0),
        translate: new Vt2(1, 0, 0, 1, i3, a2),
        rotate: new Vt2(t3, e3, -e3, t3, 0, 0),
        skew: new Vt2(1, 0, s3, 1, 0, 0)
      };
    }, Vt2.prototype.toString = function(t3) {
      return this.join(" ");
    }, Vt2.prototype.inversed = function() {
      var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = 1 / (t3 * n2 - e3 * r3), s3 = n2 * o3, c3 = -e3 * o3, u3 = -r3 * o3, h2 = t3 * o3;
      return new Vt2(s3, c3, u3, h2, -s3 * i3 - u3 * a2, -c3 * i3 - h2 * a2);
    }, Vt2.prototype.applyToPoint = function(t3) {
      var e3 = t3.x * this.sx + t3.y * this.shx + this.tx, r3 = t3.x * this.shy + t3.y * this.sy + this.ty;
      return new Cr(e3, r3);
    }, Vt2.prototype.applyToRectangle = function(t3) {
      var e3 = this.applyToPoint(t3), r3 = this.applyToPoint(new Cr(t3.x + t3.w, t3.y + t3.h));
      return new jr(e3.x, e3.y, r3.x - e3.x, r3.y - e3.y);
    }, Vt2.prototype.clone = function() {
      var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty;
      return new Vt2(t3, e3, r3, n2, i3, a2);
    }, y2.Matrix = Vt2;
    var Gt2 = y2.matrixMult = function(t3, e3) {
      return e3.multiply(t3);
    }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
    y2.unitMatrix = y2.identityMatrix = Yt2;
    var Jt2 = function(t3, e3) {
      if (!Bt2[t3]) {
        var r3 = (e3 instanceof B$1 ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
        e3.id = r3, Bt2[t3] = r3, Ot2[r3] = e3, Tt2.publish("addPattern", e3);
      }
    };
    y2.ShadingPattern = B$1, y2.TilingPattern = M$1, y2.addShadingPattern = function(t3, e3) {
      return q2("addShadingPattern()"), Jt2(t3, e3), this;
    }, y2.beginTilingPattern = function(t3) {
      q2("beginTilingPattern()"), Br(t3.boundingBox[0], t3.boundingBox[1], t3.boundingBox[2] - t3.boundingBox[0], t3.boundingBox[3] - t3.boundingBox[1], t3.matrix);
    }, y2.endTilingPattern = function(t3, e3) {
      q2("endTilingPattern()"), e3.stream = ot2[$2].join("\n"), Jt2(t3, e3), Tt2.publish("endTilingPattern", e3), Wt2.pop().restore();
    };
    var Xt2 = y2.__private__.newObject = function() {
      var t3 = Kt2();
      return Zt2(t3, true), t3;
    }, Kt2 = y2.__private__.newObjectDeferred = function() {
      return et2++, rt2[et2] = function() {
        return it2;
      }, et2;
    }, Zt2 = function(t3, e3) {
      return e3 = "boolean" == typeof e3 && e3, rt2[t3] = it2, e3 && lt2(t3 + " 0 obj"), t3;
    }, $t2 = y2.__private__.newAdditionalObject = function() {
      var t3 = {
        objId: Kt2(),
        content: ""
      };
      return at2.push(t3), t3;
    }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t3) {
      var e3 = t3.split(" ");
      if (2 !== e3.length || "g" !== e3[1] && "G" !== e3[1]) {
        if (5 === e3.length && ("k" === e3[4] || "K" === e3[4])) {
          e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"];
        }
      } else {
        var r3 = parseFloat(e3[0]);
        e3 = [r3, r3, r3, "r"];
      }
      for (var n2 = "#", i3 = 0; i3 < 3; i3++) n2 += ("0" + Math.floor(255 * parseFloat(e3[i3])).toString(16)).slice(-2);
      return n2;
    }, re2 = y2.__private__.encodeColorString = function(e3) {
      var r3;
      "string" == typeof e3 && (e3 = {
        ch1: e3
      });
      var n2 = e3.ch1, i3 = e3.ch2, a2 = e3.ch3, o3 = e3.ch4, s3 = "draw" === e3.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
      if ("string" == typeof n2 && "#" !== n2.charAt(0)) {
        var c3 = new f$2(n2);
        if (c3.ok) n2 = c3.toHex();
        else if (!/^\d*\.?\d*$/.test(n2)) throw new Error('Invalid color "' + n2 + '" passed to jsPDF.encodeColorString.');
      }
      if ("string" == typeof n2 && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = "#" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), "string" == typeof n2 && /^#[0-9A-Fa-f]{6}$/.test(n2)) {
        var u3 = parseInt(n2.substr(1), 16);
        n2 = u3 >> 16 & 255, i3 = u3 >> 8 & 255, a2 = 255 & u3;
      }
      if (void 0 === i3 || void 0 === o3 && n2 === i3 && i3 === a2) {
        if ("string" == typeof n2) r3 = n2 + " " + s3[0];
        else switch (e3.precision) {
          case 2:
            r3 = R2(n2 / 255) + " " + s3[0];
            break;
          case 3:
          default:
            r3 = T2(n2 / 255) + " " + s3[0];
        }
      } else if (void 0 === o3 || "object" === _typeof$1(o3)) {
        if (o3 && !isNaN(o3.a) && 0 === o3.a) return r3 = ["1.", "1.", "1.", s3[1]].join(" ");
        if ("string" == typeof n2) r3 = [n2, i3, a2, s3[1]].join(" ");
        else switch (e3.precision) {
          case 2:
            r3 = [R2(n2 / 255), R2(i3 / 255), R2(a2 / 255), s3[1]].join(" ");
            break;
          default:
          case 3:
            r3 = [T2(n2 / 255), T2(i3 / 255), T2(a2 / 255), s3[1]].join(" ");
        }
      } else if ("string" == typeof n2) r3 = [n2, i3, a2, o3, s3[2]].join(" ");
      else switch (e3.precision) {
        case 2:
          r3 = [R2(n2), R2(i3), R2(a2), R2(o3), s3[2]].join(" ");
          break;
        case 3:
        default:
          r3 = [T2(n2), T2(i3), T2(a2), T2(o3), s3[2]].join(" ");
      }
      return r3;
    }, ne2 = y2.__private__.getFilters = function() {
      return u2;
    }, ie2 = y2.__private__.putStream = function(t3) {
      var e3 = (t3 = t3 || {}).data || "", r3 = t3.filters || ne2(), n2 = t3.alreadyAppliedFilters || [], i3 = t3.addLength1 || false, a2 = e3.length, o3 = t3.objectId, s3 = function(t4) {
        return t4;
      };
      if (null !== m2 && void 0 === o3) throw new Error("ObjectId must be passed to putStream for file encryption");
      null !== m2 && (s3 = Ye.encryptor(o3, 0));
      var c3 = {};
      true === r3 && (r3 = ["FlateEncode"]);
      var u3 = t3.additionalKeyValues || [], h2 = (c3 = void 0 !== E$1.API.processDataByFilters ? E$1.API.processDataByFilters(e3, r3) : {
        data: e3,
        reverseChain: []
      }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
      if (0 !== c3.data.length && (u3.push({
        key: "Length",
        value: c3.data.length
      }), true === i3 && u3.push({
        key: "Length1",
        value: a2
      })), 0 != h2.length) if (h2.split("/").length - 1 == 1) u3.push({
        key: "Filter",
        value: h2
      });
      else {
        u3.push({
          key: "Filter",
          value: "[" + h2 + "]"
        });
        for (var l2 = 0; l2 < u3.length; l2 += 1) if ("DecodeParms" === u3[l2].key) {
          for (var f2 = [], d3 = 0; d3 < c3.reverseChain.split("/").length - 1; d3 += 1) f2.push("null");
          f2.push(u3[l2].value), u3[l2].value = "[" + f2.join(" ") + "]";
        }
      }
      lt2("<<");
      for (var p3 = 0; p3 < u3.length; p3++) lt2("/" + u3[p3].key + " " + u3[p3].value);
      lt2(">>"), 0 !== c3.data.length && (lt2("stream"), lt2(s3(c3.data)), lt2("endstream"));
    }, ae2 = y2.__private__.putPage = function(t3) {
      var e3 = t3.number, r3 = t3.data, n2 = t3.objId, i3 = t3.contentsObjId;
      Zt2(n2, true), lt2("<</Type /Page"), lt2("/Parent " + t3.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t3.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O2(t3.mediaBox.bottomLeftX)) + " " + parseFloat(O2(t3.mediaBox.bottomLeftY)) + " " + O2(t3.mediaBox.topRightX) + " " + O2(t3.mediaBox.topRightY) + "]"), null !== t3.cropBox && lt2("/CropBox [" + O2(t3.cropBox.bottomLeftX) + " " + O2(t3.cropBox.bottomLeftY) + " " + O2(t3.cropBox.topRightX) + " " + O2(t3.cropBox.topRightY) + "]"), null !== t3.bleedBox && lt2("/BleedBox [" + O2(t3.bleedBox.bottomLeftX) + " " + O2(t3.bleedBox.bottomLeftY) + " " + O2(t3.bleedBox.topRightX) + " " + O2(t3.bleedBox.topRightY) + "]"), null !== t3.trimBox && lt2("/TrimBox [" + O2(t3.trimBox.bottomLeftX) + " " + O2(t3.trimBox.bottomLeftY) + " " + O2(t3.trimBox.topRightX) + " " + O2(t3.trimBox.topRightY) + "]"), null !== t3.artBox && lt2("/ArtBox [" + O2(t3.artBox.bottomLeftX) + " " + O2(t3.artBox.bottomLeftY) + " " + O2(t3.artBox.topRightX) + " " + O2(t3.artBox.topRightY) + "]"), "number" == typeof t3.userUnit && 1 !== t3.userUnit && lt2("/UserUnit " + t3.userUnit), Tt2.publish("putPage", {
        objId: n2,
        pageContext: Rt2[e3],
        pageNumber: e3,
        page: r3
      }), lt2("/Contents " + i3 + " 0 R"), lt2(">>"), lt2("endobj");
      var a2 = r3.join("\n");
      return S2 === x2.ADVANCED && (a2 += "\nQ"), Zt2(i3, true), ie2({
        data: a2,
        filters: ne2(),
        objectId: i3
      }), lt2("endobj"), n2;
    }, oe2 = y2.__private__.putPages = function() {
      var t3, e3, r3 = [];
      for (t3 = 1; t3 <= Dt2; t3++) Rt2[t3].objId = Kt2(), Rt2[t3].contentsObjId = Kt2();
      for (t3 = 1; t3 <= Dt2; t3++) r3.push(ae2({
        number: t3,
        data: ot2[t3],
        objId: Rt2[t3].objId,
        contentsObjId: Rt2[t3].contentsObjId,
        mediaBox: Rt2[t3].mediaBox,
        cropBox: Rt2[t3].cropBox,
        bleedBox: Rt2[t3].bleedBox,
        trimBox: Rt2[t3].trimBox,
        artBox: Rt2[t3].artBox,
        userUnit: Rt2[t3].userUnit,
        rootDictionaryObjId: Qt2,
        resourceDictionaryObjId: te2
      }));
      Zt2(Qt2, true), lt2("<</Type /Pages");
      var n2 = "/Kids [";
      for (e3 = 0; e3 < Dt2; e3++) n2 += r3[e3] + " 0 R ";
      lt2(n2 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
    }, se2 = function(t3) {
      Tt2.publish("putFont", {
        font: t3,
        out: lt2,
        newObject: Xt2,
        putStream: ie2
      }), true !== t3.isAlreadyPutted && (t3.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F$1(t3.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t3.encoding && lt2("/Encoding /" + t3.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
    }, ce2 = function() {
      for (var t3 in Ft2) Ft2.hasOwnProperty(t3) && (false === v2 || true === v2 && b2.hasOwnProperty(t3)) && se2(Ft2[t3]);
    }, ue2 = function(t3) {
      t3.objectNumber = Xt2();
      var e3 = [];
      e3.push({
        key: "Type",
        value: "/XObject"
      }), e3.push({
        key: "Subtype",
        value: "/Form"
      }), e3.push({
        key: "BBox",
        value: "[" + [O2(t3.x), O2(t3.y), O2(t3.x + t3.width), O2(t3.y + t3.height)].join(" ") + "]"
      }), e3.push({
        key: "Matrix",
        value: "[" + t3.matrix.toString() + "]"
      });
      var r3 = t3.pages[1].join("\n");
      ie2({
        data: r3,
        additionalKeyValues: e3,
        objectId: t3.objectNumber
      }), lt2("endobj");
    }, he2 = function() {
      for (var t3 in zt2) zt2.hasOwnProperty(t3) && ue2(zt2[t3]);
    }, le2 = function(t3, e3) {
      var r3, n2 = [], i3 = 1 / (e3 - 1);
      for (r3 = 0; r3 < 1; r3 += i3) n2.push(r3);
      if (n2.push(1), 0 != t3[0].offset) {
        var a2 = {
          offset: 0,
          color: t3[0].color
        };
        t3.unshift(a2);
      }
      if (1 != t3[t3.length - 1].offset) {
        var o3 = {
          offset: 1,
          color: t3[t3.length - 1].color
        };
        t3.push(o3);
      }
      for (var s3 = "", c3 = 0, u3 = 0; u3 < n2.length; u3++) {
        for (r3 = n2[u3]; r3 > t3[c3 + 1].offset; ) c3++;
        var h2 = t3[c3].offset, l2 = (r3 - h2) / (t3[c3 + 1].offset - h2), f2 = t3[c3].color, d3 = t3[c3 + 1].color;
        s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d3[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d3[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d3[2]).toString(16));
      }
      return s3.trim();
    }, fe2 = function(t3, e3) {
      e3 || (e3 = 21);
      var r3 = Xt2(), n2 = le2(t3.colors, e3), i3 = [];
      i3.push({
        key: "FunctionType",
        value: "0"
      }), i3.push({
        key: "Domain",
        value: "[0.0 1.0]"
      }), i3.push({
        key: "Size",
        value: "[" + e3 + "]"
      }), i3.push({
        key: "BitsPerSample",
        value: "8"
      }), i3.push({
        key: "Range",
        value: "[0.0 1.0 0.0 1.0 0.0 1.0]"
      }), i3.push({
        key: "Decode",
        value: "[0.0 1.0 0.0 1.0 0.0 1.0]"
      }), ie2({
        data: n2,
        additionalKeyValues: i3,
        alreadyAppliedFilters: ["/ASCIIHexDecode"],
        objectId: r3
      }), lt2("endobj"), t3.objectNumber = Xt2(), lt2("<< /ShadingType " + t3.type), lt2("/ColorSpace /DeviceRGB");
      var a2 = "/Coords [" + O2(parseFloat(t3.coords[0])) + " " + O2(parseFloat(t3.coords[1])) + " ";
      2 === t3.type ? a2 += O2(parseFloat(t3.coords[2])) + " " + O2(parseFloat(t3.coords[3])) : a2 += O2(parseFloat(t3.coords[2])) + " " + O2(parseFloat(t3.coords[3])) + " " + O2(parseFloat(t3.coords[4])) + " " + O2(parseFloat(t3.coords[5])), lt2(a2 += "]"), t3.matrix && lt2("/Matrix [" + t3.matrix.toString() + "]"), lt2("/Function " + r3 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
    }, de2 = function(t3, e3) {
      var r3 = Kt2(), n2 = Xt2();
      e3.push({
        resourcesOid: r3,
        objectOid: n2
      }), t3.objectNumber = n2;
      var i3 = [];
      i3.push({
        key: "Type",
        value: "/Pattern"
      }), i3.push({
        key: "PatternType",
        value: "1"
      }), i3.push({
        key: "PaintType",
        value: "1"
      }), i3.push({
        key: "TilingType",
        value: "1"
      }), i3.push({
        key: "BBox",
        value: "[" + t3.boundingBox.map(O2).join(" ") + "]"
      }), i3.push({
        key: "XStep",
        value: O2(t3.xStep)
      }), i3.push({
        key: "YStep",
        value: O2(t3.yStep)
      }), i3.push({
        key: "Resources",
        value: r3 + " 0 R"
      }), t3.matrix && i3.push({
        key: "Matrix",
        value: "[" + t3.matrix.toString() + "]"
      }), ie2({
        data: t3.stream,
        additionalKeyValues: i3,
        objectId: t3.objectNumber
      }), lt2("endobj");
    }, pe2 = function(t3) {
      var e3;
      for (e3 in Ot2) Ot2.hasOwnProperty(e3) && (Ot2[e3] instanceof B$1 ? fe2(Ot2[e3]) : Ot2[e3] instanceof M$1 && de2(Ot2[e3], t3));
    }, ge2 = function(t3) {
      for (var e3 in t3.objectNumber = Xt2(), lt2("<<"), t3) switch (e3) {
        case "opacity":
          lt2("/ca " + R2(t3[e3]));
          break;
        case "stroke-opacity":
          lt2("/CA " + R2(t3[e3]));
      }
      lt2(">>"), lt2("endobj");
    }, me2 = function() {
      var t3;
      for (t3 in Mt2) Mt2.hasOwnProperty(t3) && ge2(Mt2[t3]);
    }, ve2 = function() {
      for (var t3 in lt2("/XObject <<"), zt2) zt2.hasOwnProperty(t3) && zt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + zt2[t3].objectNumber + " 0 R");
      Tt2.publish("putXobjectDict"), lt2(">>");
    }, be2 = function() {
      Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
    }, ye2 = function() {
      for (var t3 in lt2("/Font <<"), Ft2) Ft2.hasOwnProperty(t3) && (false === v2 || true === v2 && b2.hasOwnProperty(t3)) && lt2("/" + t3 + " " + Ft2[t3].objectNumber + " 0 R");
      lt2(">>");
    }, we2 = function() {
      if (Object.keys(Ot2).length > 0) {
        for (var t3 in lt2("/Shading <<"), Ot2) Ot2.hasOwnProperty(t3) && Ot2[t3] instanceof B$1 && Ot2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Ot2[t3].objectNumber + " 0 R");
        Tt2.publish("putShadingPatternDict"), lt2(">>");
      }
    }, Ne2 = function(t3) {
      if (Object.keys(Ot2).length > 0) {
        for (var e3 in lt2("/Pattern <<"), Ot2) Ot2.hasOwnProperty(e3) && Ot2[e3] instanceof y2.TilingPattern && Ot2[e3].objectNumber >= 0 && Ot2[e3].objectNumber < t3 && lt2("/" + e3 + " " + Ot2[e3].objectNumber + " 0 R");
        Tt2.publish("putTilingPatternDict"), lt2(">>");
      }
    }, Le2 = function() {
      if (Object.keys(Mt2).length > 0) {
        var t3;
        for (t3 in lt2("/ExtGState <<"), Mt2) Mt2.hasOwnProperty(t3) && Mt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Mt2[t3].objectNumber + " 0 R");
        Tt2.publish("putGStateDict"), lt2(">>");
      }
    }, Ae = function(t3) {
      Zt2(t3.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t3.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
    }, xe = function() {
      var t3 = [];
      ce2(), me2(), he2(), pe2(t3), Tt2.publish("putResources"), t3.forEach(Ae), Ae({
        resourcesOid: te2,
        objectOid: Number.MAX_SAFE_INTEGER
      }), Tt2.publish("postPutResources");
    }, Se = function() {
      Tt2.publish("putAdditionalObjects");
      for (var t3 = 0; t3 < at2.length; t3++) {
        var e3 = at2[t3];
        Zt2(e3.objId, true), lt2(e3.content), lt2("endobj");
      }
      Tt2.publish("postPutAdditionalObjects");
    }, _e = function(t3) {
      Ct2[t3.fontName] = Ct2[t3.fontName] || {}, Ct2[t3.fontName][t3.fontStyle] = t3.id;
    }, Pe = function(t3, e3, r3, n2, i3) {
      var a2 = {
        id: "F" + (Object.keys(Ft2).length + 1).toString(10),
        postScriptName: t3,
        fontName: e3,
        fontStyle: r3,
        encoding: n2,
        isStandardFont: i3 || false,
        metadata: {}
      };
      return Tt2.publish("addFont", {
        font: a2,
        instance: this
      }), Ft2[a2.id] = a2, _e(a2), a2.id;
    }, ke = function(t3) {
      for (var e3 = 0, r3 = pt2.length; e3 < r3; e3++) {
        var n2 = Pe.call(this, t3[e3][0], t3[e3][1], t3[e3][2], pt2[e3][3], true);
        false === v2 && (b2[n2] = true);
        var i3 = t3[e3][0].split("-");
        _e({
          id: n2,
          fontName: i3[0],
          fontStyle: i3[1] || ""
        });
      }
      Tt2.publish("addFonts", {
        fonts: Ft2,
        dictionary: Ct2
      });
    }, Ie = function(t3) {
      return t3.foo = function() {
        try {
          return t3.apply(this, arguments);
        } catch (t4) {
          var e3 = t4.stack || "";
          ~e3.indexOf(" at ") && (e3 = e3.split(" at ")[1]);
          var r3 = "Error in function " + e3.split("\n")[0].split("<")[0] + ": " + t4.message;
          if (!n$1.console) throw new Error(r3);
          n$1.console.error(r3, t4), n$1.alert && alert(r3);
        }
      }, t3.foo.bar = t3, t3.foo;
    }, Fe = function(t3, e3) {
      var r3, n2, i3, a2, o3, s3, c3, u3, h2;
      if (i3 = (e3 = e3 || {}).sourceEncoding || "Unicode", o3 = e3.outputEncoding, (e3.autoencode || o3) && Ft2[St2].metadata && Ft2[St2].metadata[i3] && Ft2[St2].metadata[i3].encoding && (a2 = Ft2[St2].metadata[i3].encoding, !o3 && Ft2[St2].encoding && (o3 = Ft2[St2].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), "string" == typeof o3 && (o3 = a2[o3]), o3)) {
        for (c3 = false, s3 = [], r3 = 0, n2 = t3.length; r3 < n2; r3++) (u3 = o3[t3.charCodeAt(r3)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t3[r3]), s3[r3].charCodeAt(0) >> 8 && (c3 = true);
        t3 = s3.join("");
      }
      for (r3 = t3.length; void 0 === c3 && 0 !== r3; ) t3.charCodeAt(r3 - 1) >> 8 && (c3 = true), r3--;
      if (!c3) return t3;
      for (s3 = e3.noBOM ? [] : [254, 255], r3 = 0, n2 = t3.length; r3 < n2; r3++) {
        if ((h2 = (u3 = t3.charCodeAt(r3)) >> 8) >> 8) throw new Error("Character at position " + r3 + " of string '" + t3 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
        s3.push(h2), s3.push(u3 - (h2 << 8));
      }
      return String.fromCharCode.apply(void 0, s3);
    }, Ce = y2.__private__.pdfEscape = y2.pdfEscape = function(t3, e3) {
      return Fe(t3, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
    }, je = y2.__private__.beginPage = function(t3) {
      ot2[++Dt2] = [], Rt2[Dt2] = {
        objId: 0,
        contentsObjId: 0,
        userUnit: Number(d2),
        artBox: null,
        bleedBox: null,
        cropBox: null,
        trimBox: null,
        mediaBox: {
          bottomLeftX: 0,
          bottomLeftY: 0,
          topRightX: Number(t3[0]),
          topRightY: Number(t3[1])
        }
      }, Me(Dt2), ht2(ot2[$2]);
    }, Oe = function(t3, e3) {
      var r3, n2, o3;
      switch (i2 = e3 || i2, "string" == typeof t3 && (r3 = A2(t3.toLowerCase()), Array.isArray(r3) && (n2 = r3[0], o3 = r3[1])), Array.isArray(t3) && (n2 = t3[0] * _t2, o3 = t3[1] * _t2), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a$1.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i2.substr(0, 1)) {
        case "l":
          o3 > n2 && (s2 = [o3, n2]);
          break;
        case "p":
          n2 > o3 && (s2 = [o3, n2]);
      }
      je(s2), pr(fr), lt2(Lr), 0 !== kr && lt2(kr + " J"), 0 !== Ir && lt2(Ir + " j"), Tt2.publish("addPage", {
        pageNumber: Dt2
      });
    }, Be = function(t3) {
      t3 > 0 && t3 <= Dt2 && (ot2.splice(t3, 1), Rt2.splice(t3, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
    }, Me = function(t3) {
      t3 > 0 && t3 <= Dt2 && ($2 = t3);
    }, Ee = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
      return ot2.length - 1;
    }, qe = function(t3, e3, r3) {
      var n2, i3 = void 0;
      return r3 = r3 || {}, t3 = void 0 !== t3 ? t3 : Ft2[St2].fontName, e3 = void 0 !== e3 ? e3 : Ft2[St2].fontStyle, n2 = t3.toLowerCase(), void 0 !== Ct2[n2] && void 0 !== Ct2[n2][e3] ? i3 = Ct2[n2][e3] : void 0 !== Ct2[t3] && void 0 !== Ct2[t3][e3] ? i3 = Ct2[t3][e3] : false === r3.disableWarning && a$1.warn("Unable to look up font label for font '" + t3 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i3 || r3.noFallback || null == (i3 = Ct2.times[e3]) && (i3 = Ct2.times.normal), i3;
    }, De = y2.__private__.putInfo = function() {
      var t3 = Xt2(), e3 = function(t4) {
        return t4;
      };
      for (var r3 in null !== m2 && (e3 = Ye.encryptor(t3, 0)), lt2("<<"), lt2("/Producer (" + Ce(e3("jsPDF " + E$1.version)) + ")"), xt2) xt2.hasOwnProperty(r3) && xt2[r3] && lt2("/" + r3.substr(0, 1).toUpperCase() + r3.substr(1) + " (" + Ce(e3(xt2[r3])) + ")");
      lt2("/CreationDate (" + Ce(e3(W2)) + ")"), lt2(">>"), lt2("endobj");
    }, Re = y2.__private__.putCatalog = function(t3) {
      var e3 = (t3 = t3 || {}).rootDictionaryObjId || Qt2;
      switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e3 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
        case "fullwidth":
          lt2("/OpenAction [3 0 R /FitH null]");
          break;
        case "fullheight":
          lt2("/OpenAction [3 0 R /FitV null]");
          break;
        case "fullpage":
          lt2("/OpenAction [3 0 R /Fit]");
          break;
        case "original":
          lt2("/OpenAction [3 0 R /XYZ null null 1]");
          break;
        default:
          var r3 = "" + mt2;
          "%" === r3.substr(r3.length - 1) && (mt2 = parseInt(mt2) / 100), "number" == typeof mt2 && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
      }
      switch (Nt2 || (Nt2 = "continuous"), Nt2) {
        case "continuous":
          lt2("/PageLayout /OneColumn");
          break;
        case "single":
          lt2("/PageLayout /SinglePage");
          break;
        case "two":
        case "twoleft":
          lt2("/PageLayout /TwoColumnLeft");
          break;
        case "tworight":
          lt2("/PageLayout /TwoColumnRight");
      }
      yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
    }, Te = y2.__private__.putTrailer = function() {
      lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), null !== m2 && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
    }, Ue = y2.__private__.putHeader = function() {
      lt2("%PDF-" + w2), lt2("%\xBA\xDF\xAC\xE0");
    }, ze = y2.__private__.putXRef = function() {
      var t3 = "0000000000";
      lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
      for (var e3 = 1; e3 <= et2; e3++) {
        "function" == typeof rt2[e3] ? lt2((t3 + rt2[e3]()).slice(-10) + " 00000 n ") : void 0 !== rt2[e3] ? lt2((t3 + rt2[e3]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
      }
    }, He = y2.__private__.buildDocument = function() {
      ut2(), ht2(nt2), Tt2.publish("buildDocument"), Ue(), oe2(), Se(), xe(), null !== m2 && be2(), De(), Re();
      var t3 = it2;
      return ze(), Te(), lt2("startxref"), lt2("" + t3), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
    }, We = y2.__private__.getBlob = function(t3) {
      return new Blob([dt2(t3)], {
        type: "application/pdf"
      });
    }, Ve = y2.output = y2.__private__.output = Ie(function(t3, e3) {
      switch ("string" == typeof (e3 = e3 || {}) ? e3 = {
        filename: e3
      } : e3.filename = e3.filename || "generated.pdf", t3) {
        case void 0:
          return He();
        case "save":
          y2.save(e3.filename);
          break;
        case "arraybuffer":
          return dt2(He());
        case "blob":
          return We(He());
        case "bloburi":
        case "bloburl":
          if (void 0 !== n$1.URL && "function" == typeof n$1.URL.createObjectURL) return n$1.URL && n$1.URL.createObjectURL(We(He())) || void 0;
          a$1.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
          break;
        case "datauristring":
        case "dataurlstring":
          var r3 = "", i3 = He();
          try {
            r3 = h$2(i3);
          } catch (t4) {
            r3 = h$2(unescape(encodeURIComponent(i3)));
          }
          return "data:application/pdf;filename=" + e3.filename + ";base64," + r3;
        case "pdfobjectnewwindow":
          if ("[object Window]" === Object.prototype.toString.call(n$1)) {
            var o3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
            e3.pdfObjectUrl && (o3 = e3.pdfObjectUrl, s3 = "");
            var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o3 + '"' + s3 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");<\/script></body></html>", u3 = n$1.open();
            return null !== u3 && u3.document.write(c3), u3;
          }
          throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
        case "pdfjsnewwindow":
          if ("[object Window]" === Object.prototype.toString.call(n$1)) {
            var l2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', f2 = n$1.open();
            if (null !== f2) {
              f2.document.write(l2);
              var d3 = this;
              f2.document.documentElement.querySelector("#pdfViewer").onload = function() {
                f2.document.title = e3.filename, f2.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d3.output("bloburl"));
              };
            }
            return f2;
          }
          throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
        case "dataurlnewwindow":
          if ("[object Window]" !== Object.prototype.toString.call(n$1)) throw new Error("The option dataurlnewwindow just works in a browser-environment.");
          var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', g3 = n$1.open();
          if (null !== g3 && (g3.document.write(p3), g3.document.title = e3.filename), g3 || "undefined" == typeof safari) return g3;
          break;
        case "datauri":
        case "dataurl":
          return n$1.document.location.href = this.output("datauristring", e3);
        default:
          return null;
      }
    }), Ge = function(t3) {
      return true === Array.isArray(Ut2) && Ut2.indexOf(t3) > -1;
    };
    switch (o2) {
      case "pt":
        _t2 = 1;
        break;
      case "mm":
        _t2 = 72 / 25.4;
        break;
      case "cm":
        _t2 = 72 / 2.54;
        break;
      case "in":
        _t2 = 72;
        break;
      case "px":
        _t2 = 1 == Ge("px_scaling") ? 0.75 : 96 / 72;
        break;
      case "pc":
      case "em":
        _t2 = 12;
        break;
      case "ex":
        _t2 = 6;
        break;
      default:
        if ("number" != typeof o2) throw new Error("Invalid unit: " + o2);
        _t2 = o2;
    }
    var Ye = null;
    K2(), Y2();
    var Je = function(t3) {
      return null !== m2 ? Ye.encryptor(t3, 0) : function(t4) {
        return t4;
      };
    }, Xe = y2.__private__.getPageInfo = y2.getPageInfo = function(t3) {
      if (isNaN(t3) || t3 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
      return {
        objId: Rt2[t3].objId,
        pageNumber: t3,
        pageContext: Rt2[t3]
      };
    }, Ke = y2.__private__.getPageInfoByObjId = function(t3) {
      if (isNaN(t3) || t3 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
      for (var e3 in Rt2) if (Rt2[e3].objId === t3) break;
      return Xe(e3);
    }, Ze = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
      return {
        objId: Rt2[$2].objId,
        pageNumber: $2,
        pageContext: Rt2[$2]
      };
    };
    y2.addPage = function() {
      return Oe.apply(this, arguments), this;
    }, y2.setPage = function() {
      return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
    }, y2.insertPage = function(t3) {
      return this.addPage(), this.movePage($2, t3), this;
    }, y2.movePage = function(t3, e3) {
      var r3, n2;
      if (t3 > e3) {
        r3 = ot2[t3], n2 = Rt2[t3];
        for (var i3 = t3; i3 > e3; i3--) ot2[i3] = ot2[i3 - 1], Rt2[i3] = Rt2[i3 - 1];
        ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);
      } else if (t3 < e3) {
        r3 = ot2[t3], n2 = Rt2[t3];
        for (var a2 = t3; a2 < e3; a2++) ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];
        ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);
      }
      return this;
    }, y2.deletePage = function() {
      return Be.apply(this, arguments), this;
    }, y2.__private__.text = y2.text = function(e3, r3, n2, i3, a2) {
      var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3 = (i3 = i3 || {}).scope || this;
      if ("number" == typeof e3 && "number" == typeof r3 && ("string" == typeof n2 || Array.isArray(n2))) {
        var m3 = n2;
        n2 = r3, r3 = e3, e3 = m3;
      }
      if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], "object" === _typeof$1(f2 = arguments[3]) && null !== f2 || ("string" == typeof c3 && (u3 = c3, c3 = null), "string" == typeof f2 && (u3 = f2, f2 = null), "number" == typeof f2 && (c3 = f2, f2 = null), i3 = {
        flags: f2,
        angle: c3,
        align: u3
      })) : (q2("The transform parameter of text() with a Matrix value"), p3 = a2), isNaN(r3) || isNaN(n2) || null == e3) throw new Error("Invalid arguments passed to jsPDF.text");
      if (0 === e3.length) return g3;
      var v3 = "", y3 = false, w3 = "number" == typeof i3.lineHeightFactor ? i3.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;
      function L3(t3) {
        return t3 = t3.split("	").join(Array(i3.TabLen || 9).join(" ")), Ce(t3, f2);
      }
      function A3(t3) {
        for (var e4, r4 = t3.concat(), n3 = [], i4 = r4.length; i4--; ) "string" == typeof (e4 = r4.shift()) ? n3.push(e4) : Array.isArray(t3) && (1 === e4.length || void 0 === e4[1] && void 0 === e4[2]) ? n3.push(e4[0]) : n3.push([e4[0], e4[1], e4[2]]);
        return n3;
      }
      function _3(t3, e4) {
        var r4;
        if ("string" == typeof t3) r4 = e4(t3)[0];
        else if (Array.isArray(t3)) {
          for (var n3, i4, a3 = t3.concat(), o4 = [], s4 = a3.length; s4--; ) "string" == typeof (n3 = a3.shift()) ? o4.push(e4(n3)[0]) : Array.isArray(n3) && "string" == typeof n3[0] && (i4 = e4(n3[0], n3[1], n3[2]), o4.push([i4[0], i4[1], i4[2]]));
          r4 = o4;
        }
        return r4;
      }
      var P3 = false, k3 = true;
      if ("string" == typeof e3) P3 = true;
      else if (Array.isArray(e3)) {
        var I2 = e3.concat();
        s3 = [];
        for (var F2, C2 = I2.length; C2--; ) ("string" != typeof (F2 = I2.shift()) || Array.isArray(F2) && "string" != typeof F2[0]) && (k3 = false);
        P3 = k3;
      }
      if (false === P3) throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
      "string" == typeof e3 && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
      var j2 = gt2 / g3.internal.scaleFactor, B2 = j2 * (w3 - 1);
      switch (i3.baseline) {
        case "bottom":
          n2 -= B2;
          break;
        case "top":
          n2 += j2 - B2;
          break;
        case "hanging":
          n2 += j2 - 2 * B2;
          break;
        case "middle":
          n2 += j2 / 2 - B2;
      }
      if ((l2 = i3.maxWidth || 0) > 0 && ("string" == typeof e3 ? e3 = g3.splitTextToSize(e3, l2) : "[object Array]" === Object.prototype.toString.call(e3) && (e3 = e3.reduce(function(t3, e4) {
        return t3.concat(g3.splitTextToSize(e4, l2));
      }, []))), o3 = {
        text: e3,
        x: r3,
        y: n2,
        options: i3,
        mutex: {
          pdfEscape: Ce,
          activeFontKey: St2,
          fonts: Ft2,
          activeFontSize: gt2
        }
      }, Tt2.publish("preProcessText", o3), e3 = o3.text, c3 = (i3 = o3.options).angle, p3 instanceof Vt2 == false && c3 && "number" == typeof c3) {
        c3 *= Math.PI / 180, 0 === i3.rotationDirection && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);
        var M2 = Math.cos(c3), E2 = Math.sin(c3);
        p3 = new Vt2(M2, E2, -E2, M2, 0, 0);
      } else c3 && c3 instanceof Vt2 && (p3 = c3);
      S2 !== x2.ADVANCED || p3 || (p3 = Yt2), void 0 !== (h2 = i3.charSpace || _r) && (v3 += O2(U2(h2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d3 = i3.horizontalScale) && (v3 += O2(100 * d3) + " Tz\n"), i3.lang;
      var D3 = -1, R3 = void 0 !== i3.renderingMode ? i3.renderingMode : i3.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
      switch (R3) {
        case 0:
        case false:
        case "fill":
          D3 = 0;
          break;
        case 1:
        case true:
        case "stroke":
          D3 = 1;
          break;
        case 2:
        case "fillThenStroke":
          D3 = 2;
          break;
        case 3:
        case "invisible":
          D3 = 3;
          break;
        case 4:
        case "fillAndAddForClipping":
          D3 = 4;
          break;
        case 5:
        case "strokeAndAddPathForClipping":
          D3 = 5;
          break;
        case 6:
        case "fillThenStrokeAndAddToPathForClipping":
          D3 = 6;
          break;
        case 7:
        case "addToPathForClipping":
          D3 = 7;
      }
      var z3 = void 0 !== T3.usedRenderingMode ? T3.usedRenderingMode : -1;
      -1 !== D3 ? v3 += D3 + " Tr\n" : -1 !== z3 && (v3 += "0 Tr\n"), -1 !== D3 && (T3.usedRenderingMode = D3), u3 = i3.align || "left";
      var H3, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St2];
      h2 = i3.charSpace || _r, l2 = i3.maxWidth || 0, f2 = Object.assign({
        autoencode: true,
        noBOM: true
      }, i3.flags);
      var Y3 = [], J3 = function(t3) {
        return g3.getStringUnitWidth(t3, {
          font: G3,
          charSpace: h2,
          fontSize: gt2,
          doKerning: false
        }) * gt2 / N3;
      };
      if ("[object Array]" === Object.prototype.toString.call(e3)) {
        var X3;
        s3 = A3(e3), "left" !== u3 && (H3 = s3.map(J3));
        var K3, Z3 = 0;
        if ("right" === u3) {
          r3 -= H3[0], e3 = [], C2 = s3.length;
          for (var $3 = 0; $3 < C2; $3++) 0 === $3 ? (K3 = br(r3), X3 = yr(n2)) : (K3 = U2(Z3 - H3[$3]), X3 = -W3), e3.push([s3[$3], K3, X3]), Z3 = H3[$3];
        } else if ("center" === u3) {
          r3 -= H3[0] / 2, e3 = [], C2 = s3.length;
          for (var Q3 = 0; Q3 < C2; Q3++) 0 === Q3 ? (K3 = br(r3), X3 = yr(n2)) : (K3 = U2((Z3 - H3[Q3]) / 2), X3 = -W3), e3.push([s3[Q3], K3, X3]), Z3 = H3[Q3];
        } else if ("left" === u3) {
          e3 = [], C2 = s3.length;
          for (var tt3 = 0; tt3 < C2; tt3++) e3.push(s3[tt3]);
        } else if ("justify" === u3 && "Identity-H" === G3.encoding) {
          e3 = [], C2 = s3.length, l2 = 0 !== l2 ? l2 : V3;
          for (var et3 = 0, rt3 = 0; rt3 < C2; rt3++) if (X3 = 0 === rt3 ? yr(n2) : -W3, K3 = 0 === rt3 ? br(r3) : et3, rt3 < C2 - 1) {
            var nt3 = U2((l2 - H3[rt3]) / (s3[rt3].split(" ").length - 1)), it3 = s3[rt3].split(" ");
            e3.push([it3[0] + " ", K3, X3]), et3 = 0;
            for (var at3 = 1; at3 < it3.length; at3++) {
              var ot3 = (J3(it3[at3 - 1] + " " + it3[at3]) - J3(it3[at3])) * N3 + nt3;
              at3 == it3.length - 1 ? e3.push([it3[at3], ot3, 0]) : e3.push([it3[at3] + " ", ot3, 0]), et3 -= ot3;
            }
          } else e3.push([s3[rt3], K3, X3]);
          e3.push(["", et3, 0]);
        } else {
          if ("justify" !== u3) throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
          e3 = [], C2 = s3.length, l2 = 0 !== l2 ? l2 : V3;
          for (rt3 = 0; rt3 < C2; rt3++) X3 = 0 === rt3 ? yr(n2) : -W3, K3 = 0 === rt3 ? br(r3) : 0, rt3 < C2 - 1 ? Y3.push(O2(U2((l2 - H3[rt3]) / (s3[rt3].split(" ").length - 1)))) : Y3.push(0), e3.push([s3[rt3], K3, X3]);
        }
      }
      var st3 = "boolean" == typeof i3.R2L ? i3.R2L : bt2;
      true === st3 && (e3 = _3(e3, function(t3, e4, r4) {
        return [t3.split("").reverse().join(""), e4, r4];
      })), o3 = {
        text: e3,
        x: r3,
        y: n2,
        options: i3,
        mutex: {
          pdfEscape: Ce,
          activeFontKey: St2,
          fonts: Ft2,
          activeFontSize: gt2
        }
      }, Tt2.publish("postProcessText", o3), e3 = o3.text, y3 = o3.mutex.isHex || false;
      var ct3 = Ft2[St2].encoding;
      "WinAnsiEncoding" !== ct3 && "StandardEncoding" !== ct3 || (e3 = _3(e3, function(t3, e4, r4) {
        return [L3(t3), e4, r4];
      })), s3 = A3(e3), e3 = [];
      for (var ut3, ht3, ft3, dt3 = 0, pt3 = 1, mt3 = Array.isArray(s3[0]) ? pt3 : dt3, vt3 = "", yt3 = function(t3, e4, r4) {
        var n3 = "";
        return r4 instanceof Vt2 ? (r4 = "number" == typeof i3.angle ? Gt2(r4, new Vt2(1, 0, 0, 1, t3, e4)) : Gt2(new Vt2(1, 0, 0, 1, t3, e4), r4), S2 === x2.ADVANCED && (r4 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r4)), n3 = r4.join(" ") + " Tm\n") : n3 = O2(t3) + " " + O2(e4) + " Td\n", n3;
      }, wt3 = 0; wt3 < s3.length; wt3++) {
        switch (vt3 = "", mt3) {
          case pt3:
            ft3 = (y3 ? "<" : "(") + s3[wt3][0] + (y3 ? ">" : ")"), ut3 = parseFloat(s3[wt3][1]), ht3 = parseFloat(s3[wt3][2]);
            break;
          case dt3:
            ft3 = (y3 ? "<" : "(") + s3[wt3] + (y3 ? ">" : ")"), ut3 = br(r3), ht3 = yr(n2);
        }
        void 0 !== Y3 && void 0 !== Y3[wt3] && (vt3 = Y3[wt3] + " Tw\n"), 0 === wt3 ? e3.push(vt3 + yt3(ut3, ht3, p3) + ft3) : mt3 === dt3 ? e3.push(vt3 + ft3) : mt3 === pt3 && e3.push(vt3 + yt3(ut3, ht3, p3) + ft3);
      }
      e3 = mt3 === dt3 ? e3.join(" Tj\nT* ") : e3.join(" Tj\n"), e3 += " Tj\n";
      var Nt3 = "BT\n/";
      return Nt3 += St2 + " " + gt2 + " Tf\n", Nt3 += O2(gt2 * w3) + " TL\n", Nt3 += xr + "\n", Nt3 += v3, Nt3 += e3, lt2(Nt3 += "ET"), b2[St2] = true, g3;
    };
    var $e = y2.__private__.clip = y2.clip = function(t3) {
      return lt2("evenodd" === t3 ? "W*" : "W"), this;
    };
    y2.clipEvenOdd = function() {
      return $e("evenodd");
    }, y2.__private__.discardPath = y2.discardPath = function() {
      return lt2("n"), this;
    };
    var Qe = y2.__private__.isValidStyle = function(t3) {
      var e3 = false;
      return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t3) && (e3 = true), e3;
    };
    y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t3) {
      return Qe(t3) && (g2 = t3), this;
    };
    var tr = y2.__private__.getStyle = y2.getStyle = function(t3) {
      var e3 = g2;
      switch (t3) {
        case "D":
        case "S":
          e3 = "S";
          break;
        case "F":
          e3 = "f";
          break;
        case "FD":
        case "DF":
          e3 = "B";
          break;
        case "f":
        case "f*":
        case "B":
        case "B*":
          e3 = t3;
      }
      return e3;
    }, er = y2.close = function() {
      return lt2("h"), this;
    };
    y2.stroke = function() {
      return lt2("S"), this;
    }, y2.fill = function(t3) {
      return rr("f", t3), this;
    }, y2.fillEvenOdd = function(t3) {
      return rr("f*", t3), this;
    }, y2.fillStroke = function(t3) {
      return rr("B", t3), this;
    }, y2.fillStrokeEvenOdd = function(t3) {
      return rr("B*", t3), this;
    };
    var rr = function(e3, r3) {
      "object" === _typeof$1(r3) ? ar(r3, e3) : lt2(e3);
    }, nr = function(t3) {
      null === t3 || S2 === x2.ADVANCED && void 0 === t3 || (t3 = tr(t3), lt2(t3));
    };
    function ir(t3, e3, r3, n2, i3) {
      var a2 = new M$1(e3 || this.boundingBox, r3 || this.xStep, n2 || this.yStep, this.gState, i3 || this.matrix);
      a2.stream = this.stream;
      var o3 = t3 + "$$" + this.cloneIndex++ + "$$";
      return Jt2(o3, a2), a2;
    }
    var ar = function(t3, e3) {
      var r3 = Bt2[t3.key], n2 = Ot2[r3];
      if (n2 instanceof B$1) lt2("q"), lt2(or(e3)), n2.gState && y2.setGState(n2.gState), lt2(t3.matrix.toString() + " cm"), lt2("/" + r3 + " sh"), lt2("Q");
      else if (n2 instanceof M$1) {
        var i3 = new Vt2(1, 0, 0, -1, 0, Rr());
        t3.matrix && (i3 = i3.multiply(t3.matrix || Yt2), r3 = ir.call(n2, t3.key, t3.boundingBox, t3.xStep, t3.yStep, i3).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r3 + " scn"), n2.gState && y2.setGState(n2.gState), lt2(e3), lt2("Q");
      }
    }, or = function(t3) {
      switch (t3) {
        case "f":
        case "F":
          return "W n";
        case "f*":
          return "W* n";
        case "B":
          return "W S";
        case "B*":
          return "W* S";
        case "S":
          return "W S";
        case "n":
          return "W n";
      }
    }, sr = y2.moveTo = function(t3, e3) {
      return lt2(O2(U2(t3)) + " " + O2(H2(e3)) + " m"), this;
    }, cr = y2.lineTo = function(t3, e3) {
      return lt2(O2(U2(t3)) + " " + O2(H2(e3)) + " l"), this;
    }, ur = y2.curveTo = function(t3, e3, r3, n2, i3, a2) {
      return lt2([O2(U2(t3)), O2(H2(e3)), O2(U2(r3)), O2(H2(n2)), O2(U2(i3)), O2(H2(a2)), "c"].join(" ")), this;
    };
    y2.__private__.line = y2.line = function(t3, e3, r3, n2, i3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3)) throw new Error("Invalid arguments passed to jsPDF.line");
      return S2 === x2.COMPAT ? this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1], i3 || "S") : this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1]).stroke();
    }, y2.__private__.lines = y2.lines = function(t3, e3, r3, n2, i3, a2) {
      var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3, m3, v3;
      if ("number" == typeof t3 && (v3 = r3, r3 = e3, e3 = t3, t3 = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e3) || isNaN(r3) || !Array.isArray(t3) || !Array.isArray(n2) || !Qe(i3) || "boolean" != typeof a2) throw new Error("Invalid arguments passed to jsPDF.lines");
      for (sr(e3, r3), o3 = n2[0], s3 = n2[1], u3 = t3.length, g3 = e3, m3 = r3, c3 = 0; c3 < u3; c3++) 2 === (h2 = t3[c3]).length ? (g3 = h2[0] * o3 + g3, m3 = h2[1] * s3 + m3, cr(g3, m3)) : (l2 = h2[0] * o3 + g3, f2 = h2[1] * s3 + m3, d3 = h2[2] * o3 + g3, p3 = h2[3] * s3 + m3, g3 = h2[4] * o3 + g3, m3 = h2[5] * s3 + m3, ur(l2, f2, d3, p3, g3, m3));
      return a2 && er(), nr(i3), this;
    }, y2.path = function(t3) {
      for (var e3 = 0; e3 < t3.length; e3++) {
        var r3 = t3[e3], n2 = r3.c;
        switch (r3.op) {
          case "m":
            sr(n2[0], n2[1]);
            break;
          case "l":
            cr(n2[0], n2[1]);
            break;
          case "c":
            ur.apply(this, n2);
            break;
          case "h":
            er();
        }
      }
      return this;
    }, y2.__private__.rect = y2.rect = function(t3, e3, r3, n2, i3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3)) throw new Error("Invalid arguments passed to jsPDF.rect");
      return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(U2(t3)), O2(H2(e3)), O2(U2(r3)), O2(U2(n2)), "re"].join(" ")), nr(i3), this;
    }, y2.__private__.triangle = y2.triangle = function(t3, e3, r3, n2, i3, a2, o3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3)) throw new Error("Invalid arguments passed to jsPDF.triangle");
      return this.lines([[r3 - t3, n2 - e3], [i3 - r3, a2 - n2], [t3 - i3, e3 - a2]], t3, e3, [1, 1], o3, true), this;
    }, y2.__private__.roundedRect = y2.roundedRect = function(t3, e3, r3, n2, i3, a2, o3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
      var s3 = 4 / 3 * (Math.SQRT2 - 1);
      return i3 = Math.min(i3, 0.5 * r3), a2 = Math.min(a2, 0.5 * n2), this.lines([[r3 - 2 * i3, 0], [i3 * s3, 0, i3, a2 - a2 * s3, i3, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i3 * s3, a2, -i3, a2], [2 * i3 - r3, 0], [-i3 * s3, 0, -i3, -a2 * s3, -i3, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i3 * s3, -a2, i3, -a2]], t3 + i3, e3, [1, 1], o3, true), this;
    }, y2.__private__.ellipse = y2.ellipse = function(t3, e3, r3, n2, i3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
      var a2 = 4 / 3 * (Math.SQRT2 - 1) * r3, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
      return sr(t3 + r3, e3), ur(t3 + r3, e3 - o3, t3 + a2, e3 - n2, t3, e3 - n2), ur(t3 - a2, e3 - n2, t3 - r3, e3 - o3, t3 - r3, e3), ur(t3 - r3, e3 + o3, t3 - a2, e3 + n2, t3, e3 + n2), ur(t3 + a2, e3 + n2, t3 + r3, e3 + o3, t3 + r3, e3), nr(i3), this;
    }, y2.__private__.circle = y2.circle = function(t3, e3, r3, n2) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || !Qe(n2)) throw new Error("Invalid arguments passed to jsPDF.circle");
      return this.ellipse(t3, e3, r3, r3, n2);
    }, y2.setFont = function(t3, e3, r3) {
      return r3 && (e3 = k2(e3, r3)), St2 = qe(t3, e3, {
        disableWarning: false
      }), this;
    };
    var hr = y2.__private__.getFont = y2.getFont = function() {
      return Ft2[qe.apply(y2, arguments)];
    };
    y2.__private__.getFontList = y2.getFontList = function() {
      var t3, e3, r3 = {};
      for (t3 in Ct2) if (Ct2.hasOwnProperty(t3)) for (e3 in r3[t3] = [], Ct2[t3]) Ct2[t3].hasOwnProperty(e3) && r3[t3].push(e3);
      return r3;
    }, y2.addFont = function(t3, e3, r3, n2, i3) {
      var a2 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
      return arguments[3] && -1 !== a2.indexOf(arguments[3]) ? i3 = arguments[3] : arguments[3] && -1 == a2.indexOf(arguments[3]) && (r3 = k2(r3, n2)), i3 = i3 || "Identity-H", Pe.call(this, t3, e3, r3, i3);
    };
    var lr, fr = e2.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {
      return fr;
    }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t3) {
      return fr = t3, lt2(O2(U2(t3)) + " w"), this;
    };
    y2.__private__.setLineDash = E$1.API.setLineDash = E$1.API.setLineDashPattern = function(t3, e3) {
      if (t3 = t3 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t3)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
      return t3 = t3.map(function(t4) {
        return O2(U2(t4));
      }).join(" "), e3 = O2(U2(e3)), lt2("[" + t3 + "] " + e3 + " d"), this;
    };
    var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {
      return gt2 * lr;
    };
    y2.__private__.getLineHeight = y2.getLineHeight = function() {
      return gt2 * lr;
    };
    var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t3) {
      return "number" == typeof (t3 = t3 || 1.15) && (lr = t3), this;
    }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
      return lr;
    };
    mr(e2.lineHeight);
    var br = y2.__private__.getHorizontalCoordinate = function(t3) {
      return U2(t3);
    }, yr = y2.__private__.getVerticalCoordinate = function(t3) {
      return S2 === x2.ADVANCED ? t3 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t3);
    }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t3) {
      return O2(br(t3));
    }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t3) {
      return O2(yr(t3));
    }, Lr = e2.strokeColor || "0 G";
    y2.__private__.getStrokeColor = y2.getDrawColor = function() {
      return ee2(Lr);
    }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t3, e3, r3, n2) {
      return Lr = re2({
        ch1: t3,
        ch2: e3,
        ch3: r3,
        ch4: n2,
        pdfColorType: "draw",
        precision: 2
      }), lt2(Lr), this;
    };
    var Ar = e2.fillColor || "0 g";
    y2.__private__.getFillColor = y2.getFillColor = function() {
      return ee2(Ar);
    }, y2.__private__.setFillColor = y2.setFillColor = function(t3, e3, r3, n2) {
      return Ar = re2({
        ch1: t3,
        ch2: e3,
        ch3: r3,
        ch4: n2,
        pdfColorType: "fill",
        precision: 2
      }), lt2(Ar), this;
    };
    var xr = e2.textColor || "0 g", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {
      return ee2(xr);
    };
    y2.__private__.setTextColor = y2.setTextColor = function(t3, e3, r3, n2) {
      return xr = re2({
        ch1: t3,
        ch2: e3,
        ch3: r3,
        ch4: n2,
        pdfColorType: "text",
        precision: 3
      }), this;
    };
    var _r = e2.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {
      return parseFloat(_r || 0);
    };
    y2.__private__.setCharSpace = y2.setCharSpace = function(t3) {
      if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
      return _r = t3, this;
    };
    var kr = 0;
    y2.CapJoinStyles = {
      0: 0,
      butt: 0,
      but: 0,
      miter: 0,
      1: 1,
      round: 1,
      rounded: 1,
      circle: 1,
      2: 2,
      projecting: 2,
      project: 2,
      square: 2,
      bevel: 2
    }, y2.__private__.setLineCap = y2.setLineCap = function(t3) {
      var e3 = y2.CapJoinStyles[t3];
      if (void 0 === e3) throw new Error("Line cap style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
      return kr = e3, lt2(e3 + " J"), this;
    };
    var Ir = 0;
    y2.__private__.setLineJoin = y2.setLineJoin = function(t3) {
      var e3 = y2.CapJoinStyles[t3];
      if (void 0 === e3) throw new Error("Line join style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
      return Ir = e3, lt2(e3 + " j"), this;
    }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t3) {
      if (t3 = t3 || 0, isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
      return lt2(O2(U2(t3)) + " M"), this;
    }, y2.GState = j$1, y2.setGState = function(t3) {
      (t3 = "string" == typeof t3 ? Mt2[Et2[t3]] : Fr(null, t3)).equals(qt2) || (lt2("/" + t3.id + " gs"), qt2 = t3);
    };
    var Fr = function(t3, e3) {
      if (!t3 || !Et2[t3]) {
        var r3 = false;
        for (var n2 in Mt2) if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e3)) {
          r3 = true;
          break;
        }
        if (r3) e3 = Mt2[n2];
        else {
          var i3 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
          Mt2[i3] = e3, e3.id = i3;
        }
        return t3 && (Et2[t3] = e3.id), Tt2.publish("addGState", e3), e3;
      }
    };
    y2.addGState = function(t3, e3) {
      return Fr(t3, e3), this;
    }, y2.saveGraphicsState = function() {
      return lt2("q"), jt2.push({
        key: St2,
        size: gt2,
        color: xr
      }), this;
    }, y2.restoreGraphicsState = function() {
      lt2("Q");
      var t3 = jt2.pop();
      return St2 = t3.key, gt2 = t3.size, xr = t3.color, qt2 = null, this;
    }, y2.setCurrentTransformationMatrix = function(t3) {
      return lt2(t3.toString() + " cm"), this;
    }, y2.comment = function(t3) {
      return lt2("#" + t3), this;
    };
    var Cr = function(t3, e3) {
      var r3 = t3 || 0;
      Object.defineProperty(this, "x", {
        enumerable: true,
        get: function() {
          return r3;
        },
        set: function(t4) {
          isNaN(t4) || (r3 = parseFloat(t4));
        }
      });
      var n2 = e3 || 0;
      Object.defineProperty(this, "y", {
        enumerable: true,
        get: function() {
          return n2;
        },
        set: function(t4) {
          isNaN(t4) || (n2 = parseFloat(t4));
        }
      });
      var i3 = "pt";
      return Object.defineProperty(this, "type", {
        enumerable: true,
        get: function() {
          return i3;
        },
        set: function(t4) {
          i3 = t4.toString();
        }
      }), this;
    }, jr = function(t3, e3, r3, n2) {
      Cr.call(this, t3, e3), this.type = "rect";
      var i3 = r3 || 0;
      Object.defineProperty(this, "w", {
        enumerable: true,
        get: function() {
          return i3;
        },
        set: function(t4) {
          isNaN(t4) || (i3 = parseFloat(t4));
        }
      });
      var a2 = n2 || 0;
      return Object.defineProperty(this, "h", {
        enumerable: true,
        get: function() {
          return a2;
        },
        set: function(t4) {
          isNaN(t4) || (a2 = parseFloat(t4));
        }
      }), this;
    }, Or = function() {
      this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
    };
    Or.prototype.restore = function() {
      Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
    };
    var Br = function(t3, e3, r3, n2, i3) {
      Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t3, kt2 = e3, It2 = i3, je([r3, n2]);
    }, Mr = function(t3) {
      if (Ht2[t3]) Wt2.pop().restore();
      else {
        var e3 = new Or(), r3 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
        e3.id = r3, Ht2[t3] = r3, zt2[r3] = e3, Tt2.publish("addFormObject", e3), Wt2.pop().restore();
      }
    };
    for (var Er in y2.beginFormObject = function(t3, e3, r3, n2, i3) {
      return Br(t3, e3, r3, n2, i3), this;
    }, y2.endFormObject = function(t3) {
      return Mr(t3), this;
    }, y2.doFormObject = function(t3, e3) {
      var r3 = zt2[Ht2[t3]];
      return lt2("q"), lt2(e3.toString() + " cm"), lt2("/" + r3.id + " Do"), lt2("Q"), this;
    }, y2.getFormObject = function(t3) {
      var e3 = zt2[Ht2[t3]];
      return {
        x: e3.x,
        y: e3.y,
        width: e3.width,
        height: e3.height,
        matrix: e3.matrix
      };
    }, y2.save = function(t3, e3) {
      return t3 = t3 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, false === e3.returnPromise ? (l$2(We(He()), t3), "function" == typeof l$2.unload && n$1.setTimeout && setTimeout(l$2.unload, 911), this) : new Promise(function(e4, r3) {
        try {
          var i3 = l$2(We(He()), t3);
          "function" == typeof l$2.unload && n$1.setTimeout && setTimeout(l$2.unload, 911), e4(i3);
        } catch (t4) {
          r3(t4.message);
        }
      });
    }, E$1.API) E$1.API.hasOwnProperty(Er) && ("events" === Er && E$1.API.events.length ? (function(t3, e3) {
      var r3, n2, i3;
      for (i3 = e3.length - 1; -1 !== i3; i3--) r3 = e3[i3][0], n2 = e3[i3][1], t3.subscribe.apply(t3, [r3].concat("function" == typeof n2 ? [n2] : n2));
    })(Tt2, E$1.API.events) : y2[Er] = E$1.API[Er]);
    var qr = y2.getPageWidth = function(t3) {
      return (Rt2[t3 = t3 || $2].mediaBox.topRightX - Rt2[t3].mediaBox.bottomLeftX) / _t2;
    }, Dr = y2.setPageWidth = function(t3, e3) {
      Rt2[t3].mediaBox.topRightX = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftX;
    }, Rr = y2.getPageHeight = function(t3) {
      return (Rt2[t3 = t3 || $2].mediaBox.topRightY - Rt2[t3].mediaBox.bottomLeftY) / _t2;
    }, Tr = y2.setPageHeight = function(t3, e3) {
      Rt2[t3].mediaBox.topRightY = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftY;
    };
    return y2.internal = {
      pdfEscape: Ce,
      getStyle: tr,
      getFont: hr,
      getFontSize: vt2,
      getCharSpace: Pr,
      getTextColor: Sr,
      getLineHeight: gr,
      getLineHeightFactor: vr,
      getLineWidth: dr,
      write: ft2,
      getHorizontalCoordinate: br,
      getVerticalCoordinate: yr,
      getCoordinateString: wr,
      getVerticalCoordinateString: Nr,
      collections: {},
      newObject: Xt2,
      newAdditionalObject: $t2,
      newObjectDeferred: Kt2,
      newObjectDeferredBegin: Zt2,
      getFilters: ne2,
      putStream: ie2,
      events: Tt2,
      scaleFactor: _t2,
      pageSize: {
        getWidth: function() {
          return qr($2);
        },
        setWidth: function(t3) {
          Dr($2, t3);
        },
        getHeight: function() {
          return Rr($2);
        },
        setHeight: function(t3) {
          Tr($2, t3);
        }
      },
      encryptionOptions: m2,
      encryption: Ye,
      getEncryptor: Je,
      output: Ve,
      getNumberOfPages: Ee,
      pages: ot2,
      out: lt2,
      f2: R2,
      f3: T2,
      getPageInfo: Xe,
      getPageInfoByObjId: Ke,
      getCurrentPageInfo: Ze,
      getPDFVersion: N2,
      Point: Cr,
      Rectangle: jr,
      Matrix: Vt2,
      hasHotfix: Ge
    }, Object.defineProperty(y2.internal.pageSize, "width", {
      get: function() {
        return qr($2);
      },
      set: function(t3) {
        Dr($2, t3);
      },
      enumerable: true,
      configurable: true
    }), Object.defineProperty(y2.internal.pageSize, "height", {
      get: function() {
        return Rr($2);
      },
      set: function(t3) {
        Tr($2, t3);
      },
      enumerable: true,
      configurable: true
    }), ke.call(y2, pt2), St2 = "F1", Oe(s2, i2), Tt2.publish("initialized"), y2;
  }
  I$1.prototype.lsbFirstWord = function(t3) {
    return String.fromCharCode(t3 >> 0 & 255, t3 >> 8 & 255, t3 >> 16 & 255, t3 >> 24 & 255);
  }, I$1.prototype.toHexString = function(t3) {
    return t3.split("").map(function(t4) {
      return ("0" + (255 & t4.charCodeAt(0)).toString(16)).slice(-2);
    }).join("");
  }, I$1.prototype.hexToBytes = function(t3) {
    for (var e2 = [], r2 = 0; r2 < t3.length; r2 += 2) e2.push(String.fromCharCode(parseInt(t3.substr(r2, 2), 16)));
    return e2.join("");
  }, I$1.prototype.processOwnerPassword = function(t3, e2) {
    return P$1(x$1(e2).substr(0, 5), t3);
  }, I$1.prototype.encryptor = function(t3, e2) {
    var r2 = x$1(this.encryptionKey + String.fromCharCode(255 & t3, t3 >> 8 & 255, t3 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);
    return function(t4) {
      return P$1(r2, t4);
    };
  }, j$1.prototype.equals = function(e2) {
    var r2, n2 = "id,objectNumber,equals";
    if (!e2 || _typeof$1(e2) !== _typeof$1(this)) return false;
    var i2 = 0;
    for (r2 in this) if (!(n2.indexOf(r2) >= 0)) {
      if (this.hasOwnProperty(r2) && !e2.hasOwnProperty(r2)) return false;
      if (this[r2] !== e2[r2]) return false;
      i2++;
    }
    for (r2 in e2) e2.hasOwnProperty(r2) && n2.indexOf(r2) < 0 && i2--;
    return 0 === i2;
  }, E$1.API = {
    events: []
  }, E$1.version = "3.0.1";
  var q$1 = E$1.API;
  var D$1 = 1;
  var R$1 = function(t3) {
    return t3.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  };
  var T$2 = function(t3) {
    return t3.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
  };
  var U$1 = function(t3) {
    return t3.toFixed(2);
  };
  var z$1 = function(t3) {
    return t3.toFixed(5);
  };
  q$1.__acroform__ = {};
  var H$1 = function(t3, e2) {
    t3.prototype = Object.create(e2.prototype), t3.prototype.constructor = t3;
  };
  var W$1 = function(t3) {
    return t3 * D$1;
  };
  var V$1 = function(t3) {
    var e2 = new ut$1(), r2 = At$1.internal.getHeight(t3) || 0, n2 = At$1.internal.getWidth(t3) || 0;
    return e2.BBox = [0, 0, Number(U$1(n2)), Number(U$1(r2))], e2;
  };
  var G$1 = q$1.__acroform__.setBit = function(t3, e2) {
    if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
    return t3 |= 1 << e2;
  };
  var Y$1 = q$1.__acroform__.clearBit = function(t3, e2) {
    if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
    return t3 &= ~(1 << e2);
  };
  var J$1 = q$1.__acroform__.getBit = function(t3, e2) {
    if (isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
    return 0 == (t3 & 1 << e2) ? 0 : 1;
  };
  var X$1 = q$1.__acroform__.getBitForPdf = function(t3, e2) {
    if (isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
    return J$1(t3, e2 - 1);
  };
  var K$1 = q$1.__acroform__.setBitForPdf = function(t3, e2) {
    if (isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
    return G$1(t3, e2 - 1);
  };
  var Z$1 = q$1.__acroform__.clearBitForPdf = function(t3, e2) {
    if (isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
    return Y$1(t3, e2 - 1);
  };
  var $$1 = q$1.__acroform__.calculateCoordinates = function(t3, e2) {
    var r2 = e2.internal.getHorizontalCoordinate, n2 = e2.internal.getVerticalCoordinate, i2 = t3[0], a2 = t3[1], o2 = t3[2], s2 = t3[3], c2 = {};
    return c2.lowerLeft_X = r2(i2) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r2(i2 + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(U$1(c2.lowerLeft_X)), Number(U$1(c2.lowerLeft_Y)), Number(U$1(c2.upperRight_X)), Number(U$1(c2.upperRight_Y))];
  };
  var Q$1 = function(t3) {
    if (t3.appearanceStreamContent) return t3.appearanceStreamContent;
    if (t3.V || t3.DV) {
      var e2 = [], r2 = t3._V || t3.DV, n2 = tt$1(t3, r2), i2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id;
      e2.push("/Tx BMC"), e2.push("q"), e2.push("BT"), e2.push(t3.scope.__private__.encodeColorString(t3.color)), e2.push("/" + i2 + " " + U$1(n2.fontSize) + " Tf"), e2.push("1 0 0 1 0 0 Tm"), e2.push(n2.text), e2.push("ET"), e2.push("Q"), e2.push("EMC");
      var a2 = V$1(t3);
      return a2.scope = t3.scope, a2.stream = e2.join("\n"), a2;
    }
  };
  var tt$1 = function(t3, e2) {
    var r2 = 0 === t3.fontSize ? t3.maxFontSize : t3.fontSize, n2 = {
      text: "",
      fontSize: ""
    }, i2 = (e2 = ")" == (e2 = "(" == e2.substr(0, 1) ? e2.substr(1) : e2).substr(e2.length - 1) ? e2.substr(0, e2.length - 1) : e2).split(" ");
    i2 = t3.multiline ? i2.map(function(t4) {
      return t4.split("\n");
    }) : i2.map(function(t4) {
      return [t4];
    });
    var a2 = r2, o2 = At$1.internal.getHeight(t3) || 0;
    o2 = o2 < 0 ? -o2 : o2;
    var s2 = At$1.internal.getWidth(t3) || 0;
    s2 = s2 < 0 ? -s2 : s2;
    var c2 = function(e3, r3, n3) {
      if (e3 + 1 < i2.length) {
        var a3 = r3 + " " + i2[e3 + 1][0];
        return et$1(a3, t3, n3).width <= s2 - 4;
      }
      return false;
    };
    a2++;
    t: for (; a2 > 0; ) {
      e2 = "", a2--;
      var u2, h2, l2 = et$1("3", t3, a2).height, f2 = t3.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p2 = 0, g2 = 0, m2 = 0;
      if (a2 <= 0) {
        e2 = "(...) Tj\n", e2 += "% Width of Text: " + et$1(e2, t3, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
        break;
      }
      for (var v2 = "", b2 = 0, y2 = 0; y2 < i2.length; y2++) if (i2.hasOwnProperty(y2)) {
        var w2 = false;
        if (1 !== i2[y2].length && m2 !== i2[y2].length - 1) {
          if ((l2 + 2) * (b2 + 2) + 2 > o2) continue t;
          v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;
        } else {
          v2 = " " == (v2 += i2[y2][m2] + " ").substr(v2.length - 1) ? v2.substr(0, v2.length - 1) : v2;
          var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i2.length - 1;
          if (L2 && !A2) {
            v2 += " ", m2 = 0;
            continue;
          }
          if (L2 || A2) {
            if (A2) g2 = N2;
            else if (t3.multiline && (l2 + 2) * (b2 + 2) + 2 > o2) continue t;
          } else {
            if (!t3.multiline) continue t;
            if ((l2 + 2) * (b2 + 2) + 2 > o2) continue t;
            g2 = N2;
          }
        }
        for (var x2 = "", S2 = p2; S2 <= g2; S2++) {
          var _2 = i2[S2];
          if (t3.multiline) {
            if (S2 === g2) {
              x2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
              continue;
            }
            if (S2 === p2) {
              x2 += _2[_2.length - 1] + " ";
              continue;
            }
          }
          x2 += _2[0] + " ";
        }
        switch (x2 = " " == x2.substr(x2.length - 1) ? x2.substr(0, x2.length - 1) : x2, h2 = et$1(x2, t3, a2).width, t3.textAlign) {
          case "right":
            u2 = s2 - h2 - 2;
            break;
          case "center":
            u2 = (s2 - h2) / 2;
            break;
          case "left":
          default:
            u2 = 2;
        }
        e2 += U$1(u2) + " " + U$1(d2) + " Td\n", e2 += "(" + R$1(x2) + ") Tj\n", e2 += -U$1(u2) + " 0 Td\n", d2 = -(a2 + 2), h2 = 0, p2 = w2 ? g2 : g2 + 1, b2++, v2 = "";
      }
      break;
    }
    return n2.text = e2, n2.fontSize = a2, n2;
  };
  var et$1 = function(t3, e2, r2) {
    var n2 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i2 = e2.scope.getStringUnitWidth(t3, {
      font: n2,
      fontSize: parseFloat(r2),
      charSpace: 0
    }) * parseFloat(r2);
    return {
      height: e2.scope.getStringUnitWidth("3", {
        font: n2,
        fontSize: parseFloat(r2),
        charSpace: 0
      }) * parseFloat(r2) * 1.5,
      width: i2
    };
  };
  var rt$1 = {
    fields: [],
    xForms: [],
    acroFormDictionaryRoot: null,
    printedOut: false,
    internal: null,
    isInitialized: false
  };
  var nt$1 = function(t3, e2) {
    var r2 = {
      type: "reference",
      object: t3
    };
    void 0 === e2.internal.getPageInfo(t3.page).pageContext.annotations.find(function(t4) {
      return t4.type === r2.type && t4.object === r2.object;
    }) && e2.internal.getPageInfo(t3.page).pageContext.annotations.push(r2);
  };
  var it$1 = function(e2, r2) {
    for (var n2 in e2) if (e2.hasOwnProperty(n2)) {
      var i2 = n2, a2 = e2[n2];
      r2.internal.newObjectDeferredBegin(a2.objId, true), "object" === _typeof$1(a2) && "function" == typeof a2.putStream && a2.putStream(), delete e2[i2];
    }
  };
  var at$1 = function(e2, r2) {
    if (r2.scope = e2, void 0 !== e2.internal && (void 0 === e2.internal.acroformPlugin || false === e2.internal.acroformPlugin.isInitialized)) {
      if (lt$1.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt$1)), e2.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
      D$1 = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new ht$1(), e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe("postPutResources", function() {
        !(function(t3) {
          t3.internal.events.unsubscribe(t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t3.internal.acroformPlugin.printedOut = true;
        })(e2);
      }), e2.internal.events.subscribe("buildDocument", function() {
        !(function(t3) {
          t3.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
          var e3 = t3.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
          for (var r3 in e3) if (e3.hasOwnProperty(r3)) {
            var n2 = e3[r3];
            n2.objId = void 0, n2.hasAnnotation && nt$1(n2, t3);
          }
        })(e2);
      }), e2.internal.events.subscribe("putCatalog", function() {
        !(function(t3) {
          if (void 0 === t3.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("putCatalogCallback: Root missing.");
          t3.internal.write("/AcroForm " + t3.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
        })(e2);
      }), e2.internal.events.subscribe("postPutPages", function(r3) {
        !(function(e3, r4) {
          var n2 = !e3;
          for (var i2 in e3 || (r4.internal.newObjectDeferredBegin(r4.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r4.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || r4.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (e3.hasOwnProperty(i2)) {
            var a2 = e3[i2], o2 = [], s2 = a2.Rect;
            if (a2.Rect && (a2.Rect = $$1(a2.Rect, r4)), r4.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At$1.createDefaultAppearanceStream(a2), "object" === _typeof$1(a2) && "function" == typeof a2.getKeyValueListForStream && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
              var c2 = Q$1(a2);
              o2.push({
                key: "AP",
                value: "<</N " + c2 + ">>"
              }), r4.internal.acroformPlugin.xForms.push(c2);
            }
            if (a2.appearanceStreamContent) {
              var u2 = "";
              for (var h2 in a2.appearanceStreamContent) if (a2.appearanceStreamContent.hasOwnProperty(h2)) {
                var l2 = a2.appearanceStreamContent[h2];
                if (u2 += "/" + h2 + " ", u2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                  for (var i2 in l2) if (l2.hasOwnProperty(i2)) {
                    var f2 = l2[i2];
                    "function" == typeof f2 && (f2 = f2.call(r4, a2)), u2 += "/" + i2 + " " + f2 + " ", r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);
                  }
                } else "function" == typeof (f2 = l2) && (f2 = f2.call(r4, a2)), u2 += "/" + i2 + " " + f2, r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);
                u2 += ">>";
              }
              o2.push({
                key: "AP",
                value: "<<\n" + u2 + ">>"
              });
            }
            r4.internal.putStream({
              additionalKeyValues: o2,
              objectId: a2.objId
            }), r4.internal.out("endobj");
          }
          n2 && it$1(r4.internal.acroformPlugin.xForms, r4);
        })(r3, e2);
      }), e2.internal.acroformPlugin.isInitialized = true;
    }
  };
  var ot$1 = q$1.__acroform__.arrayToPdfArray = function(e2, r2, n2) {
    var i2 = function(t3) {
      return t3;
    };
    if (Array.isArray(e2)) {
      for (var a2 = "[", o2 = 0; o2 < e2.length; o2++) switch (0 !== o2 && (a2 += " "), _typeof$1(e2[o2])) {
        case "boolean":
        case "number":
        case "object":
          a2 += e2[o2].toString();
          break;
        case "string":
          "/" !== e2[o2].substr(0, 1) ? (void 0 !== r2 && n2 && (i2 = n2.internal.getEncryptor(r2)), a2 += "(" + R$1(i2(e2[o2].toString())) + ")") : a2 += e2[o2].toString();
      }
      return a2 += "]";
    }
    throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
  };
  var st$1 = function(t3, e2, r2) {
    var n2 = function(t4) {
      return t4;
    };
    return void 0 !== e2 && r2 && (n2 = r2.internal.getEncryptor(e2)), (t3 = t3 || "").toString(), t3 = "(" + R$1(n2(t3)) + ")";
  };
  var ct$1 = function() {
    this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", {
      get: function() {
        if (void 0 === this._objId) {
          if (void 0 === this.scope) return;
          this._objId = this.scope.internal.newObjectDeferred();
        }
        return this._objId;
      },
      set: function(t3) {
        this._objId = t3;
      }
    }), Object.defineProperty(this, "scope", {
      value: this._scope,
      writable: true
    });
  };
  ct$1.prototype.toString = function() {
    return this.objId + " 0 R";
  }, ct$1.prototype.putStream = function() {
    var t3 = this.getKeyValueListForStream();
    this.scope.internal.putStream({
      data: this.stream,
      additionalKeyValues: t3,
      objectId: this.objId
    }), this.scope.internal.out("endobj");
  }, ct$1.prototype.getKeyValueListForStream = function() {
    var t3 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t4) {
      return "content" != t4 && "appearanceStreamContent" != t4 && "scope" != t4 && "objId" != t4 && "_" != t4.substring(0, 1);
    });
    for (var r2 in e2) if (false === Object.getOwnPropertyDescriptor(this, e2[r2]).configurable) {
      var n2 = e2[r2], i2 = this[n2];
      i2 && (Array.isArray(i2) ? t3.push({
        key: n2,
        value: ot$1(i2, this.objId, this.scope)
      }) : i2 instanceof ct$1 ? (i2.scope = this.scope, t3.push({
        key: n2,
        value: i2.objId + " 0 R"
      })) : "function" != typeof i2 && t3.push({
        key: n2,
        value: i2
      }));
    }
    return t3;
  };
  var ut$1 = function() {
    ct$1.call(this), Object.defineProperty(this, "Type", {
      value: "/XObject",
      configurable: false,
      writable: true
    }), Object.defineProperty(this, "Subtype", {
      value: "/Form",
      configurable: false,
      writable: true
    }), Object.defineProperty(this, "FormType", {
      value: 1,
      configurable: false,
      writable: true
    });
    var t3, e2 = [];
    Object.defineProperty(this, "BBox", {
      configurable: false,
      get: function() {
        return e2;
      },
      set: function(t4) {
        e2 = t4;
      }
    }), Object.defineProperty(this, "Resources", {
      value: "2 0 R",
      configurable: false,
      writable: true
    }), Object.defineProperty(this, "stream", {
      enumerable: false,
      configurable: true,
      set: function(e3) {
        t3 = e3.trim();
      },
      get: function() {
        return t3 || null;
      }
    });
  };
  H$1(ut$1, ct$1);
  var ht$1 = function() {
    ct$1.call(this);
    var t3, e2 = [];
    Object.defineProperty(this, "Kids", {
      enumerable: false,
      configurable: true,
      get: function() {
        return e2.length > 0 ? e2 : void 0;
      }
    }), Object.defineProperty(this, "Fields", {
      enumerable: false,
      configurable: false,
      get: function() {
        return e2;
      }
    }), Object.defineProperty(this, "DA", {
      enumerable: false,
      configurable: false,
      get: function() {
        if (t3) {
          var e3 = function(t4) {
            return t4;
          };
          return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R$1(e3(t3)) + ")";
        }
      },
      set: function(e3) {
        t3 = e3;
      }
    });
  };
  H$1(ht$1, ct$1);
  var lt$1 = function t() {
    ct$1.call(this);
    var e2 = 4;
    Object.defineProperty(this, "F", {
      enumerable: false,
      configurable: false,
      get: function() {
        return e2;
      },
      set: function(t3) {
        if (isNaN(t3)) throw new Error('Invalid value "' + t3 + '" for attribute F supplied.');
        e2 = t3;
      }
    }), Object.defineProperty(this, "showWhenPrinted", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(e2, 3));
      },
      set: function(t3) {
        true === Boolean(t3) ? this.F = K$1(e2, 3) : this.F = Z$1(e2, 3);
      }
    });
    var r2 = 0;
    Object.defineProperty(this, "Ff", {
      enumerable: false,
      configurable: false,
      get: function() {
        return r2;
      },
      set: function(t3) {
        if (isNaN(t3)) throw new Error('Invalid value "' + t3 + '" for attribute Ff supplied.');
        r2 = t3;
      }
    });
    var n2 = [];
    Object.defineProperty(this, "Rect", {
      enumerable: false,
      configurable: false,
      get: function() {
        if (0 !== n2.length) return n2;
      },
      set: function(t3) {
        n2 = void 0 !== t3 ? t3 : [];
      }
    }), Object.defineProperty(this, "x", {
      enumerable: true,
      configurable: true,
      get: function() {
        return !n2 || isNaN(n2[0]) ? 0 : n2[0];
      },
      set: function(t3) {
        n2[0] = t3;
      }
    }), Object.defineProperty(this, "y", {
      enumerable: true,
      configurable: true,
      get: function() {
        return !n2 || isNaN(n2[1]) ? 0 : n2[1];
      },
      set: function(t3) {
        n2[1] = t3;
      }
    }), Object.defineProperty(this, "width", {
      enumerable: true,
      configurable: true,
      get: function() {
        return !n2 || isNaN(n2[2]) ? 0 : n2[2];
      },
      set: function(t3) {
        n2[2] = t3;
      }
    }), Object.defineProperty(this, "height", {
      enumerable: true,
      configurable: true,
      get: function() {
        return !n2 || isNaN(n2[3]) ? 0 : n2[3];
      },
      set: function(t3) {
        n2[3] = t3;
      }
    });
    var i2 = "";
    Object.defineProperty(this, "FT", {
      enumerable: true,
      configurable: false,
      get: function() {
        return i2;
      },
      set: function(t3) {
        switch (t3) {
          case "/Btn":
          case "/Tx":
          case "/Ch":
          case "/Sig":
            i2 = t3;
            break;
          default:
            throw new Error('Invalid value "' + t3 + '" for attribute FT supplied.');
        }
      }
    });
    var a2 = null;
    Object.defineProperty(this, "T", {
      enumerable: true,
      configurable: false,
      get: function() {
        if (!a2 || a2.length < 1) {
          if (this instanceof yt$1) return;
          a2 = "FieldObject" + t.FieldNum++;
        }
        var e3 = function(t3) {
          return t3;
        };
        return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R$1(e3(a2)) + ")";
      },
      set: function(t3) {
        a2 = t3.toString();
      }
    }), Object.defineProperty(this, "fieldName", {
      configurable: true,
      enumerable: true,
      get: function() {
        return a2;
      },
      set: function(t3) {
        a2 = t3;
      }
    });
    var o2 = "helvetica";
    Object.defineProperty(this, "fontName", {
      enumerable: true,
      configurable: true,
      get: function() {
        return o2;
      },
      set: function(t3) {
        o2 = t3;
      }
    });
    var s2 = "normal";
    Object.defineProperty(this, "fontStyle", {
      enumerable: true,
      configurable: true,
      get: function() {
        return s2;
      },
      set: function(t3) {
        s2 = t3;
      }
    });
    var c2 = 0;
    Object.defineProperty(this, "fontSize", {
      enumerable: true,
      configurable: true,
      get: function() {
        return c2;
      },
      set: function(t3) {
        c2 = t3;
      }
    });
    var u2 = void 0;
    Object.defineProperty(this, "maxFontSize", {
      enumerable: true,
      configurable: true,
      get: function() {
        return void 0 === u2 ? 50 / D$1 : u2;
      },
      set: function(t3) {
        u2 = t3;
      }
    });
    var h2 = "black";
    Object.defineProperty(this, "color", {
      enumerable: true,
      configurable: true,
      get: function() {
        return h2;
      },
      set: function(t3) {
        h2 = t3;
      }
    });
    var l2 = "/F1 0 Tf 0 g";
    Object.defineProperty(this, "DA", {
      enumerable: true,
      configurable: false,
      get: function() {
        if (!(!l2 || this instanceof yt$1 || this instanceof Nt$1)) return st$1(l2, this.objId, this.scope);
      },
      set: function(t3) {
        t3 = t3.toString(), l2 = t3;
      }
    });
    var f2 = null;
    Object.defineProperty(this, "DV", {
      enumerable: false,
      configurable: false,
      get: function() {
        if (f2) return this instanceof mt$1 == false ? st$1(f2, this.objId, this.scope) : f2;
      },
      set: function(t3) {
        t3 = t3.toString(), f2 = this instanceof mt$1 == false ? "(" === t3.substr(0, 1) ? T$2(t3.substr(1, t3.length - 2)) : T$2(t3) : t3;
      }
    }), Object.defineProperty(this, "defaultValue", {
      enumerable: true,
      configurable: true,
      get: function() {
        return this instanceof mt$1 == true ? T$2(f2.substr(1, f2.length - 1)) : f2;
      },
      set: function(t3) {
        t3 = t3.toString(), f2 = this instanceof mt$1 == true ? "/" + t3 : t3;
      }
    });
    var d2 = null;
    Object.defineProperty(this, "_V", {
      enumerable: false,
      configurable: false,
      get: function() {
        if (d2) return d2;
      },
      set: function(t3) {
        this.V = t3;
      }
    }), Object.defineProperty(this, "V", {
      enumerable: false,
      configurable: false,
      get: function() {
        if (d2) return this instanceof mt$1 == false ? st$1(d2, this.objId, this.scope) : d2;
      },
      set: function(t3) {
        t3 = t3.toString(), d2 = this instanceof mt$1 == false ? "(" === t3.substr(0, 1) ? T$2(t3.substr(1, t3.length - 2)) : T$2(t3) : t3;
      }
    }), Object.defineProperty(this, "value", {
      enumerable: true,
      configurable: true,
      get: function() {
        return this instanceof mt$1 == true ? T$2(d2.substr(1, d2.length - 1)) : d2;
      },
      set: function(t3) {
        t3 = t3.toString(), d2 = this instanceof mt$1 == true ? "/" + t3 : t3;
      }
    }), Object.defineProperty(this, "hasAnnotation", {
      enumerable: true,
      configurable: true,
      get: function() {
        return this.Rect;
      }
    }), Object.defineProperty(this, "Type", {
      enumerable: true,
      configurable: false,
      get: function() {
        return this.hasAnnotation ? "/Annot" : null;
      }
    }), Object.defineProperty(this, "Subtype", {
      enumerable: true,
      configurable: false,
      get: function() {
        return this.hasAnnotation ? "/Widget" : null;
      }
    });
    var p2, g2 = false;
    Object.defineProperty(this, "hasAppearanceStream", {
      enumerable: true,
      configurable: true,
      get: function() {
        return g2;
      },
      set: function(t3) {
        t3 = Boolean(t3), g2 = t3;
      }
    }), Object.defineProperty(this, "page", {
      enumerable: true,
      configurable: true,
      get: function() {
        if (p2) return p2;
      },
      set: function(t3) {
        p2 = t3;
      }
    }), Object.defineProperty(this, "readOnly", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 1));
      },
      set: function(t3) {
        true === Boolean(t3) ? this.Ff = K$1(this.Ff, 1) : this.Ff = Z$1(this.Ff, 1);
      }
    }), Object.defineProperty(this, "required", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 2));
      },
      set: function(t3) {
        true === Boolean(t3) ? this.Ff = K$1(this.Ff, 2) : this.Ff = Z$1(this.Ff, 2);
      }
    }), Object.defineProperty(this, "noExport", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 3));
      },
      set: function(t3) {
        true === Boolean(t3) ? this.Ff = K$1(this.Ff, 3) : this.Ff = Z$1(this.Ff, 3);
      }
    });
    var m2 = null;
    Object.defineProperty(this, "Q", {
      enumerable: true,
      configurable: false,
      get: function() {
        if (null !== m2) return m2;
      },
      set: function(t3) {
        if (-1 === [0, 1, 2].indexOf(t3)) throw new Error('Invalid value "' + t3 + '" for attribute Q supplied.');
        m2 = t3;
      }
    }), Object.defineProperty(this, "textAlign", {
      get: function() {
        var t3;
        switch (m2) {
          case 0:
          default:
            t3 = "left";
            break;
          case 1:
            t3 = "center";
            break;
          case 2:
            t3 = "right";
        }
        return t3;
      },
      configurable: true,
      enumerable: true,
      set: function(t3) {
        switch (t3) {
          case "right":
          case 2:
            m2 = 2;
            break;
          case "center":
          case 1:
            m2 = 1;
            break;
          case "left":
          case 0:
          default:
            m2 = 0;
        }
      }
    });
  };
  H$1(lt$1, ct$1);
  var ft$1 = function() {
    lt$1.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
    var t3 = 0;
    Object.defineProperty(this, "TI", {
      enumerable: true,
      configurable: false,
      get: function() {
        return t3;
      },
      set: function(e3) {
        t3 = e3;
      }
    }), Object.defineProperty(this, "topIndex", {
      enumerable: true,
      configurable: true,
      get: function() {
        return t3;
      },
      set: function(e3) {
        t3 = e3;
      }
    });
    var e2 = [];
    Object.defineProperty(this, "Opt", {
      enumerable: true,
      configurable: false,
      get: function() {
        return ot$1(e2, this.objId, this.scope);
      },
      set: function(t4) {
        var r2, n2;
        n2 = [], "string" == typeof (r2 = t4) && (n2 = (function(t5, e3, r3) {
          r3 || (r3 = 1);
          for (var n3, i2 = []; n3 = e3.exec(t5); ) i2.push(n3[r3]);
          return i2;
        })(r2, /\((.*?)\)/g)), e2 = n2;
      }
    }), this.getOptions = function() {
      return e2;
    }, this.setOptions = function(t4) {
      e2 = t4, this.sort && e2.sort();
    }, this.addOption = function(t4) {
      t4 = (t4 = t4 || "").toString(), e2.push(t4), this.sort && e2.sort();
    }, this.removeOption = function(t4, r2) {
      for (r2 = r2 || false, t4 = (t4 = t4 || "").toString(); -1 !== e2.indexOf(t4) && (e2.splice(e2.indexOf(t4), 1), false !== r2); ) ;
    }, Object.defineProperty(this, "combo", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 18));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 18) : this.Ff = Z$1(this.Ff, 18);
      }
    }), Object.defineProperty(this, "edit", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 19));
      },
      set: function(t4) {
        true === this.combo && (true === Boolean(t4) ? this.Ff = K$1(this.Ff, 19) : this.Ff = Z$1(this.Ff, 19));
      }
    }), Object.defineProperty(this, "sort", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 20));
      },
      set: function(t4) {
        true === Boolean(t4) ? (this.Ff = K$1(this.Ff, 20), e2.sort()) : this.Ff = Z$1(this.Ff, 20);
      }
    }), Object.defineProperty(this, "multiSelect", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 22));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 22) : this.Ff = Z$1(this.Ff, 22);
      }
    }), Object.defineProperty(this, "doNotSpellCheck", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 23));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 23) : this.Ff = Z$1(this.Ff, 23);
      }
    }), Object.defineProperty(this, "commitOnSelChange", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 27));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 27) : this.Ff = Z$1(this.Ff, 27);
      }
    }), this.hasAppearanceStream = false;
  };
  H$1(ft$1, lt$1);
  var dt$1 = function() {
    ft$1.call(this), this.fontName = "helvetica", this.combo = false;
  };
  H$1(dt$1, ft$1);
  var pt$1 = function() {
    dt$1.call(this), this.combo = true;
  };
  H$1(pt$1, dt$1);
  var gt$1 = function() {
    pt$1.call(this), this.edit = true;
  };
  H$1(gt$1, pt$1);
  var mt$1 = function() {
    lt$1.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 15));
      },
      set: function(t3) {
        true === Boolean(t3) ? this.Ff = K$1(this.Ff, 15) : this.Ff = Z$1(this.Ff, 15);
      }
    }), Object.defineProperty(this, "radio", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 16));
      },
      set: function(t3) {
        true === Boolean(t3) ? this.Ff = K$1(this.Ff, 16) : this.Ff = Z$1(this.Ff, 16);
      }
    }), Object.defineProperty(this, "pushButton", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 17));
      },
      set: function(t3) {
        true === Boolean(t3) ? this.Ff = K$1(this.Ff, 17) : this.Ff = Z$1(this.Ff, 17);
      }
    }), Object.defineProperty(this, "radioIsUnison", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 26));
      },
      set: function(t3) {
        true === Boolean(t3) ? this.Ff = K$1(this.Ff, 26) : this.Ff = Z$1(this.Ff, 26);
      }
    });
    var e2, r2 = {};
    Object.defineProperty(this, "MK", {
      enumerable: false,
      configurable: false,
      get: function() {
        var t3 = function(t4) {
          return t4;
        };
        if (this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(r2).length) {
          var e3, n2 = [];
          for (e3 in n2.push("<<"), r2) n2.push("/" + e3 + " (" + R$1(t3(r2[e3])) + ")");
          return n2.push(">>"), n2.join("\n");
        }
      },
      set: function(e3) {
        "object" === _typeof$1(e3) && (r2 = e3);
      }
    }), Object.defineProperty(this, "caption", {
      enumerable: true,
      configurable: true,
      get: function() {
        return r2.CA || "";
      },
      set: function(t3) {
        "string" == typeof t3 && (r2.CA = t3);
      }
    }), Object.defineProperty(this, "AS", {
      enumerable: false,
      configurable: false,
      get: function() {
        return e2;
      },
      set: function(t3) {
        e2 = t3;
      }
    }), Object.defineProperty(this, "appearanceState", {
      enumerable: true,
      configurable: true,
      get: function() {
        return e2.substr(1, e2.length - 1);
      },
      set: function(t3) {
        e2 = "/" + t3;
      }
    });
  };
  H$1(mt$1, lt$1);
  var vt$1 = function() {
    mt$1.call(this), this.pushButton = true;
  };
  H$1(vt$1, mt$1);
  var bt$1 = function() {
    mt$1.call(this), this.radio = true, this.pushButton = false;
    var t3 = [];
    Object.defineProperty(this, "Kids", {
      enumerable: true,
      configurable: false,
      get: function() {
        return t3;
      },
      set: function(e2) {
        t3 = void 0 !== e2 ? e2 : [];
      }
    });
  };
  H$1(bt$1, mt$1);
  var yt$1 = function() {
    var e2, r2;
    lt$1.call(this), Object.defineProperty(this, "Parent", {
      enumerable: false,
      configurable: false,
      get: function() {
        return e2;
      },
      set: function(t3) {
        e2 = t3;
      }
    }), Object.defineProperty(this, "optionName", {
      enumerable: false,
      configurable: true,
      get: function() {
        return r2;
      },
      set: function(t3) {
        r2 = t3;
      }
    });
    var n2, i2 = {};
    Object.defineProperty(this, "MK", {
      enumerable: false,
      configurable: false,
      get: function() {
        var t3 = function(t4) {
          return t4;
        };
        this.scope && (t3 = this.scope.internal.getEncryptor(this.objId));
        var e3, r3 = [];
        for (e3 in r3.push("<<"), i2) r3.push("/" + e3 + " (" + R$1(t3(i2[e3])) + ")");
        return r3.push(">>"), r3.join("\n");
      },
      set: function(e3) {
        "object" === _typeof$1(e3) && (i2 = e3);
      }
    }), Object.defineProperty(this, "caption", {
      enumerable: true,
      configurable: true,
      get: function() {
        return i2.CA || "";
      },
      set: function(t3) {
        "string" == typeof t3 && (i2.CA = t3);
      }
    }), Object.defineProperty(this, "AS", {
      enumerable: false,
      configurable: false,
      get: function() {
        return n2;
      },
      set: function(t3) {
        n2 = t3;
      }
    }), Object.defineProperty(this, "appearanceState", {
      enumerable: true,
      configurable: true,
      get: function() {
        return n2.substr(1, n2.length - 1);
      },
      set: function(t3) {
        n2 = "/" + t3;
      }
    }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At$1.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
  };
  H$1(yt$1, lt$1), bt$1.prototype.setAppearance = function(t3) {
    if (!("createAppearanceStream" in t3) || !("getCA" in t3)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
    for (var e2 in this.Kids) if (this.Kids.hasOwnProperty(e2)) {
      var r2 = this.Kids[e2];
      r2.appearanceStreamContent = t3.createAppearanceStream(r2.optionName), r2.caption = t3.getCA();
    }
  }, bt$1.prototype.createOption = function(t3) {
    var e2 = new yt$1();
    return e2.Parent = this, e2.optionName = t3, this.Kids.push(e2), xt$1.call(this.scope, e2), e2;
  };
  var wt$1 = function() {
    mt$1.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At$1.CheckBox.createAppearanceStream();
  };
  H$1(wt$1, mt$1);
  var Nt$1 = function() {
    lt$1.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 13));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 13) : this.Ff = Z$1(this.Ff, 13);
      }
    }), Object.defineProperty(this, "fileSelect", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 21));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 21) : this.Ff = Z$1(this.Ff, 21);
      }
    }), Object.defineProperty(this, "doNotSpellCheck", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 23));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 23) : this.Ff = Z$1(this.Ff, 23);
      }
    }), Object.defineProperty(this, "doNotScroll", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 24));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 24) : this.Ff = Z$1(this.Ff, 24);
      }
    }), Object.defineProperty(this, "comb", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 25));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 25) : this.Ff = Z$1(this.Ff, 25);
      }
    }), Object.defineProperty(this, "richText", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 26));
      },
      set: function(t4) {
        true === Boolean(t4) ? this.Ff = K$1(this.Ff, 26) : this.Ff = Z$1(this.Ff, 26);
      }
    });
    var t3 = null;
    Object.defineProperty(this, "MaxLen", {
      enumerable: true,
      configurable: false,
      get: function() {
        return t3;
      },
      set: function(e2) {
        t3 = e2;
      }
    }), Object.defineProperty(this, "maxLength", {
      enumerable: true,
      configurable: true,
      get: function() {
        return t3;
      },
      set: function(e2) {
        Number.isInteger(e2) && (t3 = e2);
      }
    }), Object.defineProperty(this, "hasAppearanceStream", {
      enumerable: true,
      configurable: true,
      get: function() {
        return this.V || this.DV;
      }
    });
  };
  H$1(Nt$1, lt$1);
  var Lt$1 = function() {
    Nt$1.call(this), Object.defineProperty(this, "password", {
      enumerable: true,
      configurable: true,
      get: function() {
        return Boolean(X$1(this.Ff, 14));
      },
      set: function(t3) {
        true === Boolean(t3) ? this.Ff = K$1(this.Ff, 14) : this.Ff = Z$1(this.Ff, 14);
      }
    }), this.password = true;
  };
  H$1(Lt$1, Nt$1);
  var At$1 = {
    CheckBox: {
      createAppearanceStream: function() {
        return {
          N: {
            On: At$1.CheckBox.YesNormal
          },
          D: {
            On: At$1.CheckBox.YesPushDown,
            Off: At$1.CheckBox.OffPushDown
          }
        };
      },
      YesPushDown: function(t3) {
        var e2 = V$1(t3);
        e2.scope = t3.scope;
        var r2 = [], n2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, i2 = t3.scope.__private__.encodeColorString(t3.color), a2 = tt$1(t3, t3.caption);
        return r2.push("0.749023 g"), r2.push("0 0 " + U$1(At$1.internal.getWidth(t3)) + " " + U$1(At$1.internal.getHeight(t3)) + " re"), r2.push("f"), r2.push("BMC"), r2.push("q"), r2.push("0 0 1 rg"), r2.push("/" + n2 + " " + U$1(a2.fontSize) + " Tf " + i2), r2.push("BT"), r2.push(a2.text), r2.push("ET"), r2.push("Q"), r2.push("EMC"), e2.stream = r2.join("\n"), e2;
      },
      YesNormal: function(t3) {
        var e2 = V$1(t3);
        e2.scope = t3.scope;
        var r2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, n2 = t3.scope.__private__.encodeColorString(t3.color), i2 = [], a2 = At$1.internal.getHeight(t3), o2 = At$1.internal.getWidth(t3), s2 = tt$1(t3, t3.caption);
        return i2.push("1 g"), i2.push("0 0 " + U$1(o2) + " " + U$1(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + U$1(o2 - 1) + " " + U$1(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + r2 + " " + U$1(s2.fontSize) + " Tf " + n2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e2.stream = i2.join("\n"), e2;
      },
      OffPushDown: function(t3) {
        var e2 = V$1(t3);
        e2.scope = t3.scope;
        var r2 = [];
        return r2.push("0.749023 g"), r2.push("0 0 " + U$1(At$1.internal.getWidth(t3)) + " " + U$1(At$1.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
      }
    },
    RadioButton: {
      Circle: {
        createAppearanceStream: function(t3) {
          var e2 = {
            D: {
              Off: At$1.RadioButton.Circle.OffPushDown
            },
            N: {}
          };
          return e2.N[t3] = At$1.RadioButton.Circle.YesNormal, e2.D[t3] = At$1.RadioButton.Circle.YesPushDown, e2;
        },
        getCA: function() {
          return "l";
        },
        YesNormal: function(t3) {
          var e2 = V$1(t3);
          e2.scope = t3.scope;
          var r2 = [], n2 = At$1.internal.getWidth(t3) <= At$1.internal.getHeight(t3) ? At$1.internal.getWidth(t3) / 4 : At$1.internal.getHeight(t3) / 4;
          n2 = Number((0.9 * n2).toFixed(5));
          var i2 = At$1.internal.Bezier_C, a2 = Number((n2 * i2).toFixed(5));
          return r2.push("q"), r2.push("1 0 0 1 " + z$1(At$1.internal.getWidth(t3) / 2) + " " + z$1(At$1.internal.getHeight(t3) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + a2 + " " + a2 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + a2 + " " + n2 + " -" + n2 + " " + a2 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + a2 + " -" + a2 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(a2 + " -" + n2 + " " + n2 + " -" + a2 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
        },
        YesPushDown: function(t3) {
          var e2 = V$1(t3);
          e2.scope = t3.scope;
          var r2 = [], n2 = At$1.internal.getWidth(t3) <= At$1.internal.getHeight(t3) ? At$1.internal.getWidth(t3) / 4 : At$1.internal.getHeight(t3) / 4;
          n2 = Number((0.9 * n2).toFixed(5));
          var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At$1.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At$1.internal.Bezier_C).toFixed(5));
          return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + z$1(At$1.internal.getWidth(t3) / 2) + " " + z$1(At$1.internal.getHeight(t3) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), r2.push("0 g"), r2.push("q"), r2.push("1 0 0 1 " + z$1(At$1.internal.getWidth(t3) / 2) + " " + z$1(At$1.internal.getHeight(t3) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
        },
        OffPushDown: function(t3) {
          var e2 = V$1(t3);
          e2.scope = t3.scope;
          var r2 = [], n2 = At$1.internal.getWidth(t3) <= At$1.internal.getHeight(t3) ? At$1.internal.getWidth(t3) / 4 : At$1.internal.getHeight(t3) / 4;
          n2 = Number((0.9 * n2).toFixed(5));
          var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At$1.internal.Bezier_C).toFixed(5));
          return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + z$1(At$1.internal.getWidth(t3) / 2) + " " + z$1(At$1.internal.getHeight(t3) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
        }
      },
      Cross: {
        createAppearanceStream: function(t3) {
          var e2 = {
            D: {
              Off: At$1.RadioButton.Cross.OffPushDown
            },
            N: {}
          };
          return e2.N[t3] = At$1.RadioButton.Cross.YesNormal, e2.D[t3] = At$1.RadioButton.Cross.YesPushDown, e2;
        },
        getCA: function() {
          return "8";
        },
        YesNormal: function(t3) {
          var e2 = V$1(t3);
          e2.scope = t3.scope;
          var r2 = [], n2 = At$1.internal.calculateCross(t3);
          return r2.push("q"), r2.push("1 1 " + U$1(At$1.internal.getWidth(t3) - 2) + " " + U$1(At$1.internal.getHeight(t3) - 2) + " re"), r2.push("W"), r2.push("n"), r2.push(U$1(n2.x1.x) + " " + U$1(n2.x1.y) + " m"), r2.push(U$1(n2.x2.x) + " " + U$1(n2.x2.y) + " l"), r2.push(U$1(n2.x4.x) + " " + U$1(n2.x4.y) + " m"), r2.push(U$1(n2.x3.x) + " " + U$1(n2.x3.y) + " l"), r2.push("s"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
        },
        YesPushDown: function(t3) {
          var e2 = V$1(t3);
          e2.scope = t3.scope;
          var r2 = At$1.internal.calculateCross(t3), n2 = [];
          return n2.push("0.749023 g"), n2.push("0 0 " + U$1(At$1.internal.getWidth(t3)) + " " + U$1(At$1.internal.getHeight(t3)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + U$1(At$1.internal.getWidth(t3) - 2) + " " + U$1(At$1.internal.getHeight(t3) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(U$1(r2.x1.x) + " " + U$1(r2.x1.y) + " m"), n2.push(U$1(r2.x2.x) + " " + U$1(r2.x2.y) + " l"), n2.push(U$1(r2.x4.x) + " " + U$1(r2.x4.y) + " m"), n2.push(U$1(r2.x3.x) + " " + U$1(r2.x3.y) + " l"), n2.push("s"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
        },
        OffPushDown: function(t3) {
          var e2 = V$1(t3);
          e2.scope = t3.scope;
          var r2 = [];
          return r2.push("0.749023 g"), r2.push("0 0 " + U$1(At$1.internal.getWidth(t3)) + " " + U$1(At$1.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
        }
      }
    },
    createDefaultAppearanceStream: function(t3) {
      var e2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, r2 = t3.scope.__private__.encodeColorString(t3.color);
      return "/" + e2 + " " + t3.fontSize + " Tf " + r2;
    }
  };
  At$1.internal = {
    Bezier_C: 0.551915024494,
    calculateCross: function(t3) {
      var e2 = At$1.internal.getWidth(t3), r2 = At$1.internal.getHeight(t3), n2 = Math.min(e2, r2);
      return {
        x1: {
          x: (e2 - n2) / 2,
          y: (r2 - n2) / 2 + n2
        },
        x2: {
          x: (e2 - n2) / 2 + n2,
          y: (r2 - n2) / 2
        },
        x3: {
          x: (e2 - n2) / 2,
          y: (r2 - n2) / 2
        },
        x4: {
          x: (e2 - n2) / 2 + n2,
          y: (r2 - n2) / 2 + n2
        }
      };
    }
  }, At$1.internal.getWidth = function(e2) {
    var r2 = 0;
    return "object" === _typeof$1(e2) && (r2 = W$1(e2.Rect[2])), r2;
  }, At$1.internal.getHeight = function(e2) {
    var r2 = 0;
    return "object" === _typeof$1(e2) && (r2 = W$1(e2.Rect[3])), r2;
  };
  var xt$1 = q$1.addField = function(t3) {
    if (at$1(this, t3), !(t3 instanceof lt$1)) throw new Error("Invalid argument passed to jsPDF.addField.");
    var e2;
    return (e2 = t3).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t3.page = t3.scope.internal.getCurrentPageInfo().pageNumber, this;
  };
  q$1.AcroFormChoiceField = ft$1, q$1.AcroFormListBox = dt$1, q$1.AcroFormComboBox = pt$1, q$1.AcroFormEditBox = gt$1, q$1.AcroFormButton = mt$1, q$1.AcroFormPushButton = vt$1, q$1.AcroFormRadioButton = bt$1, q$1.AcroFormCheckBox = wt$1, q$1.AcroFormTextField = Nt$1, q$1.AcroFormPasswordField = Lt$1, q$1.AcroFormAppearance = At$1, q$1.AcroForm = {
    ChoiceField: ft$1,
    ListBox: dt$1,
    ComboBox: pt$1,
    EditBox: gt$1,
    Button: mt$1,
    PushButton: vt$1,
    RadioButton: bt$1,
    CheckBox: wt$1,
    TextField: Nt$1,
    PasswordField: Lt$1,
    Appearance: At$1
  }, E$1.AcroForm = {
    ChoiceField: ft$1,
    ListBox: dt$1,
    ComboBox: pt$1,
    EditBox: gt$1,
    Button: mt$1,
    PushButton: vt$1,
    RadioButton: bt$1,
    CheckBox: wt$1,
    TextField: Nt$1,
    PasswordField: Lt$1,
    Appearance: At$1
  };
  E$1.AcroForm;
  function _t(t3) {
    return t3.reduce(function(t4, e2, r2) {
      return t4[e2] = r2, t4;
    }, {});
  }
  !(function(e2) {
    e2.__addimage__ = {};
    var r2 = "UNKNOWN", n2 = {
      PNG: [[137, 80, 78, 71]],
      TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]],
      JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]],
      JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]],
      GIF87a: [[71, 73, 70, 56, 55, 97]],
      GIF89a: [[71, 73, 70, 56, 57, 97]],
      WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]],
      BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]]
    }, i2 = e2.__addimage__.getImageFileTypeByImageData = function(t3, e3) {
      var i3, a3, o3, s3, c3, u2 = r2;
      if ("RGBA" === (e3 = e3 || r2) || void 0 !== t3.data && t3.data instanceof Uint8ClampedArray && "height" in t3 && "width" in t3) return "RGBA";
      if (x2(t3)) for (c3 in n2) for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
        for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1) if (void 0 !== o3[i3][a3] && o3[i3][a3] !== t3[a3]) {
          s3 = false;
          break;
        }
        if (true === s3) {
          u2 = c3;
          break;
        }
      }
      else for (c3 in n2) for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
        for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1) if (void 0 !== o3[i3][a3] && o3[i3][a3] !== t3.charCodeAt(a3)) {
          s3 = false;
          break;
        }
        if (true === s3) {
          u2 = c3;
          break;
        }
      }
      return u2 === r2 && e3 !== r2 && (u2 = e3), u2;
    }, a2 = function t3(e3) {
      for (var r3 = this.internal.write, n3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); -1 !== i3.indexOf("FlateEncode"); ) i3.splice(i3.indexOf("FlateEncode"), 1);
      e3.objectId = this.internal.newObject();
      var a3 = [];
      if (a3.push({
        key: "Type",
        value: "/XObject"
      }), a3.push({
        key: "Subtype",
        value: "/Image"
      }), a3.push({
        key: "Width",
        value: e3.width
      }), a3.push({
        key: "Height",
        value: e3.height
      }), e3.colorSpace === b2.INDEXED ? a3.push({
        key: "ColorSpace",
        value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && void 0 !== e3.sMask ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]"
      }) : (a3.push({
        key: "ColorSpace",
        value: "/" + e3.colorSpace
      }), e3.colorSpace === b2.DEVICE_CMYK && a3.push({
        key: "Decode",
        value: "[1 0 1 0 1 0 1 0]"
      })), a3.push({
        key: "BitsPerComponent",
        value: e3.bitsPerComponent
      }), "decodeParameters" in e3 && void 0 !== e3.decodeParameters && a3.push({
        key: "DecodeParms",
        value: "<<" + e3.decodeParameters + ">>"
      }), "transparency" in e3 && Array.isArray(e3.transparency)) {
        for (var o3 = "", s3 = 0, c3 = e3.transparency.length; s3 < c3; s3++) o3 += e3.transparency[s3] + " " + e3.transparency[s3] + " ";
        a3.push({
          key: "Mask",
          value: "[" + o3 + "]"
        });
      }
      void 0 !== e3.sMask && a3.push({
        key: "SMask",
        value: e3.objectId + 1 + " 0 R"
      });
      var u2 = void 0 !== e3.filter ? ["/" + e3.filter] : void 0;
      if (n3({
        data: e3.data,
        additionalKeyValues: a3,
        alreadyAppliedFilters: u2,
        objectId: e3.objectId
      }), r3("endobj"), "sMask" in e3 && void 0 !== e3.sMask) {
        var h3 = "/Predictor " + e3.predictor + " /Colors 1 /BitsPerComponent " + e3.bitsPerComponent + " /Columns " + e3.width, l3 = {
          width: e3.width,
          height: e3.height,
          colorSpace: "DeviceGray",
          bitsPerComponent: e3.bitsPerComponent,
          decodeParameters: h3,
          data: e3.sMask
        };
        "filter" in e3 && (l3.filter = e3.filter), t3.call(this, l3);
      }
      if (e3.colorSpace === b2.INDEXED) {
        var f3 = this.internal.newObject();
        n3({
          data: _2(new Uint8Array(e3.palette)),
          objectId: f3
        }), r3("endobj");
      }
    }, o2 = function() {
      var t3 = this.internal.collections.addImage_images;
      for (var e3 in t3) a2.call(this, t3[e3]);
    }, s2 = function() {
      var t3, e3 = this.internal.collections.addImage_images, r3 = this.internal.write;
      for (var n3 in e3) r3("/I" + (t3 = e3[n3]).index, t3.objectId, "0", "R");
    }, c2 = function() {
      this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o2), this.internal.events.subscribe("putXobjectDict", s2));
    }, h2 = function() {
      var t3 = this.internal.collections.addImage_images;
      return c2.call(this), t3;
    }, l2 = function() {
      return Object.keys(this.internal.collections.addImage_images).length;
    }, f2 = function(t3) {
      return "function" == typeof e2["process" + t3.toUpperCase()];
    }, d2 = function(e3) {
      return "object" === _typeof$1(e3) && 1 === e3.nodeType;
    }, p2 = function(t3, r3) {
      if ("IMG" === t3.nodeName && t3.hasAttribute("src")) {
        var n3 = "" + t3.getAttribute("src");
        if (0 === n3.indexOf("data:image/")) return u$2(unescape(n3).split("base64,").pop());
        var i3 = e2.loadFile(n3, true);
        if (void 0 !== i3) return i3;
      }
      if ("CANVAS" === t3.nodeName) {
        if (0 === t3.width || 0 === t3.height) throw new Error("Given canvas must have data. Canvas width: " + t3.width + ", height: " + t3.height);
        var a3;
        switch (r3) {
          case "PNG":
            a3 = "image/png";
            break;
          case "WEBP":
            a3 = "image/webp";
            break;
          case "JPEG":
          case "JPG":
          default:
            a3 = "image/jpeg";
        }
        return u$2(t3.toDataURL(a3, 1).split("base64,").pop());
      }
    }, g2 = function(t3) {
      var e3 = this.internal.collections.addImage_images;
      if (e3) {
        for (var r3 in e3) if (t3 === e3[r3].alias) return e3[r3];
      }
    }, m2 = function(t3, e3, r3) {
      return t3 || e3 || (t3 = -96, e3 = -96), t3 < 0 && (t3 = -1 * r3.width * 72 / t3 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * r3.height * 72 / e3 / this.internal.scaleFactor), 0 === t3 && (t3 = e3 * r3.width / r3.height), 0 === e3 && (e3 = t3 * r3.height / r3.width), [t3, e3];
    }, v2 = function(t3, e3, r3, n3, i3, a3) {
      var o3 = m2.call(this, r3, n3, i3), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h2.call(this);
      if (r3 = o3[0], n3 = o3[1], u2[i3.index] = i3, a3) {
        a3 *= Math.PI / 180;
        var l3 = Math.cos(a3), f3 = Math.sin(a3), d3 = function(t4) {
          return t4.toFixed(4);
        }, p3 = [d3(l3), d3(f3), d3(-1 * f3), d3(l3), 0, 0, "cm"];
      }
      this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t3), c3(e3 + n3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(r3), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r3), "0", "0", s3(n3), s3(t3), c3(e3 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
    }, b2 = e2.color_spaces = {
      DEVICE_RGB: "DeviceRGB",
      DEVICE_GRAY: "DeviceGray",
      DEVICE_CMYK: "DeviceCMYK",
      CAL_GREY: "CalGray",
      CAL_RGB: "CalRGB",
      LAB: "Lab",
      ICC_BASED: "ICCBased",
      INDEXED: "Indexed",
      PATTERN: "Pattern",
      SEPARATION: "Separation",
      DEVICE_N: "DeviceN"
    };
    e2.decode = {
      DCT_DECODE: "DCTDecode",
      FLATE_DECODE: "FlateDecode",
      LZW_DECODE: "LZWDecode",
      JPX_DECODE: "JPXDecode",
      JBIG2_DECODE: "JBIG2Decode",
      ASCII85_DECODE: "ASCII85Decode",
      ASCII_HEX_DECODE: "ASCIIHexDecode",
      RUN_LENGTH_DECODE: "RunLengthDecode",
      CCITT_FAX_DECODE: "CCITTFaxDecode"
    };
    var y2 = e2.image_compression = {
      NONE: "NONE",
      FAST: "FAST",
      MEDIUM: "MEDIUM",
      SLOW: "SLOW"
    }, w2 = e2.__addimage__.sHashCode = function(t3) {
      var e3, r3, n3 = 0;
      if ("string" == typeof t3) for (r3 = t3.length, e3 = 0; e3 < r3; e3++) n3 = (n3 << 5) - n3 + t3.charCodeAt(e3), n3 |= 0;
      else if (x2(t3)) for (r3 = t3.byteLength / 2, e3 = 0; e3 < r3; e3++) n3 = (n3 << 5) - n3 + t3[e3], n3 |= 0;
      return n3;
    }, N2 = e2.__addimage__.validateStringAsBase64 = function(t3) {
      (t3 = t3 || "").toString().trim();
      var e3 = true;
      return 0 === t3.length && (e3 = false), t3.length % 4 != 0 && (e3 = false), false === /^[A-Za-z0-9+/]+$/.test(t3.substr(0, t3.length - 2)) && (e3 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t3.substr(-2)) && (e3 = false), e3;
    }, L2 = e2.__addimage__.extractImageFromDataUrl = function(t3) {
      if (null == t3) return null;
      if (!(t3 = t3.trim()).startsWith("data:")) return null;
      var e3 = t3.indexOf(",");
      return e3 < 0 ? null : t3.substring(0, e3).trim().endsWith("base64") ? t3.substring(e3 + 1) : null;
    }, A2 = e2.__addimage__.supportsArrayBuffer = function() {
      return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
    };
    e2.__addimage__.isArrayBuffer = function(t3) {
      return A2() && t3 instanceof ArrayBuffer;
    };
    var x2 = e2.__addimage__.isArrayBufferView = function(t3) {
      return A2() && "undefined" != typeof Uint32Array && (t3 instanceof Int8Array || t3 instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array);
    }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t3) {
      for (var e3 = t3.length, r3 = new Uint8Array(e3), n3 = 0; n3 < e3; n3++) r3[n3] = t3.charCodeAt(n3);
      return r3;
    }, _2 = e2.__addimage__.arrayBufferToBinaryString = function(t3) {
      for (var e3 = "", r3 = x2(t3) ? t3 : new Uint8Array(t3), n3 = 0; n3 < r3.length; n3 += 8192) e3 += String.fromCharCode.apply(null, r3.subarray(n3, n3 + 8192));
      return e3;
    };
    e2.addImage = function() {
      var e3, n3, i3, a3, o3, s3, u2, h3, l3;
      if ("number" == typeof arguments[1] ? (n3 = r2, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h3 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h3 = arguments[7], l3 = arguments[8]), "object" === _typeof$1(e3 = arguments[0]) && !d2(e3) && "imageData" in e3) {
        var f3 = e3;
        e3 = f3.imageData, n3 = f3.format || n3 || r2, i3 = f3.x || i3 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h3 = f3.compression || h3, l3 = f3.rotation || f3.angle || l3;
      }
      var p3 = this.internal.getFilters();
      if (void 0 === h3 && -1 !== p3.indexOf("FlateEncode") && (h3 = "SLOW"), isNaN(i3) || isNaN(a3)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
      c2.call(this);
      var g3 = P2.call(this, e3, n3, u2, h3);
      return v2.call(this, i3, a3, o3, s3, g3, l3), this;
    };
    var P2 = function(t3, n3, a3, o3) {
      var s3, c3, u2;
      if ("string" == typeof t3 && i2(t3) === r2) {
        t3 = unescape(t3);
        var h3 = k2(t3, false);
        ("" !== h3 || void 0 !== (h3 = e2.loadFile(t3, true))) && (t3 = h3);
      }
      if (d2(t3) && (t3 = p2(t3, n3)), n3 = i2(t3, n3), !f2(n3)) throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
      if ((null == (u2 = a3) || 0 === u2.length) && (a3 = (function(t4) {
        return "string" == typeof t4 || x2(t4) ? w2(t4) : x2(t4.data) ? w2(t4.data) : null;
      })(t3)), (s3 = g2.call(this, a3)) || (A2() && (t3 instanceof Uint8Array || "RGBA" === n3 || (c3 = t3, t3 = S2(t3))), s3 = this["process" + n3.toUpperCase()](t3, l2.call(this), a3, (function(t4) {
        return t4 && "string" == typeof t4 && (t4 = t4.toUpperCase()), t4 in e2.image_compression ? t4 : y2.NONE;
      })(o3), c3)), !s3) throw new Error("An unknown error occurred whilst processing the image.");
      return s3;
    }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t3, e3) {
      e3 = "boolean" != typeof e3 || e3;
      var r3, n3 = "";
      if ("string" == typeof t3) {
        var i3;
        r3 = null !== (i3 = L2(t3)) && void 0 !== i3 ? i3 : t3;
        try {
          n3 = u$2(r3);
        } catch (t4) {
          if (e3) throw N2(r3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t4.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
        }
      }
      return n3;
    };
    e2.getImageProperties = function(t3) {
      var n3, a3, o3 = "";
      if (d2(t3) && (t3 = p2(t3)), "string" == typeof t3 && i2(t3) === r2 && ("" === (o3 = k2(t3, false)) && (o3 = e2.loadFile(t3) || ""), t3 = o3), a3 = i2(t3), !f2(a3)) throw new Error("addImage does not support files of type '" + a3 + "', please ensure that a plugin for '" + a3 + "' support is added.");
      if (!A2() || t3 instanceof Uint8Array || (t3 = S2(t3)), !(n3 = this["process" + a3.toUpperCase()](t3))) throw new Error("An unknown error occurred whilst processing the image");
      return n3.fileType = a3, n3;
    };
  })(E$1.API), /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    var e2 = function(t4) {
      if (void 0 !== t4 && "" != t4) return true;
    };
    E$1.API.events.push(["addPage", function(t4) {
      this.internal.getPageInfo(t4.pageNumber).pageContext.annotations = [];
    }]), t3.events.push(["putPage", function(t4) {
      for (var r2, n2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t4.objId), c2 = t4.pageContext.annotations, u2 = false, h2 = 0; h2 < c2.length && !u2; h2++) switch ((r2 = c2[h2]).type) {
        case "link":
          (e2(r2.options.url) || e2(r2.options.pageNumber)) && (u2 = true);
          break;
        case "reference":
        case "text":
        case "freetext":
          u2 = true;
      }
      if (0 != u2) {
        this.internal.write("/Annots [");
        for (var l2 = 0; l2 < c2.length; l2++) {
          r2 = c2[l2];
          var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t4.objId);
          switch (r2.type) {
            case "reference":
              this.internal.write(" " + r2.object.objId + " 0 R ");
              break;
            case "text":
              var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = r2.title || "Note";
              i2 = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a2(r2.bounds.x) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a2(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y) + "] ") + "/Contents (" + f2(m2(r2.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m2(v2)) + ") >>", p2.content = i2;
              var b2 = p2.objId + " 0 R";
              i2 = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a2(r2.bounds.x + 30) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a2(r2.bounds.x + r2.bounds.w + 30) + " " + o2(r2.bounds.y) + "] ") + " /Parent " + b2, r2.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
              break;
            case "freetext":
              n2 = "/Rect [" + a2(r2.bounds.x) + " " + o2(r2.bounds.y) + " " + a2(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y + r2.bounds.h) + "] ";
              var y2 = r2.color || "#000000";
              i2 = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f2(d2(r2.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
              break;
            case "link":
              if (r2.options.name) {
                var w2 = this.annotations._nameMap[r2.options.name];
                r2.options.pageNumber = w2.page, r2.options.top = w2.y;
              } else r2.options.top || (r2.options.top = 0);
              if (n2 = "/Rect [" + r2.finalBounds.x + " " + r2.finalBounds.y + " " + r2.finalBounds.w + " " + r2.finalBounds.h + "] ", i2 = "", r2.options.url) i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(r2.options.url)) + ") >>";
              else if (r2.options.pageNumber) {
                switch (i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r2.options.pageNumber).objId + " 0 R", r2.options.magFactor = r2.options.magFactor || "XYZ", r2.options.magFactor) {
                  case "Fit":
                    i2 += " /Fit]";
                    break;
                  case "FitH":
                    i2 += " /FitH " + r2.options.top + "]";
                    break;
                  case "FitV":
                    r2.options.left = r2.options.left || 0, i2 += " /FitV " + r2.options.left + "]";
                    break;
                  case "XYZ":
                  default:
                    var N2 = o2(r2.options.top);
                    r2.options.left = r2.options.left || 0, void 0 === r2.options.zoom && (r2.options.zoom = 0), i2 += " /XYZ " + r2.options.left + " " + N2 + " " + r2.options.zoom + "]";
                }
              }
              "" != i2 && (i2 += " >>", this.internal.write(i2));
          }
        }
        this.internal.write("]");
      }
    }]), t3.createAnnotation = function(t4) {
      var e3 = this.internal.getCurrentPageInfo();
      switch (t4.type) {
        case "link":
          this.link(t4.bounds.x, t4.bounds.y, t4.bounds.w, t4.bounds.h, t4);
          break;
        case "text":
        case "freetext":
          e3.pageContext.annotations.push(t4);
      }
    }, t3.link = function(t4, e3, r2, n2, i2) {
      var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
      a2.pageContext.annotations.push({
        finalBounds: {
          x: o2(t4),
          y: s2(e3),
          w: o2(t4 + r2),
          h: s2(e3 + n2)
        },
        options: i2,
        type: "link"
      });
    }, t3.textWithLink = function(t4, e3, r2, n2) {
      var i2, a2, o2 = this.getTextWidth(t4), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
      if (void 0 !== n2.maxWidth) {
        a2 = n2.maxWidth;
        var c2 = this.splitTextToSize(t4, a2).length;
        i2 = Math.ceil(s2 * c2);
      } else a2 = o2, i2 = s2;
      return this.text(t4, e3, r2, n2), r2 += 0.2 * s2, "center" === n2.align && (e3 -= o2 / 2), "right" === n2.align && (e3 -= o2), this.link(e3, r2 - s2, a2, i2, n2), o2;
    }, t3.getTextWidth = function(t4) {
      var e3 = this.internal.getFontSize();
      return this.getStringUnitWidth(t4) * e3 / this.internal.scaleFactor;
    };
  })(E$1.API), /**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    var e2 = {
      1569: [65152],
      1570: [65153, 65154],
      1571: [65155, 65156],
      1572: [65157, 65158],
      1573: [65159, 65160],
      1574: [65161, 65162, 65163, 65164],
      1575: [65165, 65166],
      1576: [65167, 65168, 65169, 65170],
      1577: [65171, 65172],
      1578: [65173, 65174, 65175, 65176],
      1579: [65177, 65178, 65179, 65180],
      1580: [65181, 65182, 65183, 65184],
      1581: [65185, 65186, 65187, 65188],
      1582: [65189, 65190, 65191, 65192],
      1583: [65193, 65194],
      1584: [65195, 65196],
      1585: [65197, 65198],
      1586: [65199, 65200],
      1587: [65201, 65202, 65203, 65204],
      1588: [65205, 65206, 65207, 65208],
      1589: [65209, 65210, 65211, 65212],
      1590: [65213, 65214, 65215, 65216],
      1591: [65217, 65218, 65219, 65220],
      1592: [65221, 65222, 65223, 65224],
      1593: [65225, 65226, 65227, 65228],
      1594: [65229, 65230, 65231, 65232],
      1601: [65233, 65234, 65235, 65236],
      1602: [65237, 65238, 65239, 65240],
      1603: [65241, 65242, 65243, 65244],
      1604: [65245, 65246, 65247, 65248],
      1605: [65249, 65250, 65251, 65252],
      1606: [65253, 65254, 65255, 65256],
      1607: [65257, 65258, 65259, 65260],
      1608: [65261, 65262],
      1609: [65263, 65264, 64488, 64489],
      1610: [65265, 65266, 65267, 65268],
      1649: [64336, 64337],
      1655: [64477],
      1657: [64358, 64359, 64360, 64361],
      1658: [64350, 64351, 64352, 64353],
      1659: [64338, 64339, 64340, 64341],
      1662: [64342, 64343, 64344, 64345],
      1663: [64354, 64355, 64356, 64357],
      1664: [64346, 64347, 64348, 64349],
      1667: [64374, 64375, 64376, 64377],
      1668: [64370, 64371, 64372, 64373],
      1670: [64378, 64379, 64380, 64381],
      1671: [64382, 64383, 64384, 64385],
      1672: [64392, 64393],
      1676: [64388, 64389],
      1677: [64386, 64387],
      1678: [64390, 64391],
      1681: [64396, 64397],
      1688: [64394, 64395],
      1700: [64362, 64363, 64364, 64365],
      1702: [64366, 64367, 64368, 64369],
      1705: [64398, 64399, 64400, 64401],
      1709: [64467, 64468, 64469, 64470],
      1711: [64402, 64403, 64404, 64405],
      1713: [64410, 64411, 64412, 64413],
      1715: [64406, 64407, 64408, 64409],
      1722: [64414, 64415],
      1723: [64416, 64417, 64418, 64419],
      1726: [64426, 64427, 64428, 64429],
      1728: [64420, 64421],
      1729: [64422, 64423, 64424, 64425],
      1733: [64480, 64481],
      1734: [64473, 64474],
      1735: [64471, 64472],
      1736: [64475, 64476],
      1737: [64482, 64483],
      1739: [64478, 64479],
      1740: [64508, 64509, 64510, 64511],
      1744: [64484, 64485, 64486, 64487],
      1746: [64430, 64431],
      1747: [64432, 64433]
    }, r2 = {
      65247: {
        65154: 65269,
        65156: 65271,
        65160: 65273,
        65166: 65275
      },
      65248: {
        65154: 65270,
        65156: 65272,
        65160: 65274,
        65166: 65276
      },
      65165: {
        65247: {
          65248: {
            65258: 65010
          }
        }
      },
      1617: {
        1612: 64606,
        1613: 64607,
        1614: 64608,
        1615: 64609,
        1616: 64610
      }
    }, n2 = {
      1612: 64606,
      1613: 64607,
      1614: 64608,
      1615: 64609,
      1616: 64610
    }, i2 = [1570, 1571, 1573, 1575];
    t3.__arabicParser__ = {};
    var a2 = t3.__arabicParser__.isInArabicSubstitutionA = function(t4) {
      return void 0 !== e2[t4.charCodeAt(0)];
    }, o2 = t3.__arabicParser__.isArabicLetter = function(t4) {
      return "string" == typeof t4 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t4);
    }, s2 = t3.__arabicParser__.isArabicEndLetter = function(t4) {
      return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length <= 2;
    }, c2 = t3.__arabicParser__.isArabicAlfLetter = function(t4) {
      return o2(t4) && i2.indexOf(t4.charCodeAt(0)) >= 0;
    };
    t3.__arabicParser__.arabicLetterHasIsolatedForm = function(t4) {
      return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 1;
    };
    var u2 = t3.__arabicParser__.arabicLetterHasFinalForm = function(t4) {
      return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 2;
    };
    t3.__arabicParser__.arabicLetterHasInitialForm = function(t4) {
      return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 3;
    };
    var h2 = t3.__arabicParser__.arabicLetterHasMedialForm = function(t4) {
      return o2(t4) && a2(t4) && 4 == e2[t4.charCodeAt(0)].length;
    }, l2 = t3.__arabicParser__.resolveLigatures = function(t4) {
      var e3 = 0, n3 = r2, i3 = "", a3 = 0;
      for (e3 = 0; e3 < t4.length; e3 += 1) void 0 !== n3[t4.charCodeAt(e3)] ? (a3++, "number" == typeof (n3 = n3[t4.charCodeAt(e3)]) && (i3 += String.fromCharCode(n3), n3 = r2, a3 = 0), e3 === t4.length - 1 && (n3 = r2, i3 += t4.charAt(e3 - (a3 - 1)), e3 -= a3 - 1, a3 = 0)) : (n3 = r2, i3 += t4.charAt(e3 - a3), e3 -= a3, a3 = 0);
      return i3;
    };
    t3.__arabicParser__.isArabicDiacritic = function(t4) {
      return void 0 !== t4 && void 0 !== n2[t4.charCodeAt(0)];
    };
    var f2 = t3.__arabicParser__.getCorrectForm = function(t4, e3, r3) {
      return o2(t4) ? false === a2(t4) ? -1 : !u2(t4) || !o2(e3) && !o2(r3) || !o2(r3) && s2(e3) || s2(t4) && !o2(e3) || s2(t4) && c2(e3) || s2(t4) && s2(e3) ? 0 : h2(t4) && o2(e3) && !s2(e3) && o2(r3) && u2(r3) ? 3 : s2(t4) || !o2(r3) ? 1 : 2 : -1;
    }, d2 = function(t4) {
      var r3 = 0, n3 = 0, i3 = 0, a3 = "", s3 = "", c3 = "", u3 = (t4 = t4 || "").split("\\s+"), h3 = [];
      for (r3 = 0; r3 < u3.length; r3 += 1) {
        for (h3.push(""), n3 = 0; n3 < u3[r3].length; n3 += 1) a3 = u3[r3][n3], s3 = u3[r3][n3 - 1], c3 = u3[r3][n3 + 1], o2(a3) ? (i3 = f2(a3, s3, c3), h3[r3] += -1 !== i3 ? String.fromCharCode(e2[a3.charCodeAt(0)][i3]) : a3) : h3[r3] += a3;
        h3[r3] = l2(h3[r3]);
      }
      return h3.join(" ");
    }, p2 = t3.__arabicParser__.processArabic = t3.processArabic = function() {
      var t4, e3 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r3 = [];
      if (Array.isArray(e3)) {
        var n3 = 0;
        for (r3 = [], n3 = 0; n3 < e3.length; n3 += 1) Array.isArray(e3[n3]) ? r3.push([d2(e3[n3][0]), e3[n3][1], e3[n3][2]]) : r3.push([d2(e3[n3])]);
        t4 = r3;
      } else t4 = d2(e3);
      return "string" == typeof arguments[0] ? t4 : (arguments[0].text = t4, arguments[0]);
    };
    t3.events.push(["preProcessText", p2]);
  })(E$1.API), E$1.API.autoPrint = function(t3) {
    var e2;
    switch ((t3 = t3 || {}).variant = t3.variant || "non-conform", t3.variant) {
      case "javascript":
        this.addJS("print({});");
        break;
      case "non-conform":
      default:
        this.internal.events.subscribe("postPutResources", function() {
          e2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
        }), this.internal.events.subscribe("putCatalog", function() {
          this.internal.out("/OpenAction " + e2 + " 0 R");
        });
    }
    return this;
  }, /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    var e2 = function() {
      var t4 = void 0;
      Object.defineProperty(this, "pdf", {
        get: function() {
          return t4;
        },
        set: function(e4) {
          t4 = e4;
        }
      });
      var e3 = 150;
      Object.defineProperty(this, "width", {
        get: function() {
          return e3;
        },
        set: function(t5) {
          e3 = isNaN(t5) || false === Number.isInteger(t5) || t5 < 0 ? 150 : t5, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
        }
      });
      var r2 = 300;
      Object.defineProperty(this, "height", {
        get: function() {
          return r2;
        },
        set: function(t5) {
          r2 = isNaN(t5) || false === Number.isInteger(t5) || t5 < 0 ? 300 : t5, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r2 + 1);
        }
      });
      var n2 = [];
      Object.defineProperty(this, "childNodes", {
        get: function() {
          return n2;
        },
        set: function(t5) {
          n2 = t5;
        }
      });
      var i2 = {};
      Object.defineProperty(this, "style", {
        get: function() {
          return i2;
        },
        set: function(t5) {
          i2 = t5;
        }
      }), Object.defineProperty(this, "parentNode", {});
    };
    e2.prototype.getContext = function(t4, e3) {
      var r2;
      if ("2d" !== (t4 = t4 || "2d")) return null;
      for (r2 in e3) this.pdf.context2d.hasOwnProperty(r2) && (this.pdf.context2d[r2] = e3[r2]);
      return this.pdf.context2d._canvas = this, this.pdf.context2d;
    }, e2.prototype.toDataURL = function() {
      throw new Error("toDataURL is not implemented.");
    }, t3.events.push(["initialized", function() {
      this.canvas = new e2(), this.canvas.pdf = this;
    }]);
  })(E$1.API), (function(e2) {
    var r2 = {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0
    }, n2 = false, i2 = function() {
      void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r2), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
    }, a2 = function() {
      this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
    }, o2 = function() {
      var t3 = arguments[0];
      Object.defineProperty(this, "x", {
        enumerable: true,
        get: function() {
          return t3;
        },
        set: function(e4) {
          t3 = e4;
        }
      });
      var e3 = arguments[1];
      Object.defineProperty(this, "y", {
        enumerable: true,
        get: function() {
          return e3;
        },
        set: function(t4) {
          e3 = t4;
        }
      });
      var r3 = arguments[2];
      Object.defineProperty(this, "width", {
        enumerable: true,
        get: function() {
          return r3;
        },
        set: function(t4) {
          r3 = t4;
        }
      });
      var n3 = arguments[3];
      Object.defineProperty(this, "height", {
        enumerable: true,
        get: function() {
          return n3;
        },
        set: function(t4) {
          n3 = t4;
        }
      });
      var i3 = arguments[4];
      Object.defineProperty(this, "text", {
        enumerable: true,
        get: function() {
          return i3;
        },
        set: function(t4) {
          i3 = t4;
        }
      });
      var a3 = arguments[5];
      Object.defineProperty(this, "lineNumber", {
        enumerable: true,
        get: function() {
          return a3;
        },
        set: function(t4) {
          a3 = t4;
        }
      });
      var o3 = arguments[6];
      return Object.defineProperty(this, "align", {
        enumerable: true,
        get: function() {
          return o3;
        },
        set: function(t4) {
          o3 = t4;
        }
      }), this;
    };
    o2.prototype.clone = function() {
      return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
    }, o2.prototype.toArray = function() {
      return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
    }, e2.setHeaderFunction = function(t3) {
      return i2.call(this), this.internal.__cell__.headerFunction = "function" == typeof t3 ? t3 : void 0, this;
    }, e2.getTextDimensions = function(t3, e3) {
      i2.call(this);
      var r3 = (e3 = e3 || {}).fontSize || this.getFontSize(), n3 = e3.font || this.getFont(), a3 = e3.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;
      if (!Array.isArray(t3) && "string" != typeof t3) {
        if ("number" != typeof t3) throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
        t3 = String(t3);
      }
      var h2 = e3.maxWidth;
      h2 > 0 ? "string" == typeof t3 ? t3 = this.splitTextToSize(t3, h2) : "[object Array]" === Object.prototype.toString.call(t3) && (t3 = t3.reduce(function(t4, e4) {
        return t4.concat(u2.splitTextToSize(e4, h2));
      }, [])) : t3 = Array.isArray(t3) ? t3 : [t3];
      for (var l2 = 0; l2 < t3.length; l2++) o3 < (c3 = this.getStringUnitWidth(t3[l2], {
        font: n3
      }) * r3) && (o3 = c3);
      return 0 !== o3 && (s3 = t3.length), {
        w: o3 /= a3,
        h: Math.max((s3 * r3 * this.getLineHeightFactor() - r3 * (this.getLineHeightFactor() - 1)) / a3, 0)
      };
    }, e2.cellAddPage = function() {
      i2.call(this), this.addPage();
      var t3 = this.internal.__cell__.margins || r2;
      return this.internal.__cell__.lastCell = new o2(t3.left, t3.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
    };
    var s2 = e2.cell = function() {
      var t3;
      t3 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);
      var e3 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r2, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;
      return void 0 !== e3.lineNumber && (e3.lineNumber === t3.lineNumber ? (t3.x = (e3.x || 0) + (e3.width || 0), t3.y = e3.y || 0) : e3.y + e3.height + t3.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t3.y = s3.top, u2 && c3 && (this.printHeaderRow(t3.lineNumber, true), t3.y += c3[0].height)) : t3.y = e3.y + e3.height || t3.y), void 0 !== t3.text[0] && (this.rect(t3.x, t3.y, t3.width, t3.height, true === n2 ? "FD" : void 0), "right" === t3.align ? this.text(t3.text, t3.x + t3.width - a3, t3.y + a3, {
        align: "right",
        baseline: "top"
      }) : "center" === t3.align ? this.text(t3.text, t3.x + t3.width / 2, t3.y + a3, {
        align: "center",
        baseline: "top",
        maxWidth: t3.width - a3 - a3
      }) : this.text(t3.text, t3.x + a3, t3.y + a3, {
        align: "left",
        baseline: "top",
        maxWidth: t3.width - a3 - a3
      })), this.internal.__cell__.lastCell = t3, this;
    };
    e2.table = function(e3, n3, u2, h2, l2) {
      if (i2.call(this), !u2) throw new Error("No data for PDF table.");
      var f2, d2, p2, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = false !== l2.printHeaders, S2 = l2.css && void 0 !== l2.css["font-size"] ? 16 * l2.css["font-size"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({
        width: this.getPageWidth()
      }, r2), P2 = "number" == typeof l2.padding ? l2.padding : 3, k2 = l2.headerBackgroundColor || "#c8c8c8", I2 = l2.headerTextColor || "#000";
      if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), null == h2) v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {
        return "left";
      });
      else if (Array.isArray(h2) && "object" === _typeof$1(h2[0])) for (m2 = h2.map(function(t3) {
        return t3.name;
      }), v2 = h2.map(function(t3) {
        return t3.prompt || t3.name || "";
      }), b2 = h2.map(function(t3) {
        return t3.align || "left";
      }), f2 = 0; f2 < h2.length; f2 += 1) w2[h2[f2].name] = h2[f2].width * (19.049976 / 25.4);
      else Array.isArray(h2) && "string" == typeof h2[0] && (v2 = m2 = h2, b2 = m2.map(function() {
        return "left";
      }));
      if (A2 || Array.isArray(h2) && "string" == typeof h2[0]) for (f2 = 0; f2 < m2.length; f2 += 1) {
        for (y2[g2 = m2[f2]] = u2.map(function(t3) {
          return t3[g2];
        }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], {
          fontSize: this.internal.__cell__.table_font_size,
          scaleFactor: this.internal.scaleFactor
        }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d2.length; p2 += 1) N2.push(this.getTextDimensions(d2[p2], {
          fontSize: this.internal.__cell__.table_font_size,
          scaleFactor: this.internal.scaleFactor
        }).w);
        w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
      }
      if (x2) {
        var F2 = {};
        for (f2 = 0; f2 < m2.length; f2 += 1) F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];
        var C2 = c2.call(this, F2, w2);
        L2 = m2.map(function(t3) {
          return new o2(e3, n3, w2[t3], C2, F2[t3].text, void 0, F2[t3].align);
        }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
      }
      var j2 = h2.reduce(function(t3, e4) {
        return t3[e4.name] = e4.align, t3;
      }, {});
      for (f2 = 0; f2 < u2.length; f2 += 1) {
        "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({
          row: f2,
          data: u2[f2]
        }, this);
        var O2 = c2.call(this, u2[f2], w2);
        for (p2 = 0; p2 < m2.length; p2 += 1) {
          var B2 = u2[f2][m2[p2]];
          "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({
            row: f2,
            col: p2,
            data: B2
          }, this), s2.call(this, new o2(e3, n3, w2[m2[p2]], O2, B2, f2 + 2, j2[m2[p2]]));
        }
      }
      return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = n3, this;
    };
    var c2 = function(t3, e3) {
      var r3 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
      return Object.keys(t3).map(function(n4) {
        var i4 = t3[n4];
        return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e3[n4] - r3 - r3);
      }, this).map(function(t4) {
        return this.getLineHeightFactor() * t4.length * n3 / i3 + r3 + r3;
      }, this).reduce(function(t4, e4) {
        return Math.max(t4, e4);
      }, 0);
    };
    e2.setTableHeaderRow = function(t3) {
      i2.call(this), this.internal.__cell__.tableHeaderRow = t3;
    }, e2.printHeaderRow = function(t3, e3) {
      if (i2.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
      var r3;
      if (n2 = true, "function" == typeof this.internal.__cell__.headerFunction) {
        var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
        this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
      }
      this.setFont(void 0, "bold");
      for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {
        r3 = this.internal.__cell__.tableHeaderRow[u2].clone(), e3 && (r3.y = this.internal.__cell__.margins.top || 0, c3.push(r3)), r3.lineNumber = t3;
        var h2 = this.getTextColor();
        this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r3), this.setTextColor(h2);
      }
      c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, "normal"), n2 = false;
    };
  })(E$1.API);
  var Pt$1 = {
    italic: ["italic", "oblique", "normal"],
    oblique: ["oblique", "italic", "normal"],
    normal: ["normal", "oblique", "italic"]
  };
  var kt$1 = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
  var It$1 = _t(kt$1);
  var Ft$1 = [100, 200, 300, 400, 500, 600, 700, 800, 900];
  var Ct$1 = _t(Ft$1);
  function jt$1(t3) {
    var e2 = t3.family.replace(/"|'/g, "").toLowerCase(), r2 = (function(t4) {
      return Pt$1[t4 = t4 || "normal"] ? t4 : "normal";
    })(t3.style), n2 = (function(t4) {
      if (!t4) return 400;
      if ("number" == typeof t4) return t4 >= 100 && t4 <= 900 && t4 % 100 == 0 ? t4 : 400;
      if (/^\d00$/.test(t4)) return parseInt(t4);
      switch (t4) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    })(t3.weight), i2 = (function(t4) {
      return "number" == typeof It$1[t4 = t4 || "normal"] ? t4 : "normal";
    })(t3.stretch);
    return {
      family: e2,
      style: r2,
      weight: n2,
      stretch: i2,
      src: t3.src || [],
      ref: t3.ref || {
        name: e2,
        style: [i2, r2, n2].join(" ")
      }
    };
  }
  function Ot$1(t3, e2, r2, n2) {
    var i2;
    for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 += n2) if (t3[e2[i2]]) return t3[e2[i2]];
    for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 -= n2) if (t3[e2[i2]]) return t3[e2[i2]];
  }
  var Bt$1 = {
    "sans-serif": "helvetica",
    fixed: "courier",
    monospace: "courier",
    terminal: "courier",
    cursive: "times",
    fantasy: "times",
    serif: "times"
  };
  var Mt$1 = {
    caption: "times",
    icon: "times",
    menu: "times",
    "message-box": "times",
    "small-caption": "times",
    "status-bar": "times"
  };
  function Et$1(t3) {
    return [t3.stretch, t3.style, t3.weight, t3.family].join(" ");
  }
  function qt(t3, e2, r2) {
    for (var n2 = (r2 = r2 || {}).defaultFontFamily || "times", i2 = Object.assign({}, Bt$1, r2.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e2.length; ++s2) if (i2[(a2 = jt$1(e2[s2])).family] && (a2.family = i2[a2.family]), t3.hasOwnProperty(a2.family)) {
      o2 = t3[a2.family];
      break;
    }
    if (!(o2 = o2 || t3[n2])) throw new Error("Could not find a font-family for the rule '" + Et$1(a2) + "' and default family '" + n2 + "'.");
    if (o2 = (function(t4, e3) {
      if (e3[t4]) return e3[t4];
      var r3 = It$1[t4], n3 = r3 <= It$1.normal ? -1 : 1, i3 = Ot$1(e3, kt$1, r3, n3);
      if (!i3) throw new Error("Could not find a matching font-stretch value for " + t4);
      return i3;
    })(a2.stretch, o2), o2 = (function(t4, e3) {
      if (e3[t4]) return e3[t4];
      for (var r3 = Pt$1[t4], n3 = 0; n3 < r3.length; ++n3) if (e3[r3[n3]]) return e3[r3[n3]];
      throw new Error("Could not find a matching font-style for " + t4);
    })(a2.style, o2), !(o2 = (function(t4, e3) {
      if (e3[t4]) return e3[t4];
      if (400 === t4 && e3[500]) return e3[500];
      if (500 === t4 && e3[400]) return e3[400];
      var r3 = Ct$1[t4], n3 = Ot$1(e3, Ft$1, r3, t4 < 400 ? -1 : 1);
      if (!n3) throw new Error("Could not find a matching font-weight for value " + t4);
      return n3;
    })(a2.weight, o2))) throw new Error("Failed to resolve a font for the rule '" + Et$1(a2) + "'.");
    return o2;
  }
  function Dt$1(t3) {
    return t3.trimLeft();
  }
  function Rt$1(t3, e2) {
    for (var r2 = 0; r2 < t3.length; ) {
      if (t3.charAt(r2) === e2) return [t3.substring(0, r2), t3.substring(r2 + 1)];
      r2 += 1;
    }
    return null;
  }
  function Tt$1(t3) {
    var e2 = t3.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
    return null === e2 ? null : [e2[0], t3.substring(e2[0].length)];
  }
  var Ut$1;
  var zt$1;
  var Ht$1;
  var Wt$1 = ["times"];
  !(function(e2) {
    var r2, n2, i2, o2, s2, c2, u2, h2, l2, d2 = function(t3) {
      return t3 = t3 || {}, this.isStrokeTransparent = t3.isStrokeTransparent || false, this.strokeOpacity = t3.strokeOpacity || 1, this.strokeStyle = t3.strokeStyle || "#000000", this.fillStyle = t3.fillStyle || "#000000", this.isFillTransparent = t3.isFillTransparent || false, this.fillOpacity = t3.fillOpacity || 1, this.font = t3.font || "10px sans-serif", this.textBaseline = t3.textBaseline || "alphabetic", this.textAlign = t3.textAlign || "left", this.lineWidth = t3.lineWidth || 1, this.lineJoin = t3.lineJoin || "miter", this.lineCap = t3.lineCap || "butt", this.path = t3.path || [], this.transform = void 0 !== t3.transform ? t3.transform.clone() : new h2(), this.globalCompositeOperation = t3.globalCompositeOperation || "normal", this.globalAlpha = t3.globalAlpha || 1, this.clip_path = t3.clip_path || [], this.currentPoint = t3.currentPoint || new c2(), this.miterLimit = t3.miterLimit || 10, this.lastPoint = t3.lastPoint || new c2(), this.lineDashOffset = t3.lineDashOffset || 0, this.lineDash = t3.lineDash || [], this.margin = t3.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t3.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t3.ignoreClearRect || t3.ignoreClearRect, this;
    };
    e2.events.push(["initialized", function() {
      this.context2d = new p2(this), r2 = this.internal.f2, n2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h2 = this.internal.Matrix, l2 = new d2();
    }]);
    var p2 = function(t3) {
      Object.defineProperty(this, "canvas", {
        get: function() {
          return {
            parentNode: false,
            style: false
          };
        }
      });
      var e3 = t3;
      Object.defineProperty(this, "pdf", {
        get: function() {
          return e3;
        }
      });
      var r3 = false;
      Object.defineProperty(this, "pageWrapXEnabled", {
        get: function() {
          return r3;
        },
        set: function(t4) {
          r3 = Boolean(t4);
        }
      });
      var n3 = false;
      Object.defineProperty(this, "pageWrapYEnabled", {
        get: function() {
          return n3;
        },
        set: function(t4) {
          n3 = Boolean(t4);
        }
      });
      var i3 = 0;
      Object.defineProperty(this, "posX", {
        get: function() {
          return i3;
        },
        set: function(t4) {
          isNaN(t4) || (i3 = t4);
        }
      });
      var a2 = 0;
      Object.defineProperty(this, "posY", {
        get: function() {
          return a2;
        },
        set: function(t4) {
          isNaN(t4) || (a2 = t4);
        }
      }), Object.defineProperty(this, "margin", {
        get: function() {
          return l2.margin;
        },
        set: function(t4) {
          var e4;
          "number" == typeof t4 ? e4 = [t4, t4, t4, t4] : ((e4 = new Array(4))[0] = t4[0], e4[1] = t4.length >= 2 ? t4[1] : e4[0], e4[2] = t4.length >= 3 ? t4[2] : e4[0], e4[3] = t4.length >= 4 ? t4[3] : e4[1]), l2.margin = e4;
        }
      });
      var o3 = false;
      Object.defineProperty(this, "autoPaging", {
        get: function() {
          return o3;
        },
        set: function(t4) {
          o3 = t4;
        }
      });
      var s3 = 0;
      Object.defineProperty(this, "lastBreak", {
        get: function() {
          return s3;
        },
        set: function(t4) {
          s3 = t4;
        }
      });
      var c3 = [];
      Object.defineProperty(this, "pageBreaks", {
        get: function() {
          return c3;
        },
        set: function(t4) {
          c3 = t4;
        }
      }), Object.defineProperty(this, "ctx", {
        get: function() {
          return l2;
        },
        set: function(t4) {
          t4 instanceof d2 && (l2 = t4);
        }
      }), Object.defineProperty(this, "path", {
        get: function() {
          return l2.path;
        },
        set: function(t4) {
          l2.path = t4;
        }
      });
      var u3 = [];
      Object.defineProperty(this, "ctxStack", {
        get: function() {
          return u3;
        },
        set: function(t4) {
          u3 = t4;
        }
      }), Object.defineProperty(this, "fillStyle", {
        get: function() {
          return this.ctx.fillStyle;
        },
        set: function(t4) {
          var e4;
          e4 = g2(t4), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = 0 === e4.a, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, {
            a: e4.a
          }), this.pdf.setTextColor(e4.r, e4.g, e4.b, {
            a: e4.a
          });
        }
      }), Object.defineProperty(this, "strokeStyle", {
        get: function() {
          return this.ctx.strokeStyle;
        },
        set: function(t4) {
          var e4 = g2(t4);
          this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = 0 === e4.a, this.ctx.strokeOpacity = e4.a, 0 === e4.a ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
        }
      }), Object.defineProperty(this, "lineCap", {
        get: function() {
          return this.ctx.lineCap;
        },
        set: function(t4) {
          -1 !== ["butt", "round", "square"].indexOf(t4) && (this.ctx.lineCap = t4, this.pdf.setLineCap(t4));
        }
      }), Object.defineProperty(this, "lineWidth", {
        get: function() {
          return this.ctx.lineWidth;
        },
        set: function(t4) {
          isNaN(t4) || (this.ctx.lineWidth = t4, this.pdf.setLineWidth(t4));
        }
      }), Object.defineProperty(this, "lineJoin", {
        get: function() {
          return this.ctx.lineJoin;
        },
        set: function(t4) {
          -1 !== ["bevel", "round", "miter"].indexOf(t4) && (this.ctx.lineJoin = t4, this.pdf.setLineJoin(t4));
        }
      }), Object.defineProperty(this, "miterLimit", {
        get: function() {
          return this.ctx.miterLimit;
        },
        set: function(t4) {
          isNaN(t4) || (this.ctx.miterLimit = t4, this.pdf.setMiterLimit(t4));
        }
      }), Object.defineProperty(this, "textBaseline", {
        get: function() {
          return this.ctx.textBaseline;
        },
        set: function(t4) {
          this.ctx.textBaseline = t4;
        }
      }), Object.defineProperty(this, "textAlign", {
        get: function() {
          return this.ctx.textAlign;
        },
        set: function(t4) {
          -1 !== ["right", "end", "center", "left", "start"].indexOf(t4) && (this.ctx.textAlign = t4);
        }
      });
      var h3 = null;
      function f2(t4, e4) {
        if (null === h3) {
          var r4 = (function(t5) {
            var e5 = [];
            return Object.keys(t5).forEach(function(r5) {
              t5[r5].forEach(function(t6) {
                var n4 = null;
                switch (t6) {
                  case "bold":
                    n4 = {
                      family: r5,
                      weight: "bold"
                    };
                    break;
                  case "italic":
                    n4 = {
                      family: r5,
                      style: "italic"
                    };
                    break;
                  case "bolditalic":
                    n4 = {
                      family: r5,
                      weight: "bold",
                      style: "italic"
                    };
                    break;
                  case "":
                  case "normal":
                    n4 = {
                      family: r5
                    };
                }
                null !== n4 && (n4.ref = {
                  name: r5,
                  style: t6
                }, e5.push(n4));
              });
            }), e5;
          })(t4.getFontList());
          h3 = (function(t5) {
            for (var e5 = {}, r5 = 0; r5 < t5.length; ++r5) {
              var n4 = jt$1(t5[r5]), i4 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;
              e5[i4] = e5[i4] || {}, e5[i4][a3] = e5[i4][a3] || {}, e5[i4][a3][o4] = e5[i4][a3][o4] || {}, e5[i4][a3][o4][s4] = n4;
            }
            return e5;
          })(r4.concat(e4));
        }
        return h3;
      }
      var p3 = null;
      Object.defineProperty(this, "fontFaces", {
        get: function() {
          return p3;
        },
        set: function(t4) {
          h3 = null, p3 = t4;
        }
      }), Object.defineProperty(this, "font", {
        get: function() {
          return this.ctx.font;
        },
        set: function(t4) {
          var e4;
          if (this.ctx.font = t4, null !== (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t4))) {
            var r4 = e4[1];
            e4[2];
            var n4 = e4[3], i4 = e4[4];
            e4[5];
            var a3 = e4[6], o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
            i4 = "px" === o4 ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : "em" === o4 ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
            var s4 = (function(t5) {
              var e5, r5, n5 = [], i5 = t5.trim();
              if ("" === i5) return Wt$1;
              if (i5 in Mt$1) return [Mt$1[i5]];
              for (; "" !== i5; ) {
                switch (r5 = null, e5 = (i5 = Dt$1(i5)).charAt(0)) {
                  case '"':
                  case "'":
                    r5 = Rt$1(i5.substring(1), e5);
                    break;
                  default:
                    r5 = Tt$1(i5);
                }
                if (null === r5) return Wt$1;
                if (n5.push(r5[0]), "" !== (i5 = Dt$1(r5[1])) && "," !== i5.charAt(0)) return Wt$1;
                i5 = i5.replace(/^,/, "");
              }
              return n5;
            })(a3);
            if (this.fontFaces) {
              var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t5) {
                return {
                  family: t5,
                  stretch: "normal",
                  weight: n4,
                  style: r4
                };
              }));
              this.pdf.setFont(c4.ref.name, c4.ref.style);
            } else {
              var u4 = "";
              ("bold" === n4 || parseInt(n4, 10) >= 700 || "bold" === r4) && (u4 = "bold"), "italic" === r4 && (u4 += "italic"), 0 === u4.length && (u4 = "normal");
              for (var h4 = "", l3 = {
                arial: "Helvetica",
                Arial: "Helvetica",
                verdana: "Helvetica",
                Verdana: "Helvetica",
                helvetica: "Helvetica",
                Helvetica: "Helvetica",
                "sans-serif": "Helvetica",
                fixed: "Courier",
                monospace: "Courier",
                terminal: "Courier",
                cursive: "Times",
                fantasy: "Times",
                serif: "Times"
              }, d3 = 0; d3 < s4.length; d3++) {
                if (void 0 !== this.pdf.internal.getFont(s4[d3], u4, {
                  noFallback: true,
                  disableWarning: true
                })) {
                  h4 = s4[d3];
                  break;
                }
                if ("bolditalic" === u4 && void 0 !== this.pdf.internal.getFont(s4[d3], "bold", {
                  noFallback: true,
                  disableWarning: true
                })) h4 = s4[d3], u4 = "bold";
                else if (void 0 !== this.pdf.internal.getFont(s4[d3], "normal", {
                  noFallback: true,
                  disableWarning: true
                })) {
                  h4 = s4[d3], u4 = "normal";
                  break;
                }
              }
              if ("" === h4) {
                for (var p4 = 0; p4 < s4.length; p4++) if (l3[s4[p4]]) {
                  h4 = l3[s4[p4]];
                  break;
                }
              }
              h4 = "" === h4 ? "Times" : h4, this.pdf.setFont(h4, u4);
            }
          }
        }
      }), Object.defineProperty(this, "globalCompositeOperation", {
        get: function() {
          return this.ctx.globalCompositeOperation;
        },
        set: function(t4) {
          this.ctx.globalCompositeOperation = t4;
        }
      }), Object.defineProperty(this, "globalAlpha", {
        get: function() {
          return this.ctx.globalAlpha;
        },
        set: function(t4) {
          this.ctx.globalAlpha = t4;
        }
      }), Object.defineProperty(this, "lineDashOffset", {
        get: function() {
          return this.ctx.lineDashOffset;
        },
        set: function(t4) {
          this.ctx.lineDashOffset = t4, T2.call(this);
        }
      }), Object.defineProperty(this, "lineDash", {
        get: function() {
          return this.ctx.lineDash;
        },
        set: function(t4) {
          this.ctx.lineDash = t4, T2.call(this);
        }
      }), Object.defineProperty(this, "ignoreClearRect", {
        get: function() {
          return this.ctx.ignoreClearRect;
        },
        set: function(t4) {
          this.ctx.ignoreClearRect = Boolean(t4);
        }
      });
    };
    p2.prototype.setLineDash = function(t3) {
      this.lineDash = t3;
    }, p2.prototype.getLineDash = function() {
      return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
    }, p2.prototype.fill = function() {
      A2.call(this, "fill", false);
    }, p2.prototype.stroke = function() {
      A2.call(this, "stroke", false);
    }, p2.prototype.beginPath = function() {
      this.path = [{
        type: "begin"
      }];
    }, p2.prototype.moveTo = function(t3, e3) {
      if (isNaN(t3) || isNaN(e3)) throw a$1.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
      var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
      this.path.push({
        type: "mt",
        x: r3.x,
        y: r3.y
      }), this.ctx.lastPoint = new c2(t3, e3);
    }, p2.prototype.closePath = function() {
      var e3 = new c2(0, 0), r3 = 0;
      for (r3 = this.path.length - 1; -1 !== r3; r3--) if ("begin" === this.path[r3].type && "object" === _typeof$1(this.path[r3 + 1]) && "number" == typeof this.path[r3 + 1].x) {
        e3 = new c2(this.path[r3 + 1].x, this.path[r3 + 1].y);
        break;
      }
      this.path.push({
        type: "close"
      }), this.ctx.lastPoint = new c2(e3.x, e3.y);
    }, p2.prototype.lineTo = function(t3, e3) {
      if (isNaN(t3) || isNaN(e3)) throw a$1.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
      var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
      this.path.push({
        type: "lt",
        x: r3.x,
        y: r3.y
      }), this.ctx.lastPoint = new c2(r3.x, r3.y);
    }, p2.prototype.clip = function() {
      this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
    }, p2.prototype.quadraticCurveTo = function(t3, e3, r3, n3) {
      if (isNaN(r3) || isNaN(n3) || isNaN(t3) || isNaN(e3)) throw a$1.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
      var i3 = this.ctx.transform.applyToPoint(new c2(r3, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
      this.path.push({
        type: "qct",
        x1: o3.x,
        y1: o3.y,
        x: i3.x,
        y: i3.y
      }), this.ctx.lastPoint = new c2(i3.x, i3.y);
    }, p2.prototype.bezierCurveTo = function(t3, e3, r3, n3, i3, o3) {
      if (isNaN(i3) || isNaN(o3) || isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3)) throw a$1.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
      var s3 = this.ctx.transform.applyToPoint(new c2(i3, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t3, e3)), h3 = this.ctx.transform.applyToPoint(new c2(r3, n3));
      this.path.push({
        type: "bct",
        x1: u3.x,
        y1: u3.y,
        x2: h3.x,
        y2: h3.y,
        x: s3.x,
        y: s3.y
      }), this.ctx.lastPoint = new c2(s3.x, s3.y);
    }, p2.prototype.arc = function(t3, e3, r3, n3, i3, o3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3)) throw a$1.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
      if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {
        var s3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
        t3 = s3.x, e3 = s3.y;
        var u3 = this.ctx.transform.applyToPoint(new c2(0, r3)), h3 = this.ctx.transform.applyToPoint(new c2(0, 0));
        r3 = Math.sqrt(Math.pow(u3.x - h3.x, 2) + Math.pow(u3.y - h3.y, 2));
      }
      Math.abs(i3 - n3) >= 2 * Math.PI && (n3 = 0, i3 = 2 * Math.PI), this.path.push({
        type: "arc",
        x: t3,
        y: e3,
        radius: r3,
        startAngle: n3,
        endAngle: i3,
        counterclockwise: o3
      });
    }, p2.prototype.arcTo = function(t3, e3, r3, n3, i3) {
      throw new Error("arcTo not implemented.");
    }, p2.prototype.rect = function(t3, e3, r3, n3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3)) throw a$1.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
      this.moveTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3 + r3, e3 + n3), this.lineTo(t3, e3 + n3), this.lineTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3, e3);
    }, p2.prototype.fillRect = function(t3, e3, r3, n3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3)) throw a$1.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
      if (!m2.call(this)) {
        var i3 = {};
        "butt" !== this.lineCap && (i3.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t3, e3, r3, n3), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
      }
    }, p2.prototype.strokeRect = function(t3, e3, r3, n3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3)) throw a$1.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
      v2.call(this) || (this.beginPath(), this.rect(t3, e3, r3, n3), this.stroke());
    }, p2.prototype.clearRect = function(t3, e3, r3, n3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3)) throw a$1.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
      this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t3, e3, r3, n3));
    }, p2.prototype.save = function(t3) {
      t3 = "boolean" != typeof t3 || t3;
      for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++) this.pdf.setPage(r3 + 1), this.pdf.internal.out("q");
      if (this.pdf.setPage(e3), t3) {
        this.ctx.fontSize = this.pdf.internal.getFontSize();
        var n3 = new d2(this.ctx);
        this.ctxStack.push(this.ctx), this.ctx = n3;
      }
    }, p2.prototype.restore = function(t3) {
      t3 = "boolean" != typeof t3 || t3;
      for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++) this.pdf.setPage(r3 + 1), this.pdf.internal.out("Q");
      this.pdf.setPage(e3), t3 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
    }, p2.prototype.toDataURL = function() {
      throw new Error("toDataUrl not implemented.");
    };
    var g2 = function(t3) {
      var e3, r3, n3, i3;
      if (true === t3.isCanvasGradient && (t3 = t3.getColor()), !t3) return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        style: t3
      };
      if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t3)) e3 = 0, r3 = 0, n3 = 0, i3 = 0;
      else {
        var a2 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t3);
        if (null !== a2) e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = 1;
        else if (null !== (a2 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t3))) e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = parseFloat(a2[4]);
        else {
          if (i3 = 1, "string" == typeof t3 && "#" !== t3.charAt(0)) {
            var o3 = new f$2(t3);
            t3 = o3.ok ? o3.toHex() : "#000000";
          }
          4 === t3.length ? (e3 = t3.substring(1, 2), e3 += e3, r3 = t3.substring(2, 3), r3 += r3, n3 = t3.substring(3, 4), n3 += n3) : (e3 = t3.substring(1, 3), r3 = t3.substring(3, 5), n3 = t3.substring(5, 7)), e3 = parseInt(e3, 16), r3 = parseInt(r3, 16), n3 = parseInt(n3, 16);
        }
      }
      return {
        r: e3,
        g: r3,
        b: n3,
        a: i3,
        style: t3
      };
    }, m2 = function() {
      return this.ctx.isFillTransparent || 0 == this.globalAlpha;
    }, v2 = function() {
      return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
    };
    p2.prototype.fillText = function(t3, e3, r3, n3) {
      if (isNaN(e3) || isNaN(r3) || "string" != typeof t3) throw a$1.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
      if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {
        var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
        C2.call(this, {
          text: t3,
          x: e3,
          y: r3,
          scale: o3,
          angle: i3,
          align: this.textAlign,
          maxWidth: n3
        });
      }
    }, p2.prototype.strokeText = function(t3, e3, r3, n3) {
      if (isNaN(e3) || isNaN(r3) || "string" != typeof t3) throw a$1.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
      if (!v2.call(this)) {
        n3 = isNaN(n3) ? void 0 : n3;
        var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
        C2.call(this, {
          text: t3,
          x: e3,
          y: r3,
          scale: o3,
          renderingMode: "stroke",
          angle: i3,
          align: this.textAlign,
          maxWidth: n3
        });
      }
    }, p2.prototype.measureText = function(t3) {
      if ("string" != typeof t3) throw a$1.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
      var e3 = this.pdf, r3 = this.pdf.internal.scaleFactor, n3 = e3.internal.getFontSize(), i3 = e3.getStringUnitWidth(t3) * n3 / e3.internal.scaleFactor, o3 = function(t4) {
        var e4 = (t4 = t4 || {}).width || 0;
        return Object.defineProperty(this, "width", {
          get: function() {
            return e4;
          }
        }), this;
      };
      return new o3({
        width: i3 *= Math.round(96 * r3 / 72 * 1e4) / 1e4
      });
    }, p2.prototype.scale = function(t3, e3) {
      if (isNaN(t3) || isNaN(e3)) throw a$1.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
      var r3 = new h2(t3, 0, 0, e3, 0, 0);
      this.ctx.transform = this.ctx.transform.multiply(r3);
    }, p2.prototype.rotate = function(t3) {
      if (isNaN(t3)) throw a$1.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
      var e3 = new h2(Math.cos(t3), Math.sin(t3), -Math.sin(t3), Math.cos(t3), 0, 0);
      this.ctx.transform = this.ctx.transform.multiply(e3);
    }, p2.prototype.translate = function(t3, e3) {
      if (isNaN(t3) || isNaN(e3)) throw a$1.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
      var r3 = new h2(1, 0, 0, 1, t3, e3);
      this.ctx.transform = this.ctx.transform.multiply(r3);
    }, p2.prototype.transform = function(t3, e3, r3, n3, i3, o3) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3) || isNaN(o3)) throw a$1.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
      var s3 = new h2(t3, e3, r3, n3, i3, o3);
      this.ctx.transform = this.ctx.transform.multiply(s3);
    }, p2.prototype.setTransform = function(t3, e3, r3, n3, i3, a2) {
      t3 = isNaN(t3) ? 1 : t3, e3 = isNaN(e3) ? 0 : e3, r3 = isNaN(r3) ? 0 : r3, n3 = isNaN(n3) ? 1 : n3, i3 = isNaN(i3) ? 0 : i3, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h2(t3, e3, r3, n3, i3, a2);
    };
    var b2 = function() {
      return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
    };
    p2.prototype.drawImage = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {
      var l3 = this.pdf.getImageProperties(t3), f2 = 1, d3 = 1, p3 = 1, g3 = 1;
      void 0 !== n3 && void 0 !== s3 && (p3 = s3 / n3, g3 = c3 / i3, f2 = l3.width / n3 * s3 / n3, d3 = l3.height / i3 * c3 / i3), void 0 === a2 && (a2 = e3, o3 = r3, e3 = 0, r3 = 0), void 0 !== n3 && void 0 === s3 && (s3 = n3, c3 = i3), void 0 === n3 && void 0 === s3 && (s3 = l3.width, c3 = l3.height);
      for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h2(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e3 * p3, o3 - r3 * g3, n3 * f2, i3 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1) -1 === P3.indexOf(_3[k3]) && P3.push(_3[k3]);
      if (L2(P3), this.autoPaging) for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
        this.pdf.setPage(C3);
        var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = 1 === C3 ? this.posY + this.margin[0] : this.margin[0], B3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = 1 === C3 ? 0 : B3 + (C3 - 2) * M3;
        if (0 !== this.ctx.clip_path.length) {
          var D3 = this.path;
          m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
        }
        var R3 = JSON.parse(JSON.stringify(S3));
        R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];
        var T3 = (C3 > I3 || C3 < F3) && b2.call(this);
        T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t3, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
      }
      else this.pdf.addImage(t3, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
    };
    var y2 = function(t3, e3, r3) {
      var n3 = [];
      e3 = e3 || this.pdf.internal.pageSize.width, r3 = r3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
      var i3 = this.posY + this.ctx.prevPageLastElemOffset;
      switch (t3.type) {
        default:
        case "mt":
        case "lt":
          n3.push(Math.floor((t3.y + i3) / r3) + 1);
          break;
        case "arc":
          n3.push(Math.floor((t3.y + i3 - t3.radius) / r3) + 1), n3.push(Math.floor((t3.y + i3 + t3.radius) / r3) + 1);
          break;
        case "qct":
          var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x, t3.y);
          n3.push(Math.floor((a2.y + i3) / r3) + 1), n3.push(Math.floor((a2.y + a2.h + i3) / r3) + 1);
          break;
        case "bct":
          var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);
          n3.push(Math.floor((o3.y + i3) / r3) + 1), n3.push(Math.floor((o3.y + o3.h + i3) / r3) + 1);
          break;
        case "rect":
          n3.push(Math.floor((t3.y + i3) / r3) + 1), n3.push(Math.floor((t3.y + t3.h + i3) / r3) + 1);
      }
      for (var s3 = 0; s3 < n3.length; s3 += 1) for (; this.pdf.internal.getNumberOfPages() < n3[s3]; ) w2.call(this);
      return n3;
    }, w2 = function() {
      var t3 = this.fillStyle, e3 = this.strokeStyle, r3 = this.font, n3 = this.lineCap, i3 = this.lineWidth, a2 = this.lineJoin;
      this.pdf.addPage(), this.fillStyle = t3, this.strokeStyle = e3, this.font = r3, this.lineCap = n3, this.lineWidth = i3, this.lineJoin = a2;
    }, N2 = function(t3, e3, r3) {
      for (var n3 = 0; n3 < t3.length; n3++) switch (t3[n3].type) {
        case "bct":
          t3[n3].x2 += e3, t3[n3].y2 += r3;
        case "qct":
          t3[n3].x1 += e3, t3[n3].y1 += r3;
        case "mt":
        case "lt":
        case "arc":
        default:
          t3[n3].x += e3, t3[n3].y += r3;
      }
      return t3;
    }, L2 = function(t3) {
      return t3.sort(function(t4, e3) {
        return t4 - e3;
      });
    }, A2 = function(t3, e3) {
      for (var r3, n3, i3 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h3 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d3 = 0; d3 < l3.length; d3++) if (void 0 !== l3[d3].x) for (var p3 = y2.call(this, l3[d3]), g3 = 0; g3 < p3.length; g3 += 1) -1 === f2.indexOf(p3[g3]) && f2.push(p3[g3]);
      for (var m3 = 0; m3 < f2.length; m3++) for (; this.pdf.internal.getNumberOfPages() < f2[m3]; ) w2.call(this);
      if (L2(f2), this.autoPaging) for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {
        this.pdf.setPage(S3), this.fillStyle = i3, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;
        var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = 1 === S3 ? 0 : k3 + (S3 - 2) * I3;
        if (0 !== this.ctx.clip_path.length) {
          var C3 = this.path;
          r3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t3, true), this.path = C3;
        }
        if (n3 = JSON.parse(JSON.stringify(h3)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), false === e3 || 0 === S3) {
          var j3 = (S3 > v3 || S3 < A3) && b2.call(this);
          j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t3, e3), j3 && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = s3;
      }
      else this.lineWidth = c3, x2.call(this, t3, e3), this.lineWidth = s3;
      this.path = h3;
    }, x2 = function(t3, e3) {
      if (("stroke" !== t3 || e3 || !v2.call(this)) && ("stroke" === t3 || e3 || !m2.call(this))) {
        for (var r3, n3, i3 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {
          var s3 = a2[o3];
          switch (s3.type) {
            case "begin":
              i3.push({
                begin: true
              });
              break;
            case "close":
              i3.push({
                close: true
              });
              break;
            case "mt":
              i3.push({
                start: s3,
                deltas: [],
                abs: []
              });
              break;
            case "lt":
              var c3 = i3.length;
              if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r3 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {
                for (; c3 >= 0; c3--) if (true !== i3[c3 - 1].close && true !== i3[c3 - 1].begin) {
                  i3[c3 - 1].deltas.push(r3), i3[c3 - 1].abs.push(s3);
                  break;
                }
              }
              break;
            case "bct":
              r3 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
              break;
            case "qct":
              var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h3 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p3 = s3.y;
              r3 = [u3 - a2[o3 - 1].x, h3 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d3 - a2[o3 - 1].x, p3 - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
              break;
            case "arc":
              i3.push({
                deltas: [],
                abs: [],
                arc: true
              }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
          }
        }
        n3 = e3 ? null : "stroke" === t3 ? "stroke" : "fill";
        for (var g3 = false, b3 = 0; b3 < i3.length; b3++) if (i3[b3].arc) for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
          var N3 = y3[w3];
          "arc" === N3.type ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e3, !g3) : j2.call(this, N3.x, N3.y), g3 = true;
        }
        else if (true === i3[b3].close) this.pdf.internal.out("h"), g3 = false;
        else if (true !== i3[b3].begin) {
          var L3 = i3[b3].start.x, A3 = i3[b3].start.y;
          O2.call(this, i3[b3].deltas, L3, A3), g3 = true;
        }
        n3 && k2.call(this, n3), e3 && I2.call(this);
      }
    }, S2 = function(t3) {
      var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r3 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
      switch (this.ctx.textBaseline) {
        case "bottom":
          return t3 - r3;
        case "top":
          return t3 + e3 - r3;
        case "hanging":
          return t3 + e3 - 2 * r3;
        case "middle":
          return t3 + e3 / 2 - r3;
        case "ideographic":
          return t3;
        case "alphabetic":
        default:
          return t3;
      }
    }, _2 = function(t3) {
      return t3 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
    };
    p2.prototype.createLinearGradient = function() {
      var t3 = function() {
      };
      return t3.colorStops = [], t3.addColorStop = function(t4, e3) {
        this.colorStops.push([t4, e3]);
      }, t3.getColor = function() {
        return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
      }, t3.isCanvasGradient = true, t3;
    }, p2.prototype.createPattern = function() {
      return this.createLinearGradient();
    }, p2.prototype.createRadialGradient = function() {
      return this.createLinearGradient();
    };
    var P2 = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {
      for (var u3 = M2.call(this, r3, n3, i3, a2), h3 = 0; h3 < u3.length; h3++) {
        var l3 = u3[h3];
        0 === h3 && (c3 ? F2.call(this, l3.x1 + t3, l3.y1 + e3) : j2.call(this, l3.x1 + t3, l3.y1 + e3)), B2.call(this, t3, e3, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);
      }
      s3 ? I2.call(this) : k2.call(this, o3);
    }, k2 = function(t3) {
      switch (t3) {
        case "stroke":
          this.pdf.internal.out("S");
          break;
        case "fill":
          this.pdf.internal.out("f");
      }
    }, I2 = function() {
      this.pdf.clip(), this.pdf.discardPath();
    }, F2 = function(t3, e3) {
      this.pdf.internal.out(n2(t3) + " " + i2(e3) + " m");
    }, C2 = function(t3) {
      var e3;
      switch (t3.align) {
        case "right":
        case "end":
          e3 = "right";
          break;
        case "center":
          e3 = "center";
          break;
        case "left":
        case "start":
        default:
          e3 = "left";
      }
      var r3 = this.pdf.getTextDimensions(t3.text), n3 = S2.call(this, t3.y), i3 = _2.call(this, n3) - r3.h, a2 = this.ctx.transform.applyToPoint(new c2(t3.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h2();
      s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);
      for (var l3, f2, d3, p3 = this.ctx.transform.applyToRectangle(new u2(t3.x, n3, r3.w, r3.h)), g3 = s3.applyToRectangle(new u2(t3.x, i3, r3.w, r3.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1) -1 === v3.indexOf(m3[w3]) && v3.push(m3[w3]);
      if (L2(v3), this.autoPaging) for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
        this.pdf.setPage(k3);
        var I3 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B3 = O3 - this.margin[3], M3 = 1 === k3 ? 0 : F3 + (k3 - 2) * j3;
        if (0 !== this.ctx.clip_path.length) {
          var E3 = this.path;
          l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
        }
        var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
        t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale);
        var D3 = "text" !== this.autoPaging;
        if (D3 || q3.y + q3.h <= C3) {
          if (D3 || q3.y >= I3 && q3.x <= O3) {
            var R3 = D3 ? t3.text : this.pdf.splitTextToSize(t3.text, t3.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], U2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
            U2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B3, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, {
              angle: t3.angle,
              align: e3,
              renderingMode: t3.renderingMode
            }), U2 && this.pdf.restoreGraphicsState();
          }
        } else q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
        t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
      }
      else t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale), this.pdf.text(t3.text, a2.x + this.posX, a2.y + this.posY, {
        angle: t3.angle,
        align: e3,
        renderingMode: t3.renderingMode,
        maxWidth: t3.maxWidth
      }), t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
    }, j2 = function(t3, e3, r3, a2) {
      r3 = r3 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t3 + r3) + " " + i2(e3 + a2) + " l");
    }, O2 = function(t3, e3, r3) {
      return this.pdf.lines(t3, e3, r3, null, null);
    }, B2 = function(t3, e3, n3, i3, a2, c3, u3, h3) {
      this.pdf.internal.out([r2(o2(n3 + t3)), r2(s2(i3 + e3)), r2(o2(a2 + t3)), r2(s2(c3 + e3)), r2(o2(u3 + t3)), r2(s2(h3 + e3)), "c"].join(" "));
    }, M2 = function(t3, e3, r3, n3) {
      for (var i3 = 2 * Math.PI, a2 = Math.PI / 2; e3 > r3; ) e3 -= i3;
      var o3 = Math.abs(r3 - e3);
      o3 < i3 && n3 && (o3 = i3 - o3);
      for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e3; o3 > 1e-5; ) {
        var h3 = u3 + c3 * Math.min(o3, a2);
        s3.push(E2.call(this, t3, u3, h3)), o3 -= Math.abs(h3 - u3), u3 = h3;
      }
      return s3;
    }, E2 = function(t3, e3, r3) {
      var n3 = (r3 - e3) / 2, i3 = t3 * Math.cos(n3), a2 = t3 * Math.sin(n3), o3 = i3, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i3 + s3 * a2, h3 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i3), l3 = o3 - h3 * s3, f2 = s3 + h3 * o3, d3 = l3, p3 = -f2, g3 = n3 + e3, m3 = Math.cos(g3), v3 = Math.sin(g3);
      return {
        x1: t3 * Math.cos(e3),
        y1: t3 * Math.sin(e3),
        x2: l3 * m3 - f2 * v3,
        y2: l3 * v3 + f2 * m3,
        x3: d3 * m3 - p3 * v3,
        y3: d3 * v3 + p3 * m3,
        x4: t3 * Math.cos(r3),
        y4: t3 * Math.sin(r3)
      };
    }, q2 = function(t3) {
      return 180 * t3 / Math.PI;
    }, D2 = function(t3, e3, r3, n3, i3, a2) {
      var o3 = t3 + 0.5 * (r3 - t3), s3 = e3 + 0.5 * (n3 - e3), c3 = i3 + 0.5 * (r3 - i3), h3 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t3, i3, o3, c3), f2 = Math.max(t3, i3, o3, c3), d3 = Math.min(e3, a2, s3, h3), p3 = Math.max(e3, a2, s3, h3);
      return new u2(l3, d3, f2 - l3, p3 - d3);
    }, R2 = function(t3, e3, r3, n3, i3, a2, o3, s3) {
      var c3, h3, l3, f2, d3, p3, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r3 - t3, x3 = n3 - e3, S3 = i3 - r3, _3 = a2 - n3, P3 = o3 - i3, k3 = s3 - a2;
      for (h3 = 0; h3 < 41; h3++) v3 = (g3 = (l3 = t3 + (c3 = h3 / 40) * A3) + c3 * ((d3 = r3 + c3 * S3) - l3)) + c3 * (d3 + c3 * (i3 + c3 * P3 - d3) - g3), b3 = (m3 = (f2 = e3 + c3 * x3) + c3 * ((p3 = n3 + c3 * _3) - f2)) + c3 * (p3 + c3 * (a2 + c3 * k3 - p3) - m3), 0 == h3 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
      return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
    }, T2 = function() {
      if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
        var t3, e3, r3 = (t3 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({
          lineDash: t3,
          lineDashOffset: e3
        }));
        this.prevLineDash !== r3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r3);
      }
    };
  })(E$1.API), /**
   * @license
   * jsPDF filters PlugIn
   * Copyright (c) 2014 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    var r2 = function(t4) {
      var e2, r3, n3, i3, a3, o2, s2, c2, u2, h2;
      for (r3 = [], n3 = 0, i3 = (t4 += e2 = "\0\0\0\0".slice(t4.length % 4 || 4)).length; i3 > n3; n3 += 4) 0 !== (a3 = (t4.charCodeAt(n3) << 24) + (t4.charCodeAt(n3 + 1) << 16) + (t4.charCodeAt(n3 + 2) << 8) + t4.charCodeAt(n3 + 3)) ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r3.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h2 + 33)) : r3.push(122);
      return (function(t5, e3) {
        for (var r4 = e3; r4 > 0; r4--) t5.pop();
      })(r3, e2.length), String.fromCharCode.apply(String, r3) + "~>";
    }, n2 = function(t4) {
      var e2, r3, n3, i3, a3, o2 = String, s2 = "length", c2 = 255, u2 = "charCodeAt", h2 = "slice", l2 = "replace";
      for (t4[h2](-2), t4 = t4[h2](0, -2)[l2](/\s/g, "")[l2]("z", "!!!!!"), n3 = [], i3 = 0, a3 = (t4 += e2 = "uuuuu"[h2](t4[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5) r3 = 52200625 * (t4[u2](i3) - 33) + 614125 * (t4[u2](i3 + 1) - 33) + 7225 * (t4[u2](i3 + 2) - 33) + 85 * (t4[u2](i3 + 3) - 33) + (t4[u2](i3 + 4) - 33), n3.push(c2 & r3 >> 24, c2 & r3 >> 16, c2 & r3 >> 8, c2 & r3);
      return (function(t5, e3) {
        for (var r4 = e3; r4 > 0; r4--) t5.pop();
      })(n3, e2[s2]), o2.fromCharCode.apply(o2, n3);
    }, i2 = function(t4) {
      var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
      if (-1 !== (t4 = t4.replace(/\s/g, "")).indexOf(">") && (t4 = t4.substr(0, t4.indexOf(">"))), t4.length % 2 && (t4 += "0"), false === e2.test(t4)) return "";
      for (var r3 = "", n3 = 0; n3 < t4.length; n3 += 2) r3 += String.fromCharCode("0x" + (t4[n3] + t4[n3 + 1]));
      return r3;
    }, a2 = function(t4) {
      for (var r3 = new Uint8Array(t4.length), n3 = t4.length; n3--; ) r3[n3] = t4.charCodeAt(n3);
      return t4 = (r3 = zlibSync(r3)).reduce(function(t5, e2) {
        return t5 + String.fromCharCode(e2);
      }, "");
    };
    t3.processDataByFilters = function(t4, e2) {
      var o2 = 0, s2 = t4 || "", c2 = [];
      for ("string" == typeof (e2 = e2 || []) && (e2 = [e2]), o2 = 0; o2 < e2.length; o2 += 1) switch (e2[o2]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          s2 = n2(s2), c2.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          s2 = r2(s2), c2.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          s2 = i2(s2), c2.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          s2 = s2.split("").map(function(t5) {
            return ("0" + t5.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", c2.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          s2 = a2(s2), c2.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + e2[o2] + '" is not implemented');
      }
      return {
        data: s2,
        reverseChain: c2.reverse().join(" ")
      };
    };
  })(E$1.API), /**
   * @license
   * jsPDF fileloading PlugIn
   * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    t3.loadFile = function(t4, e2, r2) {
      return (function(t5, e3, r3) {
        e3 = false !== e3, r3 = "function" == typeof r3 ? r3 : function() {
        };
        var n2 = void 0;
        try {
          n2 = (function(t6, e4, r4) {
            var n3 = new XMLHttpRequest(), i2 = 0, a2 = function(t7) {
              var e5 = t7.length, r5 = [], n4 = String.fromCharCode;
              for (i2 = 0; i2 < e5; i2 += 1) r5.push(n4(255 & t7.charCodeAt(i2)));
              return r5.join("");
            };
            if (n3.open("GET", t6, !e4), n3.overrideMimeType("text/plain; charset=x-user-defined"), false === e4 && (n3.onload = function() {
              200 === n3.status ? r4(a2(this.responseText)) : r4(void 0);
            }), n3.send(null), e4 && 200 === n3.status) return a2(n3.responseText);
          })(t5, e3, r3);
        } catch (t6) {
        }
        return n2;
      })(t4, e2, r2);
    }, t3.loadImageFile = t3.loadFile;
  })(E$1.API), (function(e2) {
    function r2() {
      return (n$1.html2canvas ? Promise.resolve(n$1.html2canvas) : Promise.resolve().then(function() {
        return html2canvas$1;
      })).catch(function(t3) {
        return Promise.reject(new Error("Could not load html2canvas: " + t3));
      }).then(function(t3) {
        return t3.default ? t3.default : t3;
      });
    }
    function i2() {
      return (n$1.DOMPurify ? Promise.resolve(n$1.DOMPurify) : Promise.resolve().then(function() {
        return purify_es;
      })).catch(function(t3) {
        return Promise.reject(new Error("Could not load dompurify: " + t3));
      }).then(function(t3) {
        return t3.default ? t3.default : t3;
      });
    }
    var a2 = function(e3) {
      var r3 = _typeof$1(e3);
      return "undefined" === r3 ? "undefined" : "string" === r3 || e3 instanceof String ? "string" : "number" === r3 || e3 instanceof Number ? "number" : "function" === r3 || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && 1 === e3.nodeType ? "element" : "object" === r3 ? "object" : "unknown";
    }, o2 = function(t3, e3) {
      var r3 = document.createElement(t3);
      for (var n2 in e3.className && (r3.className = e3.className), e3.innerHTML && e3.dompurify && (r3.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style) r3.style[n2] = e3.style[n2];
      return r3;
    }, s2 = function t3(e3) {
      var r3 = Object.assign(t3.convert(Promise.resolve()), JSON.parse(JSON.stringify(t3.template))), n2 = t3.convert(Promise.resolve(), r3);
      return n2 = (n2 = n2.setProgress(1, t3, 1, [t3])).set(e3);
    };
    (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t3, e3) {
      return t3.__proto__ = e3 || s2.prototype, t3;
    }, s2.template = {
      prop: {
        src: null,
        container: null,
        overlay: null,
        canvas: null,
        img: null,
        pdf: null,
        pageSize: null,
        callback: function() {
        }
      },
      progress: {
        val: 0,
        state: null,
        n: 0,
        stack: []
      },
      opt: {
        filename: "file.pdf",
        margin: [0, 0, 0, 0],
        enableLinks: true,
        x: 0,
        y: 0,
        html2canvas: {},
        jsPDF: {},
        backgroundColor: "transparent"
      }
    }, s2.prototype.from = function(t3, e3) {
      return this.then(function() {
        switch (e3 = e3 || (function(t4) {
          switch (a2(t4)) {
            case "string":
              return "string";
            case "element":
              return "canvas" === t4.nodeName.toLowerCase() ? "canvas" : "element";
            default:
              return "unknown";
          }
        })(t3)) {
          case "string":
            return this.then(i2).then(function(e4) {
              return this.set({
                src: o2("div", {
                  innerHTML: t3,
                  dompurify: e4
                })
              });
            });
          case "element":
            return this.set({
              src: t3
            });
          case "canvas":
            return this.set({
              canvas: t3
            });
          case "img":
            return this.set({
              img: t3
            });
          default:
            return this.error("Unknown source type.");
        }
      });
    }, s2.prototype.to = function(t3) {
      switch (t3) {
        case "container":
          return this.toContainer();
        case "canvas":
          return this.toCanvas();
        case "img":
          return this.toImg();
        case "pdf":
          return this.toPdf();
        default:
          return this.error("Invalid target.");
      }
    }, s2.prototype.toContainer = function() {
      return this.thenList([function() {
        return this.prop.src || this.error("Cannot duplicate - no source HTML.");
      }, function() {
        return this.prop.pageSize || this.setPageSize();
      }]).then(function() {
        var t3 = {
          position: "relative",
          display: "inline-block",
          width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px",
          left: 0,
          right: 0,
          top: 0,
          margin: "auto",
          backgroundColor: this.opt.backgroundColor
        }, e3 = (function t4(e4, r3) {
          for (var n2 = 3 === e4.nodeType ? document.createTextNode(e4.nodeValue) : e4.cloneNode(false), i3 = e4.firstChild; i3; i3 = i3.nextSibling) true !== r3 && 1 === i3.nodeType && "SCRIPT" === i3.nodeName || n2.appendChild(t4(i3, r3));
          return 1 === e4.nodeType && ("CANVAS" === e4.nodeName ? (n2.width = e4.width, n2.height = e4.height, n2.getContext("2d").drawImage(e4, 0, 0)) : "TEXTAREA" !== e4.nodeName && "SELECT" !== e4.nodeName || (n2.value = e4.value), n2.addEventListener("load", function() {
            n2.scrollTop = e4.scrollTop, n2.scrollLeft = e4.scrollLeft;
          }, true)), n2;
        })(this.prop.src, this.opt.html2canvas.javascriptEnabled);
        "BODY" === e3.tagName && (t3.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", {
          className: "html2pdf__overlay",
          style: {
            position: "fixed",
            overflow: "hidden",
            zIndex: 1e3,
            left: "-100000px",
            right: 0,
            bottom: 0,
            top: 0
          }
        }), this.prop.container = o2("div", {
          className: "html2pdf__container",
          style: t3
        }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o2("div", {
          style: {
            clear: "both",
            border: "0 none transparent",
            margin: 0,
            padding: 0,
            height: 0
          }
        })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
      });
    }, s2.prototype.toCanvas = function() {
      var t3 = [function() {
        return document.body.contains(this.prop.container) || this.toContainer();
      }];
      return this.thenList(t3).then(r2).then(function(t4) {
        var e3 = Object.assign({}, this.opt.html2canvas);
        return delete e3.onrendered, t4(this.prop.container, e3);
      }).then(function(t4) {
        (this.opt.html2canvas.onrendered || function() {
        })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
      });
    }, s2.prototype.toContext2d = function() {
      var t3 = [function() {
        return document.body.contains(this.prop.container) || this.toContainer();
      }];
      return this.thenList(t3).then(r2).then(function(t4) {
        var e3 = this.opt.jsPDF, r3 = this.opt.fontFaces, n2 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i3 = Object.assign({
          async: true,
          allowTaint: true,
          scale: n2,
          scrollX: this.opt.scrollX || 0,
          scrollY: this.opt.scrollY || 0,
          backgroundColor: "#ffffff",
          imageTimeout: 15e3,
          logging: true,
          proxy: null,
          removeContainer: true,
          foreignObjectRendering: false,
          useCORS: false
        }, this.opt.html2canvas);
        if (delete i3.onrendered, e3.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = r3, r3) for (var a3 = 0; a3 < r3.length; ++a3) {
          var o3 = r3[a3], s3 = o3.src.find(function(t5) {
            return "truetype" === t5.format;
          });
          s3 && e3.addFont(s3.url, o3.ref.name, o3.ref.style);
        }
        return i3.windowHeight = i3.windowHeight || 0, i3.windowHeight = 0 == i3.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i3.windowHeight, e3.context2d.save(true), t4(this.prop.container, i3);
      }).then(function(t4) {
        this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
        })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
      });
    }, s2.prototype.toImg = function() {
      return this.thenList([function() {
        return this.prop.canvas || this.toCanvas();
      }]).then(function() {
        var t3 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
        this.prop.img = document.createElement("img"), this.prop.img.src = t3;
      });
    }, s2.prototype.toPdf = function() {
      return this.thenList([function() {
        return this.toContext2d();
      }]).then(function() {
        this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
      });
    }, s2.prototype.output = function(t3, e3, r3) {
      return "img" === (r3 = r3 || "pdf").toLowerCase() || "image" === r3.toLowerCase() ? this.outputImg(t3, e3) : this.outputPdf(t3, e3);
    }, s2.prototype.outputPdf = function(t3, e3) {
      return this.thenList([function() {
        return this.prop.pdf || this.toPdf();
      }]).then(function() {
        return this.prop.pdf.output(t3, e3);
      });
    }, s2.prototype.outputImg = function(t3) {
      return this.thenList([function() {
        return this.prop.img || this.toImg();
      }]).then(function() {
        switch (t3) {
          case void 0:
          case "img":
            return this.prop.img;
          case "datauristring":
          case "dataurlstring":
            return this.prop.img.src;
          case "datauri":
          case "dataurl":
            return document.location.href = this.prop.img.src;
          default:
            throw 'Image output type "' + t3 + '" is not supported.';
        }
      });
    }, s2.prototype.save = function(t3) {
      return this.thenList([function() {
        return this.prop.pdf || this.toPdf();
      }]).set(t3 ? {
        filename: t3
      } : null).then(function() {
        this.prop.pdf.save(this.opt.filename);
      });
    }, s2.prototype.doCallback = function() {
      return this.thenList([function() {
        return this.prop.pdf || this.toPdf();
      }]).then(function() {
        this.prop.callback(this.prop.pdf);
      });
    }, s2.prototype.set = function(t3) {
      if ("object" !== a2(t3)) return this;
      var e3 = Object.keys(t3 || {}).map(function(e4) {
        if (e4 in s2.template.prop) return function() {
          this.prop[e4] = t3[e4];
        };
        switch (e4) {
          case "margin":
            return this.setMargin.bind(this, t3.margin);
          case "jsPDF":
            return function() {
              return this.opt.jsPDF = t3.jsPDF, this.setPageSize();
            };
          case "pageSize":
            return this.setPageSize.bind(this, t3.pageSize);
          default:
            return function() {
              this.opt[e4] = t3[e4];
            };
        }
      }, this);
      return this.then(function() {
        return this.thenList(e3);
      });
    }, s2.prototype.get = function(t3, e3) {
      return this.then(function() {
        var r3 = t3 in s2.template.prop ? this.prop[t3] : this.opt[t3];
        return e3 ? e3(r3) : r3;
      });
    }, s2.prototype.setMargin = function(t3) {
      return this.then(function() {
        switch (a2(t3)) {
          case "number":
            t3 = [t3, t3, t3, t3];
          case "array":
            if (2 === t3.length && (t3 = [t3[0], t3[1], t3[0], t3[1]]), 4 === t3.length) break;
          default:
            return this.error("Invalid margin array.");
        }
        this.opt.margin = t3;
      }).then(this.setPageSize);
    }, s2.prototype.setPageSize = function(t3) {
      function e3(t4, e4) {
        return Math.floor(t4 * e4 / 72 * 96);
      }
      return this.then(function() {
        (t3 = t3 || E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t3.inner = {
          width: t3.width - this.opt.margin[1] - this.opt.margin[3],
          height: t3.height - this.opt.margin[0] - this.opt.margin[2]
        }, t3.inner.px = {
          width: e3(t3.inner.width, t3.k),
          height: e3(t3.inner.height, t3.k)
        }, t3.inner.ratio = t3.inner.height / t3.inner.width), this.prop.pageSize = t3;
      });
    }, s2.prototype.setProgress = function(t3, e3, r3, n2) {
      return null != t3 && (this.progress.val = t3), null != e3 && (this.progress.state = e3), null != r3 && (this.progress.n = r3), null != n2 && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;
    }, s2.prototype.updateProgress = function(t3, e3, r3, n2) {
      return this.setProgress(t3 ? this.progress.val + t3 : null, e3 || null, r3 ? this.progress.n + r3 : null, n2 ? this.progress.stack.concat(n2) : null);
    }, s2.prototype.then = function(t3, e3) {
      var r3 = this;
      return this.thenCore(t3, e3, function(t4, e4) {
        return r3.updateProgress(null, null, 1, [t4]), Promise.prototype.then.call(this, function(e5) {
          return r3.updateProgress(null, t4), e5;
        }).then(t4, e4).then(function(t5) {
          return r3.updateProgress(1), t5;
        });
      });
    }, s2.prototype.thenCore = function(t3, e3, r3) {
      r3 = r3 || Promise.prototype.then;
      t3 && (t3 = t3.bind(this)), e3 && (e3 = e3.bind(this));
      var n2 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? this : s2.convert(Object.assign({}, this), Promise.prototype), i3 = r3.call(n2, t3, e3);
      return s2.convert(i3, this.__proto__);
    }, s2.prototype.thenExternal = function(t3, e3) {
      return Promise.prototype.then.call(this, t3, e3);
    }, s2.prototype.thenList = function(t3) {
      var e3 = this;
      return t3.forEach(function(t4) {
        e3 = e3.thenCore(t4);
      }), e3;
    }, s2.prototype.catch = function(t3) {
      t3 && (t3 = t3.bind(this));
      var e3 = Promise.prototype.catch.call(this, t3);
      return s2.convert(e3, this);
    }, s2.prototype.catchExternal = function(t3) {
      return Promise.prototype.catch.call(this, t3);
    }, s2.prototype.error = function(t3) {
      return this.then(function() {
        throw new Error(t3);
      });
    }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E$1.getPageSize = function(e3, r3, n2) {
      if ("object" === _typeof$1(e3)) {
        var i3 = e3;
        e3 = i3.orientation, r3 = i3.unit || r3, n2 = i3.format || n2;
      }
      r3 = r3 || "mm", n2 = n2 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
      var a3, o3 = ("" + n2).toLowerCase(), s3 = {
        a0: [2383.94, 3370.39],
        a1: [1683.78, 2383.94],
        a2: [1190.55, 1683.78],
        a3: [841.89, 1190.55],
        a4: [595.28, 841.89],
        a5: [419.53, 595.28],
        a6: [297.64, 419.53],
        a7: [209.76, 297.64],
        a8: [147.4, 209.76],
        a9: [104.88, 147.4],
        a10: [73.7, 104.88],
        b0: [2834.65, 4008.19],
        b1: [2004.09, 2834.65],
        b2: [1417.32, 2004.09],
        b3: [1000.63, 1417.32],
        b4: [708.66, 1000.63],
        b5: [498.9, 708.66],
        b6: [354.33, 498.9],
        b7: [249.45, 354.33],
        b8: [175.75, 249.45],
        b9: [124.72, 175.75],
        b10: [87.87, 124.72],
        c0: [2599.37, 3676.54],
        c1: [1836.85, 2599.37],
        c2: [1298.27, 1836.85],
        c3: [918.43, 1298.27],
        c4: [649.13, 918.43],
        c5: [459.21, 649.13],
        c6: [323.15, 459.21],
        c7: [229.61, 323.15],
        c8: [161.57, 229.61],
        c9: [113.39, 161.57],
        c10: [79.37, 113.39],
        dl: [311.81, 623.62],
        letter: [612, 792],
        "government-letter": [576, 756],
        legal: [612, 1008],
        "junior-legal": [576, 360],
        ledger: [1224, 792],
        tabloid: [792, 1224],
        "credit-card": [153, 243]
      };
      switch (r3) {
        case "pt":
          a3 = 1;
          break;
        case "mm":
          a3 = 72 / 25.4;
          break;
        case "cm":
          a3 = 72 / 2.54;
          break;
        case "in":
          a3 = 72;
          break;
        case "px":
          a3 = 0.75;
          break;
        case "pc":
        case "em":
          a3 = 12;
          break;
        case "ex":
          a3 = 6;
          break;
        default:
          throw "Invalid unit: " + r3;
      }
      var c2, u2 = 0, h2 = 0;
      if (s3.hasOwnProperty(o3)) u2 = s3[o3][1] / a3, h2 = s3[o3][0] / a3;
      else try {
        u2 = n2[1], h2 = n2[0];
      } catch (t3) {
        throw new Error("Invalid format: " + n2);
      }
      if ("p" === e3 || "portrait" === e3) e3 = "p", h2 > u2 && (c2 = h2, h2 = u2, u2 = c2);
      else {
        if ("l" !== e3 && "landscape" !== e3) throw "Invalid orientation: " + e3;
        e3 = "l", u2 > h2 && (c2 = h2, h2 = u2, u2 = c2);
      }
      return {
        width: h2,
        height: u2,
        unit: r3,
        k: a3,
        orientation: e3
      };
    }, e2.html = function(t3, e3) {
      (e3 = e3 || {}).callback = e3.callback || function() {
      }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(jt$1) : null;
      var r3 = new s2(e3);
      return e3.worker ? r3 : r3.from(t3).doCallback();
    };
  })(E$1.API), E$1.API.addJS = function(t3) {
    return Ht$1 = t3, this.internal.events.subscribe("postPutResources", function() {
      Ut$1 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut$1 + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt$1 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht$1 + ")"), this.internal.out(">>"), this.internal.out("endobj");
    }), this.internal.events.subscribe("putCatalog", function() {
      void 0 !== Ut$1 && void 0 !== zt$1 && this.internal.out("/Names <</JavaScript " + Ut$1 + " 0 R>>");
    }), this;
  }, /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    var e2;
    t3.events.push(["postPutResources", function() {
      var t4 = this, r2 = /^(\d+) 0 obj$/;
      if (this.outline.root.children.length > 0) for (var n2 = t4.outline.render().split(/\r\n/), i2 = 0; i2 < n2.length; i2++) {
        var a2 = n2[i2], o2 = r2.exec(a2);
        if (null != o2) {
          var s2 = o2[1];
          t4.internal.newObjectDeferredBegin(s2, false);
        }
        t4.internal.write(a2);
      }
      if (this.outline.createNamedDestinations) {
        var c2 = this.internal.pages.length, u2 = [];
        for (i2 = 0; i2 < c2; i2++) {
          var h2 = t4.internal.newObject();
          u2.push(h2);
          var l2 = t4.internal.getPageInfo(i2 + 1);
          t4.internal.write("<< /D[" + l2.objId + " 0 R /XYZ null null null]>> endobj");
        }
        var f2 = t4.internal.newObject();
        t4.internal.write("<< /Names [ ");
        for (i2 = 0; i2 < u2.length; i2++) t4.internal.write("(page_" + (i2 + 1) + ")" + u2[i2] + " 0 R");
        t4.internal.write(" ] >>", "endobj"), e2 = t4.internal.newObject(), t4.internal.write("<< /Dests " + f2 + " 0 R"), t4.internal.write(">>", "endobj");
      }
    }]), t3.events.push(["putCatalog", function() {
      this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e2 + " 0 R"));
    }]), t3.events.push(["initialized", function() {
      var t4 = this;
      t4.outline = {
        createNamedDestinations: false,
        root: {
          children: []
        }
      }, t4.outline.add = function(t5, e3, r2) {
        var n2 = {
          title: e3,
          options: r2,
          children: []
        };
        return null == t5 && (t5 = this.root), t5.children.push(n2), n2;
      }, t4.outline.render = function() {
        return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t4, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
      }, t4.outline.genIds_r = function(e3) {
        e3.id = t4.internal.newObjectDeferred();
        for (var r2 = 0; r2 < e3.children.length; r2++) this.genIds_r(e3.children[r2]);
      }, t4.outline.renderRoot = function(t5) {
        this.objStart(t5), this.line("/Type /Outlines"), t5.children.length > 0 && (this.line("/First " + this.makeRef(t5.children[0])), this.line("/Last " + this.makeRef(t5.children[t5.children.length - 1]))), this.line("/Count " + this.count_r({
          count: 0
        }, t5)), this.objEnd();
      }, t4.outline.renderItems = function(e3) {
        for (var r2 = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e3.children.length; n2++) {
          var i2 = e3.children[n2];
          this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e3)), n2 > 0 && this.line("/Prev " + this.makeRef(e3.children[n2 - 1])), n2 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[n2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
          var a2 = this.count = this.count_r({
            count: 0
          }, i2);
          if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
            var o2 = t4.internal.getPageInfo(i2.options.pageNumber);
            this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r2(0) + " 0]");
          }
          this.objEnd();
        }
        for (var s2 = 0; s2 < e3.children.length; s2++) this.renderItems(e3.children[s2]);
      }, t4.outline.line = function(t5) {
        this.ctx.val += t5 + "\r\n";
      }, t4.outline.makeRef = function(t5) {
        return t5.id + " 0 R";
      }, t4.outline.makeString = function(e3) {
        return "(" + t4.internal.pdfEscape(e3) + ")";
      }, t4.outline.objStart = function(t5) {
        this.ctx.val += "\r\n" + t5.id + " 0 obj\r\n<<\r\n";
      }, t4.outline.objEnd = function() {
        this.ctx.val += ">> \r\nendobj\r\n";
      }, t4.outline.count_r = function(t5, e3) {
        for (var r2 = 0; r2 < e3.children.length; r2++) t5.count++, this.count_r(t5, e3.children[r2]);
        return t5.count;
      };
    }]);
  })(E$1.API), /**
   * @license
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    var e2 = [192, 193, 194, 195, 196, 197, 198, 199];
    t3.processJPEG = function(t4, r2, n2, i2, a2, o2) {
      var s2, c2 = this.decode.DCT_DECODE, u2 = null;
      if ("string" == typeof t4 || this.__addimage__.isArrayBuffer(t4) || this.__addimage__.isArrayBufferView(t4)) {
        switch (t4 = a2 || t4, t4 = this.__addimage__.isArrayBuffer(t4) ? new Uint8Array(t4) : t4, (s2 = (function(t5) {
          for (var r3, n3 = 256 * t5.charCodeAt(4) + t5.charCodeAt(5), i3 = t5.length, a3 = {
            width: 0,
            height: 0,
            numcomponents: 1
          }, o3 = 4; o3 < i3; o3 += 2) {
            if (o3 += n3, -1 !== e2.indexOf(t5.charCodeAt(o3 + 1))) {
              r3 = 256 * t5.charCodeAt(o3 + 5) + t5.charCodeAt(o3 + 6), a3 = {
                width: 256 * t5.charCodeAt(o3 + 7) + t5.charCodeAt(o3 + 8),
                height: r3,
                numcomponents: t5.charCodeAt(o3 + 9)
              };
              break;
            }
            n3 = 256 * t5.charCodeAt(o3 + 2) + t5.charCodeAt(o3 + 3);
          }
          return a3;
        })(t4 = this.__addimage__.isArrayBufferView(t4) ? this.__addimage__.arrayBufferToBinaryString(t4) : t4)).numcomponents) {
          case 1:
            o2 = this.color_spaces.DEVICE_GRAY;
            break;
          case 4:
            o2 = this.color_spaces.DEVICE_CMYK;
            break;
          case 3:
            o2 = this.color_spaces.DEVICE_RGB;
        }
        u2 = {
          data: t4,
          width: s2.width,
          height: s2.height,
          colorSpace: o2,
          bitsPerComponent: 8,
          filter: c2,
          index: r2,
          alias: n2
        };
      }
      return u2;
    };
  })(E$1.API);
  var Vt$1;
  var Gt$1;
  var Yt$1;
  var Jt;
  var Xt;
  var Kt = (function() {
    var t3, e2, i2;
    function a2(t4) {
      var e3, r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2, d2, p2;
      for (this.data = t4, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {
        switch (e3 = this.readUInt32(), u2 = function() {
          var t5, e4;
          for (e4 = [], t5 = 0; t5 < 4; ++t5) e4.push(String.fromCharCode(this.data[this.pos++]));
          return e4;
        }.call(this).join("")) {
          case "IHDR":
            this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
            break;
          case "acTL":
            this.animation = {
              numFrames: this.readUInt32(),
              numPlays: this.readUInt32() || 1 / 0,
              frames: []
            };
            break;
          case "PLTE":
            this.palette = this.read(e3);
            break;
          case "fcTL":
            o3 && this.animation.frames.push(o3), this.pos += 4, o3 = {
              width: this.readUInt32(),
              height: this.readUInt32(),
              xOffset: this.readUInt32(),
              yOffset: this.readUInt32()
            }, a3 = this.readUInt16(), i3 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i3, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];
            break;
          case "IDAT":
          case "fdAT":
            for ("fdAT" === u2 && (this.pos += 4, e3 -= 4), t4 = (null != o3 ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e3 ? f2 < e3 : f2 > e3; 0 <= e3 ? ++f2 : --f2) t4.push(this.data[this.pos++]);
            break;
          case "tRNS":
            switch (this.transparency = {}, this.colorType) {
              case 3:
                if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e3), this.transparency.indexed.length > n2) throw new Error("More transparent colors than palette size");
                if ((h2 = n2 - this.transparency.indexed.length) > 0) for (d2 = 0; 0 <= h2 ? d2 < h2 : d2 > h2; 0 <= h2 ? ++d2 : --d2) this.transparency.indexed.push(255);
                break;
              case 0:
                this.transparency.grayscale = this.read(e3)[0];
                break;
              case 2:
                this.transparency.rgb = this.read(e3);
            }
            break;
          case "tEXt":
            s2 = (l2 = this.read(e3)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));
            break;
          case "IEND":
            return o3 && this.animation.frames.push(o3), this.colors = function() {
              switch (this.colorType) {
                case 0:
                case 3:
                case 4:
                  return 1;
                case 2:
                case 6:
                  return 3;
              }
            }.call(this), this.hasAlphaChannel = 4 === (p2 = this.colorType) || 6 === p2, r2 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r2, this.colorSpace = function() {
              switch (this.colors) {
                case 1:
                  return "DeviceGray";
                case 3:
                  return "DeviceRGB";
              }
            }.call(this), void (this.imgData = new Uint8Array(this.imgData));
          default:
            this.pos += e3;
        }
        if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
      }
    }
    a2.prototype.read = function(t4) {
      var e3, r2;
      for (r2 = [], e3 = 0; 0 <= t4 ? e3 < t4 : e3 > t4; 0 <= t4 ? ++e3 : --e3) r2.push(this.data[this.pos++]);
      return r2;
    }, a2.prototype.readUInt32 = function() {
      return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
    }, a2.prototype.readUInt16 = function() {
      return this.data[this.pos++] << 8 | this.data[this.pos++];
    }, a2.prototype.decodePixels = function(t4) {
      var e3 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e3), i3 = 0, a3 = this;
      if (null == t4 && (t4 = this.imgData), 0 === t4.length) return new Uint8Array(0);
      function o3(r2, o4, s2, c2) {
        var u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r2) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;
        for (L2 = e3 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p2 = t4.length, N2 = 0, h2 = 0; N2 < C2 && i3 < p2; ) {
          switch (t4[i3++]) {
            case 0:
              for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1) w2[h2++] = t4[i3++];
              break;
            case 1:
              for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1) u2 = t4[i3++], d2 = f2 < e3 ? 0 : w2[h2 - e3], w2[h2++] = (u2 + d2) % 256;
              break;
            case 2:
              for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1) u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (A2 + u2) % 256;
              break;
            case 3:
              for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1) u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;
              break;
            case 4:
              for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1) u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], 0 === N2 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e3 + f2 % e3]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h2++] = (u2 + v2) % 256;
              break;
            default:
              throw new Error("Invalid filter algorithm: " + t4[i3 - 1]);
          }
          if (!j2) {
            var O2 = ((o4 + N2 * c2) * a3.width + r2) * e3, B2 = N2 * L2;
            for (f2 = 0; f2 < F2; f2 += 1) {
              for (var M2 = 0; M2 < e3; M2 += 1) n2[O2++] = w2[B2++];
              O2 += (s2 - 1) * e3;
            }
          }
          N2++;
        }
      }
      return t4 = unzlibSync(t4), 1 == a3.interlaceMethod ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;
    }, a2.prototype.decodePalette = function() {
      var t4, e3, r2, n2, i3, a3, o3, s2, c2;
      for (r2 = this.palette, a3 = this.transparency.indexed || [], i3 = new Uint8Array((a3.length || 0) + r2.length), n2 = 0, t4 = 0, e3 = o3 = 0, s2 = r2.length; o3 < s2; e3 = o3 += 3) i3[n2++] = r2[e3], i3[n2++] = r2[e3 + 1], i3[n2++] = r2[e3 + 2], i3[n2++] = null != (c2 = a3[t4++]) ? c2 : 255;
      return i3;
    }, a2.prototype.copyToImageData = function(t4, e3) {
      var r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2;
      if (n2 = this.colors, h2 = null, r2 = this.hasAlphaChannel, this.palette.length && (h2 = null != (f2 = this._decodedPalette) ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r2 = true), u2 = (i3 = t4.data || t4).length, o3 = h2 || e3, a3 = s2 = 0, 1 === n2) for (; a3 < u2; ) c2 = h2 ? 4 * e3[a3 / 4] : s2, l2 = o3[c2++], i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;
      else for (; a3 < u2; ) c2 = h2 ? 4 * e3[a3 / 4] : s2, i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;
    }, a2.prototype.decode = function() {
      var t4;
      return t4 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t4, this.decodePixels()), t4;
    };
    var o2 = function() {
      if ("[object Window]" === Object.prototype.toString.call(n$1)) {
        try {
          e2 = n$1.document.createElement("canvas"), i2 = e2.getContext("2d");
        } catch (t4) {
          return false;
        }
        return true;
      }
      return false;
    };
    return o2(), t3 = function(t4) {
      var r2;
      if (true === o2()) return i2.width = t4.width, i2.height = t4.height, i2.clearRect(0, 0, t4.width, t4.height), i2.putImageData(t4, 0, 0), (r2 = new Image()).src = e2.toDataURL(), r2;
      throw new Error("This method requires a Browser with Canvas-capability.");
    }, a2.prototype.decodeFrames = function(e3) {
      var r2, n2, i3, a3, o3, s2, c2, u2;
      if (this.animation) {
        for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3) r2 = c2[n2], i3 = e3.createImageData(r2.width, r2.height), a3 = this.decodePixels(new Uint8Array(r2.data)), this.copyToImageData(i3, a3), r2.imageData = i3, u2.push(r2.image = t3(i3));
        return u2;
      }
    }, a2.prototype.renderFrame = function(t4, e3) {
      var r2, n2, i3;
      return r2 = (n2 = this.animation.frames)[e3], i3 = n2[e3 - 1], 0 === e3 && t4.clearRect(0, 0, this.width, this.height), 1 === (null != i3 ? i3.disposeOp : void 0) ? t4.clearRect(i3.xOffset, i3.yOffset, i3.width, i3.height) : 2 === (null != i3 ? i3.disposeOp : void 0) && t4.putImageData(i3.imageData, i3.xOffset, i3.yOffset), 0 === r2.blendOp && t4.clearRect(r2.xOffset, r2.yOffset, r2.width, r2.height), t4.drawImage(r2.image, r2.xOffset, r2.yOffset);
    }, a2.prototype.animate = function(t4) {
      var e3, r2, n2, i3, a3, o3, s2 = this;
      return r2 = 0, o3 = this.animation, i3 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e3 = function() {
        var o4, c2;
        if (o4 = r2++ % i3, c2 = n2[o4], s2.renderFrame(t4, o4), i3 > 1 && r2 / i3 < a3) return s2.animation._timeout = setTimeout(e3, c2.delay);
      })();
    }, a2.prototype.stopAnimation = function() {
      var t4;
      return clearTimeout(null != (t4 = this.animation) ? t4._timeout : void 0);
    }, a2.prototype.render = function(t4) {
      var e3, r2;
      return t4._png && t4._png.stopAnimation(), t4._png = this, t4.width = this.width, t4.height = this.height, e3 = t4.getContext("2d"), this.animation ? (this.decodeFrames(e3), this.animate(e3)) : (r2 = e3.createImageData(this.width, this.height), this.copyToImageData(r2, this.decodePixels()), e3.putImageData(r2, 0, 0));
    }, a2;
  })();
  function Zt(t3) {
    var e2 = 0;
    if (71 !== t3[e2++] || 73 !== t3[e2++] || 70 !== t3[e2++] || 56 !== t3[e2++] || 56 != (t3[e2++] + 1 & 253) || 97 !== t3[e2++]) throw new Error("Invalid GIF 87a/89a header.");
    var r2 = t3[e2++] | t3[e2++] << 8, n2 = t3[e2++] | t3[e2++] << 8, i2 = t3[e2++], a2 = i2 >> 7, o2 = 1 << (7 & i2) + 1;
    t3[e2++], t3[e2++];
    var s2 = null, c2 = null;
    a2 && (s2 = e2, c2 = o2, e2 += 3 * o2);
    var u2 = true, h2 = [], l2 = 0, f2 = null, d2 = 0, p2 = null;
    for (this.width = r2, this.height = n2; u2 && e2 < t3.length; ) switch (t3[e2++]) {
      case 33:
        switch (t3[e2++]) {
          case 255:
            if (11 !== t3[e2] || 78 == t3[e2 + 1] && 69 == t3[e2 + 2] && 84 == t3[e2 + 3] && 83 == t3[e2 + 4] && 67 == t3[e2 + 5] && 65 == t3[e2 + 6] && 80 == t3[e2 + 7] && 69 == t3[e2 + 8] && 50 == t3[e2 + 9] && 46 == t3[e2 + 10] && 48 == t3[e2 + 11] && 3 == t3[e2 + 12] && 1 == t3[e2 + 13] && 0 == t3[e2 + 16]) e2 += 14, p2 = t3[e2++] | t3[e2++] << 8, e2++;
            else for (e2 += 12; ; ) {
              if (!((P2 = t3[e2++]) >= 0)) throw Error("Invalid block size");
              if (0 === P2) break;
              e2 += P2;
            }
            break;
          case 249:
            if (4 !== t3[e2++] || 0 !== t3[e2 + 4]) throw new Error("Invalid graphics extension block.");
            var g2 = t3[e2++];
            l2 = t3[e2++] | t3[e2++] << 8, f2 = t3[e2++], 0 == (1 & g2) && (f2 = null), d2 = g2 >> 2 & 7, e2++;
            break;
          case 254:
            for (; ; ) {
              if (!((P2 = t3[e2++]) >= 0)) throw Error("Invalid block size");
              if (0 === P2) break;
              e2 += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t3[e2 - 1].toString(16));
        }
        break;
      case 44:
        var m2 = t3[e2++] | t3[e2++] << 8, v2 = t3[e2++] | t3[e2++] << 8, b2 = t3[e2++] | t3[e2++] << 8, y2 = t3[e2++] | t3[e2++] << 8, w2 = t3[e2++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;
        if (w2 >> 7) {
          S2 = true;
          A2 = e2, x2 = L2, e2 += 3 * L2;
        }
        var _2 = e2;
        for (e2++; ; ) {
          var P2;
          if (!((P2 = t3[e2++]) >= 0)) throw Error("Invalid block size");
          if (0 === P2) break;
          e2 += P2;
        }
        h2.push({
          x: m2,
          y: v2,
          width: b2,
          height: y2,
          has_local_palette: S2,
          palette_offset: A2,
          palette_size: x2,
          data_offset: _2,
          data_length: e2 - _2,
          transparent_index: f2,
          interlaced: !!N2,
          delay: l2,
          disposal: d2
        });
        break;
      case 59:
        u2 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t3[e2 - 1].toString(16));
    }
    this.numFrames = function() {
      return h2.length;
    }, this.loopCount = function() {
      return p2;
    }, this.frameInfo = function(t4) {
      if (t4 < 0 || t4 >= h2.length) throw new Error("Frame index out of range.");
      return h2[t4];
    }, this.decodeAndBlitFrameBGRA = function(e3, n3) {
      var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
      $t(t3, i3.data_offset, o3, a3);
      var s3 = i3.palette_offset, c3 = i3.transparent_index;
      null === c3 && (c3 = 256);
      var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p3 = f3, g3 = 4 * h3;
      true === i3.interlaced && (g3 += 4 * r2 * 7);
      for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
        var y3 = o3[v3];
        if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3) p3 += 4;
        else {
          var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
          n3[p3++] = L3, n3[p3++] = N3, n3[p3++] = w3, n3[p3++] = 255;
        }
        --l3;
      }
    }, this.decodeAndBlitFrameRGBA = function(e3, n3) {
      var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
      $t(t3, i3.data_offset, o3, a3);
      var s3 = i3.palette_offset, c3 = i3.transparent_index;
      null === c3 && (c3 = 256);
      var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p3 = f3, g3 = 4 * h3;
      true === i3.interlaced && (g3 += 4 * r2 * 7);
      for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
        var y3 = o3[v3];
        if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3) p3 += 4;
        else {
          var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
          n3[p3++] = w3, n3[p3++] = N3, n3[p3++] = L3, n3[p3++] = 255;
        }
        --l3;
      }
    };
  }
  function $t(t3, e2, r2, n2) {
    for (var i2 = t3[e2++], o2 = 1 << i2, s2 = o2 + 1, c2 = s2 + 1, u2 = i2 + 1, h2 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p2 = t3[e2++], g2 = new Int32Array(4096), m2 = null; ; ) {
      for (; l2 < 16 && 0 !== p2; ) f2 |= t3[e2++] << l2, l2 += 8, 1 === p2 ? p2 = t3[e2++] : --p2;
      if (l2 < u2) break;
      var v2 = f2 & h2;
      if (f2 >>= u2, l2 -= u2, v2 !== o2) {
        if (v2 === s2) break;
        for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; ) w2 = g2[w2] >> 8, ++y2;
        var N2 = w2;
        if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2) return void a$1.log("Warning, gif stream longer than expected.");
        r2[d2++] = N2;
        var L2 = d2 += y2;
        for (b2 !== v2 && (r2[d2++] = N2), w2 = b2; y2--; ) w2 = g2[w2], r2[--L2] = 255 & w2, w2 >>= 8;
        null !== m2 && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h2 + 1 && u2 < 12 && (++u2, h2 = h2 << 1 | 1)), m2 = v2;
      } else c2 = s2 + 1, h2 = (1 << (u2 = i2 + 1)) - 1, m2 = null;
    }
    return d2 !== n2 && a$1.log("Warning, gif stream shorter than expected."), r2;
  }
  function Qt(t3) {
    var e2, r2, n2, i2, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h2 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
    function j2(t4, e3) {
      for (var r3 = 0, n3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
        for (var o3 = 1; o3 <= t4[a3]; o3++) i3[e3[n3]] = [], i3[e3[n3]][0] = r3, i3[e3[n3]][1] = a3, n3++, r3++;
        r3 *= 2;
      }
      return i3;
    }
    function O2(t4) {
      for (var e3 = t4[0], r3 = t4[1] - 1; r3 >= 0; ) e3 & 1 << r3 && (m2 |= 1 << v2), r3--, --v2 < 0 && (255 == m2 ? (B2(255), B2(0)) : B2(m2), v2 = 7, m2 = 0);
    }
    function B2(t4) {
      g2.push(t4);
    }
    function M2(t4) {
      B2(t4 >> 8 & 255), B2(255 & t4);
    }
    function E2(t4, e3, r3, n3, i3) {
      for (var a3, o3 = i3[0], s3 = i3[240], c3 = (function(t5, e4) {
        var r4, n4, i4, a4, o4, s4, c4, u4, h4, l3, f3 = 0;
        for (h4 = 0; h4 < 8; ++h4) {
          r4 = t5[f3], n4 = t5[f3 + 1], i4 = t5[f3 + 2], a4 = t5[f3 + 3], o4 = t5[f3 + 4], s4 = t5[f3 + 5], c4 = t5[f3 + 6];
          var p3 = r4 + (u4 = t5[f3 + 7]), g4 = r4 - u4, m4 = n4 + c4, v4 = n4 - c4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p3 + w4, A3 = p3 - w4, x3 = m4 + b4, S3 = m4 - b4;
          t5[f3] = L3 + x3, t5[f3 + 4] = L3 - x3;
          var _3 = 0.707106781 * (S3 + A3);
          t5[f3 + 2] = A3 + _3, t5[f3 + 6] = A3 - _3;
          var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v4), C3 = g4 + F3, j3 = g4 - F3;
          t5[f3 + 5] = j3 + k3, t5[f3 + 3] = j3 - k3, t5[f3 + 1] = C3 + I3, t5[f3 + 7] = C3 - I3, f3 += 8;
        }
        for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
          r4 = t5[f3], n4 = t5[f3 + 8], i4 = t5[f3 + 16], a4 = t5[f3 + 24], o4 = t5[f3 + 32], s4 = t5[f3 + 40], c4 = t5[f3 + 48];
          var O3 = r4 + (u4 = t5[f3 + 56]), B3 = r4 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i4 + s4, D2 = i4 - s4, R2 = a4 + o4, T2 = a4 - o4, U2 = O3 + R2, z2 = O3 - R2, H2 = M3 + q3, W2 = M3 - q3;
          t5[f3] = U2 + H2, t5[f3 + 32] = U2 - H2;
          var V2 = 0.707106781 * (W2 + z2);
          t5[f3 + 16] = z2 + V2, t5[f3 + 48] = z2 - V2;
          var G2 = 0.382683433 * ((U2 = T2 + D2) - (W2 = E3 + B3)), Y2 = 0.5411961 * U2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H2 = D2 + E3), K2 = B3 + X2, Z2 = B3 - X2;
          t5[f3 + 40] = Z2 + Y2, t5[f3 + 24] = Z2 - Y2, t5[f3 + 8] = K2 + J2, t5[f3 + 56] = K2 - J2, f3++;
        }
        for (h4 = 0; h4 < 64; ++h4) l3 = t5[h4] * e4[h4], d2[h4] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
        return d2;
      })(t4, e3), u3 = 0; u3 < 64; ++u3) p2[A2[u3]] = c3[u3];
      var h3 = p2[0] - r3;
      r3 = p2[0], 0 == h3 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h3]]), O2(l2[a3]));
      for (var g3 = 63; g3 > 0 && 0 == p2[g3]; ) g3--;
      if (0 == g3) return O2(o3), r3;
      for (var m3, v3 = 1; v3 <= g3; ) {
        for (var b3 = v3; 0 == p2[v3] && v3 <= g3; ) ++v3;
        var y3 = v3 - b3;
        if (y3 >= 16) {
          m3 = y3 >> 4;
          for (var w3 = 1; w3 <= m3; ++w3) O2(s3);
          y3 &= 15;
        }
        a3 = 32767 + p2[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;
      }
      return 63 != g3 && O2(o3), r3;
    }
    function q2(t4) {
      (t4 = Math.min(Math.max(t4, 1), 100), a2 != t4) && (!(function(t5) {
        for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r3 = 0; r3 < 64; r3++) {
          var n3 = o2((e3[r3] * t5 + 50) / 100);
          n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r3]] = n3;
        }
        for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
          var l3 = o2((i3[a3] * t5 + 50) / 100);
          l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;
        }
        for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p3 = 0; p3 < 8; p3++) for (var g3 = 0; g3 < 8; g3++) u2[d3] = 1 / (s2[A2[d3]] * f3[p3] * f3[g3] * 8), h2[d3] = 1 / (c2[A2[d3]] * f3[p3] * f3[g3] * 8), d3++;
      })(t4 < 50 ? Math.floor(5e3 / t4) : Math.floor(200 - 2 * t4)), a2 = t4);
    }
    this.encode = function(t4, a3) {
      a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B2(74), B2(70), B2(73), B2(70), B2(0), B2(1), B2(1), B2(0), M2(1), M2(1), B2(0), B2(0), (function() {
        M2(65499), M2(132), B2(0);
        for (var t5 = 0; t5 < 64; t5++) B2(s2[t5]);
        B2(1);
        for (var e3 = 0; e3 < 64; e3++) B2(c2[e3]);
      })(), (function(t5, e3) {
        M2(65472), M2(17), B2(8), M2(e3), M2(t5), B2(3), B2(1), B2(17), B2(0), B2(2), B2(17), B2(1), B2(3), B2(17), B2(1);
      })(t4.width, t4.height), (function() {
        M2(65476), M2(418), B2(0);
        for (var t5 = 0; t5 < 16; t5++) B2(x2[t5 + 1]);
        for (var e3 = 0; e3 <= 11; e3++) B2(S2[e3]);
        B2(16);
        for (var r3 = 0; r3 < 16; r3++) B2(_2[r3 + 1]);
        for (var n3 = 0; n3 <= 161; n3++) B2(P2[n3]);
        B2(1);
        for (var i3 = 0; i3 < 16; i3++) B2(k2[i3 + 1]);
        for (var a4 = 0; a4 <= 11; a4++) B2(I2[a4]);
        B2(17);
        for (var o4 = 0; o4 < 16; o4++) B2(F2[o4 + 1]);
        for (var s3 = 0; s3 <= 161; s3++) B2(C2[s3]);
      })(), M2(65498), M2(12), B2(3), B2(1), B2(0), B2(2), B2(17), B2(3), B2(17), B2(0), B2(63), B2(0);
      var o3 = 0, l3 = 0, f3 = 0;
      m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
      for (var d3, p3, N3, A3, j3, D2, R2, T2, U2, z2 = t4.data, H2 = t4.width, W2 = t4.height, V2 = 4 * H2, G2 = 0; G2 < W2; ) {
        for (d3 = 0; d3 < V2; ) {
          for (j3 = V2 * G2 + d3, R2 = -1, T2 = 0, U2 = 0; U2 < 64; U2++) D2 = j3 + (T2 = U2 >> 3) * V2 + (R2 = 4 * (7 & U2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p3 = z2[D2++], N3 = z2[D2++], A3 = z2[D2++], b2[U2] = (L2[p3] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[U2] = (L2[p3 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[U2] = (L2[p3 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
          o3 = E2(b2, u2, o3, e2, n2), l3 = E2(y2, h2, l3, r2, i2), f3 = E2(w2, h2, f3, r2, i2), d3 += 32;
        }
        G2 += 8;
      }
      if (v2 >= 0) {
        var Y2 = [];
        Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
      }
      return M2(65497), new Uint8Array(g2);
    }, t3 = t3 || 50, (function() {
      for (var t4 = String.fromCharCode, e3 = 0; e3 < 256; e3++) N2[e3] = t4(e3);
    })(), e2 = j2(x2, S2), r2 = j2(k2, I2), n2 = j2(_2, P2), i2 = j2(F2, C2), (function() {
      for (var t4 = 1, e3 = 2, r3 = 1; r3 <= 15; r3++) {
        for (var n3 = t4; n3 < e3; n3++) f2[32767 + n3] = r3, l2[32767 + n3] = [], l2[32767 + n3][1] = r3, l2[32767 + n3][0] = n3;
        for (var i3 = -(e3 - 1); i3 <= -t4; i3++) f2[32767 + i3] = r3, l2[32767 + i3] = [], l2[32767 + i3][1] = r3, l2[32767 + i3][0] = e3 - 1 + i3;
        t4 <<= 1, e3 <<= 1;
      }
    })(), (function() {
      for (var t4 = 0; t4 < 256; t4++) L2[t4] = 19595 * t4, L2[t4 + 256 >> 0] = 38470 * t4, L2[t4 + 512 >> 0] = 7471 * t4 + 32768, L2[t4 + 768 >> 0] = -11059 * t4, L2[t4 + 1024 >> 0] = -21709 * t4, L2[t4 + 1280 >> 0] = 32768 * t4 + 8421375, L2[t4 + 1536 >> 0] = -27439 * t4, L2[t4 + 1792 >> 0] = -5329 * t4;
    })(), q2(t3);
  }
  function te(t3, e2) {
    if (this.pos = 0, this.buffer = t3, this.datav = new DataView(t3.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag)) throw new Error("Invalid BMP File");
    this.parseHeader(), this.parseBGR();
  }
  function ee(t3) {
    function e2(t4) {
      if (!t4) throw Error("assert :P");
    }
    function r2(t4, e3, r3) {
      for (var n3 = 0; 4 > n3; n3++) if (t4[e3 + n3] != r3.charCodeAt(n3)) return true;
      return false;
    }
    function n2(t4, e3, r3, n3, i3) {
      for (var a3 = 0; a3 < i3; a3++) t4[e3 + a3] = r3[n3 + a3];
    }
    function i2(t4, e3, r3, n3) {
      for (var i3 = 0; i3 < n3; i3++) t4[e3 + i3] = r3;
    }
    function a2(t4) {
      return new Int32Array(t4);
    }
    function o2(t4, e3) {
      for (var r3 = [], n3 = 0; n3 < t4; n3++) r3.push(new e3());
      return r3;
    }
    function s2(t4, e3) {
      var r3 = [];
      return (function t5(r4, n3, i3) {
        for (var a3 = i3[n3], o3 = 0; o3 < a3 && (r4.push(i3.length > n3 + 1 ? [] : new e3()), !(i3.length < n3 + 1)); o3++) t5(r4[o3], n3 + 1, i3);
      })(r3, 0, t4), r3;
    }
    var c2 = function() {
      var t4 = this;
      function c3(t5, e3) {
        for (var r3 = 1 << e3 - 1 >>> 0; t5 & r3; ) r3 >>>= 1;
        return r3 ? (t5 & r3 - 1) + r3 : t5;
      }
      function u3(t5, r3, n3, i3, a3) {
        e2(!(i3 % n3));
        do {
          t5[r3 + (i3 -= n3)] = a3;
        } while (0 < i3);
      }
      function h3(t5, r3, n3, i3, o3) {
        if (e2(2328 >= o3), 512 >= o3) var s3 = a2(512);
        else if (null == (s3 = a2(o3))) return 0;
        return (function(t6, r4, n4, i4, o4, s4) {
          var h4, f4, d4 = r4, p4 = 1 << n4, g4 = a2(16), m4 = a2(16);
          for (e2(0 != o4), e2(null != i4), e2(null != t6), e2(0 < n4), f4 = 0; f4 < o4; ++f4) {
            if (15 < i4[f4]) return 0;
            ++g4[i4[f4]];
          }
          if (g4[0] == o4) return 0;
          for (m4[1] = 0, h4 = 1; 15 > h4; ++h4) {
            if (g4[h4] > 1 << h4) return 0;
            m4[h4 + 1] = m4[h4] + g4[h4];
          }
          for (f4 = 0; f4 < o4; ++f4) h4 = i4[f4], 0 < i4[f4] && (s4[m4[h4]++] = f4);
          if (1 == m4[15]) return (i4 = new l3()).g = 0, i4.value = s4[0], u3(t6, d4, 1, p4, i4), p4;
          var v4, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;
          for (f4 = 0, h4 = 1, o4 = 2; h4 <= n4; ++h4, o4 <<= 1) {
            if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4])) return 0;
            for (; 0 < g4[h4]; --g4[h4]) (i4 = new l3()).g = h4, i4.value = s4[f4++], u3(t6, d4 + w4, o4, A4, i4), w4 = c3(w4, h4);
          }
          for (h4 = n4 + 1, o4 = 2; 15 >= h4; ++h4, o4 <<= 1) {
            if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4])) return 0;
            for (; 0 < g4[h4]; --g4[h4]) {
              if (i4 = new l3(), (w4 & y4) != b4) {
                for (d4 += A4, v4 = 1 << (b4 = h4) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); ) ++b4, v4 <<= 1;
                p4 += A4 = 1 << (v4 = b4 - n4), t6[r4 + (b4 = w4 & y4)].g = v4 + n4, t6[r4 + b4].value = d4 - r4 - b4;
              }
              i4.g = h4 - n4, i4.value = s4[f4++], u3(t6, d4 + (w4 >> n4), o4, A4, i4), w4 = c3(w4, h4);
            }
          }
          return N4 != 2 * m4[15] - 1 ? 0 : p4;
        })(t5, r3, n3, i3, o3, s3);
      }
      function l3() {
        this.value = this.g = 0;
      }
      function f3() {
        this.value = this.g = 0;
      }
      function d3() {
        this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);
      }
      function p3(t5, r3, n3, i3) {
        e2(null != t5), e2(null != r3), e2(2147483648 > i3), t5.Ca = 254, t5.I = 0, t5.b = -8, t5.Ka = 0, t5.oa = r3, t5.pa = n3, t5.Jd = r3, t5.Yc = n3 + i3, t5.Zc = 4 <= i3 ? n3 + i3 - 4 + 1 : n3, _2(t5);
      }
      function g3(t5, e3) {
        for (var r3 = 0; 0 < e3--; ) r3 |= k2(t5, 128) << e3;
        return r3;
      }
      function m3(t5, e3) {
        var r3 = g3(t5, e3);
        return P2(t5) ? -r3 : r3;
      }
      function v3(t5, r3, n3, i3) {
        var a3, o3 = 0;
        for (e2(null != t5), e2(null != r3), e2(4294967288 > i3), t5.Sb = i3, t5.Ra = 0, t5.u = 0, t5.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3) o3 += r3[n3 + a3] << 8 * a3;
        t5.Ra = o3, t5.bb = i3, t5.oa = r3, t5.pa = n3;
      }
      function b3(t5) {
        for (; 8 <= t5.u && t5.bb < t5.Sb; ) t5.Ra >>>= 8, t5.Ra += t5.oa[t5.pa + t5.bb] << Ur - 8 >>> 0, ++t5.bb, t5.u -= 8;
        A3(t5) && (t5.h = 1, t5.u = 0);
      }
      function y3(t5, r3) {
        if (e2(0 <= r3), !t5.h && r3 <= Tr) {
          var n3 = L3(t5) & Rr[r3];
          return t5.u += r3, b3(t5), n3;
        }
        return t5.h = 1, t5.u = 0;
      }
      function w3() {
        this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
      }
      function N3() {
        this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
      }
      function L3(t5) {
        return t5.Ra >>> (t5.u & Ur - 1) >>> 0;
      }
      function A3(t5) {
        return e2(t5.bb <= t5.Sb), t5.h || t5.bb == t5.Sb && t5.u > Ur;
      }
      function x2(t5, e3) {
        t5.u = e3, t5.h = A3(t5);
      }
      function S2(t5) {
        t5.u >= zr && (e2(t5.u >= zr), b3(t5));
      }
      function _2(t5) {
        e2(null != t5 && null != t5.oa), t5.pa < t5.Zc ? (t5.I = (t5.oa[t5.pa++] | t5.I << 8) >>> 0, t5.b += 8) : (e2(null != t5 && null != t5.oa), t5.pa < t5.Yc ? (t5.b += 8, t5.I = t5.oa[t5.pa++] | t5.I << 8) : t5.Ka ? t5.b = 0 : (t5.I <<= 8, t5.b += 8, t5.Ka = 1));
      }
      function P2(t5) {
        return g3(t5, 1);
      }
      function k2(t5, e3) {
        var r3 = t5.Ca;
        0 > t5.b && _2(t5);
        var n3 = t5.b, i3 = r3 * e3 >>> 8, a3 = (t5.I >>> n3 > i3) + 0;
        for (a3 ? (r3 -= i3, t5.I -= i3 + 1 << n3 >>> 0) : r3 = i3 + 1, n3 = r3, i3 = 0; 256 <= n3; ) i3 += 8, n3 >>= 8;
        return n3 = 7 ^ i3 + Hr[n3], t5.b -= n3, t5.Ca = (r3 << n3) - 1, a3;
      }
      function I2(t5, e3, r3) {
        t5[e3 + 0] = r3 >> 24 & 255, t5[e3 + 1] = r3 >> 16 & 255, t5[e3 + 2] = r3 >> 8 & 255, t5[e3 + 3] = r3 >> 0 & 255;
      }
      function F2(t5, e3) {
        return t5[e3 + 0] << 0 | t5[e3 + 1] << 8;
      }
      function C2(t5, e3) {
        return F2(t5, e3) | t5[e3 + 2] << 16;
      }
      function j2(t5, e3) {
        return F2(t5, e3) | F2(t5, e3 + 2) << 16;
      }
      function O2(t5, r3) {
        var n3 = 1 << r3;
        return e2(null != t5), e2(0 < r3), t5.X = a2(n3), null == t5.X ? 0 : (t5.Mb = 32 - r3, t5.Xa = r3, 1);
      }
      function B2(t5, r3) {
        e2(null != t5), e2(null != r3), e2(t5.Xa == r3.Xa), n2(r3.X, 0, t5.X, 0, 1 << r3.Xa);
      }
      function M2() {
        this.X = [], this.Xa = this.Mb = 0;
      }
      function E2(t5, r3, n3, i3) {
        e2(null != n3), e2(null != i3);
        var a3 = n3[0], o3 = i3[0];
        return 0 == a3 && (a3 = (t5 * o3 + r3 / 2) / r3), 0 == o3 && (o3 = (r3 * a3 + t5 / 2) / t5), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i3[0] = o3, 1);
      }
      function q2(t5, e3) {
        return t5 + (1 << e3) - 1 >>> e3;
      }
      function D2(t5, e3) {
        return ((4278255360 & t5) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t5) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
      }
      function R2(e3, r3) {
        t4[r3] = function(r4, n3, i3, a3, o3, s3, c4) {
          var u4;
          for (u4 = 0; u4 < o3; ++u4) {
            var h4 = t4[e3](s3[c4 + u4 - 1], i3, a3 + u4);
            s3[c4 + u4] = D2(r4[n3 + u4], h4);
          }
        };
      }
      function T2() {
        this.ud = this.hd = this.jd = 0;
      }
      function U2(t5, e3) {
        return ((4278124286 & (t5 ^ e3)) >>> 1) + (t5 & e3) >>> 0;
      }
      function z2(t5) {
        return 0 <= t5 && 256 > t5 ? t5 : 0 > t5 ? 0 : 255 < t5 ? 255 : void 0;
      }
      function H2(t5, e3) {
        return z2(t5 + (t5 - e3 + 0.5 >> 1));
      }
      function W2(t5, e3, r3) {
        return Math.abs(e3 - r3) - Math.abs(t5 - r3);
      }
      function V2(t5, e3, r3, n3, i3, a3, o3) {
        for (n3 = a3[o3 - 1], r3 = 0; r3 < i3; ++r3) a3[o3 + r3] = n3 = D2(t5[e3 + r3], n3);
      }
      function G2(t5, e3, r3, n3, i3) {
        var a3;
        for (a3 = 0; a3 < r3; ++a3) {
          var o3 = t5[e3 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
          n3[i3 + a3] = (4278255360 & o3) + c4 >>> 0;
        }
      }
      function Y2(t5, e3) {
        e3.jd = t5 >> 0 & 255, e3.hd = t5 >> 8 & 255, e3.ud = t5 >> 16 & 255;
      }
      function J2(t5, e3, r3, n3, i3, a3) {
        var o3;
        for (o3 = 0; o3 < n3; ++o3) {
          var s3 = e3[r3 + o3], c4 = s3 >>> 8, u4 = s3, h4 = 255 & (h4 = (h4 = s3 >>> 16) + ((t5.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
          u4 = 255 & (u4 = (u4 = u4 + ((t5.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t5.ud << 24 >> 24) * (h4 << 24 >> 24) >>> 5));
          i3[a3 + o3] = (4278255360 & s3) + (h4 << 16) + u4;
        }
      }
      function X2(e3, r3, n3, i3, a3) {
        t4[r3] = function(t5, e4, r4, n4, o3, s3, c4, u4, h4) {
          for (n4 = c4; n4 < u4; ++n4) for (c4 = 0; c4 < h4; ++c4) o3[s3++] = a3(r4[i3(t5[e4++])]);
        }, t4[e3] = function(e4, r4, o3, s3, c4, u4, h4) {
          var l4 = 8 >> e4.b, f4 = e4.Ea, d4 = e4.K[0], p4 = e4.w;
          if (8 > l4) for (e4 = (1 << e4.b) - 1, p4 = (1 << l4) - 1; r4 < o3; ++r4) {
            var g4, m4 = 0;
            for (g4 = 0; g4 < f4; ++g4) g4 & e4 || (m4 = i3(s3[c4++])), u4[h4++] = a3(d4[m4 & p4]), m4 >>= l4;
          }
          else t4["VP8LMapColor" + n3](s3, c4, d4, p4, u4, h4, r4, o3, f4);
        };
      }
      function K2(t5, e3, r3, n3, i3) {
        for (r3 = e3 + r3; e3 < r3; ) {
          var a3 = t5[e3++];
          n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255;
        }
      }
      function Z2(t5, e3, r3, n3, i3) {
        for (r3 = e3 + r3; e3 < r3; ) {
          var a3 = t5[e3++];
          n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 24 & 255;
        }
      }
      function $2(t5, e3, r3, n3, i3) {
        for (r3 = e3 + r3; e3 < r3; ) {
          var a3 = (o3 = t5[e3++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;
          n3[i3++] = a3, n3[i3++] = o3;
        }
      }
      function Q2(t5, e3, r3, n3, i3) {
        for (r3 = e3 + r3; e3 < r3; ) {
          var a3 = (o3 = t5[e3++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
          n3[i3++] = a3, n3[i3++] = o3;
        }
      }
      function tt2(t5, e3, r3, n3, i3) {
        for (r3 = e3 + r3; e3 < r3; ) {
          var a3 = t5[e3++];
          n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 16 & 255;
        }
      }
      function et2(t5, e3, r3, i3, a3, o3) {
        if (0 == o3) for (r3 = e3 + r3; e3 < r3; ) I2(i3, ((o3 = t5[e3++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
        else n2(i3, a3, t5, e3, r3);
      }
      function rt2(e3, r3) {
        t4[r3][0] = t4[e3 + "0"], t4[r3][1] = t4[e3 + "1"], t4[r3][2] = t4[e3 + "2"], t4[r3][3] = t4[e3 + "3"], t4[r3][4] = t4[e3 + "4"], t4[r3][5] = t4[e3 + "5"], t4[r3][6] = t4[e3 + "6"], t4[r3][7] = t4[e3 + "7"], t4[r3][8] = t4[e3 + "8"], t4[r3][9] = t4[e3 + "9"], t4[r3][10] = t4[e3 + "10"], t4[r3][11] = t4[e3 + "11"], t4[r3][12] = t4[e3 + "12"], t4[r3][13] = t4[e3 + "13"], t4[r3][14] = t4[e3 + "0"], t4[r3][15] = t4[e3 + "0"];
      }
      function nt2(t5) {
        return t5 == Hn || t5 == Wn || t5 == Vn || t5 == Gn;
      }
      function it2() {
        this.eb = [], this.size = this.A = this.fb = 0;
      }
      function at2() {
        this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
      }
      function ot2() {
        this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
      }
      function st2() {
        this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
      }
      function ct2() {
        this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
      }
      function ut2(t5) {
        return alert("todo:WebPSamplerProcessPlane"), t5.T;
      }
      function ht2(t5, e3) {
        var r3 = t5.T, i3 = e3.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t5.ka * i3.A, s3 = vi[e3.ba.S], c4 = t5.y, u4 = t5.O, h4 = t5.f, l4 = t5.N, f4 = t5.ea, d4 = t5.W, p4 = e3.cc, g4 = e3.dc, m4 = e3.Mc, v4 = e3.Nc, b4 = t5.ka, y4 = t5.ka + t5.T, w4 = t5.U, N4 = w4 + 1 >> 1;
        for (0 == b4 ? s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3, null, null, w4) : (s3(e3.ec, e3.fc, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4), ++r3); b4 + 2 < y4; b4 += 2) p4 = h4, g4 = l4, m4 = f4, v4 = d4, l4 += t5.Rc, d4 += t5.Rc, o3 += 2 * i3.A, s3(c4, (u4 += 2 * t5.fa) - t5.fa, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4);
        return u4 += t5.fa, t5.j + y4 < t5.o ? (n2(e3.ec, e3.fc, c4, u4, w4), n2(e3.cc, e3.dc, h4, l4, N4), n2(e3.Mc, e3.Nc, f4, d4, N4), r3--) : 1 & y4 || s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3 + i3.A, null, null, w4), r3;
      }
      function lt2(t5, r3, n3) {
        var i3 = t5.F, a3 = [t5.J];
        if (null != i3) {
          var o3 = t5.U, s3 = r3.ba.S, c4 = s3 == Tn || s3 == Vn;
          r3 = r3.ba.f.RGBA;
          var u4 = [0], h4 = t5.ka;
          u4[0] = t5.T, t5.Kb && (0 == h4 ? --u4[0] : (--h4, a3[0] -= t5.width), t5.j + t5.ka + t5.T == t5.o && (u4[0] = t5.o - t5.j - h4));
          var l4 = r3.eb;
          h4 = r3.fb + h4 * r3.A;
          t5 = Sn(i3, a3[0], t5.width, o3, u4, l4, h4 + (c4 ? 0 : 3), r3.A), e2(n3 == u4), t5 && nt2(s3) && An(l4, h4, c4, o3, u4, r3.A);
        }
        return 0;
      }
      function ft2(t5) {
        var e3 = t5.ma, r3 = e3.ba.S, n3 = 11 > r3, i3 = r3 == qn || r3 == Rn || r3 == Tn || r3 == Un || 12 == r3 || nt2(r3);
        if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mr(e3.Oa, t5, i3 ? 11 : 12)) return 0;
        if (i3 && nt2(r3) && br(), t5.da) alert("todo:use_scaling");
        else {
          if (n3) {
            if (e3.Ib = ut2, t5.Kb) {
              if (r3 = t5.U + 1 >> 1, e3.memory = a2(t5.U + 2 * r3), null == e3.memory) return 0;
              e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t5.U, e3.Mc = e3.cc, e3.Nc = e3.dc + r3, e3.Ib = ht2, br();
            }
          } else alert("todo:EmitYUV");
          i3 && (e3.Jb = lt2, n3 && mr());
        }
        if (n3 && !Ci) {
          for (t5 = 0; 256 > t5; ++t5) ji[t5] = 89858 * (t5 - 128) + _i >> Si, Mi[t5] = -22014 * (t5 - 128) + _i, Bi[t5] = -45773 * (t5 - 128), Oi[t5] = 113618 * (t5 - 128) + _i >> Si;
          for (t5 = Pi; t5 < ki; ++t5) e3 = 76283 * (t5 - 16) + _i >> Si, Ei[t5 - Pi] = Vt2(e3, 255), qi[t5 - Pi] = Vt2(e3 + 8 >> 4, 15);
          Ci = 1;
        }
        return 1;
      }
      function dt2(t5) {
        var r3 = t5.ma, n3 = t5.U, i3 = t5.T;
        return e2(!(1 & t5.ka)), 0 >= n3 || 0 >= i3 ? 0 : (n3 = r3.Ib(t5, r3), null != r3.Jb && r3.Jb(t5, r3, n3), r3.Dc += n3, 1);
      }
      function pt2(t5) {
        t5.ma.memory = null;
      }
      function gt2(t5, e3, r3, n3) {
        return 47 != y3(t5, 8) ? 0 : (e3[0] = y3(t5, 14) + 1, r3[0] = y3(t5, 14) + 1, n3[0] = y3(t5, 1), 0 != y3(t5, 3) ? 0 : !t5.h);
      }
      function mt2(t5, e3) {
        if (4 > t5) return t5 + 1;
        var r3 = t5 - 2 >> 1;
        return (2 + (1 & t5) << r3) + y3(e3, r3) + 1;
      }
      function vt2(t5, e3) {
        return 120 < e3 ? e3 - 120 : 1 <= (r3 = ((r3 = $n[e3 - 1]) >> 4) * t5 + (8 - (15 & r3))) ? r3 : 1;
        var r3;
      }
      function bt2(t5, e3, r3) {
        var n3 = L3(r3), i3 = t5[e3 += 255 & n3].g - 8;
        return 0 < i3 && (x2(r3, r3.u + 8), n3 = L3(r3), e3 += t5[e3].value, e3 += n3 & (1 << i3) - 1), x2(r3, r3.u + t5[e3].g), t5[e3].value;
      }
      function yt2(t5, r3, n3) {
        return n3.g += t5.g, n3.value += t5.value << r3 >>> 0, e2(8 >= n3.g), t5.g;
      }
      function wt2(t5, r3, n3) {
        var i3 = t5.xc;
        return e2((r3 = 0 == i3 ? 0 : t5.vc[t5.md * (n3 >> i3) + (r3 >> i3)]) < t5.Wb), t5.Ya[r3];
      }
      function Nt2(t5, r3, i3, a3) {
        var o3 = t5.ab, s3 = t5.c * r3, c4 = t5.C;
        r3 = c4 + r3;
        var u4 = i3, h4 = a3;
        for (a3 = t5.Ta, i3 = t5.Ua; 0 < o3--; ) {
          var l4 = t5.gc[o3], f4 = c4, d4 = r3, p4 = u4, g4 = h4, m4 = (h4 = a3, u4 = i3, l4.Ea);
          switch (e2(f4 < d4), e2(d4 <= l4.nc), l4.hc) {
            case 2:
              Gr(p4, g4, (d4 - f4) * m4, h4, u4);
              break;
            case 0:
              var v4 = f4, b4 = d4, y4 = h4, w4 = u4, N4 = (_3 = l4).Ea;
              0 == v4 && (Wr(p4, g4, null, null, 1, y4, w4), V2(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
              for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * x3; v4 < b4; ) {
                var P3 = S3, k3 = _3, I3 = 1;
                for (Vr(p4, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {
                  var F3 = (I3 & ~A4) + L4;
                  F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p4, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;
                }
                g4 += N4, w4 += N4, ++v4 & A4 || (_3 += x3);
              }
              d4 != l4.nc && n2(h4, u4 - m4, h4, u4 + (d4 - f4 - 1) * m4, m4);
              break;
            case 1:
              for (m4 = p4, b4 = g4, N4 = (p4 = l4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << l4.b) - 1)), v4 = q2(p4, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v4; f4 < d4; ) {
                for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; ) Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h4, u4), b4 += g4, u4 += g4;
                b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h4, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v4);
              }
              break;
            case 3:
              if (p4 == h4 && g4 == u4 && 0 < l4.b) {
                for (b4 = h4, p4 = m4 = u4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * q2(l4.Ea, l4.b)), g4 = h4, y4 = u4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4) v4[w4] = g4[y4 + w4];
                for (w4 = N4 - 1; 0 <= w4; --w4) b4[p4 + w4] = v4[w4];
                Yr(l4, f4, d4, h4, m4, h4, u4);
              } else Yr(l4, f4, d4, p4, g4, h4, u4);
          }
          u4 = a3, h4 = i3;
        }
        h4 != i3 && n2(a3, i3, u4, h4, s3);
      }
      function Lt2(t5, r3) {
        var n3 = t5.V, i3 = t5.Ba + t5.c * t5.C, a3 = r3 - t5.C;
        if (e2(r3 <= t5.l.o), e2(16 >= a3), 0 < a3) {
          var o3 = t5.l, s3 = t5.Ta, c4 = t5.Ua, u4 = o3.width;
          if (Nt2(t5, a3, n3, i3), a3 = c4 = [c4], e2((n3 = t5.C) < (i3 = r3)), e2(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), n3 < o3.j) {
            var h4 = o3.j - n3;
            n3 = o3.j;
            a3[0] += h4 * u4;
          }
          if (n3 >= i3 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - n3, n3 = 1), n3) {
            if (c4 = c4[0], 11 > (n3 = t5.ca).S) {
              var l4 = n3.f.RGBA, f4 = (i3 = n3.S, a3 = o3.U, o3 = o3.T, h4 = l4.eb, l4.A), d4 = o3;
              for (l4 = l4.fb + t5.Ma * l4.A; 0 < d4--; ) {
                var p4 = s3, g4 = c4, m4 = a3, v4 = h4, b4 = l4;
                switch (i3) {
                  case En:
                    Qr(p4, g4, m4, v4, b4);
                    break;
                  case qn:
                    tn(p4, g4, m4, v4, b4);
                    break;
                  case Hn:
                    tn(p4, g4, m4, v4, b4), An(v4, b4, 0, m4, 1, 0);
                    break;
                  case Dn:
                    nn(p4, g4, m4, v4, b4);
                    break;
                  case Rn:
                    et2(p4, g4, m4, v4, b4, 1);
                    break;
                  case Wn:
                    et2(p4, g4, m4, v4, b4, 1), An(v4, b4, 0, m4, 1, 0);
                    break;
                  case Tn:
                    et2(p4, g4, m4, v4, b4, 0);
                    break;
                  case Vn:
                    et2(p4, g4, m4, v4, b4, 0), An(v4, b4, 1, m4, 1, 0);
                    break;
                  case Un:
                    en(p4, g4, m4, v4, b4);
                    break;
                  case Gn:
                    en(p4, g4, m4, v4, b4), xn(v4, b4, m4, 1, 0);
                    break;
                  case zn:
                    rn(p4, g4, m4, v4, b4);
                    break;
                  default:
                    e2(0);
                }
                c4 += u4, l4 += f4;
              }
              t5.Ma += o3;
            } else alert("todo:EmitRescaledRowsYUVA");
            e2(t5.Ma <= n3.height);
          }
        }
        t5.C = r3, e2(t5.C <= t5.i);
      }
      function At2(t5) {
        var e3;
        if (0 < t5.ua) return 0;
        for (e3 = 0; e3 < t5.Wb; ++e3) {
          var r3 = t5.Ya[e3].G, n3 = t5.Ya[e3].H;
          if (0 < r3[1][n3[1] + 0].g || 0 < r3[2][n3[2] + 0].g || 0 < r3[3][n3[3] + 0].g) return 0;
        }
        return 1;
      }
      function xt2(t5, r3, n3, i3, a3, o3) {
        if (0 != t5.Z) {
          var s3 = t5.qd, c4 = t5.rd;
          for (e2(null != mi[t5.Z]); r3 < n3; ++r3) mi[t5.Z](s3, c4, i3, a3, i3, a3, o3), s3 = i3, c4 = a3, a3 += o3;
          t5.qd = s3, t5.rd = c4;
        }
      }
      function St2(t5, r3) {
        var n3 = t5.l.ma, i3 = 0 == n3.Z || 1 == n3.Z ? t5.l.j : t5.C;
        i3 = t5.C < i3 ? i3 : t5.C;
        if (e2(r3 <= t5.l.o), r3 > i3) {
          var a3 = t5.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i3, c4 = t5.V, u4 = t5.Ba + t5.c * i3, h4 = t5.gc;
          e2(1 == t5.ab), e2(3 == h4[0].hc), Xr(h4[0], i3, r3, c4, u4, o3, s3), xt2(n3, i3, r3, o3, s3, a3);
        }
        t5.C = t5.Ma = r3;
      }
      function _t2(t5, r3, n3, i3, a3, o3, s3) {
        var c4 = t5.$ / i3, u4 = t5.$ % i3, h4 = t5.m, l4 = t5.s, f4 = n3 + t5.$, d4 = f4;
        a3 = n3 + i3 * a3;
        var p4 = n3 + i3 * o3, g4 = 280 + l4.ua, m4 = t5.Pb ? c4 : 16777216, v4 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p4 ? wt2(l4, u4, c4) : null;
        e2(t5.C < o3), e2(p4 <= a3);
        var w4 = false;
        t: for (; ; ) {
          for (; w4 || f4 < p4; ) {
            var N4 = 0;
            if (c4 >= m4) {
              var _3 = f4 - n3;
              e2((m4 = t5).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B2(m4.s.Wa, m4.s.vb), m4 = c4 + ti;
            }
            if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e2(null != y4), y4.Qb && (r3[f4] = y4.qb, w4 = true), !w4) if (S2(h4), y4.jc) {
              N4 = h4, _3 = r3;
              var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];
              e2(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e2(256 <= k3.value), N4 = k3.value), 0 == N4 && (w4 = true);
            } else N4 = bt2(y4.G[0], y4.H[0], h4);
            if (h4.h) break;
            if (w4 || 256 > N4) {
              if (!w4) if (y4.nd) r3[f4] = (y4.qb | N4 << 8) >>> 0;
              else {
                if (S2(h4), w4 = bt2(y4.G[1], y4.H[1], h4), S2(h4), _3 = bt2(y4.G[2], y4.H[2], h4), P3 = bt2(y4.G[3], y4.H[3], h4), h4.h) break;
                r3[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
              }
              if (w4 = false, ++f4, ++u4 >= i3 && (u4 = 0, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t5, c4), null != v4)) for (; d4 < f4; ) N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else if (280 > N4) {
              if (N4 = mt2(N4 - 256, h4), _3 = bt2(y4.G[4], y4.H[4], h4), S2(h4), _3 = vt2(i3, _3 = mt2(_3, h4)), h4.h) break;
              if (f4 - n3 < _3 || a3 - f4 < N4) break t;
              for (P3 = 0; P3 < N4; ++P3) r3[f4 + P3] = r3[f4 + P3 - _3];
              for (f4 += N4, u4 += N4; u4 >= i3; ) u4 -= i3, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t5, c4);
              if (e2(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), null != v4) for (; d4 < f4; ) N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else {
              if (!(N4 < g4)) break t;
              for (w4 = N4 - 280, e2(null != v4); d4 < f4; ) N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
              N4 = f4, e2(!(w4 >>> (_3 = v4).Xa)), r3[N4] = _3.X[w4], w4 = true;
            }
            w4 || e2(h4.h == A3(h4));
          }
          if (t5.Pb && h4.h && f4 < a3) e2(t5.m.h), t5.a = 5, t5.m = t5.wd, t5.$ = t5.xd, 0 < t5.s.ua && B2(t5.s.vb, t5.s.Wa);
          else {
            if (h4.h) break t;
            null != s3 && s3(t5, c4 > o3 ? o3 : c4), t5.a = 0, t5.$ = f4 - n3;
          }
          return 1;
        }
        return t5.a = 3, 0;
      }
      function Pt2(t5) {
        e2(null != t5), t5.vc = null, t5.yc = null, t5.Ya = null;
        var r3 = t5.Wa;
        null != r3 && (r3.X = null), t5.vb = null, e2(null != t5);
      }
      function kt2() {
        var e3 = new or();
        return null == e3 ? null : (e3.a = 0, e3.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t4.VP8LMapColor32b = Jr, t4.VP8LMapColor8b = Kr, e3);
      }
      function It2(t5, r3, n3, s3, c4) {
        var u4 = 1, f4 = [t5], p4 = [r3], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
        t: for (; ; ) {
          if (n3) for (; u4 && y3(g4, 1); ) {
            var w4 = f4, N4 = p4, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);
            if (A4.Oc & 1 << I3) u4 = 0;
            else {
              switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e2(4 >= A4.ab), I3) {
                case 0:
                case 1:
                  k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                  break;
                case 3:
                  var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                  if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {
                    var B3, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);
                    if (null == T3) F3 = 0;
                    else {
                      var U3 = E3.K[0], z3 = E3.w;
                      for (T3[0] = E3.K[0][0], B3 = 1; B3 < 1 * M3; ++B3) T3[B3] = D2(U3[z3 + B3], T3[B3 - 1]);
                      for (; B3 < 4 * R3; ++B3) T3[B3] = 0;
                      E3.K[0] = null, E3.K[0] = T3, F3 = 1;
                    }
                  }
                  _3 = F3;
                  break;
                case 2:
                  break;
                default:
                  e2(0);
              }
              u4 = _3;
            }
          }
          if (f4 = f4[0], p4 = p4[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
            s3.a = 3;
            break t;
          }
          var H3;
          if (H3 = u4) e: {
            var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p4, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Qn[K3];
            r: for (; ; ) {
              if (Z3 && y3($3, 1)) {
                var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                if (!It2(at3, ot3, 0, Y3, tt3)) break r;
                for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                  var ct3 = tt3[W3] >> 8 & 65535;
                  tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);
                }
              }
              if ($3.h) break r;
              for (V3 = 0; 5 > V3; ++V3) {
                var ut3 = Xn[V3];
                !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
              }
              var ht3 = o2(et3 * nt3, l3), lt3 = et3, ft3 = o2(lt3, d3);
              if (null == ft3) var dt3 = null;
              else e2(65536 >= lt3), dt3 = ft3;
              var pt3 = a2(rt3);
              if (null == dt3 || null == pt3 || null == ht3) {
                Y3.a = 1;
                break r;
              }
              var gt3 = ht3;
              for (W3 = G3 = 0; W3 < et3; ++W3) {
                var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                for (V3 = 0; 5 > V3; ++V3) {
                  ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                  n: {
                    var At3, xt3 = ut3, St3 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St3.m, Bt3 = y3(Ot3, 1);
                    if (i2(kt3, 0, 0, xt3), Bt3) {
                      var Mt3 = y3(Ot3, 1) + 1, Et3 = y3(Ot3, 1), qt3 = y3(Ot3, 0 == Et3 ? 1 : 8);
                      kt3[qt3] = 1, 2 == Mt3 && (kt3[qt3 = y3(Ot3, 8)] = 1);
                      var Dt3 = 1;
                    } else {
                      var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                      if (19 < Tt3) {
                        St3.a = 3;
                        var Ut3 = 0;
                        break n;
                      }
                      for (At3 = 0; At3 < Tt3; ++At3) Rt3[Zn[At3]] = y3(Ot3, 3);
                      var zt3 = void 0, Ht3 = void 0, Wt3 = St3, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);
                      i: for (; h3(Zt3, 0, 7, Vt3, 19); ) {
                        if (y3(Xt3, 1)) {
                          var $t3 = 2 + 2 * y3(Xt3, 3);
                          if ((zt3 = 2 + y3(Xt3, $t3)) > Gt3) break i;
                        } else zt3 = Gt3;
                        for (Ht3 = 0; Ht3 < Gt3 && zt3--; ) {
                          S2(Xt3);
                          var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                          x2(Xt3, Xt3.u + Qt3.g);
                          var te3 = Qt3.value;
                          if (16 > te3) Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                          else {
                            var ee3 = 16 == te3, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y3(Xt3, Yn[re3]) + ne3;
                            if (Ht3 + ie3 > Gt3) break i;
                            for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; ) Yt3[Ht3++] = ae3;
                          }
                        }
                        Jt3 = 1;
                        break i;
                      }
                      Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                    }
                    (Dt3 = Dt3 && !Ot3.h) && (jt3 = h3(Ft3, Ct3, 8, kt3, xt3)), Dt3 && 0 != jt3 ? Ut3 = jt3 : (St3.a = 3, Ut3 = 0);
                  }
                  if (0 == Ut3) break r;
                  if (Nt3 && 1 == Kn[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += Ut3, 3 >= V3) {
                    var oe3, se3 = pt3[0];
                    for (oe3 = 1; oe3 < ut3; ++oe3) pt3[oe3] > se3 && (se3 = pt3[oe3]);
                    Lt3 += se3;
                  }
                }
                if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                  var ce3, ue3 = mt3;
                  for (ce3 = 0; ce3 < Dr; ++ce3) {
                    var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                    256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                  }
                }
              }
              Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = ht3, H3 = 1;
              break e;
            }
            H3 = 0;
          }
          if (!(u4 = H3)) {
            s3.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
              s3.a = 1, u4 = 0;
              break t;
            }
          } else m4.ua = 0;
          var de3 = s3, pe3 = f4, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
          if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, n3) {
            s3.xb = pi;
            break t;
          }
          if (null == (v4 = a2(f4 * p4))) {
            s3.a = 1, u4 = 0;
            break t;
          }
          u4 = (u4 = _t2(s3, v4, 0, f4, p4, p4, null)) && !g4.h;
          break t;
        }
        return u4 ? (null != c4 ? c4[0] = v4 : (e2(null == v4), e2(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;
      }
      function Ft2(t5, r3) {
        var n3 = t5.c * t5.i, i3 = n3 + r3 + 16 * r3;
        return e2(t5.c <= r3), t5.V = a2(i3), null == t5.V ? (t5.Ta = null, t5.Ua = 0, t5.a = 1, 0) : (t5.Ta = t5.V, t5.Ua = t5.Ba + n3 + r3, 1);
      }
      function Ct2(t5, r3) {
        var n3 = t5.C, i3 = r3 - n3, a3 = t5.V, o3 = t5.Ba + t5.c * n3;
        for (e2(r3 <= t5.l.o); 0 < i3; ) {
          var s3 = 16 < i3 ? 16 : i3, c4 = t5.l.ma, u4 = t5.l.width, h4 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d4 = t5.Ta, p4 = t5.Ua;
          Nt2(t5, s3, a3, o3), _n(d4, p4, l4, f4, h4), xt2(c4, n3, n3 + s3, l4, f4, u4), i3 -= s3, a3 += s3 * t5.c, n3 += s3;
        }
        e2(n3 == r3), t5.C = t5.Ma = r3;
      }
      function jt2() {
        this.ub = this.yd = this.td = this.Rb = 0;
      }
      function Ot2() {
        this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
      }
      function Bt2() {
        this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
      }
      function Mt2() {
        this.Yb = (function() {
          var t5 = [];
          return (function t6(e3, r3, n3) {
            for (var i3 = n3[r3], a3 = 0; a3 < i3 && (e3.push(n3.length > r3 + 1 ? [] : 0), !(n3.length < r3 + 1)); a3++) t6(e3[a3], r3 + 1, n3);
          })(t5, 0, [3, 11]), t5;
        })();
      }
      function Et2() {
        this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
      }
      function qt2() {
        this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
      }
      function Dt2() {
        this.ld = this.La = this.dd = this.tc = 0;
      }
      function Rt2() {
        this.Na = this.la = 0;
      }
      function Tt2() {
        this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
      }
      function Ut2() {
        this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
      }
      function zt2() {
        this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new Ut2()), this.aa = 0, this.l = new Gt2();
      }
      function Ht2() {
        this.y = a2(16), this.f = a2(8), this.ea = a2(8);
      }
      function Wt2() {
        this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new zt2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
      }
      function Vt2(t5, e3) {
        return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
      }
      function Gt2() {
        this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
      }
      function Yt2() {
        var t5 = new Wt2();
        return null != t5 && (t5.a = 0, t5.sc = "OK", t5.cb = 0, t5.Xb = 0, ni || (ni = Zt2)), t5;
      }
      function Jt2(t5, e3, r3) {
        return 0 == t5.a && (t5.a = e3, t5.sc = r3, t5.cb = 0), 0;
      }
      function Xt2(t5, e3, r3) {
        return 3 <= r3 && 157 == t5[e3 + 0] && 1 == t5[e3 + 1] && 42 == t5[e3 + 2];
      }
      function Kt2(t5, r3) {
        if (null == t5) return 0;
        if (t5.a = 0, t5.sc = "OK", null == r3) return Jt2(t5, 2, "null VP8Io passed to VP8GetHeaders()");
        var n3 = r3.data, a3 = r3.w, o3 = r3.ha;
        if (4 > o3) return Jt2(t5, 7, "Truncated header.");
        var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t5.Od;
        if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td) return Jt2(t5, 3, "Incorrect keyframe parameters.");
        if (!c4.yd) return Jt2(t5, 4, "Frame not displayable.");
        a3 += 3, o3 -= 3;
        var u4 = t5.Kc;
        if (c4.Rb) {
          if (7 > o3) return Jt2(t5, 7, "cannot parse picture header");
          if (!Xt2(n3, a3, o3)) return Jt2(t5, 3, "Bad code word");
          u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t5.za = u4.c + 15 >> 4, t5.Ub = u4.i + 15 >> 4, r3.width = u4.c, r3.height = u4.i, r3.Da = 0, r3.j = 0, r3.v = 0, r3.va = r3.width, r3.o = r3.height, r3.da = 0, r3.ib = r3.width, r3.hb = r3.height, r3.U = r3.width, r3.T = r3.height, i2((s3 = t5.Pa).jb, 0, 255, s3.jb.length), e2(null != (s3 = t5.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
        }
        if (c4.ub > o3) return Jt2(t5, 7, "bad partition length");
        p3(s3 = t5.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t5.Qa;
        var h4, l4 = t5.Pa;
        if (e2(null != s3), e2(null != u4), u4.Cb = P2(s3), u4.Cb) {
          if (u4.Bb = P2(s3), P2(s3)) {
            for (u4.Fb = P2(s3), h4 = 0; 4 > h4; ++h4) u4.Zb[h4] = P2(s3) ? m3(s3, 7) : 0;
            for (h4 = 0; 4 > h4; ++h4) u4.Lb[h4] = P2(s3) ? m3(s3, 6) : 0;
          }
          if (u4.Bb) for (h4 = 0; 3 > h4; ++h4) l4.jb[h4] = P2(s3) ? g3(s3, 8) : 255;
        } else u4.Bb = 0;
        if (s3.Ka) return Jt2(t5, 3, "cannot parse segment header");
        if ((u4 = t5.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {
          for (l4 = 0; 4 > l4; ++l4) P2(s3) && (u4.vd[l4] = m3(s3, 6));
          for (l4 = 0; 4 > l4; ++l4) P2(s3) && (u4.od[l4] = m3(s3, 6));
        }
        if (t5.L = 0 == u4.Tb ? 0 : u4.zd ? 1 : 2, s3.Ka) return Jt2(t5, 3, "cannot parse filter header");
        var f4 = o3;
        if (o3 = h4 = a3, a3 = h4 + f4, u4 = f4, t5.Xb = (1 << g3(t5.m, 2)) - 1, f4 < 3 * (l4 = t5.Xb)) n3 = 7;
        else {
          for (h4 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {
            var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
            d4 > u4 && (d4 = u4), p3(t5.Jc[+f4], n3, h4, d4), h4 += d4, u4 -= d4, o3 += 3;
          }
          p3(t5.Jc[+l4], n3, h4, u4), n3 = h4 < a3 ? 0 : 5;
        }
        if (0 != n3) return Jt2(t5, n3, "cannot parse partitions");
        for (n3 = g3(h4 = t5.m, 7), o3 = P2(h4) ? m3(h4, 4) : 0, a3 = P2(h4) ? m3(h4, 4) : 0, u4 = P2(h4) ? m3(h4, 4) : 0, l4 = P2(h4) ? m3(h4, 4) : 0, h4 = P2(h4) ? m3(h4, 4) : 0, f4 = t5.Qa, d4 = 0; 4 > d4; ++d4) {
          if (f4.Cb) {
            var v4 = f4.Zb[d4];
            f4.Fb || (v4 += n3);
          } else {
            if (0 < d4) {
              t5.pb[d4] = t5.pb[0];
              continue;
            }
            v4 = n3;
          }
          var b4 = t5.pb[d4];
          b4.Sc[0] = ei[Vt2(v4 + o3, 127)], b4.Sc[1] = ri[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ri[Vt2(v4 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v4 + l4, 117)], b4.Qc[1] = ri[Vt2(v4 + h4, 127)], b4.lc = v4 + h4;
        }
        if (!c4.Rb) return Jt2(t5, 4, "Not a key frame.");
        for (P2(s3), c4 = t5.Pa, n3 = 0; 4 > n3; ++n3) {
          for (o3 = 0; 8 > o3; ++o3) for (a3 = 0; 3 > a3; ++a3) for (u4 = 0; 11 > u4; ++u4) l4 = k2(s3, ui[n3][o3][a3][u4]) ? g3(s3, 8) : si[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;
          for (o3 = 0; 17 > o3; ++o3) c4.Xc[n3][o3] = c4.Wc[n3][hi[o3]];
        }
        return t5.kc = P2(s3), t5.kc && (t5.Bd = g3(s3, 8)), t5.cb = 1;
      }
      function Zt2(t5, e3, r3, n3, i3, a3, o3) {
        var s3 = e3[i3].Yb[r3];
        for (r3 = 0; 16 > i3; ++i3) {
          if (!k2(t5, s3[r3 + 0])) return i3;
          for (; !k2(t5, s3[r3 + 1]); ) if (s3 = e3[++i3].Yb[0], r3 = 0, 16 == i3) return 16;
          var c4 = e3[i3 + 1].Yb;
          if (k2(t5, s3[r3 + 2])) {
            var u4 = t5, h4 = 0;
            if (k2(u4, (f4 = s3)[(l4 = r3) + 3])) {
              if (k2(u4, f4[l4 + 6])) {
                for (s3 = 0, l4 = 2 * (h4 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h4])), h4 = 0, f4 = ii[l4]; f4[s3]; ++s3) h4 += h4 + k2(u4, f4[s3]);
                h4 += 3 + (8 << l4);
              } else k2(u4, f4[l4 + 7]) ? (h4 = 7 + 2 * k2(u4, 165), h4 += k2(u4, 145)) : h4 = 5 + k2(u4, 159);
            } else h4 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;
            s3 = c4[2];
          } else h4 = 1, s3 = c4[1];
          c4 = o3 + ai[i3], 0 > (u4 = t5).b && _2(u4);
          var l4, f4 = u4.b, d4 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;
          --u4.b, u4.Ca += d4, u4.Ca |= 1, u4.I -= (l4 + 1 & d4) << f4, a3[c4] = ((h4 ^ d4) - d4) * n3[(0 < i3) + 0];
        }
        return 16;
      }
      function $t2(t5) {
        var e3 = t5.rb[t5.sb - 1];
        e3.la = 0, e3.Na = 0, i2(t5.zc, 0, 0, t5.zc.length), t5.ja = 0;
      }
      function Qt2(t5, r3) {
        if (null == t5) return 0;
        if (null == r3) return Jt2(t5, 2, "NULL VP8Io parameter in VP8Decode().");
        if (!t5.cb && !Kt2(t5, r3)) return 0;
        if (e2(t5.cb), null == r3.ac || r3.ac(r3)) {
          r3.ob && (t5.L = 0);
          var s3 = Ri[t5.L];
          if (2 == t5.L ? (t5.yb = 0, t5.zb = 0) : (t5.yb = r3.v - s3 >> 4, t5.zb = r3.j - s3 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = r3.o + 15 + s3 >> 4, t5.Hb = r3.va + 15 + s3 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {
            var c4 = t5.ed;
            for (s3 = 0; 4 > s3; ++s3) {
              var u4;
              if (t5.Qa.Cb) {
                var h4 = t5.Qa.Lb[s3];
                t5.Qa.Fb || (h4 += c4.Tb);
              } else h4 = c4.Tb;
              for (u4 = 0; 1 >= u4; ++u4) {
                var l4 = t5.gd[s3][u4], f4 = h4;
                if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {
                  var d4 = f4;
                  0 < c4.wb && (d4 = 4 < c4.wb ? d4 >> 2 : d4 >> 1) > 9 - c4.wb && (d4 = 9 - c4.wb), 1 > d4 && (d4 = 1), l4.dd = d4, l4.tc = 2 * f4 + d4, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;
                } else l4.tc = 0;
                l4.La = u4;
              }
            }
          }
          s3 = 0;
        } else Jt2(t5, 6, "Frame setup failed"), s3 = t5.a;
        if (s3 = 0 == s3) {
          if (s3) {
            t5.$c = 0, 0 < t5.Aa || (t5.Ic = Ui);
            t: {
              s3 = t5.Ic;
              c4 = 4 * (d4 = t5.za);
              var p4 = 32 * d4, g4 = d4 + 1, m4 = 0 < t5.L ? d4 * (0 < t5.Aa ? 2 : 1) : 0, v4 = (2 == t5.Aa ? 2 : 1) * d4;
              if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri[t5.L]) / 2 * p4) + (h4 = null != t5.Fa && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != l4) s3 = 0;
              else {
                if (l4 > t5.Vb) {
                  if (t5.Vb = 0, t5.Ec = a2(l4), t5.Fc = 0, null == t5.Ec) {
                    s3 = Jt2(t5, 1, "no memory during frame initialization.");
                    break t;
                  }
                  t5.Vb = l4;
                }
                l4 = t5.Ec, f4 = t5.Fc, t5.Ac = l4, t5.Bc = f4, f4 += c4, t5.Gd = o2(p4, Ht2), t5.Hd = 0, t5.rb = o2(g4 + 1, Rt2), t5.sb = 1, t5.wa = m4 ? o2(m4, Dt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d4), e2(true), t5.oc = l4, t5.pc = f4, f4 += 832, t5.ya = o2(v4, Ut2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, 2 == t5.Aa && (t5.D.aa += d4), t5.R = 16 * d4, t5.B = 8 * d4, d4 = (p4 = Ri[t5.L]) * t5.R, p4 = p4 / 2 * t5.B, t5.sa = l4, t5.ta = f4 + d4, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s3 * t5.R + p4, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s3 * t5.B + p4, t5.$c = 0, f4 += u4, t5.mb = h4 ? l4 : null, t5.nb = h4 ? f4 : null, e2(f4 + h4 <= t5.Fc + t5.Vb), $t2(t5), i2(t5.Ac, t5.Bc, 0, c4), s3 = 1;
              }
            }
            if (s3) {
              if (r3.ka = 0, r3.y = t5.sa, r3.O = t5.ta, r3.f = t5.qa, r3.N = t5.ra, r3.ea = t5.Ha, r3.Vd = t5.Ia, r3.fa = t5.R, r3.Rc = t5.B, r3.F = null, r3.J = 0, !Cn) {
                for (s3 = -255; 255 >= s3; ++s3) Pn[255 + s3] = 0 > s3 ? -s3 : s3;
                for (s3 = -1020; 1020 >= s3; ++s3) kn[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;
                for (s3 = -112; 112 >= s3; ++s3) In[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;
                for (s3 = -255; 510 >= s3; ++s3) Fn[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;
                Cn = 1;
              }
              an = ue2, on = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = ze, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s3 = 1;
            } else s3 = 0;
          }
          s3 && (s3 = (function(t6, r4) {
            for (t6.M = 0; t6.M < t6.Va; ++t6.M) {
              var o3, s4 = t6.Jc[t6.M & t6.Xb], c5 = t6.m, u5 = t6;
              for (o3 = 0; o3 < u5.za; ++o3) {
                var h5 = c5, l5 = u5, f5 = l5.Ac, d5 = l5.Bc + 4 * o3, p5 = l5.zc, g5 = l5.ya[l5.aa + o3];
                if (l5.Qa.Bb ? g5.$b = k2(h5, l5.Pa.jb[0]) ? 2 + k2(h5, l5.Pa.jb[2]) : k2(h5, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h5, l5.Bd)), g5.Za = !k2(h5, 145) + 0, g5.Za) {
                  var m5 = g5.Ob, v5 = 0;
                  for (l5 = 0; 4 > l5; ++l5) {
                    var b4, y4 = p5[0 + l5];
                    for (b4 = 0; 4 > b4; ++b4) {
                      y4 = ci[f5[d5 + b4]][y4];
                      for (var w4 = oi[k2(h5, y4[0])]; 0 < w4; ) w4 = oi[2 * w4 + k2(h5, y4[w4])];
                      y4 = -w4, f5[d5 + b4] = y4;
                    }
                    n2(m5, v5, f5, d5, 4), v5 += 4, p5[0 + l5] = y4;
                  }
                } else y4 = k2(h5, 156) ? k2(h5, 128) ? 1 : 3 : k2(h5, 163) ? 2 : 0, g5.Ob[0] = y4, i2(f5, d5, y4, 4), i2(p5, 0, y4, 4);
                g5.Dd = k2(h5, 142) ? k2(h5, 114) ? k2(h5, 183) ? 1 : 3 : 2 : 0;
              }
              if (u5.m.Ka) return Jt2(t6, 7, "Premature end-of-partition0 encountered.");
              for (; t6.ja < t6.za; ++t6.ja) {
                if (u5 = s4, h5 = (c5 = t6).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d5 = c5.kc ? o3.Ad : 0) h5.la = f5.la = 0, o3.Za || (h5.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
                else {
                  var N4, L4;
                  h5 = f5, f5 = u5, d5 = c5.Pa.Xc, p5 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p5.$b];
                  if (l5 = p5.ad, m5 = 0, v5 = c5.rb[c5.sb - 1], y4 = b4 = 0, i2(l5, m5, 0, 384), p5.Za) var A4 = 0, x3 = d5[3];
                  else {
                    w4 = a2(16);
                    var S3 = h5.Na + v5.Na;
                    if (S3 = ni(f5, d5[1], S3, g5.Eb, 0, w4, 0), h5.Na = v5.Na = (0 < S3) + 0, 1 < S3) an(w4, 0, l5, m5);
                    else {
                      var _3 = w4[0] + 3 >> 3;
                      for (w4 = 0; 256 > w4; w4 += 16) l5[m5 + w4] = _3;
                    }
                    A4 = 1, x3 = d5[0];
                  }
                  var P3 = 15 & h5.la, I3 = 15 & v5.la;
                  for (w4 = 0; 4 > w4; ++w4) {
                    var F3 = 1 & I3;
                    for (_3 = L4 = 0; 4 > _3; ++_3) P3 = P3 >> 1 | (F3 = (S3 = ni(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                    P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                  }
                  for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                    for (L4 = 0, P3 = h5.la >> 4 + N4, I3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                      for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3) S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f5, d5[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                      P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                    }
                    y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;
                  }
                  h5.la = x3, v5.la = A4, p5.Hc = b4, p5.Gc = y4, p5.ia = 43690 & y4 ? 0 : g5.ia, d5 = !(b4 | y4);
                }
                if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d5), u5.Ka) return Jt2(t6, 7, "Premature end-of-file encountered.");
              }
              if ($t2(t6), c5 = r4, u5 = 1, o3 = (s4 = t6).D, h5 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, 0 == s4.Aa) t: {
                if (o3.M = s4.M, o3.uc = h5, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h5 = (y4 = Ri[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d5 = s4.sa, p5 = s4.ta - h5 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v5 = s4.Ia - f5 + _3, I3 = 0 == (P3 = L4.M), b4 = P3 >= s4.Va - 1, 2 == s4.Aa && Or(s4, L4), L4.uc) for (F3 = (S3 = s4).D.M, e2(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                  A4 = L4, x3 = F3;
                  var C3 = (j3 = (U3 = S3).D).Nb;
                  N4 = U3.R;
                  var j3 = j3.wa[j3.Y + A4], O3 = U3.sa, B3 = U3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                  if (0 != E3) if (e2(3 <= E3), 1 == U3.L) 0 < A4 && wn(O3, B3, N4, E3 + 4), j3.La && Ln(O3, B3, N4, E3), 0 < x3 && yn(O3, B3, N4, E3 + 4), j3.La && Nn(O3, B3, N4, E3);
                  else {
                    var q3 = U3.B, D3 = U3.qa, R3 = U3.ra + 8 * C3 * q3 + 8 * A4, T3 = U3.Ha, U3 = U3.Ia + 8 * C3 * q3 + 8 * A4;
                    C3 = j3.ld;
                    0 < A4 && (fn(O3, B3, N4, E3 + 4, M3, C3), pn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (mn(O3, B3, N4, E3, M3, C3), bn(D3, R3, T3, U3, q3, E3, M3, C3)), 0 < x3 && (ln2(O3, B3, N4, E3 + 4, M3, C3), dn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (gn(O3, B3, N4, E3, M3, C3), vn(D3, R3, T3, U3, q3, E3, M3, C3));
                  }
                }
                if (s4.ia && alert("todo:DitherRow"), null != c5.put) {
                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d5, c5.O = p5, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v5), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, null != s4.Fa && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, null == c5.F && 0 == c5.F.length)) {
                    u5 = Jt2(s4, 3, "Could not decode alpha data.");
                    break t;
                  }
                  L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e2(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), null != c5.F && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, null != c5.F && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));
                }
                o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h5, d5, p5 + 16 * s4.R, h5), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v5 + 8 * s4.B, f5));
              }
              if (!u5) return Jt2(t6, 6, "Output aborted.");
            }
            return 1;
          })(t5, r3)), null != r3.bc && r3.bc(r3), s3 &= 1;
        }
        return s3 ? (t5.cb = 0, s3) : 0;
      }
      function te2(t5, e3, r3, n3, i3) {
        i3 = t5[e3 + r3 + 32 * n3] + (i3 >> 3), t5[e3 + r3 + 32 * n3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
      }
      function ee2(t5, e3, r3, n3, i3, a3) {
        te2(t5, e3, 0, r3, n3 + i3), te2(t5, e3, 1, r3, n3 + a3), te2(t5, e3, 2, r3, n3 - a3), te2(t5, e3, 3, r3, n3 - i3);
      }
      function re2(t5) {
        return (20091 * t5 >> 16) + t5;
      }
      function ne2(t5, e3, r3, n3) {
        var i3, o3 = 0, s3 = a2(16);
        for (i3 = 0; 4 > i3; ++i3) {
          var c4 = t5[e3 + 0] + t5[e3 + 8], u4 = t5[e3 + 0] - t5[e3 + 8], h4 = (35468 * t5[e3 + 4] >> 16) - re2(t5[e3 + 12]), l4 = re2(t5[e3 + 4]) + (35468 * t5[e3 + 12] >> 16);
          s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h4, s3[o3 + 2] = u4 - h4, s3[o3 + 3] = c4 - l4, o3 += 4, e3++;
        }
        for (i3 = o3 = 0; 4 > i3; ++i3) c4 = (t5 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t5 - s3[o3 + 8], h4 = (35468 * s3[o3 + 4] >> 16) - re2(s3[o3 + 12]), te2(r3, n3, 0, 0, c4 + (l4 = re2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r3, n3, 1, 0, u4 + h4), te2(r3, n3, 2, 0, u4 - h4), te2(r3, n3, 3, 0, c4 - l4), o3++, n3 += 32;
      }
      function ie2(t5, e3, r3, n3) {
        var i3 = t5[e3 + 0] + 4, a3 = 35468 * t5[e3 + 4] >> 16, o3 = re2(t5[e3 + 4]), s3 = 35468 * t5[e3 + 1] >> 16;
        ee2(r3, n3, 0, i3 + o3, t5 = re2(t5[e3 + 1]), s3), ee2(r3, n3, 1, i3 + a3, t5, s3), ee2(r3, n3, 2, i3 - a3, t5, s3), ee2(r3, n3, 3, i3 - o3, t5, s3);
      }
      function ae2(t5, e3, r3, n3, i3) {
        ne2(t5, e3, r3, n3), i3 && ne2(t5, e3 + 16, r3, n3 + 4);
      }
      function oe2(t5, e3, r3, n3) {
        on(t5, e3 + 0, r3, n3, 1), on(t5, e3 + 32, r3, n3 + 128, 1);
      }
      function se2(t5, e3, r3, n3) {
        var i3;
        for (t5 = t5[e3 + 0] + 4, i3 = 0; 4 > i3; ++i3) for (e3 = 0; 4 > e3; ++e3) te2(r3, n3, e3, i3, t5);
      }
      function ce2(t5, e3, r3, n3) {
        t5[e3 + 0] && un(t5, e3 + 0, r3, n3), t5[e3 + 16] && un(t5, e3 + 16, r3, n3 + 4), t5[e3 + 32] && un(t5, e3 + 32, r3, n3 + 128), t5[e3 + 48] && un(t5, e3 + 48, r3, n3 + 128 + 4);
      }
      function ue2(t5, e3, r3, n3) {
        var i3, o3 = a2(16);
        for (i3 = 0; 4 > i3; ++i3) {
          var s3 = t5[e3 + 0 + i3] + t5[e3 + 12 + i3], c4 = t5[e3 + 4 + i3] + t5[e3 + 8 + i3], u4 = t5[e3 + 4 + i3] - t5[e3 + 8 + i3], h4 = t5[e3 + 0 + i3] - t5[e3 + 12 + i3];
          o3[0 + i3] = s3 + c4, o3[8 + i3] = s3 - c4, o3[4 + i3] = h4 + u4, o3[12 + i3] = h4 - u4;
        }
        for (i3 = 0; 4 > i3; ++i3) s3 = (t5 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], c4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], u4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], h4 = t5 - o3[3 + 4 * i3], r3[n3 + 0] = s3 + c4 >> 3, r3[n3 + 16] = h4 + u4 >> 3, r3[n3 + 32] = s3 - c4 >> 3, r3[n3 + 48] = h4 - u4 >> 3, n3 += 64;
      }
      function he2(t5, e3, r3) {
        var n3, i3 = e3 - 32, a3 = Bn, o3 = 255 - t5[i3 - 1];
        for (n3 = 0; n3 < r3; ++n3) {
          var s3, c4 = a3, u4 = o3 + t5[e3 - 1];
          for (s3 = 0; s3 < r3; ++s3) t5[e3 + s3] = c4[u4 + t5[i3 + s3]];
          e3 += 32;
        }
      }
      function le2(t5, e3) {
        he2(t5, e3, 4);
      }
      function fe2(t5, e3) {
        he2(t5, e3, 8);
      }
      function de2(t5, e3) {
        he2(t5, e3, 16);
      }
      function pe2(t5, e3) {
        var r3;
        for (r3 = 0; 16 > r3; ++r3) n2(t5, e3 + 32 * r3, t5, e3 - 32, 16);
      }
      function ge2(t5, e3) {
        var r3;
        for (r3 = 16; 0 < r3; --r3) i2(t5, e3, t5[e3 - 1], 16), e3 += 32;
      }
      function me2(t5, e3, r3) {
        var n3;
        for (n3 = 0; 16 > n3; ++n3) i2(e3, r3 + 32 * n3, t5, 16);
      }
      function ve2(t5, e3) {
        var r3, n3 = 16;
        for (r3 = 0; 16 > r3; ++r3) n3 += t5[e3 - 1 + 32 * r3] + t5[e3 + r3 - 32];
        me2(n3 >> 5, t5, e3);
      }
      function be2(t5, e3) {
        var r3, n3 = 8;
        for (r3 = 0; 16 > r3; ++r3) n3 += t5[e3 - 1 + 32 * r3];
        me2(n3 >> 4, t5, e3);
      }
      function ye2(t5, e3) {
        var r3, n3 = 8;
        for (r3 = 0; 16 > r3; ++r3) n3 += t5[e3 + r3 - 32];
        me2(n3 >> 4, t5, e3);
      }
      function we2(t5, e3) {
        me2(128, t5, e3);
      }
      function Ne2(t5, e3, r3) {
        return t5 + 2 * e3 + r3 + 2 >> 2;
      }
      function Le2(t5, e3) {
        var r3, i3 = e3 - 32;
        i3 = new Uint8Array([Ne2(t5[i3 - 1], t5[i3 + 0], t5[i3 + 1]), Ne2(t5[i3 + 0], t5[i3 + 1], t5[i3 + 2]), Ne2(t5[i3 + 1], t5[i3 + 2], t5[i3 + 3]), Ne2(t5[i3 + 2], t5[i3 + 3], t5[i3 + 4])]);
        for (r3 = 0; 4 > r3; ++r3) n2(t5, e3 + 32 * r3, i3, 0, i3.length);
      }
      function Ae(t5, e3) {
        var r3 = t5[e3 - 1], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
        I2(t5, e3 + 0, 16843009 * Ne2(t5[e3 - 1 - 32], r3, n3)), I2(t5, e3 + 32, 16843009 * Ne2(r3, n3, i3)), I2(t5, e3 + 64, 16843009 * Ne2(n3, i3, a3)), I2(t5, e3 + 96, 16843009 * Ne2(i3, a3, a3));
      }
      function xe(t5, e3) {
        var r3, n3 = 4;
        for (r3 = 0; 4 > r3; ++r3) n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
        for (n3 >>= 3, r3 = 0; 4 > r3; ++r3) i2(t5, e3 + 32 * r3, n3, 4);
      }
      function Se(t5, e3) {
        var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];
        t5[e3 + 0 + 96] = Ne2(n3, i3, t5[e3 - 1 + 96]), t5[e3 + 1 + 96] = t5[e3 + 0 + 64] = Ne2(r3, n3, i3), t5[e3 + 2 + 96] = t5[e3 + 1 + 64] = t5[e3 + 0 + 32] = Ne2(a3, r3, n3), t5[e3 + 3 + 96] = t5[e3 + 2 + 64] = t5[e3 + 1 + 32] = t5[e3 + 0 + 0] = Ne2(o3, a3, r3), t5[e3 + 3 + 64] = t5[e3 + 2 + 32] = t5[e3 + 1 + 0] = Ne2(s3, o3, a3), t5[e3 + 3 + 32] = t5[e3 + 2 + 0] = Ne2(c4, s3, o3), t5[e3 + 3 + 0] = Ne2(u4, c4, s3);
      }
      function _e(t5, e3) {
        var r3 = t5[e3 + 1 - 32], n3 = t5[e3 + 2 - 32], i3 = t5[e3 + 3 - 32], a3 = t5[e3 + 4 - 32], o3 = t5[e3 + 5 - 32], s3 = t5[e3 + 6 - 32], c4 = t5[e3 + 7 - 32];
        t5[e3 + 0 + 0] = Ne2(t5[e3 + 0 - 32], r3, n3), t5[e3 + 1 + 0] = t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 2 + 0] = t5[e3 + 1 + 32] = t5[e3 + 0 + 64] = Ne2(n3, i3, a3), t5[e3 + 3 + 0] = t5[e3 + 2 + 32] = t5[e3 + 1 + 64] = t5[e3 + 0 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 64] = t5[e3 + 1 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = t5[e3 + 2 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, c4);
      }
      function Pe(t5, e3) {
        var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];
        t5[e3 + 0 + 0] = t5[e3 + 1 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 2 + 64] = o3 + s3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 3 + 64] = s3 + c4 + 1 >> 1, t5[e3 + 3 + 0] = c4 + u4 + 1 >> 1, t5[e3 + 0 + 96] = Ne2(i3, n3, r3), t5[e3 + 0 + 64] = Ne2(n3, r3, a3), t5[e3 + 0 + 32] = t5[e3 + 1 + 96] = Ne2(r3, a3, o3), t5[e3 + 1 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 2 + 32] = t5[e3 + 3 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 32] = Ne2(s3, c4, u4);
      }
      function ke(t5, e3) {
        var r3 = t5[e3 + 0 - 32], n3 = t5[e3 + 1 - 32], i3 = t5[e3 + 2 - 32], a3 = t5[e3 + 3 - 32], o3 = t5[e3 + 4 - 32], s3 = t5[e3 + 5 - 32], c4 = t5[e3 + 6 - 32], u4 = t5[e3 + 7 - 32];
        t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 0 + 64] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 1 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 3 + 0] = t5[e3 + 2 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 1 + 32] = t5[e3 + 0 + 96] = Ne2(n3, i3, a3), t5[e3 + 2 + 32] = t5[e3 + 1 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, u4);
      }
      function Ie(t5, e3) {
        var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
        t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 0 + 32] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 32] = t5[e3 + 0 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 1 + 0] = Ne2(r3, n3, i3), t5[e3 + 3 + 0] = t5[e3 + 1 + 32] = Ne2(n3, i3, a3), t5[e3 + 3 + 32] = t5[e3 + 1 + 64] = Ne2(i3, a3, a3), t5[e3 + 3 + 64] = t5[e3 + 2 + 64] = t5[e3 + 0 + 96] = t5[e3 + 1 + 96] = t5[e3 + 2 + 96] = t5[e3 + 3 + 96] = a3;
      }
      function Fe(t5, e3) {
        var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96], o3 = t5[e3 - 1 - 32], s3 = t5[e3 + 0 - 32], c4 = t5[e3 + 1 - 32], u4 = t5[e3 + 2 - 32];
        t5[e3 + 0 + 0] = t5[e3 + 2 + 32] = r3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = t5[e3 + 2 + 64] = n3 + r3 + 1 >> 1, t5[e3 + 0 + 64] = t5[e3 + 2 + 96] = i3 + n3 + 1 >> 1, t5[e3 + 0 + 96] = a3 + i3 + 1 >> 1, t5[e3 + 3 + 0] = Ne2(s3, c4, u4), t5[e3 + 2 + 0] = Ne2(o3, s3, c4), t5[e3 + 1 + 0] = t5[e3 + 3 + 32] = Ne2(r3, o3, s3), t5[e3 + 1 + 32] = t5[e3 + 3 + 64] = Ne2(n3, r3, o3), t5[e3 + 1 + 64] = t5[e3 + 3 + 96] = Ne2(i3, n3, r3), t5[e3 + 1 + 96] = Ne2(a3, i3, n3);
      }
      function Ce(t5, e3) {
        var r3;
        for (r3 = 0; 8 > r3; ++r3) n2(t5, e3 + 32 * r3, t5, e3 - 32, 8);
      }
      function je(t5, e3) {
        var r3;
        for (r3 = 0; 8 > r3; ++r3) i2(t5, e3, t5[e3 - 1], 8), e3 += 32;
      }
      function Oe(t5, e3, r3) {
        var n3;
        for (n3 = 0; 8 > n3; ++n3) i2(e3, r3 + 32 * n3, t5, 8);
      }
      function Be(t5, e3) {
        var r3, n3 = 8;
        for (r3 = 0; 8 > r3; ++r3) n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
        Oe(n3 >> 4, t5, e3);
      }
      function Me(t5, e3) {
        var r3, n3 = 4;
        for (r3 = 0; 8 > r3; ++r3) n3 += t5[e3 + r3 - 32];
        Oe(n3 >> 3, t5, e3);
      }
      function Ee(t5, e3) {
        var r3, n3 = 4;
        for (r3 = 0; 8 > r3; ++r3) n3 += t5[e3 - 1 + 32 * r3];
        Oe(n3 >> 3, t5, e3);
      }
      function qe(t5, e3) {
        Oe(128, t5, e3);
      }
      function De(t5, e3, r3) {
        var n3 = t5[e3 - r3], i3 = t5[e3 + 0], a3 = 3 * (i3 - n3) + jn[1020 + t5[e3 - 2 * r3] - t5[e3 + r3]], o3 = On[112 + (a3 + 4 >> 3)];
        t5[e3 - r3] = Bn[255 + n3 + On[112 + (a3 + 3 >> 3)]], t5[e3 + 0] = Bn[255 + i3 - o3];
      }
      function Re(t5, e3, r3, n3) {
        var i3 = t5[e3 + 0], a3 = t5[e3 + r3];
        return Mn[255 + t5[e3 - 2 * r3] - t5[e3 - r3]] > n3 || Mn[255 + a3 - i3] > n3;
      }
      function Te(t5, e3, r3, n3) {
        return 4 * Mn[255 + t5[e3 - r3] - t5[e3 + 0]] + Mn[255 + t5[e3 - 2 * r3] - t5[e3 + r3]] <= n3;
      }
      function Ue(t5, e3, r3, n3, i3) {
        var a3 = t5[e3 - 3 * r3], o3 = t5[e3 - 2 * r3], s3 = t5[e3 - r3], c4 = t5[e3 + 0], u4 = t5[e3 + r3], h4 = t5[e3 + 2 * r3], l4 = t5[e3 + 3 * r3];
        return 4 * Mn[255 + s3 - c4] + Mn[255 + o3 - u4] > n3 ? 0 : Mn[255 + t5[e3 - 4 * r3] - a3] <= i3 && Mn[255 + a3 - o3] <= i3 && Mn[255 + o3 - s3] <= i3 && Mn[255 + l4 - h4] <= i3 && Mn[255 + h4 - u4] <= i3 && Mn[255 + u4 - c4] <= i3;
      }
      function ze(t5, e3, r3, n3) {
        var i3 = 2 * n3 + 1;
        for (n3 = 0; 16 > n3; ++n3) Te(t5, e3 + n3, r3, i3) && De(t5, e3 + n3, r3);
      }
      function He(t5, e3, r3, n3) {
        var i3 = 2 * n3 + 1;
        for (n3 = 0; 16 > n3; ++n3) Te(t5, e3 + n3 * r3, 1, i3) && De(t5, e3 + n3 * r3, 1);
      }
      function We(t5, e3, r3, n3) {
        var i3;
        for (i3 = 3; 0 < i3; --i3) ze(t5, e3 += 4 * r3, r3, n3);
      }
      function Ve(t5, e3, r3, n3) {
        var i3;
        for (i3 = 3; 0 < i3; --i3) He(t5, e3 += 4, r3, n3);
      }
      function Ge(t5, e3, r3, n3, i3, a3, o3, s3) {
        for (a3 = 2 * a3 + 1; 0 < i3--; ) {
          if (Ue(t5, e3, r3, a3, o3)) if (Re(t5, e3, r3, s3)) De(t5, e3, r3);
          else {
            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - 2 * h4], f4 = c4[u4 - h4], d4 = c4[u4 + 0], p4 = c4[u4 + h4], g4 = c4[u4 + 2 * h4], m4 = 27 * (b4 = jn[1020 + 3 * (d4 - f4) + jn[1020 + l4 - p4]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            c4[u4 - 3 * h4] = Bn[255 + c4[u4 - 3 * h4] + b4], c4[u4 - 2 * h4] = Bn[255 + l4 + v4], c4[u4 - h4] = Bn[255 + f4 + m4], c4[u4 + 0] = Bn[255 + d4 - m4], c4[u4 + h4] = Bn[255 + p4 - v4], c4[u4 + 2 * h4] = Bn[255 + g4 - b4];
          }
          e3 += n3;
        }
      }
      function Ye(t5, e3, r3, n3, i3, a3, o3, s3) {
        for (a3 = 2 * a3 + 1; 0 < i3--; ) {
          if (Ue(t5, e3, r3, a3, o3)) if (Re(t5, e3, r3, s3)) De(t5, e3, r3);
          else {
            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - h4], f4 = c4[u4 + 0], d4 = c4[u4 + h4], p4 = On[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
            c4[u4 - 2 * h4] = Bn[255 + c4[u4 - 2 * h4] + m4], c4[u4 - h4] = Bn[255 + l4 + g4], c4[u4 + 0] = Bn[255 + f4 - p4], c4[u4 + h4] = Bn[255 + d4 - m4];
          }
          e3 += n3;
        }
      }
      function Je(t5, e3, r3, n3, i3, a3) {
        Ge(t5, e3, r3, 1, 16, n3, i3, a3);
      }
      function Xe(t5, e3, r3, n3, i3, a3) {
        Ge(t5, e3, 1, r3, 16, n3, i3, a3);
      }
      function Ke(t5, e3, r3, n3, i3, a3) {
        var o3;
        for (o3 = 3; 0 < o3; --o3) Ye(t5, e3 += 4 * r3, r3, 1, 16, n3, i3, a3);
      }
      function Ze(t5, e3, r3, n3, i3, a3) {
        var o3;
        for (o3 = 3; 0 < o3; --o3) Ye(t5, e3 += 4, 1, r3, 16, n3, i3, a3);
      }
      function $e(t5, e3, r3, n3, i3, a3, o3, s3) {
        Ge(t5, e3, i3, 1, 8, a3, o3, s3), Ge(r3, n3, i3, 1, 8, a3, o3, s3);
      }
      function Qe(t5, e3, r3, n3, i3, a3, o3, s3) {
        Ge(t5, e3, 1, i3, 8, a3, o3, s3), Ge(r3, n3, 1, i3, 8, a3, o3, s3);
      }
      function tr(t5, e3, r3, n3, i3, a3, o3, s3) {
        Ye(t5, e3 + 4 * i3, i3, 1, 8, a3, o3, s3), Ye(r3, n3 + 4 * i3, i3, 1, 8, a3, o3, s3);
      }
      function er(t5, e3, r3, n3, i3, a3, o3, s3) {
        Ye(t5, e3 + 4, 1, i3, 8, a3, o3, s3), Ye(r3, n3 + 4, 1, i3, 8, a3, o3, s3);
      }
      function rr() {
        this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
      }
      function nr() {
        this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
      }
      function ir() {
        this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
      }
      function ar() {
        this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l3();
      }
      function or() {
        this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;
      }
      function sr() {
        this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
      }
      function cr(t5, e3, r3, n3, i3, a3, o3) {
        for (t5 = null == t5 ? 0 : t5[e3 + 0], e3 = 0; e3 < o3; ++e3) i3[a3 + e3] = t5 + r3[n3 + e3] & 255, t5 = i3[a3 + e3];
      }
      function ur(t5, e3, r3, n3, i3, a3, o3) {
        var s3;
        if (null == t5) cr(null, null, r3, n3, i3, a3, o3);
        else for (s3 = 0; s3 < o3; ++s3) i3[a3 + s3] = t5[e3 + s3] + r3[n3 + s3] & 255;
      }
      function hr(t5, e3, r3, n3, i3, a3, o3) {
        if (null == t5) cr(null, null, r3, n3, i3, a3, o3);
        else {
          var s3, c4 = t5[e3 + 0], u4 = c4, h4 = c4;
          for (s3 = 0; s3 < o3; ++s3) u4 = h4 + (c4 = t5[e3 + s3]) - u4, h4 = r3[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i3[a3 + s3] = h4;
        }
      }
      function lr(t5, r3, i3, o3) {
        var s3 = r3.width, c4 = r3.o;
        if (e2(null != t5 && null != r3), 0 > i3 || 0 >= o3 || i3 + o3 > c4) return null;
        if (!t5.Cc) {
          if (null == t5.ga) {
            var u4;
            if (t5.ga = new sr(), (u4 = null == t5.ga) || (u4 = r3.width * r3.o, e2(0 == t5.Gb.length), t5.Gb = a2(u4), t5.Uc = 0, null == t5.Gb ? u4 = 0 : (t5.mb = t5.Gb, t5.nb = t5.Uc, t5.rc = null, u4 = 1), u4 = !u4), !u4) {
              u4 = t5.ga;
              var h4 = t5.Fa, l4 = t5.P, f4 = t5.qc, d4 = t5.mb, p4 = t5.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;
              if (e2(null != h4 && null != d4 && null != r3), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u4.ca = d4, u4.tb = p4, u4.c = r3.width, u4.i = r3.height, e2(0 < u4.c && 0 < u4.i), 1 >= f4) r3 = 0;
              else if (u4.$a = h4[l4 + 0] >> 0 & 3, u4.Z = h4[l4 + 0] >> 2 & 3, u4.Lc = h4[l4 + 0] >> 4 & 3, l4 = h4[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4) r3 = 0;
              else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r3.width, b4.height = r3.height, b4.Da = r3.Da, b4.v = r3.v, b4.va = r3.va, b4.j = r3.j, b4.o = r3.o, u4.$a) t: {
                e2(1 == u4.$a), r3 = kt2();
                e: for (; ; ) {
                  if (null == r3) {
                    r3 = 0;
                    break t;
                  }
                  if (e2(null != u4), u4.mc = r3, r3.c = u4.c, r3.i = u4.i, r3.l = u4.l, r3.l.ma = u4, r3.l.width = u4.c, r3.l.height = u4.i, r3.a = 0, v3(r3.m, h4, g4, m4), !It2(u4.c, u4.i, 1, r3, null)) break e;
                  if (1 == r3.ab && 3 == r3.gc[0].hc && At2(r3.s) ? (u4.ic = 1, h4 = r3.c * r3.i, r3.Ta = null, r3.Ua = 0, r3.V = a2(h4), r3.Ba = 0, null == r3.V ? (r3.a = 1, r3 = 0) : r3 = 1) : (u4.ic = 0, r3 = Ft2(r3, u4.c)), !r3) break e;
                  r3 = 1;
                  break t;
                }
                u4.mc = null, r3 = 0;
              }
              else r3 = m4 >= u4.c * u4.i;
              u4 = !r3;
            }
            if (u4) return null;
            1 != t5.ga.Lc ? t5.Ga = 0 : o3 = c4 - i3;
          }
          e2(null != t5.ga), e2(i3 + o3 <= c4);
          t: {
            if (r3 = (h4 = t5.ga).c, c4 = h4.l.o, 0 == h4.$a) {
              if (g4 = t5.rc, m4 = t5.Vc, b4 = t5.Fa, l4 = t5.P + 1 + i3 * r3, f4 = t5.mb, d4 = t5.nb + i3 * r3, e2(l4 <= t5.P + t5.qc), 0 != h4.Z) for (e2(null != mi[h4.Z]), u4 = 0; u4 < o3; ++u4) mi[h4.Z](g4, m4, b4, l4, f4, d4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;
              else for (u4 = 0; u4 < o3; ++u4) n2(f4, d4, b4, l4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;
              t5.rc = g4, t5.Vc = m4;
            } else {
              if (e2(null != h4.mc), r3 = i3 + o3, e2(null != (u4 = h4.mc)), e2(r3 <= u4.i), u4.C >= r3) r3 = 1;
              else if (h4.ic || mr(), h4.ic) {
                h4 = u4.V, g4 = u4.Ba, m4 = u4.c;
                var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d4 = u4.m, p4 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r3, x3 = p4.wc, _3 = w4 < L4 ? wt2(p4, f4, l4) : null;
                e2(w4 <= N4), e2(r3 <= y4), e2(At2(p4));
                e: for (; ; ) {
                  for (; !d4.h && w4 < L4; ) {
                    if (f4 & x3 || (_3 = wt2(p4, f4, l4)), e2(null != _3), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4))) h4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r3 && !(l4 % 16) && St2(u4, l4));
                    else {
                      if (!(280 > y4)) {
                        b4 = 0;
                        break e;
                      }
                      y4 = mt2(y4 - 256, d4);
                      var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                      if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0; P3 < y4; ++P3) h4[g4 + w4 + P3] = h4[g4 + w4 + P3 - k3];
                      for (w4 += y4, f4 += y4; f4 >= m4; ) f4 -= m4, ++l4 <= r3 && !(l4 % 16) && St2(u4, l4);
                      w4 < L4 && f4 & x3 && (_3 = wt2(p4, f4, l4));
                    }
                    e2(d4.h == A3(d4));
                  }
                  St2(u4, l4 > r3 ? r3 : l4);
                  break e;
                }
                !b4 || d4.h && w4 < N4 ? (b4 = 0, u4.a = d4.h ? 5 : 3) : u4.$ = w4, r3 = b4;
              } else r3 = _t2(u4, u4.V, u4.Ba, u4.c, u4.i, r3, Ct2);
              if (!r3) {
                o3 = 0;
                break t;
              }
            }
            i3 + o3 >= c4 && (t5.Cc = 1), o3 = 1;
          }
          if (!o3) return null;
          if (t5.Cc && (null != (o3 = t5.ga) && (o3.mc = null), t5.ga = null, 0 < t5.Ga)) return alert("todo:WebPDequantizeLevels"), null;
        }
        return t5.nb + i3 * s3;
      }
      function fr(t5, e3, r3, n3, i3, a3) {
        for (; 0 < i3--; ) {
          var o3, s3 = t5, c4 = e3 + (r3 ? 1 : 0), u4 = t5, h4 = e3 + (r3 ? 0 : 3);
          for (o3 = 0; o3 < n3; ++o3) {
            var l4 = u4[h4 + 4 * o3];
            255 != l4 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);
          }
          e3 += a3;
        }
      }
      function dr(t5, e3, r3, n3, i3) {
        for (; 0 < n3--; ) {
          var a3;
          for (a3 = 0; a3 < r3; ++a3) {
            var o3 = t5[e3 + 2 * a3 + 0], s3 = 15 & (u4 = t5[e3 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;
            t5[e3 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t5[e3 + 2 * a3 + 1] = 240 & u4 | s3;
          }
          e3 += i3;
        }
      }
      function pr(t5, e3, r3, n3, i3, a3, o3, s3) {
        var c4, u4, h4 = 255;
        for (u4 = 0; u4 < i3; ++u4) {
          for (c4 = 0; c4 < n3; ++c4) {
            var l4 = t5[e3 + c4];
            a3[o3 + 4 * c4] = l4, h4 &= l4;
          }
          e3 += r3, o3 += s3;
        }
        return 255 != h4;
      }
      function gr(t5, e3, r3, n3, i3) {
        var a3;
        for (a3 = 0; a3 < i3; ++a3) r3[n3 + a3] = t5[e3 + a3] >> 8;
      }
      function mr() {
        An = fr, xn = dr, Sn = pr, _n = gr;
      }
      function vr(r3, n3, i3) {
        t4[r3] = function(t5, r4, a3, o3, s3, c4, u4, h4, l4, f4, d4, p4, g4, m4, v4, b4, y4) {
          var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h4 + 0] << 16, A4 = l4[f4 + 0] | d4[p4 + 0] << 16;
          e2(null != t5);
          var x3 = 3 * L4 + A4 + 131074 >> 2;
          for (n3(t5[r4 + 0], 255 & x3, x3 >> 16, g4, m4), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
            var S3 = s3[c4 + w4] | u4[h4 + w4] << 16, _3 = l4[f4 + w4] | d4[p4 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
            x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t5[r4 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i3), n3(t5[r4 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), null != a3 && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v4, b4 + (2 * w4 - 1) * i3), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L4 = S3, A4 = _3;
          }
          1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t5[r4 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i3), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v4, b4 + (y4 - 1) * i3)));
        };
      }
      function br() {
        vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[Un] = Ai, vi[zn] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
      }
      function yr(t5) {
        return t5 & -16384 ? 0 > t5 ? 0 : 255 : t5 >> Ii;
      }
      function wr(t5, e3) {
        return yr((19077 * t5 >> 8) + (26149 * e3 >> 8) - 14234);
      }
      function Nr(t5, e3, r3) {
        return yr((19077 * t5 >> 8) - (6419 * e3 >> 8) - (13320 * r3 >> 8) + 8708);
      }
      function Lr(t5, e3) {
        return yr((19077 * t5 >> 8) + (33050 * e3 >> 8) - 17685);
      }
      function Ar(t5, e3, r3, n3, i3) {
        n3[i3 + 0] = wr(t5, r3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = Lr(t5, e3);
      }
      function xr(t5, e3, r3, n3, i3) {
        n3[i3 + 0] = Lr(t5, e3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = wr(t5, r3);
      }
      function Sr(t5, e3, r3, n3, i3) {
        var a3 = Nr(t5, e3, r3);
        e3 = a3 << 3 & 224 | Lr(t5, e3) >> 3, n3[i3 + 0] = 248 & wr(t5, r3) | a3 >> 5, n3[i3 + 1] = e3;
      }
      function _r(t5, e3, r3, n3, i3) {
        var a3 = 240 & Lr(t5, e3) | 15;
        n3[i3 + 0] = 240 & wr(t5, r3) | Nr(t5, e3, r3) >> 4, n3[i3 + 1] = a3;
      }
      function Pr(t5, e3, r3, n3, i3) {
        n3[i3 + 0] = 255, Ar(t5, e3, r3, n3, i3 + 1);
      }
      function kr(t5, e3, r3, n3, i3) {
        xr(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;
      }
      function Ir(t5, e3, r3, n3, i3) {
        Ar(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;
      }
      function Vt2(t5, e3) {
        return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
      }
      function Fr(e3, r3, n3) {
        t4[e3] = function(t5, e4, i3, a3, o3, s3, c4, u4, h4) {
          for (var l4 = u4 + (-2 & h4) * n3; u4 != l4; ) r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4), r3(t5[e4 + 1], i3[a3 + 0], o3[s3 + 0], c4, u4 + n3), e4 += 2, ++a3, ++s3, u4 += 2 * n3;
          1 & h4 && r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4);
        };
      }
      function Cr(t5, e3, r3) {
        return 0 == r3 ? 0 == t5 ? 0 == e3 ? 6 : 5 : 0 == e3 ? 4 : 0 : r3;
      }
      function jr(t5, e3, r3, n3, i3) {
        switch (t5 >>> 30) {
          case 3:
            on(e3, r3, n3, i3, 0);
            break;
          case 2:
            sn(e3, r3, n3, i3);
            break;
          case 1:
            un(e3, r3, n3, i3);
        }
      }
      function Or(t5, e3) {
        var r3, a3, o3 = e3.M, s3 = e3.Nb, c4 = t5.oc, u4 = t5.pc + 40, h4 = t5.oc, l4 = t5.pc + 584, f4 = t5.oc, d4 = t5.pc + 600;
        for (r3 = 0; 16 > r3; ++r3) c4[u4 + 32 * r3 - 1] = 129;
        for (r3 = 0; 8 > r3; ++r3) h4[l4 + 32 * r3 - 1] = 129, f4[d4 + 32 * r3 - 1] = 129;
        for (0 < o3 ? c4[u4 - 1 - 32] = h4[l4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i2(c4, u4 - 32 - 1, 127, 21), i2(h4, l4 - 32 - 1, 127, 9), i2(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t5.za; ++a3) {
          var p4 = e3.ya[e3.aa + a3];
          if (0 < a3) {
            for (r3 = -1; 16 > r3; ++r3) n2(c4, u4 + 32 * r3 - 4, c4, u4 + 32 * r3 + 12, 4);
            for (r3 = -1; 8 > r3; ++r3) n2(h4, l4 + 32 * r3 - 4, h4, l4 + 32 * r3 + 4, 4), n2(f4, d4 + 32 * r3 - 4, f4, d4 + 32 * r3 + 4, 4);
          }
          var g4 = t5.Gd, m4 = t5.Hd + a3, v4 = p4.ad, b4 = p4.Hc;
          if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h4, l4 - 32, g4[m4].f, 0, 8), n2(f4, d4 - 32, g4[m4].ea, 0, 8)), p4.Za) {
            var y4 = c4, w4 = u4 - 32 + 16;
            for (0 < o3 && (a3 >= t5.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r3 = 0; 4 > r3; r3++) y4[w4 + 128 + r3] = y4[w4 + 256 + r3] = y4[w4 + 384 + r3] = y4[w4 + 0 + r3];
            for (r3 = 0; 16 > r3; ++r3, b4 <<= 2) y4 = c4, w4 = u4 + Di[r3], fi[p4.Ob[r3]](y4, w4), jr(b4, v4, 16 * +r3, y4, w4);
          } else if (y4 = Cr(a3, o3, p4.Ob[0]), li[y4](c4, u4), 0 != b4) for (r3 = 0; 16 > r3; ++r3, b4 <<= 2) jr(b4, v4, 16 * +r3, c4, u4 + Di[r3]);
          for (r3 = p4.Gc, y4 = Cr(a3, o3, p4.Dd), di[y4](h4, l4), di[y4](f4, d4), b4 = v4, y4 = h4, w4 = l4, 255 & (p4 = r3 >> 0) && (170 & p4 ? cn(b4, 256, y4, w4) : hn(b4, 256, y4, w4)), p4 = f4, b4 = d4, 255 & (r3 >>= 8) && (170 & r3 ? cn(v4, 320, p4, b4) : hn(v4, 320, p4, b4)), o3 < t5.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h4, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d4 + 224, 8)), r3 = 8 * s3 * t5.B, g4 = t5.sa, m4 = t5.ta + 16 * a3 + 16 * s3 * t5.R, v4 = t5.qa, p4 = t5.ra + 8 * a3 + r3, b4 = t5.Ha, y4 = t5.Ia + 8 * a3 + r3, r3 = 0; 16 > r3; ++r3) n2(g4, m4 + r3 * t5.R, c4, u4 + 32 * r3, 16);
          for (r3 = 0; 8 > r3; ++r3) n2(v4, p4 + r3 * t5.B, h4, l4 + 32 * r3, 8), n2(b4, y4 + r3 * t5.B, f4, d4 + 32 * r3, 8);
        }
      }
      function Br(t5, n3, i3, a3, o3, s3, c4, u4, h4) {
        var l4 = [0], f4 = [0], d4 = 0, p4 = null != h4 ? h4.kd : 0, g4 = null != h4 ? h4 : new nr();
        if (null == t5 || 12 > i3) return 7;
        g4.data = t5, g4.w = n3, g4.ha = i3, n3 = [n3], i3 = [i3], g4.gb = [g4.gb];
        t: {
          var m4 = n3, b4 = i3, y4 = g4.gb;
          if (e2(null != t5), e2(null != b4), e2(null != y4), y4[0] = 0, 12 <= b4[0] && !r2(t5, m4[0], "RIFF")) {
            if (r2(t5, m4[0] + 8, "WEBP")) {
              y4 = 3;
              break t;
            }
            var w4 = j2(t5, m4[0] + 4);
            if (12 > w4 || 4294967286 < w4) {
              y4 = 3;
              break t;
            }
            if (p4 && w4 > b4[0] - 8) {
              y4 = 7;
              break t;
            }
            y4[0] = w4, m4[0] += 12, b4[0] -= 12;
          }
          y4 = 0;
        }
        if (0 != y4) return y4;
        for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
          t: {
            var L4 = t5;
            b4 = n3, y4 = i3;
            var A4 = l4, x3 = f4, S3 = m4 = [0];
            if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0]) y4 = 7;
            else {
              if (!r2(L4, b4[0], "VP8X")) {
                if (10 != j2(L4, b4[0] + 4)) {
                  y4 = 3;
                  break t;
                }
                if (18 > y4[0]) {
                  y4 = 7;
                  break t;
                }
                var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
                if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                  y4 = 3;
                  break t;
                }
                null != S3 && (S3[0] = _3), null != A4 && (A4[0] = P3), null != x3 && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
              }
              y4 = 0;
            }
          }
          if (d4 = d4[0], m4 = m4[0], 0 != y4) return y4;
          if (b4 = !!(2 & m4), !w4 && d4) return 3;
          if (null != s3 && (s3[0] = !!(16 & m4)), null != c4 && (c4[0] = b4), null != u4 && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d4 && b4 && null == h4) {
            y4 = 0;
            break;
          }
          if (4 > i3) {
            y4 = 7;
            break;
          }
          if (w4 && d4 || !w4 && !d4 && !r2(t5, n3[0], "ALPH")) {
            i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
            t: {
              _3 = t5, y4 = n3, w4 = i3;
              var k3 = g4.gb;
              A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
              P3 = 22, e2(null != _3), e2(null != w4), L4 = y4[0];
              var I3 = w4[0];
              for (e2(null != A4), e2(null != S3), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
                if (y4[0] = L4, w4[0] = I3, 8 > I3) {
                  y4 = 7;
                  break t;
                }
                var F3 = j2(_3, L4 + 4);
                if (4294967286 < F3) {
                  y4 = 3;
                  break t;
                }
                var O3 = 8 + F3 + 1 & -2;
                if (P3 += O3, 0 < k3 && P3 > k3) {
                  y4 = 3;
                  break t;
                }
                if (!r2(_3, L4, "VP8 ") || !r2(_3, L4, "VP8L")) {
                  y4 = 0;
                  break t;
                }
                if (I3[0] < O3) {
                  y4 = 7;
                  break t;
                }
                r2(_3, L4, "ALPH") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;
              }
            }
            if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y4) break;
          }
          i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
          t: if (k3 = t5, y4 = n3, w4 = i3, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r2(k3, _3, "VP8 "), P3 = !r2(k3, _3, "VP8L"), e2(null != k3), e2(null != w4), e2(null != x3), e2(null != S3), 8 > w4[0]) y4 = 7;
          else {
            if (L4 || P3) {
              if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {
                y4 = 3;
                break t;
              }
              if (p4 && k3 > w4[0] - 8) {
                y4 = 7;
                break t;
              }
              x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else S3[0] = 5 <= w4[0] && 47 == k3[_3 + 0] && !(k3[_3 + 4] >> 5), x3[0] = w4[0];
            y4 = 0;
          }
          if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], 0 != y4) break;
          if (4294967286 < g4.Ja) return 3;
          if (null == u4 || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
            if (5 > i3) {
              y4 = 7;
              break;
            }
            u4 = c4, p4 = m4, b4 = s3, null == t5 || 5 > i3 ? t5 = 0 : 5 <= i3 && 47 == t5[n3 + 0] && !(t5[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t5, n3, i3), gt2(x3, w4, k3, A4) ? (null != u4 && (u4[0] = w4[0]), null != p4 && (p4[0] = k3[0]), null != b4 && (b4[0] = A4[0]), t5 = 1) : t5 = 0) : t5 = 0;
          } else {
            if (10 > i3) {
              y4 = 7;
              break;
            }
            u4 = m4, null == t5 || 10 > i3 || !Xt2(t5, n3 + 3, i3 - 3) ? t5 = 0 : (p4 = t5[n3 + 0] | t5[n3 + 1] << 8 | t5[n3 + 2] << 16, b4 = 16383 & (t5[n3 + 7] << 8 | t5[n3 + 6]), t5 = 16383 & (t5[n3 + 9] << 8 | t5[n3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t5 ? t5 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t5), t5 = 1));
          }
          if (!t5) return 3;
          if (c4 = c4[0], m4 = m4[0], d4 && (l4[0] != c4 || f4[0] != m4)) return 3;
          null != h4 && (h4[0] = g4, h4.offset = n3 - h4.w, e2(4294967286 > n3 - h4.w), e2(h4.offset == h4.ha - i3));
          break;
        }
        return 0 == y4 || 7 == y4 && d4 && null == h4 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a3 && (a3[0] = c4), null != o3 && (o3[0] = m4), 0) : y4;
      }
      function Mr(t5, e3, r3) {
        var n3 = e3.width, i3 = e3.height, a3 = 0, o3 = 0, s3 = n3, c4 = i3;
        if (e3.Da = null != t5 && 0 < t5.Da, e3.Da && (s3 = t5.cd, c4 = t5.bd, a3 = t5.v, o3 = t5.j, 11 > r3 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i3)) return 0;
        if (e3.v = a3, e3.j = o3, e3.va = a3 + s3, e3.o = o3 + c4, e3.U = s3, e3.T = c4, e3.da = null != t5 && 0 < t5.da, e3.da) {
          if (!E2(s3, c4, r3 = [t5.ib], a3 = [t5.hb])) return 0;
          e3.ib = r3[0], e3.hb = a3[0];
        }
        return e3.ob = null != t5 && t5.ob, e3.Kb = null == t5 || !t5.Sd, e3.da && (e3.ob = e3.ib < 3 * n3 / 4 && e3.hb < 3 * i3 / 4, e3.Kb = 0), 1;
      }
      function Er(t5) {
        if (null == t5) return 2;
        if (11 > t5.S) {
          var e3 = t5.f.RGBA;
          e3.fb += (t5.height - 1) * e3.A, e3.A = -e3.A;
        } else e3 = t5.f.kb, t5 = t5.height, e3.O += (t5 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t5 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t5 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, null != e3.F && (e3.J += (t5 - 1) * e3.lb, e3.lb = -e3.lb);
        return 0;
      }
      function qr(t5, e3, r3, n3) {
        if (null == n3 || 0 >= t5 || 0 >= e3) return 2;
        if (null != r3) {
          if (r3.Da) {
            var i3 = r3.cd, o3 = r3.bd, s3 = -2 & r3.v, c4 = -2 & r3.j;
            if (0 > s3 || 0 > c4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t5 || c4 + o3 > e3) return 2;
            t5 = i3, e3 = o3;
          }
          if (r3.da) {
            if (!E2(t5, e3, i3 = [r3.ib], o3 = [r3.hb])) return 2;
            t5 = i3[0], e3 = o3[0];
          }
        }
        n3.width = t5, n3.height = e3;
        t: {
          var u4 = n3.width, h4 = n3.height;
          if (t5 = n3.S, 0 >= u4 || 0 >= h4 || !(t5 >= En && 13 > t5)) t5 = 2;
          else {
            if (0 >= n3.Rd && null == n3.sd) {
              s3 = o3 = i3 = e3 = 0;
              var l4 = (c4 = u4 * zi[t5]) * h4;
              if (11 > t5 || (o3 = (h4 + 1) / 2 * (e3 = (u4 + 1) / 2), 12 == t5 && (s3 = (i3 = u4) * h4)), null == (h4 = a2(l4 + 2 * o3 + s3))) {
                t5 = 1;
                break t;
              }
              n3.sd = h4, 11 > t5 ? ((u4 = n3.f.RGBA).eb = h4, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h4, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h4, u4.N = 0 + l4, u4.Ab = e3, u4.Cd = o3, u4.ea = h4, u4.W = 0 + l4 + o3, u4.Db = e3, u4.Ed = o3, 12 == t5 && (u4.F = h4, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i3);
            }
            if (e3 = 1, i3 = n3.S, o3 = n3.width, s3 = n3.height, i3 >= En && 13 > i3) {
              if (11 > i3) t5 = n3.f.RGBA, e3 &= (c4 = Math.abs(t5.A)) * (s3 - 1) + o3 <= t5.size, e3 &= c4 >= o3 * zi[i3], e3 &= null != t5.eb;
              else {
                t5 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t5.fa);
                h4 = Math.abs(t5.Ab);
                var f4 = Math.abs(t5.Db), d4 = Math.abs(t5.lb), p4 = d4 * (s3 - 1) + o3;
                e3 &= u4 * (s3 - 1) + o3 <= t5.Fd, e3 &= h4 * (l4 - 1) + c4 <= t5.Cd, e3 = (e3 &= f4 * (l4 - 1) + c4 <= t5.Ed) & u4 >= o3 & h4 >= c4 & f4 >= c4, e3 &= null != t5.y, e3 &= null != t5.f, e3 &= null != t5.ea, 12 == i3 && (e3 &= d4 >= o3, e3 &= p4 <= t5.Tc, e3 &= null != t5.F);
              }
            } else e3 = 0;
            t5 = e3 ? 0 : 2;
          }
        }
        return 0 != t5 || null != r3 && r3.fd && (t5 = Er(n3)), t5;
      }
      var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, Ur = 32, zr = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
      R2("Predictor0", "PredictorAdd0"), t4.Predictor0 = function() {
        return 4278190080;
      }, t4.Predictor1 = function(t5) {
        return t5;
      }, t4.Predictor2 = function(t5, e3, r3) {
        return e3[r3 + 0];
      }, t4.Predictor3 = function(t5, e3, r3) {
        return e3[r3 + 1];
      }, t4.Predictor4 = function(t5, e3, r3) {
        return e3[r3 - 1];
      }, t4.Predictor5 = function(t5, e3, r3) {
        return U2(U2(t5, e3[r3 + 1]), e3[r3 + 0]);
      }, t4.Predictor6 = function(t5, e3, r3) {
        return U2(t5, e3[r3 - 1]);
      }, t4.Predictor7 = function(t5, e3, r3) {
        return U2(t5, e3[r3 + 0]);
      }, t4.Predictor8 = function(t5, e3, r3) {
        return U2(e3[r3 - 1], e3[r3 + 0]);
      }, t4.Predictor9 = function(t5, e3, r3) {
        return U2(e3[r3 + 0], e3[r3 + 1]);
      }, t4.Predictor10 = function(t5, e3, r3) {
        return U2(U2(t5, e3[r3 - 1]), U2(e3[r3 + 0], e3[r3 + 1]));
      }, t4.Predictor11 = function(t5, e3, r3) {
        var n3 = e3[r3 + 0];
        return 0 >= W2(n3 >> 24 & 255, t5 >> 24 & 255, (e3 = e3[r3 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t5 >> 16 & 255, e3 >> 16 & 255) + W2(n3 >> 8 & 255, t5 >> 8 & 255, e3 >> 8 & 255) + W2(255 & n3, 255 & t5, 255 & e3) ? n3 : t5;
      }, t4.Predictor12 = function(t5, e3, r3) {
        var n3 = e3[r3 + 0];
        return (z2((t5 >> 24 & 255) + (n3 >> 24 & 255) - ((e3 = e3[r3 - 1]) >> 24 & 255)) << 24 | z2((t5 >> 16 & 255) + (n3 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | z2((t5 >> 8 & 255) + (n3 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | z2((255 & t5) + (255 & n3) - (255 & e3))) >>> 0;
      }, t4.Predictor13 = function(t5, e3, r3) {
        var n3 = e3[r3 - 1];
        return (H2((t5 = U2(t5, e3[r3 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H2(t5 >> 16 & 255, n3 >> 16 & 255) << 16 | H2(t5 >> 8 & 255, n3 >> 8 & 255) << 8 | H2(t5 >> 0 & 255, n3 >> 0 & 255)) >>> 0;
      };
      var Wr = t4.PredictorAdd0;
      t4.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
      var Vr = t4.PredictorAdd2;
      X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t5) {
        return t5 >> 8 & 255;
      }, function(t5) {
        return t5;
      }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t5) {
        return t5;
      }, function(t5) {
        return t5 >> 8 & 255;
      });
      var Gr, Yr = t4.ColorIndexInverseTransform, Jr = t4.MapARGB, Xr = t4.VP8LColorIndexInverseTransformAlpha, Kr = t4.MapAlpha, Zr = t4.VP8LPredictorsAdd = [];
      Zr.length = 16, (t4.VP8LPredictors = []).length = 16, (t4.VP8LPredictorsAdd_C = []).length = 16, (t4.VP8LPredictors_C = []).length = 16;
      var $r, Qr, tn, en, rn, nn, an, on, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a2(511), kn = a2(2041), In = a2(225), Fn = a2(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, Un = 5, zn = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
      vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
      var bi = t4.UpsampleRgbLinePair, yi = t4.UpsampleBgrLinePair, wi = t4.UpsampleRgbaLinePair, Ni = t4.UpsampleBgraLinePair, Li = t4.UpsampleArgbLinePair, Ai = t4.UpsampleRgba4444LinePair, xi = t4.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Ci = 0, ji = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(256), Ei = a2(ki - Pi), qi = a2(ki - Pi);
      Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
      var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ui = 1;
      this.WebPDecodeRGBA = function(t5, r3, n3, i3, a3) {
        var o3 = qn, s3 = new rr(), c4 = new ot2();
        s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];
        var u4 = c4.width, h4 = c4.height, l4 = new st2();
        if (null == l4 || null == t5) var f4 = 2;
        else e2(null != l4), f4 = Br(t5, r3, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);
        if (0 != f4 ? u4 = 0 : (null != u4 && (u4[0] = l4.width[0]), null != h4 && (h4[0] = l4.height[0]), u4 = 1), u4) {
          c4.width = c4.width[0], c4.height = c4.height[0], null != i3 && (i3[0] = c4.width), null != a3 && (a3[0] = c4.height);
          t: {
            if (i3 = new Gt2(), (a3 = new nr()).data = t5, a3.w = r3, a3.ha = n3, a3.kd = 1, r3 = [0], e2(null != a3), (0 == (t5 = Br(a3.data, a3.w, a3.ha, null, null, null, r3, null, a3)) || 7 == t5) && r3[0] && (t5 = 4), 0 == (r3 = t5)) {
              if (e2(null != s3), i3.data = a3.data, i3.w = a3.w + a3.offset, i3.ha = a3.ha - a3.offset, i3.put = dt2, i3.ac = ft2, i3.bc = pt2, i3.ma = s3, a3.xa) {
                if (null == (t5 = kt2())) {
                  s3 = 1;
                  break t;
                }
                if ((function(t6, r4) {
                  var n4 = [0], i4 = [0], a4 = [0];
                  e: for (; ; ) {
                    if (null == t6) return 0;
                    if (null == r4) return t6.a = 2, 0;
                    if (t6.l = r4, t6.a = 0, v3(t6.m, r4.data, r4.w, r4.ha), !gt2(t6.m, n4, i4, a4)) {
                      t6.a = 3;
                      break e;
                    }
                    if (t6.xb = gi, r4.width = n4[0], r4.height = i4[0], !It2(n4[0], i4[0], 1, t6, null)) break e;
                    return 1;
                  }
                  return e2(0 != t6.a), 0;
                })(t5, i3)) {
                  if (i3 = 0 == (r3 = qr(i3.width, i3.height, s3.Oa, s3.ba))) {
                    e: {
                      i3 = t5;
                      r: for (; ; ) {
                        if (null == i3) {
                          i3 = 0;
                          break e;
                        }
                        if (e2(null != i3.s.yc), e2(null != i3.s.Ya), e2(0 < i3.s.Wb), e2(null != (n3 = i3.l)), e2(null != (a3 = n3.ma)), 0 != i3.xb) {
                          if (i3.ca = a3.ba, i3.tb = a3.tb, e2(null != i3.ca), !Mr(a3.Oa, n3, Rn)) {
                            i3.a = 2;
                            break r;
                          }
                          if (!Ft2(i3, n3.width)) break r;
                          if (n3.da) break r;
                          if ((n3.da || nt2(i3.ca.S)) && mr(), 11 > i3.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != i3.ca.f.kb.F && mr()), i3.Pb && 0 < i3.s.ua && null == i3.s.vb.X && !O2(i3.s.vb, i3.s.Wa.Xa)) {
                            i3.a = 1;
                            break r;
                          }
                          i3.xb = 0;
                        }
                        if (!_t2(i3, i3.V, i3.Ba, i3.c, i3.i, n3.o, Lt2)) break r;
                        a3.Dc = i3.Ma, i3 = 1;
                        break e;
                      }
                      e2(0 != i3.a), i3 = 0;
                    }
                    i3 = !i3;
                  }
                  i3 && (r3 = t5.a);
                } else r3 = t5.a;
              } else {
                if (null == (t5 = new Yt2())) {
                  s3 = 1;
                  break t;
                }
                if (t5.Fa = a3.na, t5.P = a3.P, t5.qc = a3.Sa, Kt2(t5, i3)) {
                  if (0 == (r3 = qr(i3.width, i3.height, s3.Oa, s3.ba))) {
                    if (t5.Aa = 0, n3 = s3.Oa, e2(null != (a3 = t5)), null != n3) {
                      if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {
                        for (h4 = l4 = 0; 4 > h4; ++h4) 12 > (f4 = a3.pb[h4]).lc && (f4.ia = u4 * Ti[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;
                        l4 && (alert("todo:VP8InitRandom"), a3.ia = 1);
                      }
                      a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);
                    }
                    Qt2(t5, i3) || (r3 = t5.a);
                  }
                } else r3 = t5.a;
              }
              0 == r3 && null != s3.Oa && s3.Oa.fd && (r3 = Er(s3.ba));
            }
            s3 = r3;
          }
          o3 = 0 != s3 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;
        } else o3 = null;
        return o3;
      };
      var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
    };
    function u2(t4, e3) {
      for (var r3 = "", n3 = 0; n3 < 4; n3++) r3 += String.fromCharCode(t4[e3++]);
      return r3;
    }
    function h2(t4, e3) {
      return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16) >>> 0;
    }
    function l2(t4, e3) {
      return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24) >>> 0;
    }
    new c2();
    var f2 = [0], d2 = [0], p2 = [], g2 = new c2(), m2 = t3, v2 = (function(t4, e3) {
      var r3 = {}, n3 = 0, i3 = false, a3 = 0, o3 = 0;
      if (r3.frames = [], !/** @license
         * Copyright (c) 2017 Dominik Homberger
        Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        https://webpjs.appspot.com
        WebPRiffParser dominikhlbg@gmail.com
        */
      (function(t5, e4, r4, n4) {
        for (var i4 = 0; i4 < n4; i4++) if (t5[e4 + i4] != r4.charCodeAt(i4)) return true;
        return false;
      })(t4, e3, "RIFF", 4)) {
        for (l2(t4, e3 += 4), e3 += 8; e3 < t4.length; ) {
          var s3 = u2(t4, e3), c3 = l2(t4, e3 += 4);
          e3 += 4;
          var f3 = c3 + (1 & c3);
          switch (s3) {
            case "VP8 ":
            case "VP8L":
              void 0 === r3.frames[n3] && (r3.frames[n3] = {}), (g3 = r3.frames[n3]).src_off = i3 ? o3 : e3 - 8, g3.src_size = a3 + c3 + 8, n3++, i3 && (i3 = false, a3 = 0, o3 = 0);
              break;
            case "VP8X":
              (g3 = r3.header = {}).feature_flags = t4[e3];
              var d3 = e3 + 4;
              g3.canvas_width = 1 + h2(t4, d3), d3 += 3, g3.canvas_height = 1 + h2(t4, d3), d3 += 3;
              break;
            case "ALPH":
              i3 = true, a3 = f3 + 8, o3 = e3 - 8;
              break;
            case "ANIM":
              (g3 = r3.header).bgcolor = l2(t4, e3), d3 = e3 + 4, g3.loop_count = (m3 = t4)[(v3 = d3) + 0] << 0 | m3[v3 + 1] << 8, d3 += 2;
              break;
            case "ANMF":
              var p3, g3;
              (g3 = r3.frames[n3] = {}).offset_x = 2 * h2(t4, e3), e3 += 3, g3.offset_y = 2 * h2(t4, e3), e3 += 3, g3.width = 1 + h2(t4, e3), e3 += 3, g3.height = 1 + h2(t4, e3), e3 += 3, g3.duration = h2(t4, e3), e3 += 3, p3 = t4[e3++], g3.dispose = 1 & p3, g3.blend = p3 >> 1 & 1;
          }
          "ANMF" != s3 && (e3 += f3);
        }
        var m3, v3;
        return r3;
      }
    })(m2, 0);
    v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;
    var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;
    if (b2) {
      b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];
      for (var w2 = 0; w2 < y2.length && 0 != y2[w2].blend; w2++) ;
    }
    var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);
    N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];
    for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++) p2[A2] = L2[A2];
    return this.width = d2, this.height = f2, this.data = p2, this;
  }
  !(function(t3) {
    var r2 = function() {
      return "function" == typeof zlibSync;
    }, n2 = function(r3, n3, a3, h3) {
      var l3 = 4, f3 = s2;
      switch (h3) {
        case t3.image_compression.FAST:
          l3 = 1, f3 = o2;
          break;
        case t3.image_compression.MEDIUM:
          l3 = 6, f3 = c2;
          break;
        case t3.image_compression.SLOW:
          l3 = 9, f3 = u2;
      }
      r3 = i2(r3, n3, a3, f3);
      var d2 = zlibSync(r3, {
        level: l3
      });
      return t3.__addimage__.arrayBufferToBinaryString(d2);
    }, i2 = function(t4, e2, r3, n3) {
      for (var i3, a3, o3, s3 = t4.length / e2, c3 = new Uint8Array(t4.length + s3), u3 = l2(), h3 = 0; h3 < s3; h3 += 1) {
        if (o3 = h3 * e2, i3 = t4.subarray(o3, o3 + e2), n3) c3.set(n3(i3, r3, a3), o3 + h3);
        else {
          for (var d2, p2 = u3.length, g2 = []; d2 < p2; d2 += 1) g2[d2] = u3[d2](i3, r3, a3);
          var m2 = f2(g2.concat());
          c3.set(g2[m2], o3 + h3);
        }
        a3 = i3;
      }
      return c3;
    }, a2 = function(t4) {
      var e2 = Array.apply([], t4);
      return e2.unshift(0), e2;
    }, o2 = function(t4, e2) {
      var r3, n3 = [], i3 = t4.length;
      n3[0] = 1;
      for (var a3 = 0; a3 < i3; a3 += 1) r3 = t4[a3 - e2] || 0, n3[a3 + 1] = t4[a3] - r3 + 256 & 255;
      return n3;
    }, s2 = function(t4, e2, r3) {
      var n3, i3 = [], a3 = t4.length;
      i3[0] = 2;
      for (var o3 = 0; o3 < a3; o3 += 1) n3 = r3 && r3[o3] || 0, i3[o3 + 1] = t4[o3] - n3 + 256 & 255;
      return i3;
    }, c2 = function(t4, e2, r3) {
      var n3, i3, a3 = [], o3 = t4.length;
      a3[0] = 3;
      for (var s3 = 0; s3 < o3; s3 += 1) n3 = t4[s3 - e2] || 0, i3 = r3 && r3[s3] || 0, a3[s3 + 1] = t4[s3] + 256 - (n3 + i3 >>> 1) & 255;
      return a3;
    }, u2 = function(t4, e2, r3) {
      var n3, i3, a3, o3, s3 = [], c3 = t4.length;
      s3[0] = 4;
      for (var u3 = 0; u3 < c3; u3 += 1) n3 = t4[u3 - e2] || 0, i3 = r3 && r3[u3] || 0, a3 = r3 && r3[u3 - e2] || 0, o3 = h2(n3, i3, a3), s3[u3 + 1] = t4[u3] - o3 + 256 & 255;
      return s3;
    }, h2 = function(t4, e2, r3) {
      if (t4 === e2 && e2 === r3) return t4;
      var n3 = Math.abs(e2 - r3), i3 = Math.abs(t4 - r3), a3 = Math.abs(t4 + e2 - r3 - r3);
      return n3 <= i3 && n3 <= a3 ? t4 : i3 <= a3 ? e2 : r3;
    }, l2 = function() {
      return [a2, o2, s2, c2, u2];
    }, f2 = function(t4) {
      var e2 = t4.map(function(t5) {
        return t5.reduce(function(t6, e3) {
          return t6 + Math.abs(e3);
        }, 0);
      });
      return e2.indexOf(Math.min.apply(null, e2));
    };
    t3.processPNG = function(e2, i3, a3, o3) {
      var s3, c3, u3, h3, l3, f3, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = "";
      if (this.__addimage__.isArrayBuffer(e2) && (e2 = new Uint8Array(e2)), this.__addimage__.isArrayBufferView(e2)) {
        if (e2 = (u3 = new Kt(e2)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, -1 !== [4, 6].indexOf(u3.colorType)) {
          if (8 === u3.bits) {
            g2 = (p2 = 32 == u3.pixelBitlength ? new Uint32Array(u3.decodePixels().buffer) : 16 == u3.pixelBitlength ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);
            var x2, S2 = u3.pixelBitlength - u3.bits;
            for (w2 = 0, N2 = 0; w2 < g2; w2++) {
              for (y2 = p2[w2], x2 = 0; x2 < S2; ) v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;
              m2[w2] = y2 >>> x2 & 255;
            }
          }
          if (16 === u3.bits) {
            g2 = (p2 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;
            for (var _2 = 0; w2 < g2; ) y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;
            c3 = 8;
          }
          o3 !== t3.image_compression.NONE && r2() ? (e2 = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e2 = v2, d2 = m2, L2 = void 0);
        }
        if (3 === u3.colorType && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {
          var P2 = u3.transparency.indexed, k2 = 0;
          for (w2 = 0, g2 = P2.length; w2 < g2; ++w2) k2 += P2[w2];
          if ((k2 /= 255) === g2 - 1 && -1 !== P2.indexOf(0)) h3 = [P2.indexOf(0)];
          else if (k2 !== g2) {
            for (p2 = u3.decodePixels(), m2 = new Uint8Array(p2.length), w2 = 0, g2 = p2.length; w2 < g2; w2++) m2[w2] = P2[p2[w2]];
            d2 = n2(m2, u3.width, 1);
          }
        }
        var I2 = (function(e3) {
          var r3;
          switch (e3) {
            case t3.image_compression.FAST:
              r3 = 11;
              break;
            case t3.image_compression.MEDIUM:
              r3 = 13;
              break;
            case t3.image_compression.SLOW:
              r3 = 14;
              break;
            default:
              r3 = 12;
          }
          return r3;
        })(o3);
        return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l3 + " /BitsPerComponent " + c3 + " /Columns " + u3.width, (this.__addimage__.isArrayBuffer(e2) || this.__addimage__.isArrayBufferView(e2)) && (e2 = this.__addimage__.arrayBufferToBinaryString(e2)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), {
          alias: a3,
          data: e2,
          index: i3,
          filter: L2,
          decodeParameters: A2,
          transparency: h3,
          palette: f3,
          sMask: d2,
          predictor: I2,
          width: u3.width,
          height: u3.height,
          bitsPerComponent: c3,
          colorSpace: s3
        };
      }
    };
  })(E$1.API), (function(t3) {
    t3.processGIF89A = function(e2, r2, n2, i2) {
      var a2 = new Zt(e2), o2 = a2.width, s2 = a2.height, c2 = [];
      a2.decodeAndBlitFrameRGBA(0, c2);
      var u2 = {
        data: c2,
        width: o2,
        height: s2
      }, h2 = new Qt(100).encode(u2, 100);
      return t3.processJPEG.call(this, h2, r2, n2, i2);
    }, t3.processGIF87A = t3.processGIF89A;
  })(E$1.API), te.prototype.parseHeader = function() {
    if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
      var t3 = 0 === this.colors ? 1 << this.bitPP : this.colors;
      this.palette = new Array(t3);
      for (var e2 = 0; e2 < t3; e2++) {
        var r2 = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
        this.palette[e2] = {
          red: i2,
          green: n2,
          blue: r2,
          quad: a2
        };
      }
    }
    this.height < 0 && (this.height *= -1, this.bottom_up = false);
  }, te.prototype.parseBGR = function() {
    this.pos = this.offset;
    try {
      var t3 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
      this.data = new Uint8Array(e2), this[t3]();
    } catch (t4) {
      a$1.log("bit decode error:" + t4);
    }
  }, te.prototype.bit1 = function() {
    var t3, e2 = Math.ceil(this.width / 8), r2 = e2 % 4;
    for (t3 = this.height - 1; t3 >= 0; t3--) {
      for (var n2 = this.bottom_up ? t3 : this.height - 1 - t3, i2 = 0; i2 < e2; i2++) for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
        var c2 = this.palette[a2 >> 7 - s2 & 1];
        this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
      }
      0 !== r2 && (this.pos += 4 - r2);
    }
  }, te.prototype.bit4 = function() {
    for (var t3 = Math.ceil(this.width / 2), e2 = t3 % 4, r2 = this.height - 1; r2 >= 0; r2--) {
      for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < t3; i2++) {
        var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];
        if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width) break;
        u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;
      }
      0 !== e2 && (this.pos += 4 - e2);
    }
  }, te.prototype.bit8 = function() {
    for (var t3 = this.width % 4, e2 = this.height - 1; e2 >= 0; e2--) {
      for (var r2 = this.bottom_up ? e2 : this.height - 1 - e2, n2 = 0; n2 < this.width; n2++) {
        var i2 = this.datav.getUint8(this.pos++, true), a2 = r2 * this.width * 4 + 4 * n2;
        if (i2 < this.palette.length) {
          var o2 = this.palette[i2];
          this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
        } else this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
      }
      0 !== t3 && (this.pos += 4 - t3);
    }
  }, te.prototype.bit15 = function() {
    for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = this.height - 1; r2 >= 0; r2--) {
      for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < this.width; i2++) {
        var a2 = this.datav.getUint16(this.pos, true);
        this.pos += 2;
        var o2 = (a2 & e2) / e2 * 255 | 0, s2 = (a2 >> 5 & e2) / e2 * 255 | 0, c2 = (a2 >> 10 & e2) / e2 * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h2 = n2 * this.width * 4 + 4 * i2;
        this.data[h2] = c2, this.data[h2 + 1] = s2, this.data[h2 + 2] = o2, this.data[h2 + 3] = u2;
      }
      this.pos += t3;
    }
  }, te.prototype.bit16 = function() {
    for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
      for (var i2 = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {
        var o2 = this.datav.getUint16(this.pos, true);
        this.pos += 2;
        var s2 = (o2 & e2) / e2 * 255 | 0, c2 = (o2 >> 5 & r2) / r2 * 255 | 0, u2 = (o2 >> 11) / e2 * 255 | 0, h2 = i2 * this.width * 4 + 4 * a2;
        this.data[h2] = u2, this.data[h2 + 1] = c2, this.data[h2 + 2] = s2, this.data[h2 + 3] = 255;
      }
      this.pos += t3;
    }
  }, te.prototype.bit24 = function() {
    for (var t3 = this.height - 1; t3 >= 0; t3--) {
      for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
        var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e2 * this.width * 4 + 4 * r2;
        this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
      }
      this.pos += this.width % 4;
    }
  }, te.prototype.bit32 = function() {
    for (var t3 = this.height - 1; t3 >= 0; t3--) for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e2 * this.width * 4 + 4 * r2;
      this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
    }
  }, te.prototype.getData = function() {
    return this.data;
  }, /**
   * @license
   * Copyright (c) 2018 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    t3.processBMP = function(e2, r2, n2, i2) {
      var a2 = new te(e2, false), o2 = a2.width, s2 = a2.height, c2 = {
        data: a2.getData(),
        width: o2,
        height: s2
      }, u2 = new Qt(100).encode(c2, 100);
      return t3.processJPEG.call(this, u2, r2, n2, i2);
    };
  })(E$1.API), ee.prototype.getData = function() {
    return this.data;
  }, /**
   * @license
   * Copyright (c) 2019 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    t3.processWEBP = function(e2, r2, n2, i2) {
      var a2 = new ee(e2), o2 = a2.width, s2 = a2.height, c2 = {
        data: a2.getData(),
        width: o2,
        height: s2
      }, u2 = new Qt(100).encode(c2, 100);
      return t3.processJPEG.call(this, u2, r2, n2, i2);
    };
  })(E$1.API), E$1.API.processRGBA = function(t3, e2, r2) {
    for (var n2 = t3.data, i2 = n2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i2; u2 += 4) {
      var h2 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];
      a2[s2++] = h2, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;
    }
    var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
    return {
      alpha: this.__addimage__.arrayBufferToBinaryString(o2),
      data: p2,
      index: e2,
      alias: r2,
      colorSpace: "DeviceRGB",
      bitsPerComponent: 8,
      width: t3.width,
      height: t3.height
    };
  }, E$1.API.setLanguage = function(t3) {
    return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== {
      af: "Afrikaans",
      sq: "Albanian",
      ar: "Arabic (Standard)",
      "ar-DZ": "Arabic (Algeria)",
      "ar-BH": "Arabic (Bahrain)",
      "ar-EG": "Arabic (Egypt)",
      "ar-IQ": "Arabic (Iraq)",
      "ar-JO": "Arabic (Jordan)",
      "ar-KW": "Arabic (Kuwait)",
      "ar-LB": "Arabic (Lebanon)",
      "ar-LY": "Arabic (Libya)",
      "ar-MA": "Arabic (Morocco)",
      "ar-OM": "Arabic (Oman)",
      "ar-QA": "Arabic (Qatar)",
      "ar-SA": "Arabic (Saudi Arabia)",
      "ar-SY": "Arabic (Syria)",
      "ar-TN": "Arabic (Tunisia)",
      "ar-AE": "Arabic (U.A.E.)",
      "ar-YE": "Arabic (Yemen)",
      an: "Aragonese",
      hy: "Armenian",
      as: "Assamese",
      ast: "Asturian",
      az: "Azerbaijani",
      eu: "Basque",
      be: "Belarusian",
      bn: "Bengali",
      bs: "Bosnian",
      br: "Breton",
      bg: "Bulgarian",
      my: "Burmese",
      ca: "Catalan",
      ch: "Chamorro",
      ce: "Chechen",
      zh: "Chinese",
      "zh-HK": "Chinese (Hong Kong)",
      "zh-CN": "Chinese (PRC)",
      "zh-SG": "Chinese (Singapore)",
      "zh-TW": "Chinese (Taiwan)",
      cv: "Chuvash",
      co: "Corsican",
      cr: "Cree",
      hr: "Croatian",
      cs: "Czech",
      da: "Danish",
      nl: "Dutch (Standard)",
      "nl-BE": "Dutch (Belgian)",
      en: "English",
      "en-AU": "English (Australia)",
      "en-BZ": "English (Belize)",
      "en-CA": "English (Canada)",
      "en-IE": "English (Ireland)",
      "en-JM": "English (Jamaica)",
      "en-NZ": "English (New Zealand)",
      "en-PH": "English (Philippines)",
      "en-ZA": "English (South Africa)",
      "en-TT": "English (Trinidad & Tobago)",
      "en-GB": "English (United Kingdom)",
      "en-US": "English (United States)",
      "en-ZW": "English (Zimbabwe)",
      eo: "Esperanto",
      et: "Estonian",
      fo: "Faeroese",
      fj: "Fijian",
      fi: "Finnish",
      fr: "French (Standard)",
      "fr-BE": "French (Belgium)",
      "fr-CA": "French (Canada)",
      "fr-FR": "French (France)",
      "fr-LU": "French (Luxembourg)",
      "fr-MC": "French (Monaco)",
      "fr-CH": "French (Switzerland)",
      fy: "Frisian",
      fur: "Friulian",
      gd: "Gaelic (Scots)",
      "gd-IE": "Gaelic (Irish)",
      gl: "Galacian",
      ka: "Georgian",
      de: "German (Standard)",
      "de-AT": "German (Austria)",
      "de-DE": "German (Germany)",
      "de-LI": "German (Liechtenstein)",
      "de-LU": "German (Luxembourg)",
      "de-CH": "German (Switzerland)",
      el: "Greek",
      gu: "Gujurati",
      ht: "Haitian",
      he: "Hebrew",
      hi: "Hindi",
      hu: "Hungarian",
      is: "Icelandic",
      id: "Indonesian",
      iu: "Inuktitut",
      ga: "Irish",
      it: "Italian (Standard)",
      "it-CH": "Italian (Switzerland)",
      ja: "Japanese",
      kn: "Kannada",
      ks: "Kashmiri",
      kk: "Kazakh",
      km: "Khmer",
      ky: "Kirghiz",
      tlh: "Klingon",
      ko: "Korean",
      "ko-KP": "Korean (North Korea)",
      "ko-KR": "Korean (South Korea)",
      la: "Latin",
      lv: "Latvian",
      lt: "Lithuanian",
      lb: "Luxembourgish",
      mk: "North Macedonia",
      ms: "Malay",
      ml: "Malayalam",
      mt: "Maltese",
      mi: "Maori",
      mr: "Marathi",
      mo: "Moldavian",
      nv: "Navajo",
      ng: "Ndonga",
      ne: "Nepali",
      no: "Norwegian",
      nb: "Norwegian (Bokmal)",
      nn: "Norwegian (Nynorsk)",
      oc: "Occitan",
      or: "Oriya",
      om: "Oromo",
      fa: "Persian",
      "fa-IR": "Persian/Iran",
      pl: "Polish",
      pt: "Portuguese",
      "pt-BR": "Portuguese (Brazil)",
      pa: "Punjabi",
      "pa-IN": "Punjabi (India)",
      "pa-PK": "Punjabi (Pakistan)",
      qu: "Quechua",
      rm: "Rhaeto-Romanic",
      ro: "Romanian",
      "ro-MO": "Romanian (Moldavia)",
      ru: "Russian",
      "ru-MO": "Russian (Moldavia)",
      sz: "Sami (Lappish)",
      sg: "Sango",
      sa: "Sanskrit",
      sc: "Sardinian",
      sd: "Sindhi",
      si: "Singhalese",
      sr: "Serbian",
      sk: "Slovak",
      sl: "Slovenian",
      so: "Somani",
      sb: "Sorbian",
      es: "Spanish",
      "es-AR": "Spanish (Argentina)",
      "es-BO": "Spanish (Bolivia)",
      "es-CL": "Spanish (Chile)",
      "es-CO": "Spanish (Colombia)",
      "es-CR": "Spanish (Costa Rica)",
      "es-DO": "Spanish (Dominican Republic)",
      "es-EC": "Spanish (Ecuador)",
      "es-SV": "Spanish (El Salvador)",
      "es-GT": "Spanish (Guatemala)",
      "es-HN": "Spanish (Honduras)",
      "es-MX": "Spanish (Mexico)",
      "es-NI": "Spanish (Nicaragua)",
      "es-PA": "Spanish (Panama)",
      "es-PY": "Spanish (Paraguay)",
      "es-PE": "Spanish (Peru)",
      "es-PR": "Spanish (Puerto Rico)",
      "es-ES": "Spanish (Spain)",
      "es-UY": "Spanish (Uruguay)",
      "es-VE": "Spanish (Venezuela)",
      sx: "Sutu",
      sw: "Swahili",
      sv: "Swedish",
      "sv-FI": "Swedish (Finland)",
      "sv-SV": "Swedish (Sweden)",
      ta: "Tamil",
      tt: "Tatar",
      te: "Teluga",
      th: "Thai",
      tig: "Tigre",
      ts: "Tsonga",
      tn: "Tswana",
      tr: "Turkish",
      tk: "Turkmen",
      uk: "Ukrainian",
      hsb: "Upper Sorbian",
      ur: "Urdu",
      ve: "Venda",
      vi: "Vietnamese",
      vo: "Volapuk",
      wa: "Walloon",
      cy: "Welsh",
      xh: "Xhosa",
      ji: "Yiddish",
      zu: "Zulu"
    }[t3] && (this.internal.languageSettings.languageCode = t3, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
      this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
    }), this.internal.languageSettings.isSubscribed = true)), this;
  }, Vt$1 = E$1.API, Gt$1 = Vt$1.getCharWidthsArray = function(e2, r2) {
    var n2, i2, a2 = (r2 = r2 || {}).font || this.internal.getFont(), o2 = r2.fontSize || this.internal.getFontSize(), s2 = r2.charSpace || this.internal.getCharSpace(), c2 = r2.widths ? r2.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h2 = r2.kerning ? r2.kerning : a2.metadata.Unicode.kerning, l2 = h2.fof ? h2.fof : 1, f2 = false !== r2.doKerning, d2 = 0, p2 = e2.length, g2 = 0, m2 = c2[0] || u2, v2 = [];
    for (n2 = 0; n2 < p2; n2++) i2 = e2.charCodeAt(n2), "function" == typeof a2.metadata.widthOfString ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && "object" === _typeof$1(h2[i2]) && !isNaN(parseInt(h2[i2][g2], 10)) ? h2[i2][g2] / l2 : 0, v2.push((c2[i2] || m2) / u2 + d2)), g2 = i2;
    return v2;
  }, Yt$1 = Vt$1.getStringUnitWidth = function(t3, e2) {
    var r2 = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), n2 = e2.font || this.internal.getFont(), i2 = e2.charSpace || this.internal.getCharSpace();
    return Vt$1.processArabic && (t3 = Vt$1.processArabic(t3)), "function" == typeof n2.metadata.widthOfString ? n2.metadata.widthOfString(t3, r2, i2) / r2 : Gt$1.apply(this, arguments).reduce(function(t4, e3) {
      return t4 + e3;
    }, 0);
  }, Jt = function(t3, e2, r2, n2) {
    for (var i2 = [], a2 = 0, o2 = t3.length, s2 = 0; a2 !== o2 && s2 + e2[a2] < r2; ) s2 += e2[a2], a2++;
    i2.push(t3.slice(0, a2));
    var c2 = a2;
    for (s2 = 0; a2 !== o2; ) s2 + e2[a2] > n2 && (i2.push(t3.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e2[a2], a2++;
    return c2 !== a2 && i2.push(t3.slice(c2, a2)), i2;
  }, Xt = function(t3, e2, r2) {
    r2 || (r2 = {});
    var n2, i2, a2, o2, s2, c2, u2, h2 = [], l2 = [h2], f2 = r2.textIndent || 0, d2 = 0, p2 = 0, g2 = t3.split(" "), m2 = Gt$1.apply(this, [" ", r2])[0];
    if (c2 = -1 === r2.lineIndent ? g2[0].length + 2 : r2.lineIndent || 0) {
      var v2 = Array(c2).join(" "), b2 = [];
      g2.map(function(t4) {
        (t4 = t4.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t4.map(function(t5, e3) {
          return (e3 && t5.length ? "\n" : "") + t5;
        })) : b2.push(t4[0]);
      }), g2 = b2, c2 = Yt$1.apply(this, [v2, r2]);
    }
    for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
      var y2 = 0;
      if (n2 = g2[a2], c2 && "\n" == n2[0] && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p2 = (i2 = Gt$1.apply(this, [n2, r2])).reduce(function(t4, e3) {
        return t4 + e3;
      }, 0)) > e2 || y2) {
        if (p2 > e2) {
          for (s2 = Jt.apply(this, [n2, i2, e2 - (f2 + d2), e2]), h2.push(s2.shift()), h2 = [s2.pop()]; s2.length; ) l2.push([s2.shift()]);
          p2 = i2.slice(n2.length - (h2[0] ? h2[0].length : 0)).reduce(function(t4, e3) {
            return t4 + e3;
          }, 0);
        } else h2 = [n2];
        l2.push(h2), f2 = p2 + c2, d2 = m2;
      } else h2.push(n2), f2 += d2 + p2, d2 = m2;
    }
    return u2 = c2 ? function(t4, e3) {
      return (e3 ? v2 : "") + t4.join(" ");
    } : function(t4) {
      return t4.join(" ");
    }, l2.map(u2);
  }, Vt$1.splitTextToSize = function(t3, e2, r2) {
    var n2, i2 = (r2 = r2 || {}).fontSize || this.internal.getFontSize(), a2 = function(t4) {
      if (t4.widths && t4.kerning) return {
        widths: t4.widths,
        kerning: t4.kerning
      };
      var e3 = this.internal.getFont(t4.fontName, t4.fontStyle);
      return e3.metadata.Unicode ? {
        widths: e3.metadata.Unicode.widths || {
          0: 1
        },
        kerning: e3.metadata.Unicode.kerning || {}
      } : {
        font: e3.metadata,
        fontSize: this.internal.getFontSize(),
        charSpace: this.internal.getCharSpace()
      };
    }.call(this, r2);
    n2 = Array.isArray(t3) ? t3 : String(t3).split(/\r?\n/);
    var o2 = 1 * this.internal.scaleFactor * e2 / i2;
    a2.textIndent = r2.textIndent ? 1 * r2.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = r2.lineIndent;
    var s2, c2, u2 = [];
    for (s2 = 0, c2 = n2.length; s2 < c2; s2++) u2 = u2.concat(Xt.apply(this, [n2[s2], o2, a2]));
    return u2;
  }, (function(e2) {
    e2.__fontmetrics__ = e2.__fontmetrics__ || {};
    for (var r2 = "klmnopqrstuvwxyz", n2 = {}, i2 = {}, a2 = 0; a2 < r2.length; a2++) n2[r2[a2]] = "0123456789abcdef"[a2], i2["0123456789abcdef"[a2]] = r2[a2];
    var o2 = function(t3) {
      return "0x" + parseInt(t3, 10).toString(16);
    }, s2 = e2.__fontmetrics__.compress = function(e3) {
      var r3, n3, a3, c3, u3 = ["{"];
      for (var h3 in e3) {
        if (r3 = e3[h3], isNaN(parseInt(h3, 10)) ? n3 = "'" + h3 + "'" : (h3 = parseInt(h3, 10), n3 = (n3 = o2(h3).slice(2)).slice(0, -1) + i2[n3.slice(-1)]), "number" == typeof r3) r3 < 0 ? (a3 = o2(r3).slice(3), c3 = "-") : (a3 = o2(r3).slice(2), c3 = ""), a3 = c3 + a3.slice(0, -1) + i2[a3.slice(-1)];
        else {
          if ("object" !== _typeof$1(r3)) throw new Error("Don't know what to do with value type " + _typeof$1(r3) + ".");
          a3 = s2(r3);
        }
        u3.push(n3 + a3);
      }
      return u3.push("}"), u3.join("");
    }, c2 = e2.__fontmetrics__.uncompress = function(t3) {
      if ("string" != typeof t3) throw new Error("Invalid argument passed to uncompress.");
      for (var e3, r3, i3, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h3 = "", l3 = "", f2 = t3.length - 1, d2 = 1; d2 < f2; d2 += 1) "'" == (a3 = t3[d2]) ? e3 ? (i3 = e3.join(""), e3 = void 0) : e3 = [] : e3 ? e3.push(a3) : "{" == a3 ? (u3.push([c3, i3]), c3 = {}, i3 = void 0) : "}" == a3 ? ((r3 = u3.pop())[0][r3[1]] = c3, i3 = void 0, c3 = r3[0]) : "-" == a3 ? s3 = -1 : void 0 === i3 ? n2.hasOwnProperty(a3) ? (h3 += n2[a3], i3 = parseInt(h3, 16) * s3, s3 = 1, h3 = "") : h3 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i3] = parseInt(l3, 16) * s3, s3 = 1, i3 = void 0, l3 = "") : l3 += a3;
      return o3;
    }, u2 = {
      codePages: ["WinAnsiEncoding"],
      WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
    }, h2 = {
      Unicode: {
        Courier: u2,
        "Courier-Bold": u2,
        "Courier-BoldOblique": u2,
        "Courier-Oblique": u2,
        Helvetica: u2,
        "Helvetica-Bold": u2,
        "Helvetica-BoldOblique": u2,
        "Helvetica-Oblique": u2,
        "Times-Roman": u2,
        "Times-Bold": u2,
        "Times-BoldItalic": u2,
        "Times-Italic": u2
      }
    }, l2 = {
      Unicode: {
        "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
        "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
        "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
        Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
        "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
        "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
        Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),
        Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
        "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
        ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),
        "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
        "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
        "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
        "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
      }
    };
    e2.events.push(["addFont", function(t3) {
      var e3 = t3.font, r3 = l2.Unicode[e3.postScriptName];
      r3 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = r3.widths, e3.metadata.Unicode.kerning = r3.kerning);
      var n3 = h2.Unicode[e3.postScriptName];
      n3 && (e3.metadata.Unicode.encoding = n3, e3.encoding = n3.codePages[0]);
    }]);
  })(E$1.API), /**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    var e2 = function(t4) {
      for (var e3 = t4.length, r2 = new Uint8Array(e3), n2 = 0; n2 < e3; n2++) r2[n2] = t4.charCodeAt(n2);
      return r2;
    };
    t3.API.events.push(["addFont", function(r2) {
      var n2 = void 0, i2 = r2.font, a2 = r2.instance;
      if (!i2.isStandardFont) {
        if (void 0 === a2) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
        if ("string" != typeof (n2 = false === a2.existsFileInVFS(i2.postScriptName) ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName))) throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
        !(function(r3, n3) {
          n3 = /^\x00\x01\x00\x00/.test(n3) ? e2(n3) : e2(u$2(n3)), r3.metadata = t3.API.TTFFont.open(n3), r3.metadata.Unicode = r3.metadata.Unicode || {
            encoding: {},
            kerning: {},
            widths: []
          }, r3.metadata.glyIdsUsed = [0];
        })(i2, n2);
      }
    }]);
  })(E$1), /** @license
   * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   */
  (function(t3) {
    function e2() {
      return (n$1.canvg ? Promise.resolve(n$1.canvg) : Promise.resolve().then(function() {
        return index_es;
      })).catch(function(t4) {
        return Promise.reject(new Error("Could not load canvg: " + t4));
      }).then(function(t4) {
        return t4.default ? t4.default : t4;
      });
    }
    E$1.API.addSvgAsImage = function(t4, r2, n2, i2, o2, s2, c2, u2) {
      if (isNaN(r2) || isNaN(n2)) throw a$1.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
      if (isNaN(i2) || isNaN(o2)) throw a$1.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
      var h2 = document.createElement("canvas");
      h2.width = i2, h2.height = o2;
      var l2 = h2.getContext("2d");
      l2.fillStyle = "#fff", l2.fillRect(0, 0, h2.width, h2.height);
      var f2 = {
        ignoreMouse: true,
        ignoreAnimation: true,
        ignoreDimensions: true
      }, d2 = this;
      return e2().then(function(e3) {
        return e3.fromString(l2, t4, f2);
      }, function() {
        return Promise.reject(new Error("Could not load canvg."));
      }).then(function(t5) {
        return t5.render(f2);
      }).then(function() {
        d2.addImage(h2.toDataURL("image/jpeg", 1), r2, n2, i2, o2, c2, u2);
      });
    };
  })(), E$1.API.putTotalPages = function(t3) {
    var e2, r2 = 0;
    parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t3, "g"), r2 = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t3, this.internal.getFont()), "g"), r2 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
    for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++) for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++) this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(e2, r2);
    return this;
  }, E$1.API.viewerPreferences = function(e2, r2) {
    var n2;
    e2 = e2 || {}, r2 = r2 || false;
    var i2, a2, o2, s2 = {
      HideToolbar: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      HideMenubar: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      HideWindowUI: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      FitWindow: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      CenterWindow: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      DisplayDocTitle: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.4
      },
      NonFullScreenPageMode: {
        defaultValue: "UseNone",
        value: "UseNone",
        type: "name",
        explicitSet: false,
        valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"],
        pdfVersion: 1.3
      },
      Direction: {
        defaultValue: "L2R",
        value: "L2R",
        type: "name",
        explicitSet: false,
        valueSet: ["L2R", "R2L"],
        pdfVersion: 1.3
      },
      ViewArea: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: false,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      ViewClip: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: false,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      PrintArea: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: false,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      PrintClip: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: false,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      PrintScaling: {
        defaultValue: "AppDefault",
        value: "AppDefault",
        type: "name",
        explicitSet: false,
        valueSet: ["AppDefault", "None"],
        pdfVersion: 1.6
      },
      Duplex: {
        defaultValue: "",
        value: "none",
        type: "name",
        explicitSet: false,
        valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"],
        pdfVersion: 1.7
      },
      PickTrayByPDFSize: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.7
      },
      PrintPageRange: {
        defaultValue: "",
        value: "",
        type: "array",
        explicitSet: false,
        valueSet: null,
        pdfVersion: 1.7
      },
      NumCopies: {
        defaultValue: 1,
        value: 1,
        type: "integer",
        explicitSet: false,
        valueSet: null,
        pdfVersion: 1.7
      }
    }, c2 = Object.keys(s2), u2 = [], h2 = 0, l2 = 0, f2 = 0;
    function d2(t3, e3) {
      var r3, n3 = false;
      for (r3 = 0; r3 < t3.length; r3 += 1) t3[r3] === e3 && (n3 = true);
      return n3;
    }
    if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, "reset" === e2 || true === r2) {
      var p2 = c2.length;
      for (f2 = 0; f2 < p2; f2 += 1) n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;
    }
    if ("object" === _typeof$1(e2)) {
      for (a2 in e2) if (o2 = e2[a2], d2(c2, a2) && void 0 !== o2) {
        if ("boolean" === n2[a2].type && "boolean" == typeof o2) n2[a2].value = o2;
        else if ("name" === n2[a2].type && d2(n2[a2].valueSet, o2)) n2[a2].value = o2;
        else if ("integer" === n2[a2].type && Number.isInteger(o2)) n2[a2].value = o2;
        else if ("array" === n2[a2].type) {
          for (h2 = 0; h2 < o2.length; h2 += 1) if (i2 = true, 1 === o2[h2].length && "number" == typeof o2[h2][0]) u2.push(String(o2[h2] - 1));
          else if (o2[h2].length > 1) {
            for (l2 = 0; l2 < o2[h2].length; l2 += 1) "number" != typeof o2[h2][l2] && (i2 = false);
            true === i2 && u2.push([o2[h2][0] - 1, o2[h2][1] - 1].join(" "));
          }
          n2[a2].value = "[" + u2.join(" ") + "]";
        } else n2[a2].value = n2[a2].defaultValue;
        n2[a2].explicitSet = true;
      }
    }
    return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
      var t3, e3 = [];
      for (t3 in n2) true === n2[t3].explicitSet && ("name" === n2[t3].type ? e3.push("/" + t3 + " /" + n2[t3].value) : e3.push("/" + t3 + " " + n2[t3].value));
      0 !== e3.length && this.internal.write("/ViewerPreferences\n<<\n" + e3.join("\n") + "\n>>");
    }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;
  }, /** ====================================================================
   * @license
   * jsPDF XMP metadata plugin
   * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   */
  (function(t3) {
    var e2 = function() {
      var t4 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r3 = unescape(encodeURIComponent(t4)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = r3.length + n2.length + i2.length + e3.length + a2.length;
      this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e3 + r3 + n2 + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
    }, r2 = function() {
      this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
    };
    t3.addMetadata = function(t4, n2) {
      return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = {
        metadata: t4,
        namespaceuri: n2 || "http://jspdf.default.namespaceuri/"
      }, this.internal.events.subscribe("putCatalog", r2), this.internal.events.subscribe("postPutResources", e2)), this;
    };
  })(E$1.API), (function(t3) {
    var e2 = t3.API, r2 = e2.pdfEscape16 = function(t4, e3) {
      for (var r3, n3 = e3.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t4.length; o2 < s2; ++o2) {
        if (r3 = e3.metadata.characterToGlyph(t4.charCodeAt(o2)), e3.metadata.glyIdsUsed.push(r3), e3.metadata.toUnicode[r3] = t4.charCodeAt(o2), -1 == n3.indexOf(r3) && (n3.push(r3), n3.push([parseInt(e3.metadata.widthOfGlyph(r3), 10)])), "0" == r3) return a2.join("");
        r3 = r3.toString(16), a2.push(i3[4 - r3.length], r3);
      }
      return a2.join("");
    }, n2 = function(t4) {
      var e3, r3, n3, i3, a2, o2, s2;
      for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r3 = Object.keys(t4).sort(function(t5, e4) {
        return t5 - e4;
      })).length; o2 < s2; o2++) e3 = r3[o2], n3.length >= 100 && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), void 0 !== t4[e3] && null !== t4[e3] && "function" == typeof t4[e3].toString && (i3 = ("0000" + t4[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), n3.push("<" + e3 + "><" + i3 + ">"));
      return n3.length && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a2 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    };
    e2.events.push(["putFont", function(e3) {
      !(function(e4) {
        var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
        if (r3.metadata instanceof t3.API.TTFFont && "Identity-H" === r3.encoding) {
          for (var s2 = r3.metadata.Unicode.widths, c2 = r3.metadata.subset.encode(r3.metadata.glyIdsUsed, 1), u2 = "", h2 = 0; h2 < c2.length; h2++) u2 += String.fromCharCode(c2[h2]);
          var l2 = a2();
          o2({
            data: u2,
            addLength1: true,
            objectId: l2
          }), i3("endobj");
          var f2 = a2();
          o2({
            data: n2(r3.metadata.toUnicode),
            addLength1: true,
            objectId: f2
          }), i3("endobj");
          var d2 = a2();
          i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + F$1(r3.fontName)), i3("/FontFile2 " + l2 + " 0 R"), i3("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i3("/Flags " + r3.metadata.flags), i3("/StemV " + r3.metadata.stemV), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3(">>"), i3("endobj");
          var p2 = a2();
          i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + F$1(r3.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t3.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + r3.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), r3.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + F$1(r3.fontName)), i3("/Encoding /" + r3.encoding), i3("/DescendantFonts [" + p2 + " 0 R]"), i3(">>"), i3("endobj"), r3.isAlreadyPutted = true;
        }
      })(e3);
    }]);
    e2.events.push(["putFont", function(e3) {
      !(function(e4) {
        var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
        if (r3.metadata instanceof t3.API.TTFFont && "WinAnsiEncoding" === r3.encoding) {
          for (var s2 = r3.metadata.rawData, c2 = "", u2 = 0; u2 < s2.length; u2++) c2 += String.fromCharCode(s2[u2]);
          var h2 = a2();
          o2({
            data: c2,
            addLength1: true,
            objectId: h2
          }), i3("endobj");
          var l2 = a2();
          o2({
            data: n2(r3.metadata.toUnicode),
            addLength1: true,
            objectId: l2
          }), i3("endobj");
          var f2 = a2();
          i3("<<"), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3("/StemV " + r3.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + h2 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i3("/FontName /" + F$1(r3.fontName)), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3(">>"), i3("endobj"), r3.objectNumber = a2();
          for (var d2 = 0; d2 < r3.metadata.hmtx.widths.length; d2++) r3.metadata.hmtx.widths[d2] = parseInt(r3.metadata.hmtx.widths[d2] * (1e3 / r3.metadata.head.unitsPerEm));
          i3("<</Subtype/TrueType/Type/Font/ToUnicode " + l2 + " 0 R/BaseFont/" + F$1(r3.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + r3.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t3.API.PDFObject.convert(r3.metadata.hmtx.widths) + ">>"), i3("endobj"), r3.isAlreadyPutted = true;
        }
      })(e3);
    }]);
    var i2 = function(t4) {
      var e3, n3 = t4.text || "", i3 = t4.x, a2 = t4.y, o2 = t4.options || {}, s2 = t4.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h2 = s2.fonts, l2 = u2, f2 = "", d2 = 0, p2 = "", g2 = h2[l2].encoding;
      if ("Identity-H" !== h2[l2].encoding) return {
        text: n3,
        x: i3,
        y: a2,
        options: o2,
        mutex: s2
      };
      for (p2 = n3, l2 = u2, Array.isArray(n3) && (p2 = n3[0]), d2 = 0; d2 < p2.length; d2 += 1) h2[l2].metadata.hasOwnProperty("cmap") && (e3 = h2[l2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e3 || p2[d2].charCodeAt(0) < 256 && h2[l2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d2] : f2 += "";
      var m2 = "";
      return parseInt(l2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m2 = c2(f2, l2).split("").map(function(t5) {
        return t5.charCodeAt(0).toString(16);
      }).join("") : "Identity-H" === g2 && (m2 = r2(f2, h2[l2])), s2.isHex = true, {
        text: m2,
        x: i3,
        y: a2,
        options: o2,
        mutex: s2
      };
    };
    e2.events.push(["postProcessText", function(t4) {
      var e3 = t4.text || "", r3 = [], n3 = {
        text: e3,
        x: t4.x,
        y: t4.y,
        options: t4.options,
        mutex: t4.mutex
      };
      if (Array.isArray(e3)) {
        var a2 = 0;
        for (a2 = 0; a2 < e3.length; a2 += 1) Array.isArray(e3[a2]) && 3 === e3[a2].length ? r3.push([i2(Object.assign({}, n3, {
          text: e3[a2][0]
        })).text, e3[a2][1], e3[a2][2]]) : r3.push(i2(Object.assign({}, n3, {
          text: e3[a2]
        })).text);
        t4.text = r3;
      } else t4.text = i2(Object.assign({}, n3, {
        text: e3
      })).text;
    }]);
  })(E$1), /**
   * @license
   * jsPDF virtual FileSystem functionality
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t3) {
    var e2 = function() {
      return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
    };
    t3.existsFileInVFS = function(t4) {
      return e2.call(this), void 0 !== this.internal.vFS[t4];
    }, t3.addFileToVFS = function(t4, r2) {
      return e2.call(this), this.internal.vFS[t4] = r2, this;
    }, t3.getFileFromVFS = function(t4) {
      return e2.call(this), void 0 !== this.internal.vFS[t4] ? this.internal.vFS[t4] : null;
    };
  })(E$1.API), /**
   * @license
   * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
   * MIT License
   */
  (function(t3) {
    t3.__bidiEngine__ = t3.prototype.__bidiEngine__ = function(t4) {
      var r3, n2, i2, a2, o2, s2, c2, u2 = e2, h2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = {
        L: 0,
        R: 1,
        EN: 2,
        AN: 3,
        N: 4,
        B: 5,
        S: 6
      }, d2 = {
        0: 0,
        5: 1,
        6: 2,
        7: 3,
        32: 4,
        251: 5,
        254: 6,
        255: 7
      }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
      this.__bidiEngine__ = {};
      var b2 = function(t5) {
        var e3 = t5.charCodeAt(), r4 = e3 >> 8, n3 = d2[r4];
        return void 0 !== n3 ? u2[256 * n3 + (255 & e3)] : 252 === r4 || 253 === r4 ? "AL" : g2.test(r4) ? "L" : 8 === r4 ? "R" : "N";
      }, y2 = function(t5) {
        for (var e3, r4 = 0; r4 < t5.length; r4++) {
          if ("L" === (e3 = b2(t5.charAt(r4)))) return false;
          if ("R" === e3) return true;
        }
        return false;
      }, w2 = function(t5, e3, o3, s3) {
        var c3, u3, h3, l3, f3 = e3[s3];
        switch (f3) {
          case "L":
          case "R":
            m2 = false;
            break;
          case "N":
          case "AN":
            break;
          case "EN":
            m2 && (f3 = "AN");
            break;
          case "AL":
            m2 = true, f3 = "R";
            break;
          case "WS":
            f3 = "N";
            break;
          case "CS":
            s3 < 1 || s3 + 1 >= e3.length || "EN" !== (c3 = o3[s3 - 1]) && "AN" !== c3 || "EN" !== (u3 = e3[s3 + 1]) && "AN" !== u3 ? f3 = "N" : m2 && (u3 = "AN"), f3 = u3 === c3 ? u3 : "N";
            break;
          case "ES":
            f3 = "EN" === (c3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e3.length && "EN" === e3[s3 + 1] ? "EN" : "N";
            break;
          case "ET":
            if (s3 > 0 && "EN" === o3[s3 - 1]) {
              f3 = "EN";
              break;
            }
            if (m2) {
              f3 = "N";
              break;
            }
            for (h3 = s3 + 1, l3 = e3.length; h3 < l3 && "ET" === e3[h3]; ) h3++;
            f3 = h3 < l3 && "EN" === e3[h3] ? "EN" : "N";
            break;
          case "NSM":
            if (i2 && !a2) {
              for (l3 = e3.length, h3 = s3 + 1; h3 < l3 && "NSM" === e3[h3]; ) h3++;
              if (h3 < l3) {
                var d3 = t5[s3], p3 = d3 >= 1425 && d3 <= 2303 || 64286 === d3;
                if (c3 = e3[h3], p3 && ("R" === c3 || "AL" === c3)) {
                  f3 = "R";
                  break;
                }
              }
            }
            f3 = s3 < 1 || "B" === (c3 = e3[s3 - 1]) ? "N" : o3[s3 - 1];
            break;
          case "B":
            m2 = false, r3 = true, f3 = v2;
            break;
          case "S":
            n2 = true, f3 = "N";
            break;
          case "LRE":
          case "RLE":
          case "LRO":
          case "RLO":
          case "PDF":
            m2 = false;
            break;
          case "BN":
            f3 = "N";
        }
        return f3;
      }, N2 = function(t5, e3, r4) {
        var n3 = t5.split("");
        return r4 && L2(n3, r4, {
          hiLevel: v2
        }), n3.reverse(), e3 && e3.reverse(), n3.join("");
      }, L2 = function(t5, e3, i3) {
        var a3, o3, s3, c3, u3, d3 = -1, p3 = t5.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h2, L3 = [];
        for (m2 = false, r3 = false, n2 = false, o3 = 0; o3 < p3; o3++) L3[o3] = b2(t5[o3]);
        for (s3 = 0; s3 < p3; s3++) {
          if (u3 = g3, y3[s3] = w2(t5, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e3[s3] = c3 = N3[g3][5], a3 > 0) if (16 === a3) {
            for (o3 = d3; o3 < s3; o3++) e3[o3] = 1;
            d3 = -1;
          } else d3 = -1;
          if (N3[g3][6]) -1 === d3 && (d3 = s3);
          else if (d3 > -1) {
            for (o3 = d3; o3 < s3; o3++) e3[o3] = c3;
            d3 = -1;
          }
          "B" === L3[s3] && (e3[s3] = 0), i3.hiLevel |= c3;
        }
        n2 && (function(t6, e4, r4) {
          for (var n3 = 0; n3 < r4; n3++) if ("S" === t6[n3]) {
            e4[n3] = v2;
            for (var i4 = n3 - 1; i4 >= 0 && "WS" === t6[i4]; i4--) e4[i4] = v2;
          }
        })(L3, e3, p3);
      }, A2 = function(t5, e3, n3, i3, a3) {
        if (!(a3.hiLevel < t5)) {
          if (1 === t5 && 1 === v2 && !r3) return e3.reverse(), void (n3 && n3.reverse());
          for (var o3, s3, c3, u3, h3 = e3.length, l3 = 0; l3 < h3; ) {
            if (i3[l3] >= t5) {
              for (c3 = l3 + 1; c3 < h3 && i3[c3] >= t5; ) c3++;
              for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--) o3 = e3[u3], e3[u3] = e3[s3], e3[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);
              l3 = c3;
            }
            l3++;
          }
        }
      }, x2 = function(t5, e3, r4) {
        var n3 = t5.split(""), i3 = {
          hiLevel: v2
        };
        return r4 || (r4 = []), L2(n3, r4, i3), (function(t6, e4, r5) {
          if (0 !== r5.hiLevel && c2) for (var n4, i4 = 0; i4 < t6.length; i4++) 1 === e4[i4] && (n4 = p2.indexOf(t6[i4])) >= 0 && (t6[i4] = p2[n4 + 1]);
        })(n3, r4, i3), A2(2, n3, e3, r4, i3), A2(1, n3, e3, r4, i3), n3.join("");
      };
      return this.__bidiEngine__.doBidiReorder = function(t5, e3, r4) {
        if ((function(t6, e4) {
          if (e4) for (var r5 = 0; r5 < t6.length; r5++) e4[r5] = r5;
          void 0 === a2 && (a2 = y2(t6)), void 0 === s2 && (s2 = y2(t6));
        })(t5, e3), i2 || !o2 || s2) {
          if (i2 && o2 && a2 ^ s2) v2 = a2 ? 1 : 0, t5 = N2(t5, e3, r4);
          else if (!i2 && o2 && s2) v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);
          else if (!i2 || a2 || o2 || s2) {
            if (i2 && !o2 && a2 ^ s2) t5 = N2(t5, e3), a2 ? (v2 = 0, t5 = x2(t5, e3, r4)) : (v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3));
            else if (i2 && a2 && !o2 && s2) v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);
            else if (!i2 && !o2 && a2 ^ s2) {
              var n3 = c2;
              a2 ? (v2 = 1, t5 = x2(t5, e3, r4), v2 = 0, c2 = false, t5 = x2(t5, e3, r4), c2 = n3) : (v2 = 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3), v2 = 1, c2 = false, t5 = x2(t5, e3, r4), c2 = n3, t5 = N2(t5, e3));
            }
          } else v2 = 0, t5 = x2(t5, e3, r4);
        } else v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4);
        return t5;
      }, this.__bidiEngine__.setOptions = function(t5) {
        t5 && (i2 = t5.isInputVisual, o2 = t5.isOutputVisual, a2 = t5.isInputRtl, s2 = t5.isOutputRtl, c2 = t5.isSymmetricSwapping);
      }, this.__bidiEngine__.setOptions(t4), this.__bidiEngine__;
    };
    var e2 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r2 = new t3.__bidiEngine__({
      isInputVisual: true
    });
    t3.API.events.push(["postProcessText", function(t4) {
      var e3 = t4.text;
      t4.x, t4.y;
      var n2 = t4.options || {};
      t4.mutex, n2.lang;
      var i2 = [];
      if (n2.isInputVisual = "boolean" != typeof n2.isInputVisual || n2.isInputVisual, r2.setOptions(n2), "[object Array]" === Object.prototype.toString.call(e3)) {
        var a2 = 0;
        for (i2 = [], a2 = 0; a2 < e3.length; a2 += 1) "[object Array]" === Object.prototype.toString.call(e3[a2]) ? i2.push([r2.doBidiReorder(e3[a2][0]), e3[a2][1], e3[a2][2]]) : i2.push([r2.doBidiReorder(e3[a2])]);
        t4.text = i2;
      } else t4.text = r2.doBidiReorder(e3);
      r2.setOptions({
        isInputVisual: true
      });
    }]);
  })(E$1), E$1.API.TTFFont = (function() {
    function t3(t4) {
      var e2;
      if (this.rawData = t4, e2 = this.contents = new ne(t4), this.contents.pos = 4, "ttcf" === e2.readString(4)) throw new Error("TTCF not supported.");
      e2.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
    }
    return t3.open = function(e2) {
      return new t3(e2);
    }, t3.prototype.parse = function() {
      return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
    }, t3.prototype.registerTTF = function() {
      var t4, e2, r2, n2, i2;
      if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
        var e3, r3, n3, i3;
        for (i3 = [], e3 = 0, r3 = (n3 = this.bbox).length; e3 < r3; e3++) t4 = n3[e3], i3.push(Math.round(t4 * this.scaleFactor));
        return i3;
      }.call(this), this.stemV = 0, this.post.exists ? (r2 = 255 & (n2 = this.post.italic_angle), 0 != (32768 & (e2 = n2 >> 16)) && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + "." + r2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i2 = this.familyClass) || 2 === i2 || 3 === i2 || 4 === i2 || 5 === i2 || 7 === i2, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
    }, t3.prototype.characterToGlyph = function(t4) {
      var e2;
      return (null != (e2 = this.cmap.unicode) ? e2.codeMap[t4] : void 0) || 0;
    }, t3.prototype.widthOfGlyph = function(t4) {
      var e2;
      return e2 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t4).advance * e2;
    }, t3.prototype.widthOfString = function(t4, e2, r2) {
      var n2, i2, a2, o2;
      for (a2 = 0, i2 = 0, o2 = (t4 = "" + t4).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2) n2 = t4.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r2 * (1e3 / e2) || 0;
      return a2 * (e2 / 1e3);
    }, t3.prototype.lineHeight = function(t4, e2) {
      var r2;
      return null == e2 && (e2 = false), r2 = e2 ? this.lineGap : 0, (this.ascender + r2 - this.decender) / 1e3 * t4;
    }, t3;
  })();
  var re;
  var ne = (function() {
    function t3(t4) {
      this.data = null != t4 ? t4 : [], this.pos = 0, this.length = this.data.length;
    }
    return t3.prototype.readByte = function() {
      return this.data[this.pos++];
    }, t3.prototype.writeByte = function(t4) {
      return this.data[this.pos++] = t4;
    }, t3.prototype.readUInt32 = function() {
      return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
    }, t3.prototype.writeUInt32 = function(t4) {
      return this.writeByte(t4 >>> 24 & 255), this.writeByte(t4 >> 16 & 255), this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
    }, t3.prototype.readInt32 = function() {
      var t4;
      return (t4 = this.readUInt32()) >= 2147483648 ? t4 - 4294967296 : t4;
    }, t3.prototype.writeInt32 = function(t4) {
      return t4 < 0 && (t4 += 4294967296), this.writeUInt32(t4);
    }, t3.prototype.readUInt16 = function() {
      return this.readByte() << 8 | this.readByte();
    }, t3.prototype.writeUInt16 = function(t4) {
      return this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
    }, t3.prototype.readInt16 = function() {
      var t4;
      return (t4 = this.readUInt16()) >= 32768 ? t4 - 65536 : t4;
    }, t3.prototype.writeInt16 = function(t4) {
      return t4 < 0 && (t4 += 65536), this.writeUInt16(t4);
    }, t3.prototype.readString = function(t4) {
      var e2, r2;
      for (r2 = [], e2 = 0; 0 <= t4 ? e2 < t4 : e2 > t4; e2 = 0 <= t4 ? ++e2 : --e2) r2[e2] = String.fromCharCode(this.readByte());
      return r2.join("");
    }, t3.prototype.writeString = function(t4) {
      var e2, r2, n2;
      for (n2 = [], e2 = 0, r2 = t4.length; 0 <= r2 ? e2 < r2 : e2 > r2; e2 = 0 <= r2 ? ++e2 : --e2) n2.push(this.writeByte(t4.charCodeAt(e2)));
      return n2;
    }, t3.prototype.readShort = function() {
      return this.readInt16();
    }, t3.prototype.writeShort = function(t4) {
      return this.writeInt16(t4);
    }, t3.prototype.readLongLong = function() {
      var t4, e2, r2, n2, i2, a2, o2, s2;
      return t4 = this.readByte(), e2 = this.readByte(), r2 = this.readByte(), n2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t4 ? -1 * (72057594037927940 * (255 ^ t4) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ r2) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t4 + 281474976710656 * e2 + 1099511627776 * r2 + 4294967296 * n2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
    }, t3.prototype.writeLongLong = function(t4) {
      var e2, r2;
      return e2 = Math.floor(t4 / 4294967296), r2 = 4294967295 & t4, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(r2 >> 24 & 255), this.writeByte(r2 >> 16 & 255), this.writeByte(r2 >> 8 & 255), this.writeByte(255 & r2);
    }, t3.prototype.readInt = function() {
      return this.readInt32();
    }, t3.prototype.writeInt = function(t4) {
      return this.writeInt32(t4);
    }, t3.prototype.read = function(t4) {
      var e2, r2;
      for (e2 = [], r2 = 0; 0 <= t4 ? r2 < t4 : r2 > t4; r2 = 0 <= t4 ? ++r2 : --r2) e2.push(this.readByte());
      return e2;
    }, t3.prototype.write = function(t4) {
      var e2, r2, n2, i2;
      for (i2 = [], r2 = 0, n2 = t4.length; r2 < n2; r2++) e2 = t4[r2], i2.push(this.writeByte(e2));
      return i2;
    }, t3;
  })();
  var ie = (function() {
    var t3;
    function e2(t4) {
      var e3, r2, n2;
      for (this.scalarType = t4.readInt(), this.tableCount = t4.readShort(), this.searchRange = t4.readShort(), this.entrySelector = t4.readShort(), this.rangeShift = t4.readShort(), this.tables = {}, r2 = 0, n2 = this.tableCount; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2) e3 = {
        tag: t4.readString(4),
        checksum: t4.readInt(),
        offset: t4.readInt(),
        length: t4.readInt()
      }, this.tables[e3.tag] = e3;
    }
    return e2.prototype.encode = function(e3) {
      var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2;
      for (p2 in f2 = Object.keys(e3).length, s2 = Math.log(2), h2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h2 / s2), u2 = 16 * f2 - h2, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h2), n2.writeShort(a2), n2.writeShort(u2), i2 = 16 * f2, c2 = n2.pos + i2, o2 = null, d2 = [], e3) for (l2 = e3[p2], n2.writeString(p2), n2.writeInt(t3(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), "head" === p2 && (o2 = c2), c2 += l2.length; c2 % 4; ) d2.push(0), c2++;
      return n2.write(d2), r2 = 2981146554 - t3(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r2), n2.data;
    }, t3 = function(t4) {
      var e3, r2, n2, i2;
      for (t4 = ve.call(t4); t4.length % 4; ) t4.push(0);
      for (n2 = new ne(t4), r2 = 0, e3 = 0, i2 = t4.length; e3 < i2; e3 = e3 += 4) r2 += n2.readUInt32();
      return 4294967295 & r2;
    }, e2;
  })();
  var ae = {}.hasOwnProperty;
  var oe = function(t3, e2) {
    for (var r2 in e2) ae.call(e2, r2) && (t3[r2] = e2[r2]);
    function n2() {
      this.constructor = t3;
    }
    return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
  };
  re = (function() {
    function t3(t4) {
      var e2;
      this.file = t4, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));
    }
    return t3.prototype.parse = function() {
    }, t3.prototype.encode = function() {
    }, t3.prototype.raw = function() {
      return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
    }, t3;
  })();
  var se = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "head", e2.prototype.parse = function(t4) {
      return t4.pos = this.offset, this.version = t4.readInt(), this.revision = t4.readInt(), this.checkSumAdjustment = t4.readInt(), this.magicNumber = t4.readInt(), this.flags = t4.readShort(), this.unitsPerEm = t4.readShort(), this.created = t4.readLongLong(), this.modified = t4.readLongLong(), this.xMin = t4.readShort(), this.yMin = t4.readShort(), this.xMax = t4.readShort(), this.yMax = t4.readShort(), this.macStyle = t4.readShort(), this.lowestRecPPEM = t4.readShort(), this.fontDirectionHint = t4.readShort(), this.indexToLocFormat = t4.readShort(), this.glyphDataFormat = t4.readShort();
    }, e2.prototype.encode = function(t4) {
      var e3;
      return (e3 = new ne()).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t4), e3.writeShort(this.glyphDataFormat), e3.data;
    }, e2;
  })();
  var ce = (function() {
    function t3(t4, e2) {
      var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2;
      switch (this.platformID = t4.readUInt16(), this.encodingID = t4.readShort(), this.offset = e2 + t4.readInt(), h2 = t4.pos, t4.pos = this.offset, this.format = t4.readUInt16(), this.length = t4.readUInt16(), this.language = t4.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
        case 0:
          for (s2 = 0; s2 < 256; ++s2) this.codeMap[s2] = t4.readByte();
          break;
        case 4:
          for (f2 = t4.readUInt16(), l2 = f2 / 2, t4.pos += 6, i2 = (function() {
            var e3, r3;
            for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r3.push(t4.readUInt16());
            return r3;
          })(), t4.pos += 2, p2 = (function() {
            var e3, r3;
            for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r3.push(t4.readUInt16());
            return r3;
          })(), c2 = (function() {
            var e3, r3;
            for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r3.push(t4.readUInt16());
            return r3;
          })(), u2 = (function() {
            var e3, r3;
            for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r3.push(t4.readUInt16());
            return r3;
          })(), n2 = (this.length - t4.pos + this.offset) / 2, o2 = (function() {
            var e3, r3;
            for (r3 = [], s2 = e3 = 0; 0 <= n2 ? e3 < n2 : e3 > n2; s2 = 0 <= n2 ? ++e3 : --e3) r3.push(t4.readUInt16());
            return r3;
          })(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2) for (g2 = i2[s2], r2 = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r2 = d2 <= g2 ? ++v2 : --v2) 0 === u2[s2] ? a2 = r2 + c2[s2] : 0 !== (a2 = o2[u2[s2] / 2 + (r2 - d2) - (l2 - s2)] || 0) && (a2 += c2[s2]), this.codeMap[r2] = 65535 & a2;
      }
      t4.pos = h2;
    }
    return t3.encode = function(t4, e2) {
      var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B2, M2, E2, q2, D2, R2, T2, U2, z2, H2, W2, V2, G2, Y2;
      switch (I2 = new ne(), a2 = Object.keys(t4).sort(function(t5, e3) {
        return t5 - e3;
      }), e2) {
        case "macroman":
          for (p2 = 0, g2 = (function() {
            var t5 = [];
            for (d2 = 0; d2 < 256; ++d2) t5.push(0);
            return t5;
          })(), v2 = {
            0: 0
          }, i2 = {}, F2 = 0, B2 = a2.length; F2 < B2; F2++) null == v2[W2 = t4[n2 = a2[F2]]] && (v2[W2] = ++p2), i2[n2] = {
            old: t4[n2],
            new: v2[t4[n2]]
          }, g2[n2] = v2[t4[n2]];
          return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), {
            charMap: i2,
            subtable: I2.data,
            maxGlyphID: p2 + 1
          };
        case "unicode":
          for (P2 = [], h2 = [], b2 = 0, v2 = {}, r2 = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++) null == v2[w2 = t4[n2 = a2[C2]]] && (v2[w2] = ++b2), r2[n2] = {
            old: w2,
            new: v2[w2]
          }, o2 = v2[w2] - n2, null != m2 && o2 === c2 || (m2 && h2.push(m2), P2.push(n2), c2 = o2), m2 = n2;
          for (m2 && h2.push(m2), h2.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
            if (_2 = P2[d2], u2 = h2[d2], 65535 === _2) {
              s2.push(0), N2.push(0);
              break;
            }
            if (_2 - (k2 = r2[_2].new) >= 32768) for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2) f2.push(r2[n2].new);
            else s2.push(k2 - _2), N2.push(0);
          }
          for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), z2 = 0, q2 = h2.length; z2 < q2; z2++) n2 = h2[z2], I2.writeUInt16(n2);
          for (I2.writeUInt16(0), H2 = 0, D2 = P2.length; H2 < D2; H2++) n2 = P2[H2], I2.writeUInt16(n2);
          for (V2 = 0, R2 = s2.length; V2 < R2; V2++) o2 = s2[V2], I2.writeUInt16(o2);
          for (G2 = 0, T2 = N2.length; G2 < T2; G2++) y2 = N2[G2], I2.writeUInt16(y2);
          for (Y2 = 0, U2 = f2.length; Y2 < U2; Y2++) p2 = f2[Y2], I2.writeUInt16(p2);
          return {
            charMap: r2,
            subtable: I2.data,
            maxGlyphID: b2 + 1
          };
      }
    }, t3;
  })();
  var ue = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "cmap", e2.prototype.parse = function(t4) {
      var e3, r2, n2;
      for (t4.pos = this.offset, this.version = t4.readUInt16(), n2 = t4.readUInt16(), this.tables = [], this.unicode = null, r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2) e3 = new ce(t4, this.offset), this.tables.push(e3), e3.isUnicode && null == this.unicode && (this.unicode = e3);
      return true;
    }, e2.encode = function(t4, e3) {
      var r2, n2;
      return null == e3 && (e3 = "macroman"), r2 = ce.encode(t4, e3), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r2.table = n2.data.concat(r2.subtable), r2;
    }, e2;
  })();
  var he = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "hhea", e2.prototype.parse = function(t4) {
      return t4.pos = this.offset, this.version = t4.readInt(), this.ascender = t4.readShort(), this.decender = t4.readShort(), this.lineGap = t4.readShort(), this.advanceWidthMax = t4.readShort(), this.minLeftSideBearing = t4.readShort(), this.minRightSideBearing = t4.readShort(), this.xMaxExtent = t4.readShort(), this.caretSlopeRise = t4.readShort(), this.caretSlopeRun = t4.readShort(), this.caretOffset = t4.readShort(), t4.pos += 8, this.metricDataFormat = t4.readShort(), this.numberOfMetrics = t4.readUInt16();
    }, e2;
  })();
  var le = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "OS/2", e2.prototype.parse = function(t4) {
      if (t4.pos = this.offset, this.version = t4.readUInt16(), this.averageCharWidth = t4.readShort(), this.weightClass = t4.readUInt16(), this.widthClass = t4.readUInt16(), this.type = t4.readShort(), this.ySubscriptXSize = t4.readShort(), this.ySubscriptYSize = t4.readShort(), this.ySubscriptXOffset = t4.readShort(), this.ySubscriptYOffset = t4.readShort(), this.ySuperscriptXSize = t4.readShort(), this.ySuperscriptYSize = t4.readShort(), this.ySuperscriptXOffset = t4.readShort(), this.ySuperscriptYOffset = t4.readShort(), this.yStrikeoutSize = t4.readShort(), this.yStrikeoutPosition = t4.readShort(), this.familyClass = t4.readShort(), this.panose = (function() {
        var e3, r2;
        for (r2 = [], e3 = 0; e3 < 10; ++e3) r2.push(t4.readByte());
        return r2;
      })(), this.charRange = (function() {
        var e3, r2;
        for (r2 = [], e3 = 0; e3 < 4; ++e3) r2.push(t4.readInt());
        return r2;
      })(), this.vendorID = t4.readString(4), this.selection = t4.readShort(), this.firstCharIndex = t4.readShort(), this.lastCharIndex = t4.readShort(), this.version > 0 && (this.ascent = t4.readShort(), this.descent = t4.readShort(), this.lineGap = t4.readShort(), this.winAscent = t4.readShort(), this.winDescent = t4.readShort(), this.codePageRange = (function() {
        var e3, r2;
        for (r2 = [], e3 = 0; e3 < 2; e3 = ++e3) r2.push(t4.readInt());
        return r2;
      })(), this.version > 1)) return this.xHeight = t4.readShort(), this.capHeight = t4.readShort(), this.defaultChar = t4.readShort(), this.breakChar = t4.readShort(), this.maxContext = t4.readShort();
    }, e2;
  })();
  var fe = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "post", e2.prototype.parse = function(t4) {
      var e3, r2, n2;
      switch (t4.pos = this.offset, this.format = t4.readInt(), this.italicAngle = t4.readInt(), this.underlinePosition = t4.readShort(), this.underlineThickness = t4.readShort(), this.isFixedPitch = t4.readInt(), this.minMemType42 = t4.readInt(), this.maxMemType42 = t4.readInt(), this.minMemType1 = t4.readInt(), this.maxMemType1 = t4.readInt(), this.format) {
        case 65536:
          break;
        case 131072:
          var i2;
          for (r2 = t4.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= r2 ? i2 < r2 : i2 > r2; i2 = 0 <= r2 ? ++i2 : --i2) this.glyphNameIndex.push(t4.readUInt16());
          for (this.names = [], n2 = []; t4.pos < this.offset + this.length; ) e3 = t4.readByte(), n2.push(this.names.push(t4.readString(e3)));
          return n2;
        case 151552:
          return r2 = t4.readUInt16(), this.offsets = t4.read(r2);
        case 196608:
          break;
        case 262144:
          return this.map = function() {
            var e4, r3, n3;
            for (n3 = [], i2 = e4 = 0, r3 = this.file.maxp.numGlyphs; 0 <= r3 ? e4 < r3 : e4 > r3; i2 = 0 <= r3 ? ++e4 : --e4) n3.push(t4.readUInt32());
            return n3;
          }.call(this);
      }
    }, e2;
  })();
  var de = function(t3, e2) {
    this.raw = t3, this.length = t3.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;
  };
  var pe = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "name", e2.prototype.parse = function(t4) {
      var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2, l2;
      for (t4.pos = this.offset, t4.readShort(), e3 = t4.readShort(), o2 = t4.readShort(), r2 = [], i2 = 0; 0 <= e3 ? i2 < e3 : i2 > e3; i2 = 0 <= e3 ? ++i2 : --i2) r2.push({
        platformID: t4.readShort(),
        encodingID: t4.readShort(),
        languageID: t4.readShort(),
        nameID: t4.readShort(),
        length: t4.readShort(),
        offset: this.offset + o2 + t4.readShort()
      });
      for (s2 = {}, i2 = u2 = 0, h2 = r2.length; u2 < h2; i2 = ++u2) n2 = r2[i2], t4.pos = n2.offset, c2 = t4.readString(n2.length), a2 = new de(c2, n2), null == s2[l2 = n2.nameID] && (s2[l2] = []), s2[n2.nameID].push(a2);
      this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
      try {
        this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
      } catch (t5) {
        this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
      }
      return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
    }, e2;
  })();
  var ge = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "maxp", e2.prototype.parse = function(t4) {
      return t4.pos = this.offset, this.version = t4.readInt(), this.numGlyphs = t4.readUInt16(), this.maxPoints = t4.readUInt16(), this.maxContours = t4.readUInt16(), this.maxCompositePoints = t4.readUInt16(), this.maxComponentContours = t4.readUInt16(), this.maxZones = t4.readUInt16(), this.maxTwilightPoints = t4.readUInt16(), this.maxStorage = t4.readUInt16(), this.maxFunctionDefs = t4.readUInt16(), this.maxInstructionDefs = t4.readUInt16(), this.maxStackElements = t4.readUInt16(), this.maxSizeOfInstructions = t4.readUInt16(), this.maxComponentElements = t4.readUInt16(), this.maxComponentDepth = t4.readUInt16();
    }, e2;
  })();
  var me = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "hmtx", e2.prototype.parse = function(t4) {
      var e3, r2, n2, i2, a2, o2, s2;
      for (t4.pos = this.offset, this.metrics = [], e3 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e3 < o2 : e3 > o2; e3 = 0 <= o2 ? ++e3 : --e3) this.metrics.push({
        advance: t4.readUInt16(),
        lsb: t4.readInt16()
      });
      for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = (function() {
        var r3, i3;
        for (i3 = [], e3 = r3 = 0; 0 <= n2 ? r3 < n2 : r3 > n2; e3 = 0 <= n2 ? ++r3 : --r3) i3.push(t4.readInt16());
        return i3;
      })(), this.widths = function() {
        var t5, e4, r3, n3;
        for (n3 = [], t5 = 0, e4 = (r3 = this.metrics).length; t5 < e4; t5++) i2 = r3[t5], n3.push(i2.advance);
        return n3;
      }.call(this), r2 = this.widths[this.widths.length - 1], s2 = [], e3 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e3 = 0 <= n2 ? ++a2 : --a2) s2.push(this.widths.push(r2));
      return s2;
    }, e2.prototype.forGlyph = function(t4) {
      return t4 in this.metrics ? this.metrics[t4] : {
        advance: this.metrics[this.metrics.length - 1].advance,
        lsb: this.leftSideBearings[t4 - this.metrics.length]
      };
    }, e2;
  })();
  var ve = [].slice;
  var be = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "glyf", e2.prototype.parse = function() {
      return this.cache = {};
    }, e2.prototype.glyphFor = function(t4) {
      var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2;
      return t4 in this.cache ? this.cache[t4] : (i2 = this.file.loca, e3 = this.file.contents, r2 = i2.indexOf(t4), 0 === (n2 = i2.lengthOf(t4)) ? this.cache[t4] = null : (e3.pos = this.offset + r2, a2 = (o2 = new ne(e3.read(n2))).readShort(), c2 = o2.readShort(), h2 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t4] = -1 === a2 ? new we(o2, c2, h2, s2, u2) : new ye(o2, a2, c2, h2, s2, u2), this.cache[t4]));
    }, e2.prototype.encode = function(t4, e3, r2) {
      var n2, i2, a2, o2, s2;
      for (a2 = [], i2 = [], o2 = 0, s2 = e3.length; o2 < s2; o2++) n2 = t4[e3[o2]], i2.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r2)));
      return i2.push(a2.length), {
        table: a2,
        offsets: i2
      };
    }, e2;
  })();
  var ye = (function() {
    function t3(t4, e2, r2, n2, i2, a2) {
      this.raw = t4, this.numberOfContours = e2, this.xMin = r2, this.yMin = n2, this.xMax = i2, this.yMax = a2, this.compound = false;
    }
    return t3.prototype.encode = function() {
      return this.raw.data;
    }, t3;
  })();
  var we = (function() {
    function t3(t4, e2, r2, n2, i2) {
      var a2, o2;
      for (this.raw = t4, this.xMin = e2, this.yMin = r2, this.xMax = n2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; ) a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
    }
    return t3.prototype.encode = function() {
      var t4, e2, r2;
      for (e2 = new ne(ve.call(this.raw.data)), t4 = 0, r2 = this.glyphIDs.length; t4 < r2; ++t4) e2.pos = this.glyphOffsets[t4];
      return e2.data;
    }, t3;
  })();
  var Ne = (function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "loca", e2.prototype.parse = function(t4) {
      var e3, r2;
      return t4.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = 0 === e3 ? function() {
        var e4, n2;
        for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 2) n2.push(2 * t4.readUInt16());
        return n2;
      }.call(this) : function() {
        var e4, n2;
        for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 4) n2.push(t4.readUInt32());
        return n2;
      }.call(this);
    }, e2.prototype.indexOf = function(t4) {
      return this.offsets[t4];
    }, e2.prototype.lengthOf = function(t4) {
      return this.offsets[t4 + 1] - this.offsets[t4];
    }, e2.prototype.encode = function(t4, e3) {
      for (var r2 = new Uint32Array(this.offsets.length), n2 = 0, i2 = 0, a2 = 0; a2 < r2.length; ++a2) if (r2[a2] = n2, i2 < e3.length && e3[i2] == a2) {
        ++i2, r2[a2] = n2;
        var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
        s2 > 0 && (n2 += s2);
      }
      for (var c2 = new Array(4 * r2.length), u2 = 0; u2 < r2.length; ++u2) c2[4 * u2 + 3] = 255 & r2[u2], c2[4 * u2 + 2] = (65280 & r2[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r2[u2]) >> 16, c2[4 * u2] = (4278190080 & r2[u2]) >> 24;
      return c2;
    }, e2;
  })();
  var Le = (function() {
    function t3(t4) {
      this.font = t4, this.subset = {}, this.unicodes = {}, this.next = 33;
    }
    return t3.prototype.generateCmap = function() {
      var t4, e2, r2, n2, i2;
      for (e2 in n2 = this.font.cmap.tables[0].codeMap, t4 = {}, i2 = this.subset) r2 = i2[e2], t4[e2] = n2[r2];
      return t4;
    }, t3.prototype.glyphsFor = function(t4) {
      var e2, r2, n2, i2, a2, o2, s2;
      for (n2 = {}, a2 = 0, o2 = t4.length; a2 < o2; a2++) n2[i2 = t4[a2]] = this.font.glyf.glyphFor(i2);
      for (i2 in e2 = [], n2) (null != (r2 = n2[i2]) ? r2.compound : void 0) && e2.push.apply(e2, r2.glyphIDs);
      if (e2.length > 0) for (i2 in s2 = this.glyphsFor(e2)) r2 = s2[i2], n2[i2] = r2;
      return n2;
    }, t3.prototype.encode = function(t4, e2) {
      var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2;
      for (n2 in r2 = ue.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t4), f2 = {
        0: 0
      }, m2 = r2.charMap) f2[(s2 = m2[n2]).old] = s2.new;
      for (d2 in l2 = r2.maxGlyphID, a2) d2 in f2 || (f2[d2] = l2++);
      return u2 = (function(t5) {
        var e3, r3;
        for (e3 in r3 = {}, t5) r3[t5[e3]] = e3;
        return r3;
      })(f2), h2 = Object.keys(u2).sort(function(t5, e3) {
        return t5 - e3;
      }), p2 = (function() {
        var t5, e3, r3;
        for (r3 = [], t5 = 0, e3 = h2.length; t5 < e3; t5++) o2 = h2[t5], r3.push(u2[o2]);
        return r3;
      })(), i2 = this.font.glyf.encode(a2, p2, f2), c2 = this.font.loca.encode(i2.offsets, p2), g2 = {
        cmap: this.font.cmap.raw(),
        glyf: i2.table,
        loca: c2,
        hmtx: this.font.hmtx.raw(),
        hhea: this.font.hhea.raw(),
        maxp: this.font.maxp.raw(),
        post: this.font.post.raw(),
        name: this.font.name.raw(),
        head: this.font.head.encode(e2)
      }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
    }, t3;
  })();
  E$1.API.PDFObject = (function() {
    var t3;
    function e2() {
    }
    return t3 = function(t4, e3) {
      return (Array(e3 + 1).join("0") + t4).slice(-e3);
    }, e2.convert = function(r2) {
      var n2, i2, a2, o2;
      if (Array.isArray(r2)) return "[" + (function() {
        var t4, i3, a3;
        for (a3 = [], t4 = 0, i3 = r2.length; t4 < i3; t4++) n2 = r2[t4], a3.push(e2.convert(n2));
        return a3;
      })().join(" ") + "]";
      if ("string" == typeof r2) return "/" + r2;
      if (null != r2 ? r2.isString : void 0) return "(" + r2 + ")";
      if (r2 instanceof Date) return "(D:" + t3(r2.getUTCFullYear(), 4) + t3(r2.getUTCMonth(), 2) + t3(r2.getUTCDate(), 2) + t3(r2.getUTCHours(), 2) + t3(r2.getUTCMinutes(), 2) + t3(r2.getUTCSeconds(), 2) + "Z)";
      if ("[object Object]" === {}.toString.call(r2)) {
        for (i2 in a2 = ["<<"], r2) o2 = r2[i2], a2.push("/" + i2 + " " + e2.convert(o2));
        return a2.push(">>"), a2.join("\n");
      }
      return "" + r2;
    }, e2;
  })();
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var cssesc_1;
  var hasRequiredCssesc;
  function requireCssesc() {
    if (hasRequiredCssesc) return cssesc_1;
    hasRequiredCssesc = 1;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var merge = function merge2(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      for (var key in defaults) {
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string, options) {
      options = merge(options, cssesc2.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string.charAt(0);
      var output = "";
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    cssesc_1 = cssesc;
    return cssesc_1;
  }
  var cssescExports = requireCssesc();
  var t$1 = /* @__PURE__ */ getDefaultExportFromCjs(cssescExports);
  var fontFamilyPapandreou;
  var hasRequiredFontFamilyPapandreou;
  function requireFontFamilyPapandreou() {
    if (hasRequiredFontFamilyPapandreou) return fontFamilyPapandreou;
    hasRequiredFontFamilyPapandreou = 1;
    var PLAIN = 0;
    var STRINGS = 1;
    var ESCAPING = 2;
    var IDENTIFIER = 3;
    var SEPARATING = 4;
    var SPACEAFTERIDENTIFIER = 5;
    var ESCAPINGIDENTIFIER = 6;
    var identifierPattern = /[a-z0-9_-]/i;
    var spacePattern = /[\s\t]/;
    var parse = function(str) {
      var starting = true;
      var state = PLAIN;
      var buffer = "";
      var i2 = 0;
      var quote;
      var c2;
      var names = [];
      while (true) {
        c2 = str[i2];
        if (state === PLAIN) {
          if (!c2 && starting) {
            break;
          } else if (!c2 && !starting) {
            throw new Error("Parse error");
          } else if (c2 === '"' || c2 === "'") {
            quote = c2;
            state = STRINGS;
            starting = false;
          } else if (spacePattern.test(c2)) ;
          else if (identifierPattern.test(c2)) {
            state = IDENTIFIER;
            starting = false;
            i2--;
          } else {
            throw new Error("Parse error");
          }
        } else if (state === STRINGS) {
          if (!c2) {
            throw new Error("Parse Error");
          } else if (c2 === "\\") {
            state = ESCAPING;
          } else if (c2 === quote) {
            names.push(buffer);
            buffer = "";
            state = SEPARATING;
          } else {
            buffer += c2;
          }
        } else if (state === ESCAPING) {
          if (c2 === quote || c2 === "\\") {
            buffer += c2;
            state = STRINGS;
          } else {
            throw new Error("Parse error");
          }
        } else if (state === IDENTIFIER) {
          if (!c2) {
            names.push(buffer);
            break;
          } else if (identifierPattern.test(c2)) {
            buffer += c2;
          } else if (c2 === ",") {
            names.push(buffer);
            buffer = "";
            state = PLAIN;
          } else if (spacePattern.test(c2)) {
            state = SPACEAFTERIDENTIFIER;
          } else if (c2 === "\\") {
            state = ESCAPINGIDENTIFIER;
          } else ;
        } else if (state === ESCAPINGIDENTIFIER) {
          if (/[0-9a-f]/i.test(c2)) {
            throw new Error("Parse error");
          } else {
            buffer += c2;
            state = IDENTIFIER;
          }
        } else if (state === SPACEAFTERIDENTIFIER) {
          if (!c2) {
            names.push(buffer);
            break;
          } else if (identifierPattern.test(c2)) {
            buffer += " " + c2;
            state = IDENTIFIER;
          } else if (c2 === ",") {
            names.push(buffer);
            buffer = "";
            state = PLAIN;
          } else if (spacePattern.test(c2)) ;
          else {
            throw new Error("Parse error");
          }
        } else if (state === SEPARATING) {
          if (!c2) {
            break;
          } else if (c2 === ",") {
            state = PLAIN;
          } else if (spacePattern.test(c2)) ;
          else {
            throw new Error("Parse error");
          }
        }
        i2++;
      }
      return names;
    };
    var stringsPattern = /[^a-z0-9_-]/i;
    var stringify = function(names, options) {
      var quote = options && options.quote || '"';
      if (quote !== '"' && quote !== "'") {
        throw new Error("Quote must be `'` or `\"`");
      }
      var quotePattern = new RegExp(quote, "g");
      var safeNames = [];
      for (var i2 = 0; i2 < names.length; ++i2) {
        var name = names[i2];
        if (stringsPattern.test(name)) {
          name = name.replace(/\\/g, "\\\\").replace(quotePattern, "\\" + quote);
          name = quote + name + quote;
        }
        safeNames.push(name);
      }
      return safeNames.join(", ");
    };
    fontFamilyPapandreou = {
      parse,
      stringify
    };
    return fontFamilyPapandreou;
  }
  var fontFamilyPapandreouExports = requireFontFamilyPapandreou();
  var e$1 = /* @__PURE__ */ getDefaultExportFromCjs(fontFamilyPapandreouExports);
  var path_parse;
  var hasRequiredPath_parse;
  function requirePath_parse() {
    if (hasRequiredPath_parse) return path_parse;
    hasRequiredPath_parse = 1;
    var paramCounts = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    };
    var SPECIAL_SPACES = [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
    function isSpace(ch) {
      return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || // Line terminators
      // White spaces
      ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && SPECIAL_SPACES.indexOf(ch) >= 0;
    }
    function isCommand(code) {
      switch (code | 32) {
        case 109:
        case 122:
        case 108:
        case 104:
        case 118:
        case 99:
        case 115:
        case 113:
        case 116:
        case 97:
        case 114:
          return true;
      }
      return false;
    }
    function isArc(code) {
      return (code | 32) === 97;
    }
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isDigitStart(code) {
      return code >= 48 && code <= 57 || /* 0..9 */
      code === 43 || /* + */
      code === 45 || /* - */
      code === 46;
    }
    function State(path2) {
      this.index = 0;
      this.path = path2;
      this.max = path2.length;
      this.result = [];
      this.param = 0;
      this.err = "";
      this.segmentStart = 0;
      this.data = [];
    }
    function skipSpaces(state) {
      while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {
        state.index++;
      }
    }
    function scanFlag(state) {
      var ch = state.path.charCodeAt(state.index);
      if (ch === 48) {
        state.param = 0;
        state.index++;
        return;
      }
      if (ch === 49) {
        state.param = 1;
        state.index++;
        return;
      }
      state.err = "SvgPath: arc flag can be 0 or 1 only (at pos " + state.index + ")";
    }
    function scanParam(state) {
      var start = state.index, index2 = start, max2 = state.max, zeroFirst = false, hasCeiling = false, hasDecimal = false, hasDot = false, ch;
      if (index2 >= max2) {
        state.err = "SvgPath: missed param (at pos " + index2 + ")";
        return;
      }
      ch = state.path.charCodeAt(index2);
      if (ch === 43 || ch === 45) {
        index2++;
        ch = index2 < max2 ? state.path.charCodeAt(index2) : 0;
      }
      if (!isDigit(ch) && ch !== 46) {
        state.err = "SvgPath: param should start with 0..9 or `.` (at pos " + index2 + ")";
        return;
      }
      if (ch !== 46) {
        zeroFirst = ch === 48;
        index2++;
        ch = index2 < max2 ? state.path.charCodeAt(index2) : 0;
        if (zeroFirst && index2 < max2) {
          if (ch && isDigit(ch)) {
            state.err = "SvgPath: numbers started with `0` such as `09` are illegal (at pos " + start + ")";
            return;
          }
        }
        while (index2 < max2 && isDigit(state.path.charCodeAt(index2))) {
          index2++;
          hasCeiling = true;
        }
        ch = index2 < max2 ? state.path.charCodeAt(index2) : 0;
      }
      if (ch === 46) {
        hasDot = true;
        index2++;
        while (isDigit(state.path.charCodeAt(index2))) {
          index2++;
          hasDecimal = true;
        }
        ch = index2 < max2 ? state.path.charCodeAt(index2) : 0;
      }
      if (ch === 101 || ch === 69) {
        if (hasDot && !hasCeiling && !hasDecimal) {
          state.err = "SvgPath: invalid float exponent (at pos " + index2 + ")";
          return;
        }
        index2++;
        ch = index2 < max2 ? state.path.charCodeAt(index2) : 0;
        if (ch === 43 || ch === 45) {
          index2++;
        }
        if (index2 < max2 && isDigit(state.path.charCodeAt(index2))) {
          while (index2 < max2 && isDigit(state.path.charCodeAt(index2))) {
            index2++;
          }
        } else {
          state.err = "SvgPath: invalid float exponent (at pos " + index2 + ")";
          return;
        }
      }
      state.index = index2;
      state.param = parseFloat(state.path.slice(start, index2)) + 0;
    }
    function finalizeSegment(state) {
      var cmd, cmdLC;
      cmd = state.path[state.segmentStart];
      cmdLC = cmd.toLowerCase();
      var params = state.data;
      if (cmdLC === "m" && params.length > 2) {
        state.result.push([cmd, params[0], params[1]]);
        params = params.slice(2);
        cmdLC = "l";
        cmd = cmd === "m" ? "l" : "L";
      }
      if (cmdLC === "r") {
        state.result.push([cmd].concat(params));
      } else {
        while (params.length >= paramCounts[cmdLC]) {
          state.result.push([cmd].concat(params.splice(0, paramCounts[cmdLC])));
          if (!paramCounts[cmdLC]) {
            break;
          }
        }
      }
    }
    function scanSegment(state) {
      var max2 = state.max, cmdCode, is_arc, comma_found, need_params, i2;
      state.segmentStart = state.index;
      cmdCode = state.path.charCodeAt(state.index);
      is_arc = isArc(cmdCode);
      if (!isCommand(cmdCode)) {
        state.err = "SvgPath: bad command " + state.path[state.index] + " (at pos " + state.index + ")";
        return;
      }
      need_params = paramCounts[state.path[state.index].toLowerCase()];
      state.index++;
      skipSpaces(state);
      state.data = [];
      if (!need_params) {
        finalizeSegment(state);
        return;
      }
      comma_found = false;
      for (; ; ) {
        for (i2 = need_params; i2 > 0; i2--) {
          if (is_arc && (i2 === 3 || i2 === 4)) scanFlag(state);
          else scanParam(state);
          if (state.err.length) {
            finalizeSegment(state);
            return;
          }
          state.data.push(state.param);
          skipSpaces(state);
          comma_found = false;
          if (state.index < max2 && state.path.charCodeAt(state.index) === 44) {
            state.index++;
            skipSpaces(state);
            comma_found = true;
          }
        }
        if (comma_found) {
          continue;
        }
        if (state.index >= state.max) {
          break;
        }
        if (!isDigitStart(state.path.charCodeAt(state.index))) {
          break;
        }
      }
      finalizeSegment(state);
    }
    path_parse = function pathParse(svgPath) {
      var state = new State(svgPath);
      var max2 = state.max;
      skipSpaces(state);
      while (state.index < max2 && !state.err.length) {
        scanSegment(state);
      }
      if (state.result.length) {
        if ("mM".indexOf(state.result[0][0]) < 0) {
          state.err = "SvgPath: string should start with `M` or `m`";
          state.result = [];
        } else {
          state.result[0][0] = "M";
        }
      }
      return {
        err: state.err,
        segments: state.result
      };
    };
    return path_parse;
  }
  var matrix;
  var hasRequiredMatrix;
  function requireMatrix() {
    if (hasRequiredMatrix) return matrix;
    hasRequiredMatrix = 1;
    function combine(m1, m2) {
      return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
    }
    function Matrix2() {
      if (!(this instanceof Matrix2)) {
        return new Matrix2();
      }
      this.queue = [];
      this.cache = null;
    }
    Matrix2.prototype.matrix = function(m2) {
      if (m2[0] === 1 && m2[1] === 0 && m2[2] === 0 && m2[3] === 1 && m2[4] === 0 && m2[5] === 0) {
        return this;
      }
      this.cache = null;
      this.queue.push(m2);
      return this;
    };
    Matrix2.prototype.translate = function(tx, ty) {
      if (tx !== 0 || ty !== 0) {
        this.cache = null;
        this.queue.push([1, 0, 0, 1, tx, ty]);
      }
      return this;
    };
    Matrix2.prototype.scale = function(sx, sy) {
      if (sx !== 1 || sy !== 1) {
        this.cache = null;
        this.queue.push([sx, 0, 0, sy, 0, 0]);
      }
      return this;
    };
    Matrix2.prototype.rotate = function(angle2, rx, ry) {
      var rad, cos, sin;
      if (angle2 !== 0) {
        this.translate(rx, ry);
        rad = angle2 * Math.PI / 180;
        cos = Math.cos(rad);
        sin = Math.sin(rad);
        this.queue.push([cos, sin, -sin, cos, 0, 0]);
        this.cache = null;
        this.translate(-rx, -ry);
      }
      return this;
    };
    Matrix2.prototype.skewX = function(angle2) {
      if (angle2 !== 0) {
        this.cache = null;
        this.queue.push([1, 0, Math.tan(angle2 * Math.PI / 180), 1, 0, 0]);
      }
      return this;
    };
    Matrix2.prototype.skewY = function(angle2) {
      if (angle2 !== 0) {
        this.cache = null;
        this.queue.push([1, Math.tan(angle2 * Math.PI / 180), 0, 1, 0, 0]);
      }
      return this;
    };
    Matrix2.prototype.toArray = function() {
      if (this.cache) {
        return this.cache;
      }
      if (!this.queue.length) {
        this.cache = [1, 0, 0, 1, 0, 0];
        return this.cache;
      }
      this.cache = this.queue[0];
      if (this.queue.length === 1) {
        return this.cache;
      }
      for (var i2 = 1; i2 < this.queue.length; i2++) {
        this.cache = combine(this.cache, this.queue[i2]);
      }
      return this.cache;
    };
    Matrix2.prototype.calc = function(x2, y2, isRelative) {
      var m2;
      if (!this.queue.length) {
        return [x2, y2];
      }
      if (!this.cache) {
        this.cache = this.toArray();
      }
      m2 = this.cache;
      return [x2 * m2[0] + y2 * m2[2] + (isRelative ? 0 : m2[4]), x2 * m2[1] + y2 * m2[3] + (isRelative ? 0 : m2[5])];
    };
    matrix = Matrix2;
    return matrix;
  }
  var transform_parse;
  var hasRequiredTransform_parse;
  function requireTransform_parse() {
    if (hasRequiredTransform_parse) return transform_parse;
    hasRequiredTransform_parse = 1;
    var Matrix2 = requireMatrix();
    var operations = {
      matrix: true,
      scale: true,
      rotate: true,
      translate: true,
      skewX: true,
      skewY: true
    };
    var CMD_SPLIT_RE = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
    var PARAMS_SPLIT_RE = /[\s,]+/;
    transform_parse = function transformParse(transformString) {
      var matrix2 = new Matrix2();
      var cmd, params;
      transformString.split(CMD_SPLIT_RE).forEach(function(item) {
        if (!item.length) {
          return;
        }
        if (typeof operations[item] !== "undefined") {
          cmd = item;
          return;
        }
        params = item.split(PARAMS_SPLIT_RE).map(function(i2) {
          return +i2 || 0;
        });
        switch (cmd) {
          case "matrix":
            if (params.length === 6) {
              matrix2.matrix(params);
            }
            return;
          case "scale":
            if (params.length === 1) {
              matrix2.scale(params[0], params[0]);
            } else if (params.length === 2) {
              matrix2.scale(params[0], params[1]);
            }
            return;
          case "rotate":
            if (params.length === 1) {
              matrix2.rotate(params[0], 0, 0);
            } else if (params.length === 3) {
              matrix2.rotate(params[0], params[1], params[2]);
            }
            return;
          case "translate":
            if (params.length === 1) {
              matrix2.translate(params[0], 0);
            } else if (params.length === 2) {
              matrix2.translate(params[0], params[1]);
            }
            return;
          case "skewX":
            if (params.length === 1) {
              matrix2.skewX(params[0]);
            }
            return;
          case "skewY":
            if (params.length === 1) {
              matrix2.skewY(params[0]);
            }
            return;
        }
      });
      return matrix2;
    };
    return transform_parse;
  }
  var a2c;
  var hasRequiredA2c;
  function requireA2c() {
    if (hasRequiredA2c) return a2c;
    hasRequiredA2c = 1;
    var TAU = Math.PI * 2;
    function unit_vector_angle(ux, uy, vx, vy) {
      var sign = ux * vy - uy * vx < 0 ? -1 : 1;
      var dot = ux * vx + uy * vy;
      if (dot > 1) {
        dot = 1;
      }
      if (dot < -1) {
        dot = -1;
      }
      return sign * Math.acos(dot);
    }
    function get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {
      var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
      var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;
      var rx_sq = rx * rx;
      var ry_sq = ry * ry;
      var x1p_sq = x1p * x1p;
      var y1p_sq = y1p * y1p;
      var radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;
      if (radicant < 0) {
        radicant = 0;
      }
      radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
      radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);
      var cxp = radicant * rx / ry * y1p;
      var cyp = radicant * -ry / rx * x1p;
      var cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;
      var cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;
      var v1x = (x1p - cxp) / rx;
      var v1y = (y1p - cyp) / ry;
      var v2x = (-x1p - cxp) / rx;
      var v2y = (-y1p - cyp) / ry;
      var theta1 = unit_vector_angle(1, 0, v1x, v1y);
      var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);
      if (fs === 0 && delta_theta > 0) {
        delta_theta -= TAU;
      }
      if (fs === 1 && delta_theta < 0) {
        delta_theta += TAU;
      }
      return [cx, cy, theta1, delta_theta];
    }
    function approximate_unit_arc(theta1, delta_theta) {
      var alpha = 4 / 3 * Math.tan(delta_theta / 4);
      var x1 = Math.cos(theta1);
      var y1 = Math.sin(theta1);
      var x2 = Math.cos(theta1 + delta_theta);
      var y2 = Math.sin(theta1 + delta_theta);
      return [x1, y1, x1 - y1 * alpha, y1 + x1 * alpha, x2 + y2 * alpha, y2 - x2 * alpha, x2, y2];
    }
    a2c = function a2c2(x1, y1, x2, y2, fa, fs, rx, ry, phi) {
      var sin_phi = Math.sin(phi * TAU / 360);
      var cos_phi = Math.cos(phi * TAU / 360);
      var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
      var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;
      if (x1p === 0 && y1p === 0) {
        return [];
      }
      if (rx === 0 || ry === 0) {
        return [];
      }
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      var lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);
      if (lambda > 1) {
        rx *= Math.sqrt(lambda);
        ry *= Math.sqrt(lambda);
      }
      var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);
      var result = [];
      var theta1 = cc[2];
      var delta_theta = cc[3];
      var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
      delta_theta /= segments;
      for (var i2 = 0; i2 < segments; i2++) {
        result.push(approximate_unit_arc(theta1, delta_theta));
        theta1 += delta_theta;
      }
      return result.map(function(curve) {
        for (var i3 = 0; i3 < curve.length; i3 += 2) {
          var x3 = curve[i3 + 0];
          var y3 = curve[i3 + 1];
          x3 *= rx;
          y3 *= ry;
          var xp = cos_phi * x3 - sin_phi * y3;
          var yp = sin_phi * x3 + cos_phi * y3;
          curve[i3 + 0] = xp + cc[0];
          curve[i3 + 1] = yp + cc[1];
        }
        return curve;
      });
    };
    return a2c;
  }
  var ellipse;
  var hasRequiredEllipse;
  function requireEllipse() {
    if (hasRequiredEllipse) return ellipse;
    hasRequiredEllipse = 1;
    var epsilon = 1e-10;
    var torad = Math.PI / 180;
    function Ellipse(rx, ry, ax) {
      if (!(this instanceof Ellipse)) {
        return new Ellipse(rx, ry, ax);
      }
      this.rx = rx;
      this.ry = ry;
      this.ax = ax;
    }
    Ellipse.prototype.transform = function(m2) {
      var c2 = Math.cos(this.ax * torad), s2 = Math.sin(this.ax * torad);
      var ma = [this.rx * (m2[0] * c2 + m2[2] * s2), this.rx * (m2[1] * c2 + m2[3] * s2), this.ry * (-m2[0] * s2 + m2[2] * c2), this.ry * (-m2[1] * s2 + m2[3] * c2)];
      var J2 = ma[0] * ma[0] + ma[2] * ma[2], K2 = ma[1] * ma[1] + ma[3] * ma[3];
      var D2 = ((ma[0] - ma[3]) * (ma[0] - ma[3]) + (ma[2] + ma[1]) * (ma[2] + ma[1])) * ((ma[0] + ma[3]) * (ma[0] + ma[3]) + (ma[2] - ma[1]) * (ma[2] - ma[1]));
      var JK = (J2 + K2) / 2;
      if (D2 < epsilon * JK) {
        this.rx = this.ry = Math.sqrt(JK);
        this.ax = 0;
        return this;
      }
      var L2 = ma[0] * ma[1] + ma[2] * ma[3];
      D2 = Math.sqrt(D2);
      var l1 = JK + D2 / 2, l2 = JK - D2 / 2;
      this.ax = Math.abs(L2) < epsilon && Math.abs(l1 - K2) < epsilon ? 90 : Math.atan(Math.abs(L2) > Math.abs(l1 - K2) ? (l1 - J2) / L2 : L2 / (l1 - K2)) * 180 / Math.PI;
      if (this.ax >= 0) {
        this.rx = Math.sqrt(l1);
        this.ry = Math.sqrt(l2);
      } else {
        this.ax += 90;
        this.rx = Math.sqrt(l2);
        this.ry = Math.sqrt(l1);
      }
      return this;
    };
    Ellipse.prototype.isDegenerate = function() {
      return this.rx < epsilon * this.ry || this.ry < epsilon * this.rx;
    };
    ellipse = Ellipse;
    return ellipse;
  }
  var svgpath$1;
  var hasRequiredSvgpath$1;
  function requireSvgpath$1() {
    if (hasRequiredSvgpath$1) return svgpath$1;
    hasRequiredSvgpath$1 = 1;
    var pathParse = requirePath_parse();
    var transformParse = requireTransform_parse();
    var matrix2 = requireMatrix();
    var a2c2 = requireA2c();
    var ellipse2 = requireEllipse();
    function SvgPath(path2) {
      if (!(this instanceof SvgPath)) {
        return new SvgPath(path2);
      }
      var pstate = pathParse(path2);
      this.segments = pstate.segments;
      this.err = pstate.err;
      this.__stack = [];
    }
    SvgPath.from = function(src) {
      if (typeof src === "string") return new SvgPath(src);
      if (src instanceof SvgPath) {
        var s2 = new SvgPath("");
        s2.err = src.err;
        s2.segments = src.segments.map(function(sgm) {
          return sgm.slice();
        });
        s2.__stack = src.__stack.map(function(m2) {
          return matrix2().matrix(m2.toArray());
        });
        return s2;
      }
      throw new Error("SvgPath.from: invalid param type " + src);
    };
    SvgPath.prototype.__matrix = function(m2) {
      var self2 = this, i2;
      if (!m2.queue.length) {
        return;
      }
      this.iterate(function(s2, index2, x2, y2) {
        var p2, result, name, isRelative;
        switch (s2[0]) {
          // Process 'assymetric' commands separately
          case "v":
            p2 = m2.calc(0, s2[1], true);
            result = p2[0] === 0 ? ["v", p2[1]] : ["l", p2[0], p2[1]];
            break;
          case "V":
            p2 = m2.calc(x2, s2[1], false);
            result = p2[0] === m2.calc(x2, y2, false)[0] ? ["V", p2[1]] : ["L", p2[0], p2[1]];
            break;
          case "h":
            p2 = m2.calc(s2[1], 0, true);
            result = p2[1] === 0 ? ["h", p2[0]] : ["l", p2[0], p2[1]];
            break;
          case "H":
            p2 = m2.calc(s2[1], y2, false);
            result = p2[1] === m2.calc(x2, y2, false)[1] ? ["H", p2[0]] : ["L", p2[0], p2[1]];
            break;
          case "a":
          case "A":
            var ma = m2.toArray();
            var e2 = ellipse2(s2[1], s2[2], s2[3]).transform(ma);
            if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {
              s2[5] = s2[5] ? "0" : "1";
            }
            p2 = m2.calc(s2[6], s2[7], s2[0] === "a");
            if (s2[0] === "A" && s2[6] === x2 && s2[7] === y2 || s2[0] === "a" && s2[6] === 0 && s2[7] === 0) {
              result = [s2[0] === "a" ? "l" : "L", p2[0], p2[1]];
              break;
            }
            if (e2.isDegenerate()) {
              result = [s2[0] === "a" ? "l" : "L", p2[0], p2[1]];
            } else {
              result = [s2[0], e2.rx, e2.ry, e2.ax, s2[4], s2[5], p2[0], p2[1]];
            }
            break;
          case "m":
            isRelative = index2 > 0;
            p2 = m2.calc(s2[1], s2[2], isRelative);
            result = ["m", p2[0], p2[1]];
            break;
          default:
            name = s2[0];
            result = [name];
            isRelative = name.toLowerCase() === name;
            for (i2 = 1; i2 < s2.length; i2 += 2) {
              p2 = m2.calc(s2[i2], s2[i2 + 1], isRelative);
              result.push(p2[0], p2[1]);
            }
        }
        self2.segments[index2] = result;
      }, true);
    };
    SvgPath.prototype.__evaluateStack = function() {
      var m2, i2;
      if (!this.__stack.length) {
        return;
      }
      if (this.__stack.length === 1) {
        this.__matrix(this.__stack[0]);
        this.__stack = [];
        return;
      }
      m2 = matrix2();
      i2 = this.__stack.length;
      while (--i2 >= 0) {
        m2.matrix(this.__stack[i2].toArray());
      }
      this.__matrix(m2);
      this.__stack = [];
    };
    SvgPath.prototype.toString = function() {
      var result = "", prevCmd = "", cmdSkipped = false;
      this.__evaluateStack();
      for (var i2 = 0, len = this.segments.length; i2 < len; i2++) {
        var segment = this.segments[i2];
        var cmd = segment[0];
        if (cmd !== prevCmd || cmd === "m" || cmd === "M") {
          if (cmd === "m" && prevCmd === "z") result += " ";
          result += cmd;
          cmdSkipped = false;
        } else {
          cmdSkipped = true;
        }
        for (var pos = 1; pos < segment.length; pos++) {
          var val = segment[pos];
          if (pos === 1) {
            if (cmdSkipped && val >= 0) result += " ";
          } else if (val >= 0) result += " ";
          result += val;
        }
        prevCmd = cmd;
      }
      return result;
    };
    SvgPath.prototype.translate = function(x2, y2) {
      this.__stack.push(matrix2().translate(x2, y2 || 0));
      return this;
    };
    SvgPath.prototype.scale = function(sx, sy) {
      this.__stack.push(matrix2().scale(sx, !sy && sy !== 0 ? sx : sy));
      return this;
    };
    SvgPath.prototype.rotate = function(angle2, rx, ry) {
      this.__stack.push(matrix2().rotate(angle2, rx || 0, ry || 0));
      return this;
    };
    SvgPath.prototype.skewX = function(degrees) {
      this.__stack.push(matrix2().skewX(degrees));
      return this;
    };
    SvgPath.prototype.skewY = function(degrees) {
      this.__stack.push(matrix2().skewY(degrees));
      return this;
    };
    SvgPath.prototype.matrix = function(m2) {
      this.__stack.push(matrix2().matrix(m2));
      return this;
    };
    SvgPath.prototype.transform = function(transformString) {
      if (!transformString.trim()) {
        return this;
      }
      this.__stack.push(transformParse(transformString));
      return this;
    };
    SvgPath.prototype.round = function(d2) {
      var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l2;
      d2 = d2 || 0;
      this.__evaluateStack();
      this.segments.forEach(function(s2) {
        var isRelative = s2[0].toLowerCase() === s2[0];
        switch (s2[0]) {
          case "H":
          case "h":
            if (isRelative) {
              s2[1] += deltaX;
            }
            deltaX = s2[1] - s2[1].toFixed(d2);
            s2[1] = +s2[1].toFixed(d2);
            return;
          case "V":
          case "v":
            if (isRelative) {
              s2[1] += deltaY;
            }
            deltaY = s2[1] - s2[1].toFixed(d2);
            s2[1] = +s2[1].toFixed(d2);
            return;
          case "Z":
          case "z":
            deltaX = contourStartDeltaX;
            deltaY = contourStartDeltaY;
            return;
          case "M":
          case "m":
            if (isRelative) {
              s2[1] += deltaX;
              s2[2] += deltaY;
            }
            deltaX = s2[1] - s2[1].toFixed(d2);
            deltaY = s2[2] - s2[2].toFixed(d2);
            contourStartDeltaX = deltaX;
            contourStartDeltaY = deltaY;
            s2[1] = +s2[1].toFixed(d2);
            s2[2] = +s2[2].toFixed(d2);
            return;
          case "A":
          case "a":
            if (isRelative) {
              s2[6] += deltaX;
              s2[7] += deltaY;
            }
            deltaX = s2[6] - s2[6].toFixed(d2);
            deltaY = s2[7] - s2[7].toFixed(d2);
            s2[1] = +s2[1].toFixed(d2);
            s2[2] = +s2[2].toFixed(d2);
            s2[3] = +s2[3].toFixed(d2 + 2);
            s2[6] = +s2[6].toFixed(d2);
            s2[7] = +s2[7].toFixed(d2);
            return;
          default:
            l2 = s2.length;
            if (isRelative) {
              s2[l2 - 2] += deltaX;
              s2[l2 - 1] += deltaY;
            }
            deltaX = s2[l2 - 2] - s2[l2 - 2].toFixed(d2);
            deltaY = s2[l2 - 1] - s2[l2 - 1].toFixed(d2);
            s2.forEach(function(val, i2) {
              if (!i2) {
                return;
              }
              s2[i2] = +s2[i2].toFixed(d2);
            });
            return;
        }
      });
      return this;
    };
    SvgPath.prototype.iterate = function(iterator, keepLazyStack) {
      var segments = this.segments, replacements = {}, needReplace = false, lastX = 0, lastY = 0, countourStartX = 0, countourStartY = 0;
      var i2, j2, newSegments;
      if (!keepLazyStack) {
        this.__evaluateStack();
      }
      segments.forEach(function(s2, index2) {
        var res = iterator(s2, index2, lastX, lastY);
        if (Array.isArray(res)) {
          replacements[index2] = res;
          needReplace = true;
        }
        var isRelative = s2[0] === s2[0].toLowerCase();
        switch (s2[0]) {
          case "m":
          case "M":
            lastX = s2[1] + (isRelative ? lastX : 0);
            lastY = s2[2] + (isRelative ? lastY : 0);
            countourStartX = lastX;
            countourStartY = lastY;
            return;
          case "h":
          case "H":
            lastX = s2[1] + (isRelative ? lastX : 0);
            return;
          case "v":
          case "V":
            lastY = s2[1] + (isRelative ? lastY : 0);
            return;
          case "z":
          case "Z":
            lastX = countourStartX;
            lastY = countourStartY;
            return;
          default:
            lastX = s2[s2.length - 2] + (isRelative ? lastX : 0);
            lastY = s2[s2.length - 1] + (isRelative ? lastY : 0);
        }
      });
      if (!needReplace) {
        return this;
      }
      newSegments = [];
      for (i2 = 0; i2 < segments.length; i2++) {
        if (typeof replacements[i2] !== "undefined") {
          for (j2 = 0; j2 < replacements[i2].length; j2++) {
            newSegments.push(replacements[i2][j2]);
          }
        } else {
          newSegments.push(segments[i2]);
        }
      }
      this.segments = newSegments;
      return this;
    };
    SvgPath.prototype.abs = function() {
      this.iterate(function(s2, index2, x2, y2) {
        var name = s2[0], nameUC = name.toUpperCase(), i2;
        if (name === nameUC) {
          return;
        }
        s2[0] = nameUC;
        switch (name) {
          case "v":
            s2[1] += y2;
            return;
          case "a":
            s2[6] += x2;
            s2[7] += y2;
            return;
          default:
            for (i2 = 1; i2 < s2.length; i2++) {
              s2[i2] += i2 % 2 ? x2 : y2;
            }
        }
      }, true);
      return this;
    };
    SvgPath.prototype.rel = function() {
      this.iterate(function(s2, index2, x2, y2) {
        var name = s2[0], nameLC = name.toLowerCase(), i2;
        if (name === nameLC) {
          return;
        }
        if (index2 === 0 && name === "M") {
          return;
        }
        s2[0] = nameLC;
        switch (name) {
          case "V":
            s2[1] -= y2;
            return;
          case "A":
            s2[6] -= x2;
            s2[7] -= y2;
            return;
          default:
            for (i2 = 1; i2 < s2.length; i2++) {
              s2[i2] -= i2 % 2 ? x2 : y2;
            }
        }
      }, true);
      return this;
    };
    SvgPath.prototype.unarc = function() {
      this.iterate(function(s2, index2, x2, y2) {
        var new_segments, nextX, nextY, result = [], name = s2[0];
        if (name !== "A" && name !== "a") {
          return null;
        }
        if (name === "a") {
          nextX = x2 + s2[6];
          nextY = y2 + s2[7];
        } else {
          nextX = s2[6];
          nextY = s2[7];
        }
        new_segments = a2c2(x2, y2, nextX, nextY, s2[4], s2[5], s2[1], s2[2], s2[3]);
        if (new_segments.length === 0) {
          return [[s2[0] === "a" ? "l" : "L", s2[6], s2[7]]];
        }
        new_segments.forEach(function(s3) {
          result.push(["C", s3[2], s3[3], s3[4], s3[5], s3[6], s3[7]]);
        });
        return result;
      });
      return this;
    };
    SvgPath.prototype.unshort = function() {
      var segments = this.segments;
      var prevControlX, prevControlY, prevSegment;
      var curControlX, curControlY;
      this.iterate(function(s2, idx, x2, y2) {
        var name = s2[0], nameUC = name.toUpperCase(), isRelative;
        if (!idx) {
          return;
        }
        if (nameUC === "T") {
          isRelative = name === "t";
          prevSegment = segments[idx - 1];
          if (prevSegment[0] === "Q") {
            prevControlX = prevSegment[1] - x2;
            prevControlY = prevSegment[2] - y2;
          } else if (prevSegment[0] === "q") {
            prevControlX = prevSegment[1] - prevSegment[3];
            prevControlY = prevSegment[2] - prevSegment[4];
          } else {
            prevControlX = 0;
            prevControlY = 0;
          }
          curControlX = -prevControlX;
          curControlY = -prevControlY;
          if (!isRelative) {
            curControlX += x2;
            curControlY += y2;
          }
          segments[idx] = [isRelative ? "q" : "Q", curControlX, curControlY, s2[1], s2[2]];
        } else if (nameUC === "S") {
          isRelative = name === "s";
          prevSegment = segments[idx - 1];
          if (prevSegment[0] === "C") {
            prevControlX = prevSegment[3] - x2;
            prevControlY = prevSegment[4] - y2;
          } else if (prevSegment[0] === "c") {
            prevControlX = prevSegment[3] - prevSegment[5];
            prevControlY = prevSegment[4] - prevSegment[6];
          } else {
            prevControlX = 0;
            prevControlY = 0;
          }
          curControlX = -prevControlX;
          curControlY = -prevControlY;
          if (!isRelative) {
            curControlX += x2;
            curControlY += y2;
          }
          segments[idx] = [isRelative ? "c" : "C", curControlX, curControlY, s2[1], s2[2], s2[3], s2[4]];
        }
      });
      return this;
    };
    svgpath$1 = SvgPath;
    return svgpath$1;
  }
  var svgpath;
  var hasRequiredSvgpath;
  function requireSvgpath() {
    if (hasRequiredSvgpath) return svgpath;
    hasRequiredSvgpath = 1;
    svgpath = requireSvgpath$1();
    return svgpath;
  }
  var svgpathExports = requireSvgpath();
  var s$1 = /* @__PURE__ */ getDefaultExportFromCjs(svgpathExports);
  var calculateSingle = function(input) {
    var selector = input, findMatch, typeCount = {
      "a": 0,
      "b": 0,
      "c": 0
    }, parts = [], attributeRegex2 = /(\[[^\]]+\])/g, idRegex2 = /(#[^\#\s\+>~\.\[:\)]+)/g, classRegex2 = /(\.[^\s\+>~\.\[:\)]+)/g, pseudoElementRegex2 = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi, pseudoClassWithBracketsRegex2 = /(:(?!not|global|local)[\w-]+\([^\)]*\))/gi, pseudoClassRegex2 = /(:(?!not|global|local)[^\s\+>~\.\[:]+)/g, elementRegex2 = /([^\s\+>~\.\[:]+)/g;
    findMatch = function(regex, type) {
      var matches, i2, len, match, index2, length;
      if (regex.test(selector)) {
        matches = selector.match(regex);
        for (i2 = 0, len = matches.length; i2 < len; i2 += 1) {
          typeCount[type] += 1;
          match = matches[i2];
          index2 = selector.indexOf(match);
          length = match.length;
          parts.push({
            selector: input.substr(index2, length),
            type,
            index: index2,
            length
          });
          selector = selector.replace(match, Array(length + 1).join(" "));
        }
      }
    };
    (function() {
      var replaceWithPlainText = function(regex) {
        var matches, i2, len, match;
        if (regex.test(selector)) {
          matches = selector.match(regex);
          for (i2 = 0, len = matches.length; i2 < len; i2 += 1) {
            match = matches[i2];
            selector = selector.replace(match, Array(match.length + 1).join("A"));
          }
        }
      }, escapeHexadecimalRegex = /\\[0-9A-Fa-f]{6}\s?/g, escapeHexadecimalRegex2 = /\\[0-9A-Fa-f]{1,5}\s/g, escapeSpecialCharacter = /\\./g;
      replaceWithPlainText(escapeHexadecimalRegex);
      replaceWithPlainText(escapeHexadecimalRegex2);
      replaceWithPlainText(escapeSpecialCharacter);
    })();
    (function() {
      var regex = /{[^]*/gm, matches, i2, len, match;
      if (regex.test(selector)) {
        matches = selector.match(regex);
        for (i2 = 0, len = matches.length; i2 < len; i2 += 1) {
          match = matches[i2];
          selector = selector.replace(match, Array(match.length + 1).join(" "));
        }
      }
    })();
    findMatch(attributeRegex2, "b");
    findMatch(idRegex2, "a");
    findMatch(classRegex2, "b");
    findMatch(pseudoElementRegex2, "c");
    findMatch(pseudoClassWithBracketsRegex2, "b");
    findMatch(pseudoClassRegex2, "b");
    selector = selector.replace(/[\*\s\+>~]/g, " ");
    selector = selector.replace(/[#\.]/g, " ");
    selector = selector.replace(/:not/g, "    ");
    selector = selector.replace(/:local/g, "      ");
    selector = selector.replace(/:global/g, "       ");
    selector = selector.replace(/[\(\)]/g, " ");
    findMatch(elementRegex2, "c");
    parts.sort(function(a2, b2) {
      return a2.index - b2.index;
    });
    return {
      selector: input,
      specificity: "0," + typeCount.a.toString() + "," + typeCount.b.toString() + "," + typeCount.c.toString(),
      specificityArray: [0, typeCount.a, typeCount.b, typeCount.c],
      parts
    };
  };
  var compare = function(a2, b2) {
    var aSpecificity, bSpecificity, i2;
    if (typeof a2 === "string") {
      if (a2.indexOf(",") !== -1) {
        throw "Invalid CSS selector";
      } else {
        aSpecificity = calculateSingle(a2)["specificityArray"];
      }
    } else if (Array.isArray(a2)) {
      if (a2.filter(function(e2) {
        return typeof e2 === "number";
      }).length !== 4) {
        throw "Invalid specificity array";
      } else {
        aSpecificity = a2;
      }
    } else {
      throw "Invalid CSS selector or specificity array";
    }
    if (typeof b2 === "string") {
      if (b2.indexOf(",") !== -1) {
        throw "Invalid CSS selector";
      } else {
        bSpecificity = calculateSingle(b2)["specificityArray"];
      }
    } else if (Array.isArray(b2)) {
      if (b2.filter(function(e2) {
        return typeof e2 === "number";
      }).length !== 4) {
        throw "Invalid specificity array";
      } else {
        bSpecificity = b2;
      }
    } else {
      throw "Invalid CSS selector or specificity array";
    }
    for (i2 = 0; i2 < 4; i2 += 1) {
      if (aSpecificity[i2] < bSpecificity[i2]) {
        return -1;
      } else if (aSpecificity[i2] > bSpecificity[i2]) {
        return 1;
      }
    }
    return 0;
  };
  var l$1 = function(t3, e2) {
    return l$1 = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(t4, e3) {
      t4.__proto__ = e3;
    } || function(t4, e3) {
      for (var r2 in e3) Object.prototype.hasOwnProperty.call(e3, r2) && (t4[r2] = e3[r2]);
    }, l$1(t3, e2);
  };
  function u$1(t3, e2) {
    if ("function" != typeof e2 && null !== e2) throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
    function r2() {
      this.constructor = t3;
    }
    l$1(t3, e2), t3.prototype = null === e2 ? Object.create(e2) : (r2.prototype = e2.prototype, new r2());
  }
  var h$1 = function() {
    return h$1 = Object.assign || function(t3) {
      for (var e2, r2 = 1, i2 = arguments.length; r2 < i2; r2++) for (var n2 in e2 = arguments[r2]) Object.prototype.hasOwnProperty.call(e2, n2) && (t3[n2] = e2[n2]);
      return t3;
    }, h$1.apply(this, arguments);
  };
  function f$1(t3, e2, r2, i2) {
    return new (r2 || (r2 = Promise))(function(n2, a2) {
      function s2(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          a2(t5);
        }
      }
      function o2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          a2(t5);
        }
      }
      function l2(t4) {
        var e3;
        t4.done ? n2(t4.value) : (e3 = t4.value, e3 instanceof r2 ? e3 : new r2(function(t5) {
          t5(e3);
        })).then(s2, o2);
      }
      l2((i2 = i2.apply(t3, e2 || [])).next());
    });
  }
  function c$2(t3, e2) {
    var r2, i2, n2, a2, s2 = {
      label: 0,
      sent: function() {
        if (1 & n2[0]) throw n2[1];
        return n2[1];
      },
      trys: [],
      ops: []
    };
    return a2 = {
      next: o2(0),
      throw: o2(1),
      return: o2(2)
    }, "function" == typeof Symbol && (a2[Symbol.iterator] = function() {
      return this;
    }), a2;
    function o2(a3) {
      return function(o3) {
        return (function(a4) {
          if (r2) throw new TypeError("Generator is already executing.");
          for (; s2; ) try {
            if (r2 = 1, i2 && (n2 = 2 & a4[0] ? i2.return : a4[0] ? i2.throw || ((n2 = i2.return) && n2.call(i2), 0) : i2.next) && !(n2 = n2.call(i2, a4[1])).done) return n2;
            switch (i2 = 0, n2 && (a4 = [2 & a4[0], n2.value]), a4[0]) {
              case 0:
              case 1:
                n2 = a4;
                break;
              case 4:
                return s2.label++, {
                  value: a4[1],
                  done: false
                };
              case 5:
                s2.label++, i2 = a4[1], a4 = [0];
                continue;
              case 7:
                a4 = s2.ops.pop(), s2.trys.pop();
                continue;
              default:
                if (!(n2 = s2.trys, (n2 = n2.length > 0 && n2[n2.length - 1]) || 6 !== a4[0] && 2 !== a4[0])) {
                  s2 = 0;
                  continue;
                }
                if (3 === a4[0] && (!n2 || a4[1] > n2[0] && a4[1] < n2[3])) {
                  s2.label = a4[1];
                  break;
                }
                if (6 === a4[0] && s2.label < n2[1]) {
                  s2.label = n2[1], n2 = a4;
                  break;
                }
                if (n2 && s2.label < n2[2]) {
                  s2.label = n2[2], s2.ops.push(a4);
                  break;
                }
                n2[2] && s2.ops.pop(), s2.trys.pop();
                continue;
            }
            a4 = e2.call(t3, s2);
          } catch (t4) {
            a4 = [6, t4], i2 = 0;
          } finally {
            r2 = n2 = 0;
          }
          if (5 & a4[0]) throw a4[1];
          return {
            value: a4[0] ? a4[1] : void 0,
            done: true
          };
        })([a3, o3]);
      };
    }
  }
  var p$1 = (function() {
    function t3(t4) {
      if (this.a = void 0, this.r = 0, this.g = 0, this.b = 0, this.simpleColors = {}, this.colorDefs = [], this.ok = false, t4) {
        for (var e2 in "#" == t4.charAt(0) && (t4 = t4.substr(1, 6)), t4 = (t4 = t4.replace(/ /g, "")).toLowerCase(), this.simpleColors = {
          aliceblue: "f0f8ff",
          antiquewhite: "faebd7",
          aqua: "00ffff",
          aquamarine: "7fffd4",
          azure: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "000000",
          blanchedalmond: "ffebcd",
          blue: "0000ff",
          blueviolet: "8a2be2",
          brown: "a52a2a",
          burlywood: "deb887",
          cadetblue: "5f9ea0",
          chartreuse: "7fff00",
          chocolate: "d2691e",
          coral: "ff7f50",
          cornflowerblue: "6495ed",
          cornsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "00ffff",
          darkblue: "00008b",
          darkcyan: "008b8b",
          darkgoldenrod: "b8860b",
          darkgray: "a9a9a9",
          darkgrey: "a9a9a9",
          darkgreen: "006400",
          darkkhaki: "bdb76b",
          darkmagenta: "8b008b",
          darkolivegreen: "556b2f",
          darkorange: "ff8c00",
          darkorchid: "9932cc",
          darkred: "8b0000",
          darksalmon: "e9967a",
          darkseagreen: "8fbc8f",
          darkslateblue: "483d8b",
          darkslategray: "2f4f4f",
          darkslategrey: "2f4f4f",
          darkturquoise: "00ced1",
          darkviolet: "9400d3",
          deeppink: "ff1493",
          deepskyblue: "00bfff",
          dimgray: "696969",
          dimgrey: "696969",
          dodgerblue: "1e90ff",
          feldspar: "d19275",
          firebrick: "b22222",
          floralwhite: "fffaf0",
          forestgreen: "228b22",
          fuchsia: "ff00ff",
          gainsboro: "dcdcdc",
          ghostwhite: "f8f8ff",
          gold: "ffd700",
          goldenrod: "daa520",
          gray: "808080",
          grey: "808080",
          green: "008000",
          greenyellow: "adff2f",
          honeydew: "f0fff0",
          hotpink: "ff69b4",
          indianred: "cd5c5c",
          indigo: "4b0082",
          ivory: "fffff0",
          khaki: "f0e68c",
          lavender: "e6e6fa",
          lavenderblush: "fff0f5",
          lawngreen: "7cfc00",
          lemonchiffon: "fffacd",
          lightblue: "add8e6",
          lightcoral: "f08080",
          lightcyan: "e0ffff",
          lightgoldenrodyellow: "fafad2",
          lightgray: "d3d3d3",
          lightgrey: "d3d3d3",
          lightgreen: "90ee90",
          lightpink: "ffb6c1",
          lightsalmon: "ffa07a",
          lightseagreen: "20b2aa",
          lightskyblue: "87cefa",
          lightslateblue: "8470ff",
          lightslategray: "778899",
          lightslategrey: "778899",
          lightsteelblue: "b0c4de",
          lightyellow: "ffffe0",
          lime: "00ff00",
          limegreen: "32cd32",
          linen: "faf0e6",
          magenta: "ff00ff",
          maroon: "800000",
          mediumaquamarine: "66cdaa",
          mediumblue: "0000cd",
          mediumorchid: "ba55d3",
          mediumpurple: "9370d8",
          mediumseagreen: "3cb371",
          mediumslateblue: "7b68ee",
          mediumspringgreen: "00fa9a",
          mediumturquoise: "48d1cc",
          mediumvioletred: "c71585",
          midnightblue: "191970",
          mintcream: "f5fffa",
          mistyrose: "ffe4e1",
          moccasin: "ffe4b5",
          navajowhite: "ffdead",
          navy: "000080",
          oldlace: "fdf5e6",
          olive: "808000",
          olivedrab: "6b8e23",
          orange: "ffa500",
          orangered: "ff4500",
          orchid: "da70d6",
          palegoldenrod: "eee8aa",
          palegreen: "98fb98",
          paleturquoise: "afeeee",
          palevioletred: "d87093",
          papayawhip: "ffefd5",
          peachpuff: "ffdab9",
          peru: "cd853f",
          pink: "ffc0cb",
          plum: "dda0dd",
          powderblue: "b0e0e6",
          purple: "800080",
          red: "ff0000",
          rosybrown: "bc8f8f",
          royalblue: "4169e1",
          saddlebrown: "8b4513",
          salmon: "fa8072",
          sandybrown: "f4a460",
          seagreen: "2e8b57",
          seashell: "fff5ee",
          sienna: "a0522d",
          silver: "c0c0c0",
          skyblue: "87ceeb",
          slateblue: "6a5acd",
          slategray: "708090",
          slategrey: "708090",
          snow: "fffafa",
          springgreen: "00ff7f",
          steelblue: "4682b4",
          tan: "d2b48c",
          teal: "008080",
          thistle: "d8bfd8",
          tomato: "ff6347",
          turquoise: "40e0d0",
          violet: "ee82ee",
          violetred: "d02090",
          wheat: "f5deb3",
          white: "ffffff",
          whitesmoke: "f5f5f5",
          yellow: "ffff00",
          yellowgreen: "9acd32"
        }, this.simpleColors) t4 == e2 && (t4 = this.simpleColors[e2]);
        this.colorDefs = [{
          re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
          example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
          process: function(t5) {
            return [parseInt(t5[1]), parseInt(t5[2]), parseInt(t5[3])];
          }
        }, {
          re: /^rgb\(([0-9.]+)%,\s*([0-9.]+)%,\s*([0-9.]+)%\)$/,
          example: ["rgb(50.5%, 25.75%, 75.5%)", "rgb(100%,0%,0%)"],
          process: function(t5) {
            return [Math.round(2.55 * parseFloat(t5[1])), Math.round(2.55 * parseFloat(t5[2])), Math.round(2.55 * parseFloat(t5[3]))];
          }
        }, {
          re: /^(\w{2})(\w{2})(\w{2})$/,
          example: ["#00ff00", "336699"],
          process: function(t5) {
            return [parseInt(t5[1], 16), parseInt(t5[2], 16), parseInt(t5[3], 16)];
          }
        }, {
          re: /^(\w{1})(\w{1})(\w{1})$/,
          example: ["#fb0", "f0f"],
          process: function(t5) {
            return [parseInt(t5[1] + t5[1], 16), parseInt(t5[2] + t5[2], 16), parseInt(t5[3] + t5[3], 16)];
          }
        }];
        for (var r2 = 0; r2 < this.colorDefs.length; r2++) {
          var i2 = this.colorDefs[r2].re, n2 = this.colorDefs[r2].process, a2 = i2.exec(t4);
          if (a2) {
            var s2 = n2(a2);
            this.r = s2[0], this.g = s2[1], this.b = s2[2], this.ok = true;
          }
        }
        this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
      }
    }
    return t3.prototype.toRGB = function() {
      return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    }, t3.prototype.toRGBA = function() {
      return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + (this.a || "1") + ")";
    }, t3.prototype.toHex = function() {
      var t4 = this.r.toString(16), e2 = this.g.toString(16), r2 = this.b.toString(16);
      return 1 == t4.length && (t4 = "0" + t4), 1 == e2.length && (e2 = "0" + e2), 1 == r2.length && (r2 = "0" + r2), "#" + t4 + e2 + r2;
    }, t3.prototype.getHelpXML = function() {
      for (var e2 = [], r2 = 0; r2 < this.colorDefs.length; r2++) for (var i2 = this.colorDefs[r2].example, n2 = 0; n2 < i2.length; n2++) e2[e2.length] = i2[n2];
      for (var a2 in this.simpleColors) e2[e2.length] = a2;
      var s2 = document.createElement("ul");
      s2.setAttribute("id", "rgbcolor-examples");
      for (r2 = 0; r2 < e2.length; r2++) try {
        var o2 = document.createElement("li"), l2 = new t3(e2[r2]), u2 = document.createElement("div");
        u2.style.cssText = "margin: 3px; border: 1px solid black; background:" + l2.toHex() + "; color:" + l2.toHex(), u2.appendChild(document.createTextNode("test"));
        var h2 = document.createTextNode(" " + e2[r2] + " -> " + l2.toRGB() + " -> " + l2.toHex());
        o2.appendChild(u2), o2.appendChild(h2), s2.appendChild(o2);
      } catch (t4) {
      }
      return s2;
    }, t3;
  })();
  var d = (function() {
    function t3(t4) {
      this.color = t4;
    }
    return t3.prototype.getFillData = function(t4, e2) {
      return f$1(this, void 0, void 0, function() {
        return c$2(this, function(t5) {
          return [2, void 0];
        });
      });
    }, t3;
  })();
  var m$2 = (function() {
    function t3() {
      this.xmlSpace = "", this.fill = null, this.fillOpacity = 1, this.fontFamily = "", this.fontSize = 16, this.fontStyle = "", this.fontWeight = "", this.opacity = 1, this.stroke = null, this.strokeDasharray = null, this.strokeDashoffset = 0, this.strokeLinecap = "", this.strokeLinejoin = "", this.strokeMiterlimit = 4, this.strokeOpacity = 1, this.strokeWidth = 1, this.alignmentBaseline = "", this.textAnchor = "", this.visibility = "", this.color = null, this.contextFill = null, this.contextStroke = null, this.fillRule = null;
    }
    return t3.prototype.clone = function() {
      var e2 = new t3();
      return e2.xmlSpace = this.xmlSpace, e2.fill = this.fill, e2.fillOpacity = this.fillOpacity, e2.fontFamily = this.fontFamily, e2.fontSize = this.fontSize, e2.fontStyle = this.fontStyle, e2.fontWeight = this.fontWeight, e2.opacity = this.opacity, e2.stroke = this.stroke, e2.strokeDasharray = this.strokeDasharray, e2.strokeDashoffset = this.strokeDashoffset, e2.strokeLinecap = this.strokeLinecap, e2.strokeLinejoin = this.strokeLinejoin, e2.strokeMiterlimit = this.strokeMiterlimit, e2.strokeOpacity = this.strokeOpacity, e2.strokeWidth = this.strokeWidth, e2.textAnchor = this.textAnchor, e2.alignmentBaseline = this.alignmentBaseline, e2.visibility = this.visibility, e2.color = this.color, e2.fillRule = this.fillRule, e2.contextFill = this.contextFill, e2.contextStroke = this.contextStroke, e2;
    }, t3.default = function() {
      var e2 = new t3();
      return e2.xmlSpace = "default", e2.fill = new d(new p$1("rgb(0, 0, 0)")), e2.fillOpacity = 1, e2.fontFamily = "times", e2.fontSize = 16, e2.fontStyle = "normal", e2.fontWeight = "normal", e2.opacity = 1, e2.stroke = null, e2.strokeDasharray = null, e2.strokeDashoffset = 0, e2.strokeLinecap = "butt", e2.strokeLinejoin = "miter", e2.strokeMiterlimit = 4, e2.strokeOpacity = 1, e2.strokeWidth = 1, e2.alignmentBaseline = "baseline", e2.textAnchor = "start", e2.visibility = "visible", e2.color = new p$1("rgb(0, 0, 0)"), e2.fillRule = "nonzero", e2.contextFill = null, e2.contextStroke = null, e2;
    }, t3.getContextColors = function(t4, e2) {
      void 0 === e2 && (e2 = false);
      var r2 = {};
      return t4.attributeState.contextFill && (r2.contextFill = t4.attributeState.contextFill), t4.attributeState.contextStroke && (r2.contextStroke = t4.attributeState.contextStroke), e2 && t4.attributeState.color && (r2.color = t4.attributeState.color), r2;
    }, t3;
  })();
  var g = (function() {
    function t3(t4, e2) {
      var r2, i2, n2;
      this.pdf = t4, this.svg2pdfParameters = e2.svg2pdfParameters, this.attributeState = e2.attributeState ? e2.attributeState.clone() : m$2.default(), this.viewport = e2.viewport, this.refsHandler = e2.refsHandler, this.styleSheets = e2.styleSheets, this.textMeasure = e2.textMeasure, this.transform = null !== (r2 = e2.transform) && void 0 !== r2 ? r2 : this.pdf.unitMatrix, this.withinClipPath = null !== (i2 = e2.withinClipPath) && void 0 !== i2 && i2, this.withinUse = null !== (n2 = e2.withinUse) && void 0 !== n2 && n2;
    }
    return t3.prototype.clone = function(e2) {
      var r2, i2, n2, a2;
      return void 0 === e2 && (e2 = {}), new t3(this.pdf, {
        svg2pdfParameters: this.svg2pdfParameters,
        attributeState: e2.attributeState ? e2.attributeState.clone() : this.attributeState.clone(),
        viewport: null !== (r2 = e2.viewport) && void 0 !== r2 ? r2 : this.viewport,
        refsHandler: this.refsHandler,
        styleSheets: this.styleSheets,
        textMeasure: this.textMeasure,
        transform: null !== (i2 = e2.transform) && void 0 !== i2 ? i2 : this.transform,
        withinClipPath: null !== (n2 = e2.withinClipPath) && void 0 !== n2 ? n2 : this.withinClipPath,
        withinUse: null !== (a2 = e2.withinUse) && void 0 !== a2 ? a2 : this.withinUse
      });
    }, t3;
  })();
  var y$1 = (function() {
    function e2(t3) {
      this.renderedElements = {}, this.idMap = t3, this.idPrefix = String(e2.instanceCounter++);
    }
    return e2.prototype.getRendered = function(t3, e3, r2) {
      return f$1(this, void 0, void 0, function() {
        var i2, n2;
        return c$2(this, function(a2) {
          switch (a2.label) {
            case 0:
              return i2 = this.generateKey(t3, e3), this.renderedElements.hasOwnProperty(i2) ? [2, this.renderedElements[t3]] : (n2 = this.get(t3), this.renderedElements[i2] = n2, [4, r2(n2)]);
            case 1:
              return a2.sent(), [2, n2];
          }
        });
      });
    }, e2.prototype.get = function(e3) {
      return this.idMap[t$1(e3, {
        isIdentifier: true
      })];
    }, e2.prototype.generateKey = function(t3, e3) {
      var r2 = "";
      return e3 && (r2 = ["color", "contextFill", "contextStroke"].map(function(t4) {
        var r3, i2;
        return null !== (i2 = null === (r3 = e3[t4]) || void 0 === r3 ? void 0 : r3.toRGBA()) && void 0 !== i2 ? i2 : "";
      }).join("|")), this.idPrefix + "|" + t3 + "|" + r2;
    }, e2.instanceCounter = 0, e2;
  })();
  function b(t3, e2) {
    return Math.atan2(e2[1] - t3[1], e2[0] - t3[0]);
  }
  var v$1 = 2 / 3;
  function x(t3, e2) {
    return [v$1 * (e2[0] - t3[0]) + t3[0], v$1 * (e2[1] - t3[1]) + t3[1]];
  }
  function S(t3) {
    var e2 = Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]);
    return [t3[0] / e2, t3[1] / e2];
  }
  function w(t3, e2) {
    return S([e2[0] - t3[0], e2[1] - t3[1]]);
  }
  function k(t3, e2) {
    return [t3[0] + e2[0], t3[1] + e2[1]];
  }
  function M(t3, e2) {
    var r2 = t3[0], i2 = t3[1];
    return [e2.a * r2 + e2.c * i2 + e2.e, e2.b * r2 + e2.d * i2 + e2.f];
  }
  var C = (function() {
    function t3() {
      this.segments = [];
    }
    return t3.prototype.moveTo = function(t4, e2) {
      return this.segments.push(new T$1(t4, e2)), this;
    }, t3.prototype.lineTo = function(t4, e2) {
      return this.segments.push(new F(t4, e2)), this;
    }, t3.prototype.curveTo = function(t4, e2, r2, i2, n2, a2) {
      return this.segments.push(new A(t4, e2, r2, i2, n2, a2)), this;
    }, t3.prototype.close = function() {
      return this.segments.push(new P()), this;
    }, t3.prototype.transform = function(t4) {
      this.segments.forEach(function(e2) {
        if (e2 instanceof T$1 || e2 instanceof F || e2 instanceof A) {
          var r2 = M([e2.x, e2.y], t4);
          e2.x = r2[0], e2.y = r2[1];
        }
        if (e2 instanceof A) {
          var i2 = M([e2.x1, e2.y1], t4), n2 = M([e2.x2, e2.y2], t4);
          e2.x1 = i2[0], e2.y1 = i2[1], e2.x2 = n2[0], e2.y2 = n2[1];
        }
      });
    }, t3.prototype.draw = function(t4) {
      var e2 = t4.pdf;
      this.segments.forEach(function(t5) {
        t5 instanceof T$1 ? e2.moveTo(t5.x, t5.y) : t5 instanceof F ? e2.lineTo(t5.x, t5.y) : t5 instanceof A ? e2.curveTo(t5.x1, t5.y1, t5.x2, t5.y2, t5.x, t5.y) : e2.close();
      });
    }, t3;
  })();
  var T$1 = function(t3, e2) {
    this.x = t3, this.y = e2;
  };
  var F = function(t3, e2) {
    this.x = t3, this.y = e2;
  };
  var A = function(t3, e2, r2, i2, n2, a2) {
    this.x1 = t3, this.y1 = e2, this.x2 = r2, this.y2 = i2, this.x = n2, this.y = a2;
  };
  var P = function() {
  };
  function B(t3, e2) {
    return e2.split(",").indexOf((t3.nodeName || t3.tagName).toLowerCase()) >= 0;
  }
  function N$1(t3, e2, r2, i2) {
    var n2;
    void 0 === i2 && (i2 = r2);
    var a2 = null === (n2 = t3.style) || void 0 === n2 ? void 0 : n2.getPropertyValue(i2);
    if (a2) return a2;
    var s2 = e2.getPropertyValue(t3, i2);
    return s2 || t3.hasAttribute(r2) && t3.getAttribute(r2) || void 0;
  }
  function O$1(t3, e2, r2) {
    if ("none" === N$1(t3.element, r2.styleSheets, "display")) return false;
    var i2 = e2, n2 = N$1(t3.element, r2.styleSheets, "visibility");
    return n2 && (i2 = "hidden" !== n2), i2;
  }
  function L(t3, e2, r2) {
    var i2 = O$1(t3, e2, r2);
    return 0 !== t3.element.childNodes.length && (t3.children.forEach(function(t4) {
      t4.isVisible(i2, r2) && (i2 = true);
    }), i2);
  }
  var E = (function() {
    function t3() {
      this.markers = [];
    }
    return t3.prototype.addMarker = function(t4) {
      this.markers.push(t4);
    }, t3.prototype.draw = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e2, r2, i2, n2, a2, s2, o2, l2;
        return c$2(this, function(u2) {
          switch (u2.label) {
            case 0:
              e2 = 0, u2.label = 1;
            case 1:
              return e2 < this.markers.length ? (r2 = this.markers[e2], i2 = void 0, n2 = r2.angle, a2 = r2.anchor, s2 = Math.cos(n2), o2 = Math.sin(n2), i2 = t4.pdf.Matrix(s2, o2, -o2, s2, a2[0], a2[1]), i2 = t4.pdf.matrixMult(t4.pdf.Matrix(t4.attributeState.strokeWidth, 0, 0, t4.attributeState.strokeWidth, 0, 0), i2), i2 = t4.pdf.matrixMult(i2, t4.transform), t4.pdf.saveGraphicsState(), l2 = m$2.getContextColors(t4), [4, t4.refsHandler.getRendered(r2.id, l2, function(e3) {
                return e3.apply(t4);
              })]) : [3, 4];
            case 2:
              u2.sent(), t4.pdf.doFormObject(t4.refsHandler.generateKey(r2.id, l2), i2), t4.pdf.restoreGraphicsState(), u2.label = 3;
            case 3:
              return e2++, [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }, t3;
  })();
  var I = function(t3, e2, r2, i2) {
    void 0 === i2 && (i2 = false), this.id = t3, this.anchor = e2, this.angle = r2, this.isStartMarker = i2;
  };
  var R = /url\(["']?#([^"']+)["']?\)/;
  var H = {
    bottom: "bottom",
    "text-bottom": "bottom",
    top: "top",
    "text-top": "top",
    hanging: "hanging",
    middle: "middle",
    central: "middle",
    center: "middle",
    mathematical: "middle",
    ideographic: "ideographic",
    alphabetic: "alphabetic",
    baseline: "alphabetic"
  };
  var D = "http://www.w3.org/2000/svg";
  function W(t3, e2) {
    var r2;
    return (r2 = t3 && t3.toString().match(/^([\-0-9.]+)em$/)) ? parseFloat(r2[1]) * e2 : (r2 = t3 && t3.toString().match(/^([\-0-9.]+)(px|)$/)) ? parseFloat(r2[1]) : 0;
  }
  function V(t3) {
    return H[t3] || "alphabetic";
  }
  function j(t3) {
    for (var e2, r2 = [], i2 = /[+-]?(?:(?:\d+\.?\d*)|(?:\d*\.?\d+))(?:[eE][+-]?\d+)?/g; e2 = i2.exec(t3); ) r2.push(parseFloat(e2[0]));
    return r2;
  }
  function G(t3, e2) {
    if ("transparent" === t3) {
      var r2 = new p$1("rgb(0,0,0)");
      return r2.a = 0, r2;
    }
    if (e2 && "currentcolor" === t3.toLowerCase()) return e2.color || new p$1("rgb(0,0,0)");
    if (e2 && "context-stroke" === t3.toLowerCase()) return e2.contextStroke || new p$1("rgb(0,0,0)");
    if (e2 && "context-fill" === t3.toLowerCase()) return e2.contextFill || new p$1("rgb(0,0,0)");
    var i2 = /\s*rgba\(((?:[^,\)]*,){3}[^,\)]*)\)\s*/.exec(t3);
    if (i2) {
      var n2 = j(i2[1]), a2 = new p$1("rgb(" + n2.slice(0, 3).join(",") + ")");
      return a2.a = n2[3], a2;
    }
    return new p$1(t3);
  }
  var U = {
    "sans-serif": "helvetica",
    verdana: "helvetica",
    arial: "helvetica",
    fixed: "courier",
    monospace: "courier",
    terminal: "courier",
    serif: "times",
    cursive: "times",
    fantasy: "times"
  };
  var z;
  var Y = (z = E$1.version.split("."), 2 === parseFloat(z[0]) && 3 === parseFloat(z[1]));
  function X(t3, e2) {
    return Y ? 400 == e2 ? "italic" == t3 ? "italic" : "normal" : 700 == e2 && "italic" !== t3 ? "bold" : t3 + "" + e2 : 400 == e2 || "normal" === e2 ? "italic" === t3 ? "italic" : "normal" : 700 != e2 && "bold" !== e2 || "normal" !== t3 ? (700 == e2 ? "bold" : e2) + "" + t3 : "bold";
  }
  function q(t3, e2) {
    if ("none" === N$1(e2.element, t3.styleSheets, "display")) return [0, 0, 0, 0];
    var r2 = [];
    return e2.children.forEach(function(e3) {
      var i2 = e3.getBoundingBox(t3);
      if (0 !== i2[0] || 0 !== i2[1] || 0 !== i2[2] || 0 !== i2[3]) {
        var n2 = e3.computeNodeTransform(t3);
        i2[0] = i2[0] * n2.sx + n2.tx, i2[1] = i2[1] * n2.sy + n2.ty, i2[2] = i2[2] * n2.sx, i2[3] = i2[3] * n2.sy, r2 = 0 === r2.length ? i2 : [Math.min(r2[0], i2[0]), Math.min(r2[1], i2[1]), Math.max(r2[0] + r2[2], i2[0] + i2[2]) - Math.min(r2[0], i2[0]), Math.max(r2[1] + r2[3], i2[1] + i2[3]) - Math.min(r2[1], i2[1])];
      }
    }), 0 === r2.length ? [0, 0, 0, 0] : r2;
  }
  function _$1(t3, e2) {
    var r2 = parseFloat, i2 = r2(t3.getAttribute("x1")) || r2(N$1(t3, e2.styleSheets, "x")) || r2(N$1(t3, e2.styleSheets, "cx")) - r2(N$1(t3, e2.styleSheets, "r")) || 0, n2 = r2(t3.getAttribute("x2")) || i2 + r2(N$1(t3, e2.styleSheets, "width")) || r2(N$1(t3, e2.styleSheets, "cx")) + r2(N$1(t3, e2.styleSheets, "r")) || 0, a2 = r2(t3.getAttribute("y1")) || r2(N$1(t3, e2.styleSheets, "y")) || r2(N$1(t3, e2.styleSheets, "cy")) - r2(N$1(t3, e2.styleSheets, "r")) || 0, s2 = r2(t3.getAttribute("y2")) || a2 + r2(N$1(t3, e2.styleSheets, "height")) || r2(N$1(t3, e2.styleSheets, "cy")) + r2(N$1(t3, e2.styleSheets, "r")) || 0;
    return [Math.min(i2, n2), Math.min(a2, s2), Math.max(i2, n2) - Math.min(i2, n2), Math.max(a2, s2) - Math.min(a2, s2)];
  }
  function $(t3, e2, r2, i2, n2, a2, s2, o2) {
    void 0 === o2 && (o2 = false);
    var l2, u2, h2 = e2[0], f2 = e2[1], c2 = e2[2], p2 = e2[3], d2 = n2 / c2, m2 = a2 / p2, g2 = t3.getAttribute("preserveAspectRatio");
    if (g2) {
      var y2 = g2.split(" ");
      "defer" === y2[0] && (y2 = y2.slice(1)), l2 = y2[0], u2 = y2[1] || "meet";
    } else l2 = "xMidYMid", u2 = "meet";
    if ("none" !== l2 && ("meet" === u2 ? d2 = m2 = Math.min(d2, m2) : "slice" === u2 && (d2 = m2 = Math.max(d2, m2))), o2) return s2.pdf.Matrix(d2, 0, 0, m2, 0, 0);
    var b2 = r2 - h2 * d2, v2 = i2 - f2 * m2;
    l2.indexOf("xMid") >= 0 ? b2 += (n2 - c2 * d2) / 2 : l2.indexOf("xMax") >= 0 && (b2 += n2 - c2 * d2), l2.indexOf("YMid") >= 0 ? v2 += (a2 - p2 * m2) / 2 : l2.indexOf("YMax") >= 0 && (v2 += a2 - p2 * m2);
    var x2 = s2.pdf.Matrix(1, 0, 0, 1, b2, v2), S2 = s2.pdf.Matrix(d2, 0, 0, m2, 0, 0);
    return s2.pdf.matrixMult(S2, x2);
  }
  function Q(t3, e2) {
    if (!t3 || "none" === t3) return e2.pdf.unitMatrix;
    for (var r2, i2, n2 = /^[\s,]*matrix\(([^)]+)\)\s*/, a2 = /^[\s,]*translate\(([^)]+)\)\s*/, s2 = /^[\s,]*rotate\(([^)]+)\)\s*/, o2 = /^[\s,]*scale\(([^)]+)\)\s*/, l2 = /^[\s,]*skewX\(([^)]+)\)\s*/, u2 = /^[\s,]*skewY\(([^)]+)\)\s*/, h2 = e2.pdf.unitMatrix; t3.length > 0 && t3.length !== i2; ) {
      i2 = t3.length;
      var f2 = n2.exec(t3);
      if (f2 && (r2 = j(f2[1]), h2 = e2.pdf.matrixMult(e2.pdf.Matrix(r2[0], r2[1], r2[2], r2[3], r2[4], r2[5]), h2), t3 = t3.substr(f2[0].length)), f2 = s2.exec(t3)) {
        r2 = j(f2[1]);
        var c2 = Math.PI * r2[0] / 180;
        if (h2 = e2.pdf.matrixMult(e2.pdf.Matrix(Math.cos(c2), Math.sin(c2), -Math.sin(c2), Math.cos(c2), 0, 0), h2), r2[1] || r2[2]) {
          var p2 = e2.pdf.Matrix(1, 0, 0, 1, r2[1], r2[2]), d2 = e2.pdf.Matrix(1, 0, 0, 1, -r2[1], -r2[2]);
          h2 = e2.pdf.matrixMult(d2, e2.pdf.matrixMult(h2, p2));
        }
        t3 = t3.substr(f2[0].length);
      }
      (f2 = a2.exec(t3)) && (r2 = j(f2[1]), h2 = e2.pdf.matrixMult(e2.pdf.Matrix(1, 0, 0, 1, r2[0], r2[1] || 0), h2), t3 = t3.substr(f2[0].length)), (f2 = o2.exec(t3)) && ((r2 = j(f2[1]))[1] || (r2[1] = r2[0]), h2 = e2.pdf.matrixMult(e2.pdf.Matrix(r2[0], 0, 0, r2[1], 0, 0), h2), t3 = t3.substr(f2[0].length)), (f2 = l2.exec(t3)) && (r2 = parseFloat(f2[1]), r2 *= Math.PI / 180, h2 = e2.pdf.matrixMult(e2.pdf.Matrix(1, 0, Math.tan(r2), 1, 0, 0), h2), t3 = t3.substr(f2[0].length)), (f2 = u2.exec(t3)) && (r2 = parseFloat(f2[1]), r2 *= Math.PI / 180, h2 = e2.pdf.matrixMult(e2.pdf.Matrix(1, Math.tan(r2), 0, 1, 0, 0), h2), t3 = t3.substr(f2[0].length));
    }
    return h2;
  }
  var K = (function() {
    function t3(t4, e2) {
      this.element = t4, this.children = e2, this.parent = null;
    }
    return t3.prototype.setParent = function(t4) {
      this.parent = t4;
    }, t3.prototype.getParent = function() {
      return this.parent;
    }, t3.prototype.getBoundingBox = function(t4) {
      return "none" === N$1(this.element, t4.styleSheets, "display") ? [0, 0, 0, 0] : this.getBoundingBoxCore(t4);
    }, t3.prototype.computeNodeTransform = function(t4) {
      var e2 = this.computeNodeTransformCore(t4), r2 = N$1(this.element, t4.styleSheets, "transform");
      return r2 ? t4.pdf.matrixMult(e2, Q(r2, t4)) : e2;
    }, t3;
  })();
  var J = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.render = function(t4) {
      return Promise.resolve();
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return [];
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2;
  })(K);
  var Z = (function(t3) {
    function e2(e3, r2, i2) {
      var n2 = t3.call(this, r2, i2) || this;
      return n2.pdfGradientType = e3, n2.contextColor = void 0, n2;
    }
    return u$1(e2, t3), e2.prototype.apply = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3, r2, a2, s2, o2, l2;
        return c$2(this, function(u2) {
          return (e3 = this.element.getAttribute("id")) ? (r2 = this.getStops(t4.styleSheets), a2 = 0, s2 = false, r2.forEach(function(t5) {
            var e4 = t5.opacity;
            e4 && 1 !== e4 && (a2 += e4, s2 = true);
          }), s2 && (o2 = new j$1({
            opacity: a2 / r2.length
          })), l2 = new B$1(this.pdfGradientType, this.getCoordinates(), r2, o2), t4.pdf.addShadingPattern(e3, l2), [2]) : [2];
        });
      });
    }, e2.prototype.getStops = function(t4) {
      var r2 = this;
      if (this.stops) return this.stops;
      if (void 0 === this.contextColor) {
        this.contextColor = null;
        for (var i2 = this; i2; ) {
          var n2 = N$1(i2.element, t4, "color");
          if (n2) {
            this.contextColor = G(n2, null);
            break;
          }
          i2 = i2.getParent();
        }
      }
      var a2 = [];
      return this.children.forEach(function(i3) {
        if ("stop" === i3.element.tagName.toLowerCase()) {
          var n3 = N$1(i3.element, t4, "color"), s2 = G(N$1(i3.element, t4, "stop-color") || "", n3 ? {
            color: G(n3, null)
          } : {
            color: r2.contextColor
          }), o2 = parseFloat(N$1(i3.element, t4, "stop-opacity") || "1");
          a2.push({
            offset: e2.parseGradientOffset(i3.element.getAttribute("offset") || "0"),
            color: [s2.r, s2.g, s2.b],
            opacity: o2
          });
        }
      }), this.stops = a2;
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return _$1(this.element, t4);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2.prototype.isVisible = function(t4, e3) {
      return L(this, t4, e3);
    }, e2.parseGradientOffset = function(t4) {
      var e3 = parseFloat(t4);
      return !isNaN(e3) && t4.indexOf("%") >= 0 ? e3 / 100 : e3;
    }, e2;
  })(J);
  var tt = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, "axial", e3, r2) || this;
    }
    return u$1(e2, t3), e2.prototype.getCoordinates = function() {
      return [parseFloat(this.element.getAttribute("x1") || "0"), parseFloat(this.element.getAttribute("y1") || "0"), parseFloat(this.element.getAttribute("x2") || "1"), parseFloat(this.element.getAttribute("y2") || "0")];
    }, e2;
  })(Z);
  var et = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, "radial", e3, r2) || this;
    }
    return u$1(e2, t3), e2.prototype.getCoordinates = function() {
      var t4 = this.element.getAttribute("cx"), e3 = this.element.getAttribute("cy"), r2 = this.element.getAttribute("fx"), i2 = this.element.getAttribute("fy");
      return [parseFloat(r2 || t4 || "0.5"), parseFloat(i2 || e3 || "0.5"), 0, parseFloat(t4 || "0.5"), parseFloat(e3 || "0.5"), parseFloat(this.element.getAttribute("r") || "0.5")];
    }, e2;
  })(Z);
  var rt = (function() {
    function t3(t4, e2) {
      this.key = t4, this.gradient = e2;
    }
    return t3.prototype.getFillData = function(t4, e2) {
      return f$1(this, void 0, void 0, function() {
        var r2, i2, n2;
        return c$2(this, function(a2) {
          switch (a2.label) {
            case 0:
              return [4, e2.refsHandler.getRendered(this.key, null, function(t5) {
                return t5.apply(new g(e2.pdf, {
                  refsHandler: e2.refsHandler,
                  textMeasure: e2.textMeasure,
                  styleSheets: e2.styleSheets,
                  viewport: e2.viewport,
                  svg2pdfParameters: e2.svg2pdfParameters
                }));
              })];
            case 1:
              return a2.sent(), this.gradient.element.hasAttribute("gradientUnits") && "objectboundingbox" !== this.gradient.element.getAttribute("gradientUnits").toLowerCase() ? r2 = e2.pdf.unitMatrix : (i2 = t4.getBoundingBox(e2), r2 = e2.pdf.Matrix(i2[2], 0, 0, i2[3], i2[0], i2[1])), n2 = Q(N$1(this.gradient.element, e2.styleSheets, "gradientTransform", "transform"), e2), [2, {
                key: this.key,
                matrix: e2.pdf.matrixMult(n2, r2)
              }];
          }
        });
      });
    }, t3;
  })();
  var it = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.apply = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3, r2, i2, n2, s2;
        return c$2(this, function(o2) {
          switch (o2.label) {
            case 0:
              if (!(e3 = this.element.getAttribute("id"))) return [2];
              r2 = this.getBoundingBox(t4), i2 = new M$1([r2[0], r2[1], r2[0] + r2[2], r2[1] + r2[3]], r2[2], r2[3]), t4.pdf.beginTilingPattern(i2), n2 = 0, s2 = this.children, o2.label = 1;
            case 1:
              return n2 < s2.length ? [4, s2[n2].render(new g(t4.pdf, {
                attributeState: t4.attributeState,
                refsHandler: t4.refsHandler,
                styleSheets: t4.styleSheets,
                viewport: t4.viewport,
                svg2pdfParameters: t4.svg2pdfParameters,
                textMeasure: t4.textMeasure
              }))] : [3, 4];
            case 2:
              o2.sent(), o2.label = 3;
            case 3:
              return n2++, [3, 1];
            case 4:
              return t4.pdf.endTilingPattern(e3, i2), [2];
          }
        });
      });
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return _$1(this.element, t4);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2.prototype.isVisible = function(t4, e3) {
      return L(this, t4, e3);
    }, e2;
  })(J);
  var nt = (function() {
    function t3(t4, e2) {
      this.key = t4, this.pattern = e2;
    }
    return t3.prototype.getFillData = function(t4, e2) {
      return f$1(this, void 0, void 0, function() {
        var r2, i2, n2, a2, s2, o2, l2, u2, h2, f2, p2, d2;
        return c$2(this, function(c2) {
          switch (c2.label) {
            case 0:
              return [4, e2.refsHandler.getRendered(this.key, null, function(t5) {
                return t5.apply(new g(e2.pdf, {
                  refsHandler: e2.refsHandler,
                  textMeasure: e2.textMeasure,
                  styleSheets: e2.styleSheets,
                  viewport: e2.viewport,
                  svg2pdfParameters: e2.svg2pdfParameters
                }));
              })];
            case 1:
              return c2.sent(), r2 = {
                key: this.key,
                boundingBox: void 0,
                xStep: 0,
                yStep: 0,
                matrix: void 0
              }, n2 = e2.pdf.unitMatrix, this.pattern.element.hasAttribute("patternUnits") && "objectboundingbox" !== this.pattern.element.getAttribute("patternUnits").toLowerCase() || (i2 = t4.getBoundingBox(e2), n2 = e2.pdf.Matrix(1, 0, 0, 1, i2[0], i2[1]), s2 = this.pattern.getBoundingBox(e2), o2 = s2[0] * i2[0] || 0, l2 = s2[1] * i2[1] || 0, u2 = s2[2] * i2[2] || 0, h2 = s2[3] * i2[3] || 0, r2.boundingBox = [o2, l2, o2 + u2, l2 + h2], r2.xStep = u2, r2.yStep = h2), a2 = e2.pdf.unitMatrix, this.pattern.element.hasAttribute("patternContentUnits") && "objectboundingbox" === this.pattern.element.getAttribute("patternContentUnits").toLowerCase() && (i2 || (i2 = t4.getBoundingBox(e2)), a2 = e2.pdf.Matrix(i2[2], 0, 0, i2[3], 0, 0), s2 = r2.boundingBox || this.pattern.getBoundingBox(e2), o2 = s2[0] / i2[0] || 0, l2 = s2[1] / i2[1] || 0, u2 = s2[2] / i2[2] || 0, h2 = s2[3] / i2[3] || 0, r2.boundingBox = [o2, l2, o2 + u2, l2 + h2], r2.xStep = u2, r2.yStep = h2), f2 = e2.pdf.unitMatrix, (p2 = N$1(this.pattern.element, e2.styleSheets, "patternTransform", "transform")) && (f2 = Q(p2, e2)), d2 = a2, d2 = e2.pdf.matrixMult(d2, n2), d2 = e2.pdf.matrixMult(d2, f2), d2 = e2.pdf.matrixMult(d2, e2.transform), r2.matrix = d2, [2, r2];
          }
        });
      });
    }, t3;
  })();
  function at(t3, e2) {
    var r2 = R.exec(t3);
    if (r2) {
      var i2 = r2[1], n2 = e2.refsHandler.get(i2);
      return n2 && (n2 instanceof tt || n2 instanceof et) ? (function(t4, e3, r3) {
        var i3 = e3.getStops(r3.styleSheets);
        if (0 === i3.length) return null;
        if (1 === i3.length) {
          var n3 = i3[0].color, a3 = new p$1();
          return a3.ok = true, a3.r = n3[0], a3.g = n3[1], a3.b = n3[2], a3.a = i3[0].opacity, new d(a3);
        }
        return new rt(t4, e3);
      })(i2, n2, e2) : n2 && n2 instanceof it ? new nt(i2, n2) : new d(new p$1("rgb(0, 0, 0)"));
    }
    var a2 = G(t3, e2.attributeState);
    return a2.ok ? new d(a2) : null;
  }
  function st(t3, r2, i2) {
    var n2 = i2 || r2.element, a2 = N$1(n2, t3.styleSheets, "color");
    if (a2) {
      var s2 = G(a2, t3.attributeState);
      s2.ok ? t3.attributeState.color = s2 : t3.attributeState.color = new p$1("rgb(0,0,0)");
    }
    var o2 = N$1(n2, t3.styleSheets, "visibility");
    o2 && (t3.attributeState.visibility = o2);
    var l2 = N$1(n2, t3.styleSheets, "fill");
    l2 && (t3.attributeState.fill = at(l2, t3));
    var u2 = N$1(n2, t3.styleSheets, "fill-opacity");
    u2 && (t3.attributeState.fillOpacity = parseFloat(u2));
    var h2 = N$1(n2, t3.styleSheets, "stroke-opacity");
    h2 && (t3.attributeState.strokeOpacity = parseFloat(h2));
    var f2 = N$1(n2, t3.styleSheets, "opacity");
    f2 && (t3.attributeState.opacity = parseFloat(f2));
    var c2 = N$1(n2, t3.styleSheets, "stroke-width");
    void 0 !== c2 && "" !== c2 && (t3.attributeState.strokeWidth = Math.abs(parseFloat(c2)));
    var m2 = N$1(n2, t3.styleSheets, "stroke");
    if (m2) if ("none" === m2) t3.attributeState.stroke = null;
    else {
      var g2 = G(m2, t3.attributeState);
      g2.ok && (t3.attributeState.stroke = new d(g2));
    }
    m2 && t3.attributeState.stroke instanceof d && (t3.attributeState.contextStroke = t3.attributeState.stroke.color), l2 && t3.attributeState.fill instanceof d && (t3.attributeState.contextFill = t3.attributeState.fill.color);
    var y2 = N$1(n2, t3.styleSheets, "stroke-linecap");
    y2 && (t3.attributeState.strokeLinecap = y2);
    var b2 = N$1(n2, t3.styleSheets, "stroke-linejoin");
    b2 && (t3.attributeState.strokeLinejoin = b2);
    var v2 = N$1(n2, t3.styleSheets, "stroke-dasharray");
    if (v2) {
      var x2 = parseInt(N$1(n2, t3.styleSheets, "stroke-dashoffset") || "0");
      t3.attributeState.strokeDasharray = j(v2), t3.attributeState.strokeDashoffset = x2;
    }
    var S2 = N$1(n2, t3.styleSheets, "stroke-miterlimit");
    void 0 !== S2 && "" !== S2 && (t3.attributeState.strokeMiterlimit = parseFloat(S2));
    var w2 = n2.getAttribute("xml:space");
    w2 && (t3.attributeState.xmlSpace = w2);
    var k2 = N$1(n2, t3.styleSheets, "font-weight");
    k2 && (t3.attributeState.fontWeight = k2);
    var M2 = N$1(n2, t3.styleSheets, "font-style");
    M2 && (t3.attributeState.fontStyle = M2);
    var C2 = N$1(n2, t3.styleSheets, "font-family");
    if (C2) {
      var T2 = e$1.parse(C2);
      t3.attributeState.fontFamily = (function(t4, e2, r3) {
        var i3 = X(t4.fontStyle, t4.fontWeight), n3 = r3.pdf.getFontList(), a3 = "";
        return e2.some(function(t5) {
          var e3 = n3[t5];
          return e3 && e3.indexOf(i3) >= 0 ? (a3 = t5, true) : (t5 = t5.toLowerCase(), !!U.hasOwnProperty(t5) && (a3 = t5, true));
        }) || (a3 = "times"), a3;
      })(t3.attributeState, T2, t3);
    }
    var F2 = N$1(n2, t3.styleSheets, "font-size");
    if (F2) {
      var A2 = t3.pdf.getFontSize();
      t3.attributeState.fontSize = W(F2, A2);
    }
    var P2 = N$1(n2, t3.styleSheets, "vertical-align") || N$1(n2, t3.styleSheets, "alignment-baseline");
    if (P2) {
      var B2 = P2.match(/(baseline|text-bottom|alphabetic|ideographic|middle|central|mathematical|text-top|bottom|center|top|hanging)/);
      B2 && (t3.attributeState.alignmentBaseline = B2[0]);
    }
    var O2 = N$1(n2, t3.styleSheets, "text-anchor");
    O2 && (t3.attributeState.textAnchor = O2);
    var L2 = N$1(n2, t3.styleSheets, "fill-rule");
    L2 && (t3.attributeState.fillRule = L2);
  }
  function ot(t3, e2, r2) {
    var n2 = 1, a2 = 1;
    n2 *= t3.attributeState.fillOpacity, n2 *= t3.attributeState.opacity, t3.attributeState.fill instanceof d && void 0 !== t3.attributeState.fill.color.a && (n2 *= t3.attributeState.fill.color.a), a2 *= t3.attributeState.strokeOpacity, a2 *= t3.attributeState.opacity, t3.attributeState.stroke instanceof d && void 0 !== t3.attributeState.stroke.color.a && (a2 *= t3.attributeState.stroke.color.a);
    var s2, o2, l2 = n2 < 1, u2 = a2 < 1;
    if (B(r2, "use") ? (l2 = true, u2 = true, n2 *= t3.attributeState.fill ? 1 : 0, a2 *= t3.attributeState.stroke ? 1 : 0) : t3.withinUse && (t3.attributeState.fill !== e2.attributeState.fill ? (l2 = true, n2 *= t3.attributeState.fill ? 1 : 0) : l2 && !t3.attributeState.fill && (n2 = 0), t3.attributeState.stroke !== e2.attributeState.stroke ? (u2 = true, a2 *= t3.attributeState.stroke ? 1 : 0) : u2 && !t3.attributeState.stroke && (a2 = 0)), l2 || u2) {
      var h2 = {};
      l2 && (h2.opacity = n2), u2 && (h2["stroke-opacity"] = a2), t3.pdf.setGState(new j$1(h2));
    }
    if (t3.attributeState.fill && t3.attributeState.fill !== e2.attributeState.fill && t3.attributeState.fill instanceof d && t3.attributeState.fill.color.ok && !B(r2, "text") && t3.pdf.setFillColor(t3.attributeState.fill.color.r, t3.attributeState.fill.color.g, t3.attributeState.fill.color.b), t3.attributeState.strokeWidth !== e2.attributeState.strokeWidth && t3.pdf.setLineWidth(t3.attributeState.strokeWidth), t3.attributeState.stroke !== e2.attributeState.stroke && t3.attributeState.stroke instanceof d && t3.pdf.setDrawColor(t3.attributeState.stroke.color.r, t3.attributeState.stroke.color.g, t3.attributeState.stroke.color.b), t3.attributeState.strokeLinecap !== e2.attributeState.strokeLinecap && t3.pdf.setLineCap(t3.attributeState.strokeLinecap), t3.attributeState.strokeLinejoin !== e2.attributeState.strokeLinejoin && t3.pdf.setLineJoin(t3.attributeState.strokeLinejoin), t3.attributeState.strokeDasharray === e2.attributeState.strokeDasharray && t3.attributeState.strokeDashoffset === e2.attributeState.strokeDashoffset || !t3.attributeState.strokeDasharray || t3.pdf.setLineDashPattern(t3.attributeState.strokeDasharray, t3.attributeState.strokeDashoffset), t3.attributeState.strokeMiterlimit !== e2.attributeState.strokeMiterlimit && t3.pdf.setLineMiterLimit(t3.attributeState.strokeMiterlimit), t3.attributeState.fontFamily !== e2.attributeState.fontFamily && (s2 = U.hasOwnProperty(t3.attributeState.fontFamily) ? U[t3.attributeState.fontFamily] : t3.attributeState.fontFamily), t3.attributeState.fill && t3.attributeState.fill !== e2.attributeState.fill && t3.attributeState.fill instanceof d && t3.attributeState.fill.color.ok) {
      var f2 = t3.attributeState.fill.color;
      t3.pdf.setTextColor(f2.r, f2.g, f2.b);
    }
    t3.attributeState.fontWeight === e2.attributeState.fontWeight && t3.attributeState.fontStyle === e2.attributeState.fontStyle || (o2 = X(t3.attributeState.fontStyle, t3.attributeState.fontWeight)), void 0 === s2 && void 0 === o2 || (void 0 === s2 && (s2 = U.hasOwnProperty(t3.attributeState.fontFamily) ? U[t3.attributeState.fontFamily] : t3.attributeState.fontFamily), t3.pdf.setFont(s2, o2)), t3.attributeState.fontSize !== e2.attributeState.fontSize && t3.pdf.setFontSize(t3.attributeState.fontSize * t3.pdf.internal.scaleFactor);
  }
  function lt(t3, e2, r2) {
    var i2 = R.exec(t3);
    if (i2) {
      var n2 = i2[1];
      return r2.refsHandler.get(n2) || void 0;
    }
  }
  function ut(t3, e2, r2) {
    return f$1(this, void 0, void 0, function() {
      var i2, n2;
      return c$2(this, function(a2) {
        switch (a2.label) {
          case 0:
            return i2 = r2.clone(), e2.element.hasAttribute("clipPathUnits") && "objectboundingbox" === e2.element.getAttribute("clipPathUnits").toLowerCase() && (n2 = t3.getBoundingBox(r2), i2.transform = r2.pdf.matrixMult(r2.pdf.Matrix(n2[2], 0, 0, n2[3], n2[0], n2[1]), r2.transform)), [4, e2.apply(i2)];
          case 1:
            return a2.sent(), [2];
        }
      });
    });
  }
  var ht = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.render = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3, r2, i2, n2;
        return c$2(this, function(a2) {
          switch (a2.label) {
            case 0:
              return this.isVisible("hidden" !== t4.attributeState.visibility, t4) ? ((e3 = t4.clone()).transform = e3.pdf.matrixMult(this.computeNodeTransform(e3), t4.transform), st(e3, this), r2 = N$1(this.element, e3.styleSheets, "clip-path"), (i2 = r2 && "none" !== r2) ? (n2 = lt(r2, 0, e3)) ? n2.isVisible(true, e3) ? (e3.pdf.saveGraphicsState(), [4, ut(this, n2, e3)]) : [3, 2] : [3, 4] : [3, 5]) : [2];
            case 1:
              return a2.sent(), [3, 3];
            case 2:
              return [2];
            case 3:
              return [3, 5];
            case 4:
              i2 = false, a2.label = 5;
            case 5:
              return e3.withinClipPath || e3.pdf.saveGraphicsState(), ot(e3, t4, this.element), [4, this.renderCore(e3)];
            case 6:
              return a2.sent(), e3.withinClipPath || e3.pdf.restoreGraphicsState(), i2 && e3.pdf.restoreGraphicsState(), [2];
          }
        });
      });
    }, e2;
  })(K);
  var ft = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2;
  })(ht);
  var ct = (function(t3) {
    function e2(e3, r2, i2) {
      var n2 = t3.call(this, r2, i2) || this;
      return n2.cachedPath = null, n2.hasMarkers = e3, n2;
    }
    return u$1(e2, t3), e2.prototype.renderCore = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3;
        return c$2(this, function(r2) {
          switch (r2.label) {
            case 0:
              return null === (e3 = this.getCachedPath(t4)) || 0 === e3.segments.length ? [2] : (t4.withinClipPath ? e3.transform(t4.transform) : t4.pdf.setCurrentTransformationMatrix(t4.transform), e3.draw(t4), [4, this.fillOrStroke(t4)]);
            case 1:
              return r2.sent(), this.hasMarkers ? [4, this.drawMarkers(t4, e3)] : [3, 3];
            case 2:
              r2.sent(), r2.label = 3;
            case 3:
              return [2];
          }
        });
      });
    }, e2.prototype.getCachedPath = function(t4) {
      return this.cachedPath || (this.cachedPath = this.getPath(t4));
    }, e2.prototype.drawMarkers = function(t4, e3) {
      return f$1(this, void 0, void 0, function() {
        return c$2(this, function(r2) {
          switch (r2.label) {
            case 0:
              return [4, this.getMarkers(e3, t4).draw(t4.clone({
                transform: t4.pdf.unitMatrix
              }))];
            case 1:
              return r2.sent(), [2];
          }
        });
      });
    }, e2.prototype.fillOrStroke = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3, r2, i2, n2, a2;
        return c$2(this, function(s2) {
          switch (s2.label) {
            case 0:
              return t4.withinClipPath ? [2] : (e3 = t4.attributeState.fill, r2 = t4.attributeState.stroke && 0 !== t4.attributeState.strokeWidth, e3 ? [4, e3.getFillData(this, t4)] : [3, 2]);
            case 1:
              return n2 = s2.sent(), [3, 3];
            case 2:
              n2 = void 0, s2.label = 3;
            case 3:
              return i2 = n2, a2 = "evenodd" === t4.attributeState.fillRule, e3 && r2 || t4.withinUse ? a2 ? t4.pdf.fillStrokeEvenOdd(i2) : t4.pdf.fillStroke(i2) : e3 ? a2 ? t4.pdf.fillEvenOdd(i2) : t4.pdf.fill(i2) : r2 ? t4.pdf.stroke() : t4.pdf.discardPath(), [2];
          }
        });
      });
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      var e3 = this.getCachedPath(t4);
      if (!e3 || !e3.segments.length) return [0, 0, 0, 0];
      for (var r2 = Number.POSITIVE_INFINITY, i2 = Number.POSITIVE_INFINITY, n2 = Number.NEGATIVE_INFINITY, a2 = Number.NEGATIVE_INFINITY, s2 = 0, o2 = 0, l2 = 0; l2 < e3.segments.length; l2++) {
        var u2 = e3.segments[l2];
        (u2 instanceof T$1 || u2 instanceof F || u2 instanceof A) && (s2 = u2.x, o2 = u2.y), u2 instanceof A ? (r2 = Math.min(r2, s2, u2.x1, u2.x2, u2.x), n2 = Math.max(n2, s2, u2.x1, u2.x2, u2.x), i2 = Math.min(i2, o2, u2.y1, u2.y2, u2.y), a2 = Math.max(a2, o2, u2.y1, u2.y2, u2.y)) : (r2 = Math.min(r2, s2), n2 = Math.max(n2, s2), i2 = Math.min(i2, o2), a2 = Math.max(a2, o2));
      }
      return [r2, i2, n2 - r2, a2 - i2];
    }, e2.prototype.getMarkers = function(t4, e3) {
      var r2 = N$1(this.element, e3.styleSheets, "marker-start"), i2 = N$1(this.element, e3.styleSheets, "marker-mid"), n2 = N$1(this.element, e3.styleSheets, "marker-end"), a2 = new E();
      if (r2 || i2 || n2) {
        n2 && (n2 = pt(n2)), r2 && (r2 = pt(r2)), i2 && (i2 = pt(i2));
        for (var s2 = t4.segments, o2 = [1, 0], l2 = void 0, u2 = false, h2 = [1, 0], f2 = false, c2 = function(t5) {
          var e4 = s2[t5], c3 = r2 && (1 === t5 || !(s2[t5] instanceof T$1) && s2[t5 - 1] instanceof T$1);
          c3 && s2.forEach(function(e5, r3) {
            if (!f2 && e5 instanceof P && r3 > t5) {
              var i3 = s2[r3 - 1];
              f2 = (i3 instanceof T$1 || i3 instanceof F || i3 instanceof A) && i3;
            }
          });
          var p3 = n2 && (t5 === s2.length - 1 || !(s2[t5] instanceof T$1) && s2[t5 + 1] instanceof T$1), d2 = i2 && t5 > 0 && !(1 === t5 && s2[t5 - 1] instanceof T$1), m2 = s2[t5 - 1] || null;
          if (m2 instanceof T$1 || m2 instanceof F || m2 instanceof A) {
            if (e4 instanceof A) c3 && a2.addMarker(new I(r2, [m2.x, m2.y], b(f2 ? [f2.x, f2.y] : [m2.x, m2.y], [e4.x1, e4.y1]), true)), p3 && a2.addMarker(new I(n2, [e4.x, e4.y], b([e4.x2, e4.y2], [e4.x, e4.y]))), d2 && (l2 = w([m2.x, m2.y], [e4.x1, e4.y1]), l2 = m2 instanceof T$1 ? l2 : S(k(o2, l2)), a2.addMarker(new I(i2, [m2.x, m2.y], Math.atan2(l2[1], l2[0])))), o2 = w([e4.x2, e4.y2], [e4.x, e4.y]);
            else if (e4 instanceof T$1 || e4 instanceof F) {
              if (l2 = w([m2.x, m2.y], [e4.x, e4.y]), c3) {
                var g2 = f2 ? w([f2.x, f2.y], [e4.x, e4.y]) : l2;
                a2.addMarker(new I(r2, [m2.x, m2.y], Math.atan2(g2[1], g2[0]), true));
              }
              if (p3 && a2.addMarker(new I(n2, [e4.x, e4.y], Math.atan2(l2[1], l2[0]))), d2) {
                g2 = e4 instanceof T$1 ? o2 : m2 instanceof T$1 ? l2 : S(k(o2, l2));
                a2.addMarker(new I(i2, [m2.x, m2.y], Math.atan2(g2[1], g2[0])));
              }
              o2 = l2;
            } else if (e4 instanceof P) {
              if (l2 = w([m2.x, m2.y], [u2.x, u2.y]), d2) {
                g2 = m2 instanceof T$1 ? l2 : S(k(o2, l2));
                a2.addMarker(new I(i2, [m2.x, m2.y], Math.atan2(g2[1], g2[0])));
              }
              if (p3) {
                g2 = S(k(l2, h2));
                a2.addMarker(new I(n2, [u2.x, u2.y], Math.atan2(g2[1], g2[0])));
              }
              o2 = l2;
            }
          } else {
            u2 = e4 instanceof T$1 && e4;
            var y2 = s2[t5 + 1];
            (y2 instanceof T$1 || y2 instanceof F || y2 instanceof A) && (h2 = w([u2.x, u2.y], [y2.x, y2.y]));
          }
        }, p2 = 0; p2 < s2.length; p2++) c2(p2);
      }
      return a2.markers.forEach(function(t5) {
        var r3 = e3.refsHandler.get(t5.id);
        if (r3) {
          var i3 = N$1(r3.element, e3.styleSheets, "orient");
          null != i3 && (t5.isStartMarker && "auto-start-reverse" === i3 && (t5.angle += Math.PI), isNaN(Number(i3)) || (t5.angle = parseFloat(i3) / 180 * Math.PI));
        }
      }), a2;
    }, e2;
  })(ft);
  function pt(t3) {
    var e2 = R.exec(t3);
    return e2 && e2[1] || void 0;
  }
  var dt = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, true, e3, r2) || this;
    }
    return u$1(e2, t3), e2.prototype.getPath = function(t4) {
      if (t4.withinClipPath || null === t4.attributeState.stroke) return null;
      var e3 = parseFloat(this.element.getAttribute("x1") || "0"), r2 = parseFloat(this.element.getAttribute("y1") || "0"), i2 = parseFloat(this.element.getAttribute("x2") || "0"), n2 = parseFloat(this.element.getAttribute("y2") || "0");
      return e3 || i2 || r2 || n2 ? new C().moveTo(e3, r2).lineTo(i2, n2) : null;
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2.prototype.isVisible = function(t4, e3) {
      return O$1(this, t4, e3);
    }, e2.prototype.fillOrStroke = function(e3) {
      return f$1(this, void 0, void 0, function() {
        return c$2(this, function(r2) {
          switch (r2.label) {
            case 0:
              return e3.attributeState.fill = null, [4, t3.prototype.fillOrStroke.call(this, e3)];
            case 1:
              return r2.sent(), [2];
          }
        });
      });
    }, e2;
  })(ct);
  var mt = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.apply = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3, r2, i2, n2, a2;
        return c$2(this, function(s2) {
          switch (s2.label) {
            case 0:
              return this.isVisible("hidden" !== t4.attributeState.visibility, t4) ? ((e3 = t4.clone()).transform = e3.pdf.unitMatrix, st(e3, this), r2 = N$1(this.element, e3.styleSheets, "clip-path"), r2 && "none" !== r2 && (i2 = lt(r2, 0, e3)) ? i2.isVisible(true, e3) ? [4, ut(this, i2, e3)] : [3, 2] : [3, 3]) : [2];
            case 1:
              return s2.sent(), [3, 3];
            case 2:
              return [2];
            case 3:
              ot(e3, t4, this.element), n2 = 0, a2 = this.children, s2.label = 4;
            case 4:
              return n2 < a2.length ? [4, a2[n2].render(e3)] : [3, 7];
            case 5:
              s2.sent(), s2.label = 6;
            case 6:
              return n2++, [3, 4];
            case 7:
              return [2];
          }
        });
      });
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return q(t4, this);
    }, e2.prototype.isVisible = function(t4, e3) {
      return L(this, t4, e3);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      var e3 = parseFloat(N$1(this.element, t4.styleSheets, "x") || "0"), r2 = parseFloat(N$1(this.element, t4.styleSheets, "y") || "0"), i2 = this.element.getAttribute("viewBox");
      if (i2) {
        var n2 = j(i2), a2 = parseFloat(N$1(this.element, t4.styleSheets, "width") || N$1(this.element.ownerSVGElement, t4.styleSheets, "width") || i2[2]), s2 = parseFloat(N$1(this.element, t4.styleSheets, "height") || N$1(this.element.ownerSVGElement, t4.styleSheets, "height") || i2[3]);
        return $(this.element, n2, e3, r2, a2, s2, t4);
      }
      return t4.pdf.Matrix(1, 0, 0, 1, e3, r2);
    }, e2;
  })(J);
  var gt = function(t3, e2) {
    this.width = t3, this.height = e2;
  };
  var yt = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.renderCore = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var r2, i2, n2, a2, s2, o2, l2, u2, h2, f2, p2, d2, y2;
        return c$2(this, function(c2) {
          switch (c2.label) {
            case 0:
              return r2 = parseFloat, (i2 = this.element.getAttribute("href") || this.element.getAttribute("xlink:href")) ? (n2 = i2.substring(1), a2 = t4.refsHandler.get(n2), s2 = B(a2.element, "symbol,svg") && a2.element.hasAttribute("viewBox"), o2 = r2(N$1(this.element, t4.styleSheets, "x") || "0"), l2 = r2(N$1(this.element, t4.styleSheets, "y") || "0"), u2 = void 0, h2 = void 0, s2 ? (u2 = r2(N$1(this.element, t4.styleSheets, "width") || N$1(a2.element, t4.styleSheets, "width") || "0"), h2 = r2(N$1(this.element, t4.styleSheets, "height") || N$1(a2.element, t4.styleSheets, "height") || "0"), o2 += r2(N$1(a2.element, t4.styleSheets, "x") || "0"), l2 += r2(N$1(a2.element, t4.styleSheets, "y") || "0"), p2 = j(a2.element.getAttribute("viewBox")), f2 = $(a2.element, p2, o2, l2, u2, h2, t4)) : f2 = t4.pdf.Matrix(1, 0, 0, 1, o2, l2), d2 = m$2.getContextColors(t4, true), y2 = new g(t4.pdf, {
                refsHandler: t4.refsHandler,
                styleSheets: t4.styleSheets,
                withinUse: true,
                viewport: s2 ? new gt(u2, h2) : t4.viewport,
                svg2pdfParameters: t4.svg2pdfParameters,
                textMeasure: t4.textMeasure,
                attributeState: Object.assign(m$2.default(), d2)
              }), [4, t4.refsHandler.getRendered(n2, d2, function(t5) {
                return e2.renderReferencedNode(t5, n2, y2);
              })]) : [2];
            case 1:
              return c2.sent(), t4.pdf.saveGraphicsState(), t4.pdf.setCurrentTransformationMatrix(t4.transform), s2 && "visible" !== N$1(a2.element, t4.styleSheets, "overflow") && (t4.pdf.rect(o2, l2, u2, h2), t4.pdf.clip().discardPath()), t4.pdf.doFormObject(t4.refsHandler.generateKey(n2, d2), f2), t4.pdf.restoreGraphicsState(), [2];
          }
        });
      });
    }, e2.renderReferencedNode = function(t4, e3, r2) {
      return f$1(this, void 0, void 0, function() {
        var i2;
        return c$2(this, function(n2) {
          switch (n2.label) {
            case 0:
              return i2 = [(i2 = t4.getBoundingBox(r2))[0] - 0.5 * i2[2], i2[1] - 0.5 * i2[3], 2 * i2[2], 2 * i2[3]], r2.pdf.beginFormObject(i2[0], i2[1], i2[2], i2[3], r2.pdf.unitMatrix), t4 instanceof mt ? [4, t4.apply(r2)] : [3, 2];
            case 1:
              return n2.sent(), [3, 4];
            case 2:
              return [4, t4.render(r2)];
            case 3:
              n2.sent(), n2.label = 4;
            case 4:
              return r2.pdf.endFormObject(r2.refsHandler.generateKey(e3, r2.attributeState)), [2];
          }
        });
      });
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return _$1(this.element, t4);
    }, e2.prototype.isVisible = function(t4, e3) {
      return O$1(this, t4, e3);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2;
  })(ft);
  var bt = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, false, e3, r2) || this;
    }
    return u$1(e2, t3), e2.prototype.getPath = function(t4) {
      var e3 = parseFloat(N$1(this.element, t4.styleSheets, "width") || "0"), r2 = parseFloat(N$1(this.element, t4.styleSheets, "height") || "0");
      if (!isFinite(e3) || e3 <= 0 || !isFinite(r2) || r2 <= 0) return null;
      var i2 = N$1(this.element, t4.styleSheets, "rx"), n2 = N$1(this.element, t4.styleSheets, "ry"), a2 = Math.min(parseFloat(i2 || n2 || "0"), 0.5 * e3), s2 = Math.min(parseFloat(n2 || i2 || "0"), 0.5 * r2), o2 = parseFloat(N$1(this.element, t4.styleSheets, "x") || "0"), l2 = parseFloat(N$1(this.element, t4.styleSheets, "y") || "0"), u2 = 4 / 3 * (Math.SQRT2 - 1);
      return 0 === a2 && 0 === s2 ? new C().moveTo(o2, l2).lineTo(o2 + e3, l2).lineTo(o2 + e3, l2 + r2).lineTo(o2, l2 + r2).close() : new C().moveTo(o2 += a2, l2).lineTo(o2 += e3 - 2 * a2, l2).curveTo(o2 + a2 * u2, l2, o2 + a2, l2 + (s2 - s2 * u2), o2 += a2, l2 += s2).lineTo(o2, l2 += r2 - 2 * s2).curveTo(o2, l2 + s2 * u2, o2 - a2 * u2, l2 + s2, o2 -= a2, l2 += s2).lineTo(o2 += 2 * a2 - e3, l2).curveTo(o2 - a2 * u2, l2, o2 - a2, l2 - s2 * u2, o2 -= a2, l2 -= s2).lineTo(o2, l2 += 2 * s2 - r2).curveTo(o2, l2 - s2 * u2, o2 + a2 * u2, l2 - s2, o2 += a2, l2 -= s2).close();
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2.prototype.isVisible = function(t4, e3) {
      return O$1(this, t4, e3);
    }, e2;
  })(ct);
  var vt = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, false, e3, r2) || this;
    }
    return u$1(e2, t3), e2.prototype.getPath = function(t4) {
      var e3 = this.getRx(t4), r2 = this.getRy(t4);
      if (!isFinite(e3) || r2 <= 0 || !isFinite(r2) || r2 <= 0) return null;
      var i2 = parseFloat(N$1(this.element, t4.styleSheets, "cx") || "0"), n2 = parseFloat(N$1(this.element, t4.styleSheets, "cy") || "0"), a2 = 4 / 3 * (Math.SQRT2 - 1) * e3, s2 = 4 / 3 * (Math.SQRT2 - 1) * r2;
      return new C().moveTo(i2 + e3, n2).curveTo(i2 + e3, n2 - s2, i2 + a2, n2 - r2, i2, n2 - r2).curveTo(i2 - a2, n2 - r2, i2 - e3, n2 - s2, i2 - e3, n2).curveTo(i2 - e3, n2 + s2, i2 - a2, n2 + r2, i2, n2 + r2).curveTo(i2 + a2, n2 + r2, i2 + e3, n2 + s2, i2 + e3, n2);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2.prototype.isVisible = function(t4, e3) {
      return O$1(this, t4, e3);
    }, e2;
  })(ct);
  var xt = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, e3, r2) || this;
    }
    return u$1(e2, t3), e2.prototype.getRx = function(t4) {
      return parseFloat(N$1(this.element, t4.styleSheets, "rx") || "0");
    }, e2.prototype.getRy = function(t4) {
      return parseFloat(N$1(this.element, t4.styleSheets, "ry") || "0");
    }, e2;
  })(vt);
  function St(t3) {
    var e2 = "invisible", r2 = t3.stroke && 0 !== t3.strokeWidth, i2 = t3.fill;
    return i2 && r2 ? e2 = "fillThenStroke" : i2 ? e2 = "fill" : r2 && (e2 = "stroke"), e2;
  }
  function wt(t3) {
    return t3.replace(/[\n\r]/g, "");
  }
  function kt(t3) {
    return t3.replace(/[\t]/g, " ");
  }
  function Mt(t3) {
    return t3.replace(/ +/g, " ");
  }
  function Ct(t3, e2, r2) {
    switch (N$1(t3, r2.styleSheets, "text-transform")) {
      case "uppercase":
        return e2.toUpperCase();
      case "lowercase":
        return e2.toLowerCase();
      default:
        return e2;
    }
  }
  var Tt = (function() {
    function t3(t4, e2, r2, i2) {
      this.textNode = t4, this.texts = [], this.textNodes = [], this.contexts = [], this.textAnchor = e2, this.originX = r2, this.originY = i2, this.textMeasures = [];
    }
    return t3.prototype.setX = function(t4) {
      this.originX = t4;
    }, t3.prototype.setY = function(t4) {
      this.originY = t4;
    }, t3.prototype.add = function(t4, e2, r2) {
      this.texts.push(e2), this.textNodes.push(t4), this.contexts.push(r2);
    }, t3.prototype.rightTrimText = function() {
      for (var t4 = this.texts.length - 1; t4 >= 0; t4--) if ("default" === this.contexts[t4].attributeState.xmlSpace && (this.texts[t4] = this.texts[t4].replace(/\s+$/, "")), this.texts[t4].match(/[^\s]/)) return false;
      return true;
    }, t3.prototype.measureText = function(t4) {
      for (var e2 = 0; e2 < this.texts.length; e2++) this.textMeasures.push({
        width: t4.textMeasure.measureTextWidth(this.texts[e2], this.contexts[e2].attributeState),
        length: this.texts[e2].length
      });
    }, t3.prototype.put = function(e2, r2) {
      var i2, n2, a2, s2, o2 = [], l2 = [], u2 = [], h2 = this.originX, f2 = this.originY, c2 = h2, p2 = h2;
      for (i2 = 0; i2 < this.textNodes.length; i2++) {
        n2 = this.textNodes[i2], a2 = this.contexts[i2], s2 = this.textMeasures[i2] || {
          width: e2.textMeasure.measureTextWidth(this.texts[i2], this.contexts[i2].attributeState),
          length: this.texts[i2].length
        };
        var d2 = h2, m2 = f2;
        if ("#text" !== n2.nodeName && !o2.includes(n2)) {
          o2.push(n2);
          var g2 = t3.resolveRelativePositionAttribute(n2, "dx");
          null !== g2 && (d2 += W(g2, a2.attributeState.fontSize));
          var y2 = t3.resolveRelativePositionAttribute(n2, "dy");
          null !== y2 && (m2 += W(y2, a2.attributeState.fontSize));
        }
        l2[i2] = d2, u2[i2] = m2, h2 = d2 + s2.width + s2.length * r2, f2 = m2, c2 = Math.min(c2, d2), p2 = Math.max(p2, h2);
      }
      var b2 = 0;
      switch (this.textAnchor) {
        case "start":
          b2 = 0;
          break;
        case "middle":
          b2 = (p2 - c2) / 2;
          break;
        case "end":
          b2 = p2 - c2;
      }
      for (i2 = 0; i2 < this.textNodes.length; i2++) if (n2 = this.textNodes[i2], a2 = this.contexts[i2], "#text" === n2.nodeName || "hidden" !== a2.attributeState.visibility) {
        e2.pdf.saveGraphicsState(), ot(a2, e2, n2);
        var v2 = a2.attributeState.alignmentBaseline, x2 = St(a2.attributeState);
        e2.pdf.text(this.texts[i2], l2[i2] - b2, u2[i2], {
          baseline: V(v2),
          angle: e2.transform,
          renderingMode: "fill" === x2 ? void 0 : x2,
          charSpace: 0 === r2 ? void 0 : r2
        }), e2.pdf.restoreGraphicsState();
      }
      return [h2, f2];
    }, t3.resolveRelativePositionAttribute = function(t4, e2) {
      for (var r2, i2 = t4; i2 && B(i2, "tspan"); ) {
        if (i2.hasAttribute(e2)) return i2.getAttribute(e2);
        if ((null === (r2 = t4.parentElement) || void 0 === r2 ? void 0 : r2.firstChild) !== t4) break;
        i2 = i2.parentElement;
      }
      return null;
    }, t3;
  })();
  var Ft = (function(t3) {
    function e2() {
      var e3 = null !== t3 && t3.apply(this, arguments) || this;
      return e3.boundingBox = [], e3;
    }
    return u$1(e2, t3), e2.prototype.processTSpans = function(t4, e3, r2, i2, n2, a2) {
      for (var s2 = r2.pdf.getFontSize(), o2 = r2.attributeState.xmlSpace, l2 = true, u2 = false, h2 = 0; h2 < e3.childNodes.length; h2++) {
        var f2 = e3.childNodes[h2];
        if (f2.textContent) {
          var c2 = f2.textContent;
          if ("#text" === f2.nodeName) {
            var p2 = wt(c2);
            p2 = kt(p2), "default" === o2 && (p2 = Mt(p2), l2 && p2.match(/^\s/) && (u2 = true), p2.match(/[^\s]/) && (l2 = false), a2.prevText.match(/\s$/) && (p2 = p2.replace(/^\s+/, "")));
            var d2 = Ct(e3, p2, r2);
            n2.add(e3, d2, r2), a2.prevText = c2, a2.prevContext = r2;
          } else if (B(f2, "title")) ;
          else if (B(f2, "tspan")) {
            var m2 = f2, g2 = m2.getAttribute("x");
            if (null !== g2) {
              var y2 = W(g2, s2);
              n2 = new Tt(this, N$1(m2, r2.styleSheets, "text-anchor") || r2.attributeState.textAnchor, y2, 0), i2.push({
                type: "y",
                chunk: n2
              });
            }
            var b2 = m2.getAttribute("y");
            if (null !== b2) {
              var v2 = W(b2, s2);
              n2 = new Tt(this, N$1(m2, r2.styleSheets, "text-anchor") || r2.attributeState.textAnchor, 0, v2), i2.push({
                type: "x",
                chunk: n2
              });
            }
            var x2 = r2.clone();
            st(x2, t4, m2), this.processTSpans(t4, m2, x2, i2, n2, a2);
          }
        }
      }
      return u2;
    }, e2.prototype.renderCore = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3, r2, i2, n2, a2, s2, o2, l2, u2, h2, f2, p2, d2, m2, g2, y2, b2, v2, x2, S2, w2, k2, M2;
        return c$2(this, function(c2) {
          if (t4.pdf.saveGraphicsState(), e3 = 0, r2 = 0, i2 = 1, n2 = t4.pdf.getFontSize(), a2 = W(this.element.getAttribute("x"), n2), s2 = W(this.element.getAttribute("y"), n2), o2 = W(this.element.getAttribute("dx"), n2), l2 = W(this.element.getAttribute("dy"), n2), u2 = parseFloat(this.element.getAttribute("textLength") || "0"), h2 = t4.attributeState.visibility, 0 === this.element.childElementCount) f2 = this.element.textContent || "", p2 = (function(t5, e4) {
            return t5 = kt(t5 = wt(t5)), "default" === e4.xmlSpace && (t5 = Mt(t5 = t5.trim())), t5;
          })(f2, t4.attributeState), d2 = Ct(this.element, p2, t4), e3 = t4.textMeasure.getTextOffset(d2, t4.attributeState), u2 > 0 && (m2 = t4.textMeasure.measureTextWidth(d2, t4.attributeState), "default" === t4.attributeState.xmlSpace && f2.match(/^\s/) && (i2 = 0), r2 = (u2 - m2) / (d2.length - i2) || 0), "visible" === h2 && (g2 = t4.attributeState.alignmentBaseline, y2 = St(t4.attributeState), t4.pdf.text(d2, a2 + o2 - e3, s2 + l2, {
            baseline: V(g2),
            angle: t4.transform,
            renderingMode: "fill" === y2 ? void 0 : y2,
            charSpace: 0 === r2 ? void 0 : r2
          }), this.boundingBox = [a2 + o2 - e3, s2 + l2 + 0.1 * n2, t4.textMeasure.measureTextWidth(d2, t4.attributeState), n2]);
          else {
            for (b2 = [], v2 = new Tt(this, t4.attributeState.textAnchor, a2 + o2, s2 + l2), b2.push({
              type: "",
              chunk: v2
            }), x2 = this.processTSpans(this, this.element, t4, b2, v2, {
              prevText: " ",
              prevContext: t4
            }), i2 = x2 ? 0 : 1, S2 = true, w2 = b2.length - 1; w2 >= 0; w2--) S2 && (S2 = b2[w2].chunk.rightTrimText());
            u2 > 0 && (k2 = 0, M2 = 0, b2.forEach(function(e4) {
              var r3 = e4.chunk;
              r3.measureText(t4), r3.textMeasures.forEach(function(t5) {
                var e5 = t5.width, r4 = t5.length;
                k2 += e5, M2 += r4;
              });
            }), r2 = (u2 - k2) / (M2 - i2)), b2.reduce(function(e4, i3) {
              var n3 = i3.type, a3 = i3.chunk;
              return "x" === n3 ? a3.setX(e4[0]) : "y" === n3 && a3.setY(e4[1]), a3.put(t4, r2);
            }, [0, 0]);
          }
          return t4.pdf.restoreGraphicsState(), [2];
        });
      });
    }, e2.prototype.isVisible = function(t4, e3) {
      return L(this, t4, e3);
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return this.boundingBox.length > 0 ? this.boundingBox : _$1(this.element, t4);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2;
  })(ft);
  var At = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, true, e3, r2) || this;
    }
    return u$1(e2, t3), e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2.prototype.isVisible = function(t4, e3) {
      return O$1(this, t4, e3);
    }, e2.prototype.getPath = function(t4) {
      var e3, r2, i2 = new s$1(N$1(this.element, t4.styleSheets, "d") || "").unshort().unarc().abs(), n2 = new C();
      return i2.iterate(function(t5) {
        switch (t5[0]) {
          case "M":
            n2.moveTo(t5[1], t5[2]);
            break;
          case "L":
            n2.lineTo(t5[1], t5[2]);
            break;
          case "H":
            n2.lineTo(t5[1], r2);
            break;
          case "V":
            n2.lineTo(e3, t5[1]);
            break;
          case "C":
            n2.curveTo(t5[1], t5[2], t5[3], t5[4], t5[5], t5[6]);
            break;
          case "Q":
            var i3 = x([e3, r2], [t5[1], t5[2]]), a2 = x([t5[3], t5[4]], [t5[1], t5[2]]);
            n2.curveTo(i3[0], i3[1], a2[0], a2[1], t5[3], t5[4]);
            break;
          case "Z":
            n2.close();
        }
        switch (t5[0]) {
          case "M":
          case "L":
            e3 = t5[1], r2 = t5[2];
            break;
          case "H":
            e3 = t5[1];
            break;
          case "V":
            r2 = t5[1];
            break;
          case "C":
            e3 = t5[5], r2 = t5[6];
            break;
          case "Q":
            e3 = t5[3], r2 = t5[4];
        }
      }), n2;
    }, e2;
  })(ct);
  var Pt = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,((?:.|\s)*)$/i;
  var Bt = (function(t3) {
    function e2(r2, i2) {
      var n2 = t3.call(this, r2, i2) || this;
      return n2.imageLoadingPromise = null, n2.imageUrl = n2.element.getAttribute("xlink:href") || n2.element.getAttribute("href"), n2.imageUrl && (n2.imageLoadingPromise = e2.fetchImageData(n2.imageUrl)), n2;
    }
    return u$1(e2, t3), e2.prototype.renderCore = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var r2, i2, n2, a2, s2, o2, l2, u2, h2, f2, p2, d2, m2, b2, v2, x2, S2, w2;
        return c$2(this, function(c2) {
          switch (c2.label) {
            case 0:
              return this.imageLoadingPromise ? (t4.pdf.setCurrentTransformationMatrix(t4.transform), r2 = parseFloat(N$1(this.element, t4.styleSheets, "width") || "0"), i2 = parseFloat(N$1(this.element, t4.styleSheets, "height") || "0"), n2 = parseFloat(N$1(this.element, t4.styleSheets, "x") || "0"), a2 = parseFloat(N$1(this.element, t4.styleSheets, "y") || "0"), !isFinite(r2) || r2 <= 0 || !isFinite(i2) || i2 <= 0 ? [2] : [4, this.imageLoadingPromise]) : [2];
            case 1:
              return s2 = c2.sent(), o2 = s2.data, 0 !== (l2 = s2.format).indexOf("svg") ? [3, 3] : (u2 = new DOMParser(), h2 = u2.parseFromString(o2, "image/svg+xml").firstElementChild, (!(f2 = this.element.getAttribute("preserveAspectRatio")) || f2.indexOf("defer") < 0 || !h2.getAttribute("preserveAspectRatio")) && h2.setAttribute("preserveAspectRatio", f2 || ""), h2.setAttribute("x", String(n2)), h2.setAttribute("y", String(a2)), h2.setAttribute("width", String(r2)), h2.setAttribute("height", String(i2)), [4, Gt(h2, p2 = {}).render(new g(t4.pdf, {
                refsHandler: new y$1(p2),
                styleSheets: t4.styleSheets,
                viewport: new gt(r2, i2),
                svg2pdfParameters: t4.svg2pdfParameters,
                textMeasure: t4.textMeasure
              }))]);
            case 2:
              return c2.sent(), [2];
            case 3:
              d2 = "data:image/".concat(l2, ";base64,").concat(btoa(o2)), c2.label = 4;
            case 4:
              return c2.trys.push([4, 6, , 7]), [4, e2.getImageDimensions(d2)];
            case 5:
              return m2 = c2.sent(), b2 = m2[0], v2 = m2[1], x2 = [0, 0, b2, v2], S2 = $(this.element, x2, n2, a2, r2, i2, t4), t4.pdf.setCurrentTransformationMatrix(S2), t4.pdf.addImage(d2, "", 0, 0, b2, v2), [3, 7];
            case 6:
              return w2 = c2.sent(), "object" == typeof console && console.warn && console.warn("Could not load image ".concat(this.imageUrl, ". \n").concat(w2)), [3, 7];
            case 7:
              return [2];
          }
        });
      });
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return _$1(this.element, t4);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2.prototype.isVisible = function(t4, e3) {
      return O$1(this, t4, e3);
    }, e2.fetchImageData = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var r2, i2, n2, a2, s2;
        return c$2(this, function(o2) {
          switch (o2.label) {
            case 0:
              if (!(n2 = t4.match(Pt))) return [3, 1];
              if (a2 = n2[2], "image" !== (s2 = a2.split("/"))[0]) throw new Error("Unsupported image URL: ".concat(t4));
              return i2 = s2[1], r2 = n2[5], "base64" === n2[4] ? (r2 = r2.replace(/\s/g, ""), r2 = atob(r2)) : r2 = decodeURIComponent(r2), [3, 3];
            case 1:
              return [4, e2.fetchImage(t4)];
            case 2:
              r2 = o2.sent(), i2 = t4.substring(t4.lastIndexOf(".") + 1), o2.label = 3;
            case 3:
              return [2, {
                data: r2,
                format: i2
              }];
          }
        });
      });
    }, e2.fetchImage = function(t4) {
      return new Promise(function(e3, r2) {
        var i2 = new XMLHttpRequest();
        i2.open("GET", t4, true), i2.responseType = "arraybuffer", i2.onload = function() {
          if (200 !== i2.status) throw new Error("Error ".concat(i2.status, ": Failed to load image '").concat(t4, "'"));
          for (var r3 = new Uint8Array(i2.response), n2 = "", a2 = 0; a2 < r3.length; a2++) n2 += String.fromCharCode(r3[a2]);
          e3(n2);
        }, i2.onerror = r2, i2.onabort = r2, i2.send(null);
      });
    }, e2.getMimeType = function(t4) {
      switch (t4 = t4.toLowerCase()) {
        case "jpg":
        case "jpeg":
          return "image/jpeg";
        default:
          return "image/".concat(t4);
      }
    }, e2.getImageDimensions = function(t4) {
      return new Promise(function(e3, r2) {
        var i2 = new Image();
        i2.onload = function() {
          e3([i2.width, i2.height]);
        }, i2.onerror = r2, i2.src = t4;
      });
    }, e2;
  })(ft);
  var Nt = (function(t3) {
    function e2(e3, r2, i2) {
      var n2 = t3.call(this, true, r2, i2) || this;
      return n2.closed = e3, n2;
    }
    return u$1(e2, t3), e2.prototype.getPath = function(t4) {
      if (!this.element.hasAttribute("points") || "" === this.element.getAttribute("points")) return null;
      var r2 = e2.parsePointsString(this.element.getAttribute("points")), i2 = new C();
      if (r2.length < 1) return i2;
      i2.moveTo(r2[0][0], r2[0][1]);
      for (var n2 = 1; n2 < r2.length; n2++) i2.lineTo(r2[n2][0], r2[n2][1]);
      return this.closed && i2.close(), i2;
    }, e2.prototype.isVisible = function(t4, e3) {
      return O$1(this, t4, e3);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2.parsePointsString = function(t4) {
      for (var e3 = j(t4), r2 = [], i2 = 0; i2 < e3.length - 1; i2 += 2) {
        var n2 = e3[i2], a2 = e3[i2 + 1];
        r2.push([n2, a2]);
      }
      return r2;
    }, e2;
  })(ct);
  var Ot = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, true, e3, r2) || this;
    }
    return u$1(e2, t3), e2;
  })(Nt);
  var Lt = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.render = function(t4) {
      return Promise.resolve();
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return [0, 0, 0, 0];
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2.prototype.isVisible = function(t4, e3) {
      return O$1(this, t4, e3);
    }, e2;
  })(K);
  var Et = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.apply = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3, r2, n2, a2, s2, o2;
        return c$2(this, function(l2) {
          switch (l2.label) {
            case 0:
              e3 = this.computeNodeTransform(t4), r2 = this.getBoundingBox(t4), t4.pdf.beginFormObject(r2[0], r2[1], r2[2], r2[3], e3), n2 = m$2.getContextColors(t4), (function(t5) {
                var e4 = t5.attributeState, r3 = t5.pdf, n3 = 1, a3 = 1;
                n3 *= e4.fillOpacity, n3 *= e4.opacity, e4.fill instanceof d && void 0 !== e4.fill.color.a && (n3 *= e4.fill.color.a), a3 *= e4.strokeOpacity, a3 *= e4.opacity, e4.stroke instanceof d && void 0 !== e4.stroke.color.a && (a3 *= e4.stroke.color.a);
                var s3, o3 = {};
                if (o3.opacity = n3, o3["stroke-opacity"] = a3, r3.setGState(new j$1(o3)), e4.fill && e4.fill instanceof d && e4.fill.color.ok ? r3.setFillColor(e4.fill.color.r, e4.fill.color.g, e4.fill.color.b) : r3.setFillColor(0, 0, 0), r3.setLineWidth(e4.strokeWidth), e4.stroke instanceof d ? r3.setDrawColor(e4.stroke.color.r, e4.stroke.color.g, e4.stroke.color.b) : r3.setDrawColor(0, 0, 0), r3.setLineCap(e4.strokeLinecap), r3.setLineJoin(e4.strokeLinejoin), e4.strokeDasharray ? r3.setLineDashPattern(e4.strokeDasharray, e4.strokeDashoffset) : r3.setLineDashPattern([], 0), r3.setLineMiterLimit(e4.strokeMiterlimit), s3 = U.hasOwnProperty(e4.fontFamily) ? U[e4.fontFamily] : e4.fontFamily, e4.fill && e4.fill instanceof d && e4.fill.color.ok) {
                  var l3 = e4.fill.color;
                  r3.setTextColor(l3.r, l3.g, l3.b);
                } else r3.setTextColor(0, 0, 0);
                var u2 = "";
                "bold" === e4.fontWeight && (u2 = "bold"), "italic" === e4.fontStyle && (u2 += "italic"), "" === u2 && (u2 = "normal"), void 0 !== s3 || void 0 !== u2 ? (void 0 === s3 && (s3 = U.hasOwnProperty(e4.fontFamily) ? U[e4.fontFamily] : e4.fontFamily), r3.setFont(s3, u2)) : r3.setFont("helvetica", u2), r3.setFontSize(e4.fontSize * r3.internal.scaleFactor);
              })(a2 = new g(t4.pdf, {
                refsHandler: t4.refsHandler,
                styleSheets: t4.styleSheets,
                viewport: t4.viewport,
                svg2pdfParameters: t4.svg2pdfParameters,
                textMeasure: t4.textMeasure,
                attributeState: Object.assign(m$2.default(), n2)
              })), s2 = 0, o2 = this.children, l2.label = 1;
            case 1:
              return s2 < o2.length ? [4, o2[s2].render(a2)] : [3, 4];
            case 2:
              l2.sent(), l2.label = 3;
            case 3:
              return s2++, [3, 1];
            case 4:
              return t4.pdf.endFormObject(a2.refsHandler.generateKey(this.element.getAttribute("id"), n2)), [2];
          }
        });
      });
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      var e3, r2 = this.element.getAttribute("viewBox");
      return r2 && (e3 = j(r2)), [e3 && e3[0] || 0, e3 && e3[1] || 0, e3 && e3[2] || parseFloat(this.element.getAttribute("markerWidth") || "3"), e3 && e3[3] || parseFloat(this.element.getAttribute("markerHeight") || "3")];
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      var e3, r2 = parseFloat(this.element.getAttribute("refX") || "0"), i2 = parseFloat(this.element.getAttribute("refY") || "0"), n2 = this.element.getAttribute("viewBox");
      if (n2) {
        var a2 = j(n2);
        e3 = $(this.element, a2, 0, 0, parseFloat(this.element.getAttribute("markerWidth") || "3"), parseFloat(this.element.getAttribute("markerHeight") || "3"), t4, true), e3 = t4.pdf.matrixMult(t4.pdf.Matrix(1, 0, 0, 1, -r2, -i2), e3);
      } else e3 = t4.pdf.Matrix(1, 0, 0, 1, -r2, -i2);
      return e3;
    }, e2.prototype.isVisible = function(t4, e3) {
      return L(this, t4, e3);
    }, e2;
  })(J);
  var It = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, e3, r2) || this;
    }
    return u$1(e2, t3), e2.prototype.getR = function(t4) {
      var e3;
      return null !== (e3 = this.r) && void 0 !== e3 ? e3 : this.r = parseFloat(N$1(this.element, t4.styleSheets, "r") || "0");
    }, e2.prototype.getRx = function(t4) {
      return this.getR(t4);
    }, e2.prototype.getRy = function(t4) {
      return this.getR(t4);
    }, e2;
  })(vt);
  var Rt = (function(t3) {
    function e2(e3, r2) {
      return t3.call(this, false, e3, r2) || this;
    }
    return u$1(e2, t3), e2;
  })(Nt);
  var Ht = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.renderCore = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3, r2;
        return c$2(this, function(i2) {
          switch (i2.label) {
            case 0:
              e3 = 0, r2 = this.children, i2.label = 1;
            case 1:
              return e3 < r2.length ? [4, r2[e3].render(t4)] : [3, 4];
            case 2:
              i2.sent(), i2.label = 3;
            case 3:
              return e3++, [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return q(t4, this);
    }, e2;
  })(ht);
  var Dt = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.isVisible = function(t4, e3) {
      return L(this, t4, e3);
    }, e2.prototype.render = function(e3) {
      return f$1(this, void 0, void 0, function() {
        var r2, i2, n2, a2, s2;
        return c$2(this, function(o2) {
          switch (o2.label) {
            case 0:
              return this.isVisible("hidden" !== e3.attributeState.visibility, e3) ? (r2 = this.getX(e3), i2 = this.getY(e3), n2 = this.getWidth(e3), a2 = this.getHeight(e3), e3.pdf.saveGraphicsState(), s2 = e3.transform, this.element.hasAttribute("transform") && (s2 = e3.pdf.matrixMult(Q(this.element.getAttribute("transform"), e3), s2)), e3.pdf.setCurrentTransformationMatrix(s2), e3.withinUse || "visible" === N$1(this.element, e3.styleSheets, "overflow") || e3.pdf.rect(r2, i2, n2, a2).clip().discardPath(), [4, t3.prototype.render.call(this, e3.clone({
                transform: e3.pdf.unitMatrix,
                viewport: e3.withinUse ? e3.viewport : new gt(n2, a2)
              }))]) : [2];
            case 1:
              return o2.sent(), e3.pdf.restoreGraphicsState(), [2];
          }
        });
      });
    }, e2.prototype.computeNodeTransform = function(t4) {
      return this.computeNodeTransformCore(t4);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      if (t4.withinUse) return t4.pdf.unitMatrix;
      var e3, r2 = this.getX(t4), i2 = this.getY(t4), n2 = this.getViewBox();
      if (n2) {
        var a2 = this.getWidth(t4), s2 = this.getHeight(t4);
        e3 = $(this.element, n2, r2, i2, a2, s2, t4);
      } else e3 = t4.pdf.Matrix(1, 0, 0, 1, r2, i2);
      return e3;
    }, e2.prototype.getWidth = function(t4) {
      if (void 0 !== this.width) return this.width;
      var e3, r2, i2 = t4.svg2pdfParameters;
      if (this.isOutermostSvg(t4)) {
        if (null != i2.width) e3 = i2.width;
        else if (r2 = N$1(this.element, t4.styleSheets, "width")) e3 = parseFloat(r2);
        else {
          var n2 = this.getViewBox();
          if (n2 && (null != i2.height || N$1(this.element, t4.styleSheets, "height"))) {
            var a2 = n2[2] / n2[3];
            e3 = this.getHeight(t4) * a2;
          } else e3 = Math.min(300, t4.viewport.width, 2 * t4.viewport.height);
        }
      } else e3 = (r2 = N$1(this.element, t4.styleSheets, "width")) ? parseFloat(r2) : t4.viewport.width;
      return this.width = e3;
    }, e2.prototype.getHeight = function(t4) {
      if (void 0 !== this.height) return this.height;
      var e3, r2, i2 = t4.svg2pdfParameters;
      if (this.isOutermostSvg(t4)) {
        if (null != i2.height) e3 = i2.height;
        else if (r2 = N$1(this.element, t4.styleSheets, "height")) e3 = parseFloat(r2);
        else {
          var n2 = this.getViewBox();
          if (n2) {
            var a2 = n2[2] / n2[3];
            e3 = this.getWidth(t4) / a2;
          } else e3 = Math.min(150, t4.viewport.width / 2, t4.viewport.height);
        }
      } else e3 = (r2 = N$1(this.element, t4.styleSheets, "height")) ? parseFloat(r2) : t4.viewport.height;
      return this.height = e3;
    }, e2.prototype.getX = function(t4) {
      if (void 0 !== this.x) return this.x;
      if (this.isOutermostSvg(t4)) return this.x = 0;
      var e3 = N$1(this.element, t4.styleSheets, "x");
      return this.x = e3 ? parseFloat(e3) : 0;
    }, e2.prototype.getY = function(t4) {
      if (void 0 !== this.y) return this.y;
      if (this.isOutermostSvg(t4)) return this.y = 0;
      var e3 = N$1(this.element, t4.styleSheets, "y");
      return this.y = e3 ? parseFloat(e3) : 0;
    }, e2.prototype.getViewBox = function() {
      if (void 0 !== this.viewBox) return this.viewBox;
      var t4 = this.element.getAttribute("viewBox");
      return this.viewBox = t4 ? j(t4) : void 0;
    }, e2.prototype.isOutermostSvg = function(t4) {
      return t4.svg2pdfParameters.element === this.element;
    }, e2;
  })(Ht);
  var Wt = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.isVisible = function(t4, e3) {
      return L(this, t4, e3);
    }, e2.prototype.computeNodeTransformCore = function(t4) {
      return t4.pdf.unitMatrix;
    }, e2;
  })(Ht);
  var Vt = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.renderCore = function(e3) {
      return f$1(this, void 0, void 0, function() {
        var r2, i2, n2, a2;
        return c$2(this, function(s2) {
          switch (s2.label) {
            case 0:
              return [4, t3.prototype.renderCore.call(this, e3)];
            case 1:
              return s2.sent(), (r2 = N$1(this.element, e3.styleSheets, "href")) && (i2 = this.getBoundingBox(e3), n2 = e3.pdf.internal.scaleFactor, a2 = e3.pdf.internal.pageSize.getHeight(), e3.pdf.link(n2 * (i2[0] * e3.transform.sx + e3.transform.tx), a2 - n2 * (i2[1] * e3.transform.sy + e3.transform.ty), n2 * i2[2], n2 * i2[3], {
                url: r2
              })), [2];
          }
        });
      });
    }, e2;
  })(Wt);
  var jt = (function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return u$1(e2, t3), e2.prototype.apply = function(t4) {
      return f$1(this, void 0, void 0, function() {
        var e3, r2, i2, n2, a2;
        return c$2(this, function(s2) {
          switch (s2.label) {
            case 0:
              if (!this.isVisible(true, t4)) return [2];
              e3 = t4.pdf.matrixMult(this.computeNodeTransform(t4), t4.transform), t4.pdf.setCurrentTransformationMatrix(e3), r2 = 0, i2 = this.children, s2.label = 1;
            case 1:
              return r2 < i2.length ? [4, i2[r2].render(new g(t4.pdf, {
                refsHandler: t4.refsHandler,
                styleSheets: t4.styleSheets,
                viewport: t4.viewport,
                withinClipPath: true,
                svg2pdfParameters: t4.svg2pdfParameters,
                textMeasure: t4.textMeasure
              }))] : [3, 4];
            case 2:
              s2.sent(), s2.label = 3;
            case 3:
              return r2++, [3, 1];
            case 4:
              return n2 = this.children.length > 0 && !!N$1(this.children[0].element, t4.styleSheets, "clip-rule"), a2 = n2 ? this.getClipRuleAttr(this.children[0].element, t4.styleSheets) : this.getClipRuleAttr(this.element, t4.styleSheets), t4.pdf.clip(a2).discardPath(), t4.pdf.setCurrentTransformationMatrix(e3.inversed()), [2];
          }
        });
      });
    }, e2.prototype.getBoundingBoxCore = function(t4) {
      return q(t4, this);
    }, e2.prototype.isVisible = function(t4, e3) {
      return L(this, t4, e3);
    }, e2.prototype.getClipRuleAttr = function(t4, e3) {
      return "evenodd" === N$1(t4, e3, "clip-rule") ? "evenodd" : void 0;
    }, e2;
  })(J);
  function Gt(e2, r2) {
    var i2, n2 = [];
    switch ((function(t3, e3) {
      for (var r3 = [], i3 = 0; i3 < t3.childNodes.length; i3++) {
        var n3 = t3.childNodes[i3];
        "#" !== n3.nodeName.charAt(0) && r3.push(n3);
      }
      for (i3 = 0; i3 < r3.length; i3++) e3(i3, r3[i3]);
    })(e2, function(t3, e3) {
      return n2.push(Gt(e3, r2));
    }), e2.tagName.toLowerCase()) {
      case "a":
        i2 = new Vt(e2, n2);
        break;
      case "g":
        i2 = new Wt(e2, n2);
        break;
      case "circle":
        i2 = new It(e2, n2);
        break;
      case "clippath":
        i2 = new jt(e2, n2);
        break;
      case "ellipse":
        i2 = new xt(e2, n2);
        break;
      case "lineargradient":
        i2 = new tt(e2, n2);
        break;
      case "image":
        i2 = new Bt(e2, n2);
        break;
      case "line":
        i2 = new dt(e2, n2);
        break;
      case "marker":
        i2 = new Et(e2, n2);
        break;
      case "path":
        i2 = new At(e2, n2);
        break;
      case "pattern":
        i2 = new it(e2, n2);
        break;
      case "polygon":
        i2 = new Ot(e2, n2);
        break;
      case "polyline":
        i2 = new Rt(e2, n2);
        break;
      case "radialgradient":
        i2 = new et(e2, n2);
        break;
      case "rect":
        i2 = new bt(e2, n2);
        break;
      case "svg":
        i2 = new Dt(e2, n2);
        break;
      case "symbol":
        i2 = new mt(e2, n2);
        break;
      case "text":
        i2 = new Ft(e2, n2);
        break;
      case "use":
        i2 = new yt(e2, n2);
        break;
      default:
        i2 = new Lt(e2, n2);
    }
    if (null != r2 && i2.element.hasAttribute("id")) {
      var a2 = t$1(i2.element.id, {
        isIdentifier: true
      });
      r2[a2] = r2[a2] || i2;
    }
    return i2.children.forEach(function(t3) {
      return t3.setParent(i2);
    }), i2;
  }
  var Ut = (function() {
    function t3(t4, e2) {
      this.rootSvg = t4, this.loadExternalSheets = e2, this.styleSheets = [];
    }
    return t3.prototype.load = function() {
      return f$1(this, void 0, void 0, function() {
        var t4;
        return c$2(this, function(e2) {
          switch (e2.label) {
            case 0:
              return [4, this.collectStyleSheetTexts()];
            case 1:
              return t4 = e2.sent(), this.parseCssSheets(t4), [2];
          }
        });
      });
    }, t3.prototype.collectStyleSheetTexts = function() {
      return f$1(this, void 0, void 0, function() {
        var e2, r2, i2, n2, a2;
        return c$2(this, function(s2) {
          switch (s2.label) {
            case 0:
              if (e2 = [], this.loadExternalSheets && this.rootSvg.ownerDocument) for (n2 = 0; n2 < this.rootSvg.ownerDocument.childNodes.length; n2++) "xml-stylesheet" === (r2 = this.rootSvg.ownerDocument.childNodes[n2]).nodeName && "string" == typeof r2.data && e2.push(t3.loadSheet(r2.data.match(/href=["'].*?["']/)[0].split("=")[1].slice(1, -1)));
              for (i2 = this.rootSvg.querySelectorAll("style,link"), n2 = 0; n2 < i2.length; n2++) B(a2 = i2[n2], "style") ? e2.push(a2.textContent) : this.loadExternalSheets && B(a2, "link") && "stylesheet" === a2.getAttribute("rel") && a2.hasAttribute("href") && e2.push(t3.loadSheet(a2.getAttribute("href")));
              return [4, Promise.all(e2)];
            case 1:
              return [2, s2.sent().filter(function(t4) {
                return null !== t4;
              })];
          }
        });
      });
    }, t3.prototype.parseCssSheets = function(e2) {
      for (var r2 = document.implementation.createHTMLDocument(""), i2 = 0, n2 = e2; i2 < n2.length; i2++) {
        var a2 = n2[i2], s2 = r2.createElement("style");
        s2.textContent = a2, r2.body.appendChild(s2);
        var o2 = s2.sheet;
        if (o2 instanceof CSSStyleSheet) {
          for (var l2 = o2.cssRules.length - 1; l2 >= 0; l2--) {
            var u2 = o2.cssRules[l2];
            if (u2 instanceof CSSStyleRule) {
              var h2 = u2;
              if (h2.selectorText.indexOf(",") >= 0) {
                o2.deleteRule(l2);
                for (var f2 = h2.cssText.substring(h2.selectorText.length), c2 = t3.splitSelectorAtCommas(h2.selectorText), p2 = 0; p2 < c2.length; p2++) o2.insertRule(c2[p2] + f2, l2 + p2);
              }
            } else o2.deleteRule(l2);
          }
          this.styleSheets.push(o2);
        }
      }
    }, t3.splitSelectorAtCommas = function(t4) {
      for (var e2, r2 = /,|["']/g, i2 = /[^\\]["]/g, n2 = /[^\\][']/g, a2 = [], s2 = "initial", o2 = -1, l2 = i2, u2 = 0; u2 < t4.length; ) switch (s2) {
        case "initial":
          r2.lastIndex = u2, (e2 = r2.exec(t4)) ? ("," === e2[0] ? (a2.push(t4.substring(o2 + 1, r2.lastIndex - 1).trim()), o2 = r2.lastIndex - 1) : (s2 = "withinQuotes", l2 = '"' === e2[0] ? i2 : n2), u2 = r2.lastIndex) : (a2.push(t4.substring(o2 + 1).trim()), u2 = t4.length);
          break;
        case "withinQuotes":
          l2.lastIndex = u2, (e2 = l2.exec(t4)) && (u2 = l2.lastIndex, s2 = "initial");
      }
      return a2;
    }, t3.loadSheet = function(t4) {
      return new Promise(function(e2, r2) {
        var i2 = new XMLHttpRequest();
        i2.open("GET", t4, true), i2.responseType = "text", i2.onload = function() {
          200 !== i2.status && r2(new Error("Error ".concat(i2.status, ": Failed to load '").concat(t4, "'"))), e2(i2.responseText);
        }, i2.onerror = r2, i2.onabort = r2, i2.send(null);
      }).catch(function() {
        return null;
      });
    }, t3.prototype.getPropertyValue = function(t4, e2) {
      for (var r2 = [], i2 = 0, n2 = this.styleSheets; i2 < n2.length; i2++) for (var a2 = n2[i2], s2 = 0; s2 < a2.cssRules.length; s2++) {
        var l2 = a2.cssRules[s2];
        l2.style.getPropertyValue(e2) && t4.matches(l2.selectorText) && r2.push(l2);
      }
      if (0 !== r2.length) {
        return r2.reduce(function(t5, r3) {
          return 1 === (n3 = r3, (a3 = (i3 = t5).style.getPropertyPriority(e2)) !== n3.style.getPropertyPriority(e2) ? "important" === a3 ? 1 : -1 : compare(i3.selectorText, n3.selectorText)) ? t5 : r3;
          var i3, n3, a3;
        }).style.getPropertyValue(e2) || void 0;
      }
    }, t3;
  })();
  var zt = (function() {
    function t3() {
      this.measureMethods = {};
    }
    return t3.prototype.getTextOffset = function(t4, e2) {
      var r2 = e2.textAnchor;
      if ("start" === r2) return 0;
      var i2 = this.measureTextWidth(t4, e2), n2 = 0;
      switch (r2) {
        case "end":
          n2 = i2;
          break;
        case "middle":
          n2 = i2 / 2;
      }
      return n2;
    }, t3.prototype.measureTextWidth = function(t4, e2) {
      if (0 === t4.length) return 0;
      var r2 = e2.fontFamily;
      return this.getMeasureFunction(r2).call(this, t4, e2.fontFamily, e2.fontSize + "px", e2.fontStyle, e2.fontWeight);
    }, t3.prototype.getMeasurementTextNode = function() {
      if (!this.textMeasuringTextElement) {
        this.textMeasuringTextElement = document.createElementNS(D, "text");
        var t4 = document.createElementNS(D, "svg");
        t4.appendChild(this.textMeasuringTextElement), t4.style.setProperty("position", "absolute"), t4.style.setProperty("visibility", "hidden"), document.body.appendChild(t4);
      }
      return this.textMeasuringTextElement;
    }, t3.prototype.canvasTextMeasure = function(t4, e2, r2, i2, n2) {
      var a2 = document.createElement("canvas").getContext("2d");
      return null != a2 ? (a2.font = [i2, n2, r2, e2].join(" "), a2.measureText(t4).width) : 0;
    }, t3.prototype.svgTextMeasure = function(t4, e2, r2, i2, n2, a2) {
      void 0 === a2 && (a2 = this.getMeasurementTextNode());
      var s2 = a2;
      return s2.setAttribute("font-family", e2), s2.setAttribute("font-size", r2), s2.setAttribute("font-style", i2), s2.setAttribute("font-weight", n2), s2.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), s2.textContent = t4, s2.getBBox().width;
    }, t3.prototype.getMeasureFunction = function(e2) {
      var r2 = this.measureMethods[e2];
      if (!r2) {
        var i2 = "16px", n2 = "normal", a2 = "normal", s2 = this.canvasTextMeasure(t3.testString, e2, i2, n2, a2), o2 = this.svgTextMeasure(t3.testString, e2, i2, n2, a2);
        r2 = Math.abs(s2 - o2) < t3.epsilon ? this.canvasTextMeasure : this.svgTextMeasure, this.measureMethods[e2] = r2;
      }
      return r2;
    }, t3.prototype.cleanupTextMeasuring = function() {
      if (this.textMeasuringTextElement) {
        var t4 = this.textMeasuringTextElement.parentNode;
        t4 && document.body.removeChild(t4), this.textMeasuringTextElement = void 0;
      }
    }, t3.testString = `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789!"$%&/()=?'\\+*-_.:,;^}][{#~|<>`, t3.epsilon = 0.1, t3;
  })();
  function Yt(t3, e2) {
    return f$1(this, arguments, void 0, function(t4, e3, r2) {
      var i2, n2, a2, s2, o2, l2, u2, f2, p2, d2, m2, b2, v2, x2;
      return void 0 === r2 && (r2 = {}), c$2(this, function(c2) {
        switch (c2.label) {
          case 0:
            return i2 = null !== (b2 = r2.x) && void 0 !== b2 ? b2 : 0, n2 = null !== (v2 = r2.y) && void 0 !== v2 ? v2 : 0, a2 = null !== (x2 = r2.loadExternalStyleSheets) && void 0 !== x2 && x2, o2 = new y$1(s2 = {}), [4, (l2 = new Ut(t4, a2)).load()];
          case 1:
            return c2.sent(), u2 = new gt(e3.internal.pageSize.getWidth(), e3.internal.pageSize.getHeight()), f2 = h$1(h$1({}, r2), {
              element: t4
            }), p2 = new zt(), d2 = new g(e3, {
              refsHandler: o2,
              styleSheets: l2,
              viewport: u2,
              svg2pdfParameters: f2,
              textMeasure: p2
            }), e3.advancedAPI(), e3.saveGraphicsState(), e3.setCurrentTransformationMatrix(e3.Matrix(1, 0, 0, 1, i2, n2)), e3.setLineWidth(d2.attributeState.strokeWidth), m2 = d2.attributeState.fill.color, e3.setFillColor(m2.r, m2.g, m2.b), e3.setFont(d2.attributeState.fontFamily), e3.setFontSize(d2.attributeState.fontSize * e3.internal.scaleFactor), [4, Gt(t4, s2).render(d2)];
          case 2:
            return c2.sent(), e3.restoreGraphicsState(), e3.compatAPI(), d2.textMeasure.cleanupTextMeasuring(), [2, e3];
        }
      });
    });
  }
  E$1.API.svg = function(t3, e2) {
    return void 0 === e2 && (e2 = {}), Yt(t3, this, e2);
  };
  var {
    InsertElementCommand: InsertElementCommand2,
    RemoveElementCommand: RemoveElementCommand2,
    ChangeElementCommand: ChangeElementCommand2,
    BatchCommand: BatchCommand2
  } = history;
  var svgCanvas$2 = null;
  var init$2 = (canvas) => {
    svgCanvas$2 = canvas;
    svgCanvas$2.setSvgString = setSvgString;
    svgCanvas$2.importSvgString = importSvgString;
    svgCanvas$2.uniquifyElems = uniquifyElemsMethod;
    svgCanvas$2.setUseData = setUseDataMethod;
    svgCanvas$2.convertGradients = convertGradientsMethod;
    svgCanvas$2.removeUnusedDefElems = removeUnusedDefElemsMethod;
    svgCanvas$2.svgCanvasToString = svgCanvasToString;
    svgCanvas$2.svgToString = svgToString;
    svgCanvas$2.embedImage = embedImage;
    svgCanvas$2.rasterExport = rasterExport;
    svgCanvas$2.exportPDF = exportPDF;
  };
  var svgCanvasToString = () => {
    while (svgCanvas$2.removeUnusedDefElems() > 0) {
    }
    svgCanvas$2.pathActions.clear(true);
    const childNodesElems = svgCanvas$2.getSvgContent().childNodes;
    childNodesElems.forEach((node2, i2) => {
      if (i2 && node2.nodeType === 8 && node2.data.includes("Created with")) {
        svgCanvas$2.getSvgContent().firstChild.before(node2);
      }
    });
    if (svgCanvas$2.getCurrentGroup()) {
      leaveContext();
      svgCanvas$2.selectOnly([svgCanvas$2.getCurrentGroup()]);
    }
    const nakedSvgs = [];
    const gsvgElems = svgCanvas$2.getSvgContent().querySelectorAll("g[data-gsvg]");
    Array.prototype.forEach.call(gsvgElems, (element) => {
      const attrs = element.attributes;
      let len = attrs.length;
      for (let i2 = 0; i2 < len; i2++) {
        if (attrs[i2].nodeName === "id" || attrs[i2].nodeName === "style") {
          len--;
        }
      }
      if (len <= 0) {
        const svg2 = element.firstChild;
        nakedSvgs.push(svg2);
        element.replaceWith(svg2);
      }
    });
    const output = svgCanvas$2.svgToString(svgCanvas$2.getSvgContent(), 0);
    if (nakedSvgs.length) {
      Array.prototype.forEach.call(nakedSvgs, (el) => {
        svgCanvas$2.groupSvgElem(el);
      });
    }
    return output;
  };
  var svgToString = (elem, indent) => {
    const curConfig = svgCanvas$2.getCurConfig();
    const nsMap = svgCanvas$2.getNsMap();
    const out = [];
    const unit = curConfig.baseUnit;
    const unitRe = new RegExp("^-?[\\d\\.]+" + unit + "$");
    if (elem) {
      cleanupElement(elem);
      const attrs = [...elem.attributes];
      const childs = elem.childNodes;
      attrs.sort((a2, b2) => {
        return a2.name > b2.name ? -1 : 1;
      });
      for (let i2 = 0; i2 < indent; i2++) {
        out.push(" ");
      }
      out.push("<");
      out.push(elem.localName);
      if (elem.id === "svgcontent") {
        const res = svgCanvas$2.getResolution();
        let vb = "";
        if (curConfig.dynamicOutput) {
          vb = elem.getAttribute("viewBox");
          out.push(' viewBox="' + vb + '" xmlns="' + NS.SVG + '"');
        } else {
          if (unit !== "px") {
            res.w = convertUnit(res.w, unit) + unit;
            res.h = convertUnit(res.h, unit) + unit;
          }
          out.push(' width="' + res.w + '" height="' + res.h + '" xmlns="' + NS.SVG + '"');
        }
        const nsuris = {};
        const csElements = elem.querySelectorAll("*");
        const cElements = Array.prototype.slice.call(csElements);
        cElements.push(elem);
        Array.prototype.forEach.call(cElements, (el) => {
          const uri = el.namespaceURI;
          if (uri && !nsuris[uri] && nsMap[uri] && nsMap[uri] !== "xmlns" && nsMap[uri] !== "xml") {
            nsuris[uri] = true;
            out.push(" xmlns:" + nsMap[uri] + '="' + uri + '"');
          }
          if (el.attributes.length > 0) {
            for (const [, attr] of Object.entries(el.attributes)) {
              const u2 = attr.namespaceURI;
              if (u2 && !nsuris[u2] && nsMap[u2] !== "xmlns" && nsMap[u2] !== "xml") {
                nsuris[u2] = true;
                out.push(" xmlns:" + nsMap[u2] + '="' + u2 + '"');
              }
            }
          }
        });
        let i2 = attrs.length;
        const attrNames = ["width", "height", "xmlns", "x", "y", "viewBox", "id", "overflow"];
        while (i2--) {
          const attr = attrs[i2];
          const attrVal = toXml(attr.value);
          if (attr.nodeName.startsWith("xmlns:")) {
            continue;
          }
          if (attrVal !== "" && !attrNames.includes(attr.localName) && (!attr.namespaceURI || nsMap[attr.namespaceURI])) {
            out.push(" ");
            out.push(attr.nodeName);
            out.push('="');
            out.push(attrVal);
            out.push('"');
          }
        }
      } else {
        if (elem.nodeName === "defs" && !elem.firstChild) {
          return "";
        }
        const mozAttrs = ["-moz-math-font-style", "_moz-math-font-style"];
        for (let i2 = attrs.length - 1; i2 >= 0; i2--) {
          const attr = attrs[i2];
          let attrVal = toXml(attr.value);
          if (mozAttrs.includes(attr.localName)) {
            continue;
          }
          if (attrVal === "null") {
            const styleName = attr.localName.replace(/-[a-z]/g, (s2) => s2[1].toUpperCase());
            if (Object.prototype.hasOwnProperty.call(elem.style, styleName)) {
              continue;
            }
          }
          if (attrVal !== "") {
            if (attrVal.startsWith("pointer-events")) {
              continue;
            }
            if (attr.localName === "class" && attrVal.startsWith("se_")) {
              continue;
            }
            out.push(" ");
            if (attr.localName === "d") {
              attrVal = svgCanvas$2.pathActions.convertPath(elem, true);
            }
            if (!isNaN(attrVal)) {
              attrVal = shortFloat(attrVal);
            } else if (unitRe.test(attrVal)) {
              attrVal = shortFloat(attrVal) + unit;
            }
            if (svgCanvas$2.getSvgOptionApply() && elem.nodeName === "image" && attr.localName === "href" && svgCanvas$2.getSvgOptionImages() && svgCanvas$2.getSvgOptionImages() === "embed") {
              const img = svgCanvas$2.getEncodableImages(attrVal);
              if (img) {
                attrVal = img;
              }
            }
            if (!attr.namespaceURI || attr.namespaceURI === NS.SVG || nsMap[attr.namespaceURI]) {
              out.push(attr.nodeName);
              out.push('="');
              out.push(attrVal);
              out.push('"');
            }
          }
        }
      }
      if (elem.hasChildNodes()) {
        out.push(">");
        indent++;
        let bOneLine = false;
        for (let i2 = 0; i2 < childs.length; i2++) {
          const child = childs.item(i2);
          switch (child.nodeType) {
            case 1:
              out.push("\n");
              out.push(svgCanvas$2.svgToString(child, indent));
              break;
            case 3: {
              const str = child.nodeValue.replace(/^\s+|\s+$/g, "");
              if (str !== "") {
                bOneLine = true;
                out.push(String(toXml(str)));
              }
              break;
            }
            case 4:
              out.push("\n");
              out.push(new Array(indent + 1).join(" "));
              out.push("<![CDATA[");
              out.push(child.nodeValue);
              out.push("]]>");
              break;
            case 8:
              out.push("\n");
              out.push(new Array(indent + 1).join(" "));
              out.push("<!--");
              out.push(child.data);
              out.push("-->");
              break;
          }
        }
        indent--;
        if (!bOneLine) {
          out.push("\n");
          for (let i2 = 0; i2 < indent; i2++) {
            out.push(" ");
          }
        }
        out.push("</");
        out.push(elem.localName);
        out.push(">");
      } else {
        out.push("/>");
      }
    }
    return out.join("");
  };
  var setSvgString = (xmlString, preventUndo) => {
    const curConfig = svgCanvas$2.getCurConfig();
    const dataStorage2 = svgCanvas$2.getDataStorage();
    try {
      const newDoc = text2xml(xmlString);
      if (newDoc.firstElementChild && newDoc.firstElementChild.namespaceURI !== NS.SVG) {
        return false;
      }
      svgCanvas$2.prepareSvg(newDoc);
      const batchCmd = new BatchCommand2("Change Source");
      const {
        nextSibling
      } = svgCanvas$2.getSvgContent();
      svgCanvas$2.getSvgContent().remove();
      const oldzoom = svgCanvas$2.getSvgContent();
      batchCmd.addSubCommand(new RemoveElementCommand2(oldzoom, nextSibling, svgCanvas$2.getSvgRoot()));
      if (svgCanvas$2.getDOMDocument().adoptNode) {
        svgCanvas$2.setSvgContent(svgCanvas$2.getDOMDocument().adoptNode(newDoc.documentElement));
      } else {
        svgCanvas$2.setSvgContent(svgCanvas$2.getDOMDocument().importNode(newDoc.documentElement, true));
      }
      svgCanvas$2.getSvgRoot().append(svgCanvas$2.getSvgContent());
      const content = svgCanvas$2.getSvgContent();
      svgCanvas$2.current_drawing_ = new Drawing(svgCanvas$2.getSvgContent(), svgCanvas$2.getIdPrefix());
      const nonce = svgCanvas$2.getCurrentDrawing().getNonce();
      if (nonce) {
        svgCanvas$2.call("setnonce", nonce);
      } else {
        svgCanvas$2.call("unsetnonce");
      }
      const elements2 = content.querySelectorAll("image");
      Array.prototype.forEach.call(elements2, (image) => {
        preventClickDefault(image);
        const val = svgCanvas$2.getHref(image);
        if (val) {
          if (val.startsWith("data:")) {
            const m2 = val.match(/svgedit_url=(.*?);/);
            if (m2) {
              const url = decodeURIComponent(m2[1]);
              const iimg = new Image();
              iimg.addEventListener("load", () => {
                setHref(image, val);
              });
              iimg.src = url;
            }
          }
          svgCanvas$2.embedImage(val);
        }
      });
      const nodes = content.querySelectorAll("[id]");
      const ids = {};
      const totalNodes = nodes.length;
      for (let i2 = 0; i2 < totalNodes; i2++) {
        const currentId = nodes[i2].id ? nodes[i2].id : "undefined";
        if (isNaN(ids[currentId])) {
          ids[currentId] = 0;
        }
        ids[currentId]++;
      }
      Object.entries(ids).forEach(([key, value]) => {
        if (value > 1) {
          const nodes2 = content.querySelectorAll('[id="' + key + '"]');
          for (let i2 = 1; i2 < nodes2.length; i2++) {
            nodes2[i2].setAttribute("id", svgCanvas$2.getNextId());
          }
        }
      });
      const svgElements = content.querySelectorAll("svg");
      Array.prototype.forEach.call(svgElements, (element) => {
        if (getClosest(element.parentNode, "defs")) {
          return;
        }
        svgCanvas$2.uniquifyElems(element);
        const pa = element.parentNode;
        if (pa.childNodes.length === 1 && pa.nodeName === "g") {
          dataStorage2.put(pa, "gsvg", element);
          pa.id = pa.id || svgCanvas$2.getNextId();
        } else {
          svgCanvas$2.groupSvgElem(element);
        }
      });
      if (isGecko()) {
        const svgDefs = findDefs();
        const findElems = content.querySelectorAll("linearGradient, radialGradient, pattern");
        Array.prototype.forEach.call(findElems, (ele) => {
          svgDefs.appendChild(ele);
        });
      }
      svgCanvas$2.setUseData(content);
      svgCanvas$2.convertGradients(content);
      const attrs = {
        id: "svgcontent",
        overflow: curConfig.show_outside_canvas ? "visible" : "hidden"
      };
      let percs = false;
      if (content.getAttribute("viewBox")) {
        const viBox = content.getAttribute("viewBox");
        const vb = viBox.split(/[ ,]+/);
        attrs.width = vb[2];
        attrs.height = vb[3];
      } else {
        ;
        ["width", "height"].forEach((dim) => {
          const val = content.getAttribute(dim) || "100%";
          if (String(val).substr(-1) === "%") {
            percs = true;
          } else {
            attrs[dim] = convertToNum(dim, val);
          }
        });
      }
      identifyLayers();
      const chiElems = content.children;
      Array.prototype.forEach.call(chiElems, (chiElem) => {
        const visElems2 = chiElem.querySelectorAll(svgCanvas$2.getVisElems());
        Array.prototype.forEach.call(visElems2, (elem) => {
          if (!elem.id) {
            elem.id = svgCanvas$2.getNextId();
          }
        });
      });
      if (percs) {
        const bb = getStrokedBBoxDefaultVisible();
        attrs.width = bb.width + bb.x;
        attrs.height = bb.height + bb.y;
      }
      if (attrs.width <= 0) {
        attrs.width = 100;
      }
      if (attrs.height <= 0) {
        attrs.height = 100;
      }
      for (const [key, value] of Object.entries(attrs)) {
        content.setAttribute(key, value);
      }
      svgCanvas$2.contentW = attrs.width;
      svgCanvas$2.contentH = attrs.height;
      batchCmd.addSubCommand(new InsertElementCommand2(svgCanvas$2.getSvgContent()));
      const width = content.getAttribute("width");
      const height = content.getAttribute("height");
      const changes = {
        width,
        height
      };
      batchCmd.addSubCommand(new ChangeElementCommand2(svgCanvas$2.getSvgRoot(), changes));
      svgCanvas$2.setZoom(1);
      svgCanvas$2.clearSelection();
      clearData();
      svgCanvas$2.getSvgRoot().append(svgCanvas$2.selectorManager.selectorParentGroup);
      if (!preventUndo) svgCanvas$2.addCommandToHistory(batchCmd);
      svgCanvas$2.call("sourcechanged", [svgCanvas$2.getSvgContent()]);
    } catch (e2) {
      console.error(e2);
      return false;
    }
    return true;
  };
  var importSvgString = (xmlString, preserveDimension) => {
    const dataStorage2 = svgCanvas$2.getDataStorage();
    let j2;
    let ts;
    let useEl;
    try {
      const uid2 = hashCode(xmlString);
      let useExisting = false;
      if (svgCanvas$2.getImportIds(uid2) && svgCanvas$2.getImportIds(uid2).symbol) {
        const parents = getParents(svgCanvas$2.getImportIds(uid2).symbol, "#svgroot");
        if (parents?.length) {
          useExisting = true;
        }
      }
      const batchCmd = new BatchCommand2("Import Image");
      let symbol;
      if (useExisting) {
        symbol = svgCanvas$2.getImportIds(uid2).symbol;
        ts = svgCanvas$2.getImportIds(uid2).xform;
      } else {
        const newDoc = text2xml(xmlString);
        svgCanvas$2.prepareSvg(newDoc);
        const svg2 = svgCanvas$2.getDOMDocument().adoptNode ? svgCanvas$2.getDOMDocument().adoptNode(newDoc.documentElement) : svgCanvas$2.getDOMDocument().importNode(newDoc.documentElement, true);
        svgCanvas$2.uniquifyElems(svg2);
        const innerw = convertToNum("width", svg2.getAttribute("width"));
        const innerh = convertToNum("height", svg2.getAttribute("height"));
        const innervb = svg2.getAttribute("viewBox");
        const vb = innervb ? innervb.split(/[ ,]+/) : [0, 0, innerw, innerh];
        for (j2 = 0; j2 < 4; ++j2) {
          vb[j2] = Number(vb[j2]);
        }
        const canvash = Number(svgCanvas$2.getSvgContent().getAttribute("height"));
        ts = innerh > innerw ? "scale(" + canvash / 3 / vb[3] + ")" : "scale(" + canvash / 3 / vb[2] + ")";
        ts = "translate(0) " + ts + " translate(0)";
        symbol = svgCanvas$2.getDOMDocument().createElementNS(NS.SVG, "symbol");
        const defs = findDefs();
        if (isGecko()) {
          const elements2 = svg2.querySelectorAll("linearGradient, radialGradient, pattern");
          Array.prototype.forEach.call(elements2, (el) => {
            defs.appendChild(el);
          });
        }
        while (svg2.firstChild) {
          const first = svg2.firstChild;
          symbol.append(first);
        }
        const attrs = svg2.attributes;
        for (const attr of attrs) {
          symbol.setAttribute(attr.nodeName, attr.value);
        }
        symbol.id = svgCanvas$2.getNextId();
        svgCanvas$2.setImportIds(uid2, {
          symbol,
          xform: ts
        });
        findDefs().append(symbol);
        batchCmd.addSubCommand(new InsertElementCommand2(symbol));
      }
      useEl = svgCanvas$2.getDOMDocument().createElementNS(NS.SVG, "use");
      useEl.id = svgCanvas$2.getNextId();
      svgCanvas$2.setHref(useEl, "#" + symbol.id);
      (svgCanvas$2.getCurrentGroup() || svgCanvas$2.getCurrentDrawing().getCurrentLayer()).append(useEl);
      batchCmd.addSubCommand(new InsertElementCommand2(useEl));
      svgCanvas$2.clearSelection();
      if (!preserveDimension) {
        useEl.setAttribute("transform", ts);
        recalculateDimensions(useEl);
      }
      dataStorage2.put(useEl, "symbol", symbol);
      dataStorage2.put(useEl, "ref", symbol);
      svgCanvas$2.addToSelection([useEl]);
      svgCanvas$2.addCommandToHistory(batchCmd);
      svgCanvas$2.call("changed", [svgCanvas$2.getSvgContent()]);
    } catch (e2) {
      console.error(e2);
      return null;
    }
    return useEl;
  };
  var embedImage = (src) => {
    return new Promise((resolve, reject) => {
      const imgI = new Image();
      imgI.addEventListener("load", (e2) => {
        const cvs = document.createElement("canvas");
        cvs.width = e2.currentTarget.width;
        cvs.height = e2.currentTarget.height;
        cvs.getContext("2d").drawImage(e2.currentTarget, 0, 0);
        try {
          let urldata = ";svgedit_url=" + encodeURIComponent(src);
          urldata = cvs.toDataURL().replace(";base64", urldata + ";base64");
          svgCanvas$2.setEncodableImages(src, urldata);
        } catch (e3) {
          svgCanvas$2.setEncodableImages(src, false);
        }
        svgCanvas$2.setGoodImage(src);
        resolve(svgCanvas$2.getEncodableImages(src));
      });
      imgI.addEventListener("error", (e2) => {
        reject(new Error(`error loading image: ${e2.currentTarget.attributes.src.value}`));
      });
      imgI.setAttribute("src", src);
    });
  };
  var getIssues = () => {
    const uiStrings2 = svgCanvas$2.getUIStrings();
    svgCanvas$2.clearSelection();
    const issues = [];
    const issueCodes = [];
    const issueList = {
      feGaussianBlur: uiStrings2.NoBlur,
      foreignObject: uiStrings2.NoforeignObject,
      "[stroke-dasharray]": uiStrings2.NoDashArray
    };
    const content = svgCanvas$2.getSvgContent();
    if (!("font" in document.querySelector("CANVAS").getContext("2d"))) {
      issueList.text = uiStrings2.NoText;
    }
    for (const [sel, descr] of Object.entries(issueList)) {
      if (content.querySelectorAll(sel).length) {
        issueCodes.push(sel);
        issues.push(descr);
      }
    }
    return {
      issues,
      issueCodes
    };
  };
  var convertImagesToBase64 = async (svgElement) => {
    const imageElements = svgElement.querySelectorAll("image");
    const promises = Array.from(imageElements).map(async (img) => {
      const href = img.getAttribute("xlink:href") || img.getAttribute("href");
      if (href && !href.startsWith("data:")) {
        try {
          const response = await fetch(href);
          const blob = await response.blob();
          const reader = new FileReader();
          return new Promise((resolve) => {
            reader.onload = () => {
              setHref(img, reader.result);
              resolve();
            };
            reader.readAsDataURL(blob);
          });
        } catch (error) {
          console.error("Failed to fetch image:", error);
        }
      }
    });
    await Promise.all(promises);
  };
  var rasterExport = (imgType = "PNG", quality = 1, windowName = "Exported Image", opts = {}) => {
    return new Promise((resolve, reject) => {
      const type = imgType === "ICO" ? "BMP" : imgType;
      const mimeType = `image/${type.toLowerCase()}`;
      const {
        issues,
        issueCodes
      } = getIssues();
      const svgElement = svgCanvas$2.getSvgContent();
      const svgClone = svgElement.cloneNode(true);
      convertImagesToBase64(svgClone).then(() => {
        const svgData = new XMLSerializer().serializeToString(svgClone);
        const svgBlob = new Blob([svgData], {
          type: "image/svg+xml;charset=utf-8"
        });
        const url = URL.createObjectURL(svgBlob);
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const width = svgElement.clientWidth || svgElement.getAttribute("width");
        const height = svgElement.clientHeight || svgElement.getAttribute("height");
        canvas.width = width;
        canvas.height = height;
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, width, height);
          URL.revokeObjectURL(url);
          const datauri = canvas.toDataURL(mimeType, quality);
          let blobUrl;
          const onExportComplete = (blobUrl2) => {
            const exportObj = {
              datauri,
              bloburl: blobUrl2,
              svg: svgData,
              issues,
              issueCodes,
              type: imgType,
              mimeType,
              quality,
              windowName
            };
            if (!opts.avoidEvent) {
              svgCanvas$2.call("exported", exportObj);
            }
            resolve(exportObj);
          };
          canvas.toBlob((blob) => {
            blobUrl = URL.createObjectURL(blob);
            onExportComplete(blobUrl);
          }, mimeType, quality);
        };
        img.onerror = (err2) => {
          console.error("Failed to load SVG into image element:", err2);
          reject(err2);
        };
        img.src = url;
      }).catch(reject);
    });
  };
  var exportPDF = (windowName = "svg.pdf", outputType = isChrome() ? "save" : "dataurlstring") => {
    return new Promise((resolve, reject) => {
      const res = svgCanvas$2.getResolution();
      const orientation = res.w > res.h ? "landscape" : "portrait";
      const unit = "pt";
      const svgElement = svgCanvas$2.getSvgContent().cloneNode(true);
      convertImagesToBase64(svgElement).then(() => {
        const svgData = new XMLSerializer().serializeToString(svgElement);
        const svgBlob = new Blob([svgData], {
          type: "image/svg+xml;charset=utf-8"
        });
        const url = URL.createObjectURL(svgBlob);
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = res.w;
        canvas.height = res.h;
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, res.w, res.h);
          URL.revokeObjectURL(url);
          const imgData = canvas.toDataURL("image/png");
          const doc = new E$1({
            orientation,
            unit,
            format: [res.w, res.h]
          });
          const docTitle = svgCanvas$2.getDocumentTitle();
          doc.setProperties({
            title: docTitle
          });
          doc.addImage(imgData, "PNG", 0, 0, res.w, res.h);
          const {
            issues,
            issueCodes
          } = getIssues();
          const obj = {
            issues,
            issueCodes,
            windowName,
            outputType
          };
          obj.output = doc.output(outputType, outputType === "save" ? windowName : void 0);
          svgCanvas$2.call("exportedPDF", obj);
          resolve(obj);
        };
        img.onerror = (err2) => {
          console.error("Failed to load SVG into image element:", err2);
          reject(err2);
        };
        img.src = url;
      }).catch(reject);
    });
  };
  var uniquifyElemsMethod = (g2) => {
    const ids = {};
    const refElems = ["filter", "linearGradient", "pattern", "radialGradient", "symbol", "textPath", "use"];
    walkTree(g2, (n2) => {
      if (n2.nodeType === 1) {
        if (n2.id) {
          if (!(n2.id in ids)) {
            ids[n2.id] = {
              elem: null,
              attrs: [],
              hrefs: []
            };
          }
          ids[n2.id].elem = n2;
        }
        svgCanvas$2.getrefAttrs().forEach((attr) => {
          const attrnode = n2.getAttributeNode(attr);
          if (attrnode) {
            const url = svgCanvas$2.getUrlFromAttr(attrnode.value);
            const refid = url ? url.substr(1) : null;
            if (refid) {
              if (!(refid in ids)) {
                ids[refid] = {
                  elem: null,
                  attrs: [],
                  hrefs: []
                };
              }
              ids[refid].attrs.push(attrnode);
            }
          }
        });
        const href = svgCanvas$2.getHref(n2);
        if (href && refElems.includes(n2.nodeName)) {
          const refid = href.substr(1);
          if (refid) {
            if (!(refid in ids)) {
              ids[refid] = {
                elem: null,
                attrs: [],
                hrefs: []
              };
            }
            ids[refid].hrefs.push(n2);
          }
        }
      }
    });
    for (const oldid in ids) {
      if (!oldid) {
        continue;
      }
      const {
        elem
      } = ids[oldid];
      if (elem) {
        const newid = svgCanvas$2.getNextId();
        elem.id = newid;
        const {
          attrs
        } = ids[oldid];
        let j2 = attrs.length;
        while (j2--) {
          const attr = attrs[j2];
          attr.ownerElement.setAttribute(attr.name, "url(#" + newid + ")");
        }
        const hreffers = ids[oldid].hrefs;
        let k2 = hreffers.length;
        while (k2--) {
          const hreffer = hreffers[k2];
          svgCanvas$2.setHref(hreffer, "#" + newid);
        }
      }
    }
  };
  var setUseDataMethod = (parent) => {
    let elems = parent;
    if (parent.tagName !== "use") {
      elems = elems.querySelectorAll("use");
    }
    Array.prototype.forEach.call(elems, (el, _2) => {
      const dataStorage2 = svgCanvas$2.getDataStorage();
      const id = svgCanvas$2.getHref(el).substr(1);
      const refElem = svgCanvas$2.getElement(id);
      if (!refElem) {
        return;
      }
      dataStorage2.put(el, "ref", refElem);
      if (refElem.tagName === "symbol" || refElem.tagName === "svg") {
        dataStorage2.put(el, "symbol", refElem);
        dataStorage2.put(el, "ref", refElem);
      }
    });
  };
  var removeUnusedDefElemsMethod = () => {
    const defs = svgCanvas$2.getSvgContent().getElementsByTagNameNS(NS.SVG, "defs");
    if (!defs || !defs.length) {
      return 0;
    }
    const defelemUses = [];
    let numRemoved = 0;
    const attrs = ["fill", "stroke", "filter", "marker-start", "marker-mid", "marker-end"];
    const alen = attrs.length;
    const allEls = svgCanvas$2.getSvgContent().getElementsByTagNameNS(NS.SVG, "*");
    const allLen = allEls.length;
    let i2;
    let j2;
    for (i2 = 0; i2 < allLen; i2++) {
      const el = allEls[i2];
      for (j2 = 0; j2 < alen; j2++) {
        const ref = svgCanvas$2.getUrlFromAttr(el.getAttribute(attrs[j2]));
        if (ref) {
          defelemUses.push(ref.substr(1));
        }
      }
      const href = getHref(el);
      if (href && href.startsWith("#")) {
        defelemUses.push(href.substr(1));
      }
    }
    Array.prototype.forEach.call(defs, (def, i3) => {
      const defelems = def.querySelectorAll("linearGradient, radialGradient, filter, marker, svg, symbol");
      i3 = defelems.length;
      while (i3--) {
        const defelem = defelems[i3];
        const {
          id
        } = defelem;
        if (!defelemUses.includes(id)) {
          svgCanvas$2.setRemovedElements(id, defelem);
          defelem.remove();
          numRemoved++;
        }
      }
    });
    return numRemoved;
  };
  var convertGradientsMethod = (elem) => {
    let elems = elem.querySelectorAll("linearGradient, radialGradient");
    if (!elems.length && isWebkit()) {
      elems = Array.prototype.filter.call(elem.querySelectorAll("*"), (curThis) => {
        return curThis.tagName.includes("Gradient");
      });
    }
    Array.prototype.forEach.call(elems, (grad) => {
      if (grad.getAttribute("gradientUnits") === "userSpaceOnUse") {
        const svgContent = svgCanvas$2.getSvgContent();
        let fillStrokeElems = svgContent.querySelectorAll('[fill="url(#' + grad.id + ')"],[stroke="url(#' + grad.id + ')"]');
        if (!fillStrokeElems.length) {
          const tmpFillStrokeElems = svgContent.querySelectorAll('[*|href="#' + grad.id + '"]');
          if (!tmpFillStrokeElems.length) {
            return;
          } else {
            if ((tmpFillStrokeElems[0].tagName === "linearGradient" || tmpFillStrokeElems[0].tagName === "radialGradient") && tmpFillStrokeElems[0].getAttribute("gradientUnits") === "userSpaceOnUse") {
              fillStrokeElems = svgContent.querySelectorAll('[fill="url(#' + tmpFillStrokeElems[0].id + ')"],[stroke="url(#' + tmpFillStrokeElems[0].id + ')"]');
            } else {
              return;
            }
          }
        }
        const bb = getBBox(fillStrokeElems[0]);
        if (!bb) {
          return;
        }
        if (grad.tagName === "linearGradient") {
          const gCoords = {
            x1: grad.getAttribute("x1"),
            y1: grad.getAttribute("y1"),
            x2: grad.getAttribute("x2"),
            y2: grad.getAttribute("y2")
          };
          const tlist = getTransformList(grad);
          if (tlist?.numberOfItems > 0) {
            const m2 = transformListToTransform(tlist).matrix;
            const pt1 = transformPoint(gCoords.x1, gCoords.y1, m2);
            const pt2 = transformPoint(gCoords.x2, gCoords.y2, m2);
            gCoords.x1 = pt1.x;
            gCoords.y1 = pt1.y;
            gCoords.x2 = pt2.x;
            gCoords.y2 = pt2.y;
            grad.removeAttribute("gradientTransform");
          }
          grad.setAttribute("x1", (gCoords.x1 - bb.x) / bb.width);
          grad.setAttribute("y1", (gCoords.y1 - bb.y) / bb.height);
          grad.setAttribute("x2", (gCoords.x2 - bb.x) / bb.width);
          grad.setAttribute("y2", (gCoords.y2 - bb.y) / bb.height);
          grad.removeAttribute("gradientUnits");
        }
      }
    });
  };
  var svgCanvas$1;
  var selectorManager_;
  var gripRadius = window.ontouchstart ? 10 : 4;
  var Selector = class _Selector {
    /**
    * @param {Integer} id - Internally identify the selector
    * @param {Element} elem - DOM element associated with this selector
    * @param {module:utilities.BBoxObject} [bbox] - Optional bbox to use for initialization (prevents duplicate `getBBox` call).
    */
    constructor(id, elem, bbox) {
      this.id = id;
      this.selectedElement = elem;
      this.locked = true;
      this.selectorGroup = svgCanvas$1.createSVGElement({
        element: "g",
        attr: {
          id: "selectorGroup" + this.id
        }
      });
      this.selectorRect = svgCanvas$1.createSVGElement({
        element: "path",
        attr: {
          id: "selectedBox" + this.id,
          fill: "none",
          stroke: "#22C",
          "stroke-width": "1",
          "stroke-dasharray": "5,5",
          // need to specify this so that the rect is not selectable
          style: "pointer-events:none"
        }
      });
      this.selectorGroup.append(this.selectorRect);
      this.gripCoords = {
        nw: null,
        n: null,
        ne: null,
        e: null,
        se: null,
        s: null,
        sw: null,
        w: null
      };
      this.reset(this.selectedElement, bbox);
    }
    /**
    * Used to reset the id and element that the selector is attached to.
    * @param {Element} e - DOM element associated with this selector
    * @param {module:utilities.BBoxObject} bbox - Optional bbox to use for reset (prevents duplicate getBBox call).
    * @returns {void}
    */
    reset(e2, bbox) {
      this.locked = true;
      this.selectedElement = e2;
      this.resize(bbox);
      this.selectorGroup.setAttribute("display", "inline");
    }
    /**
    * Show the resize grips of this selector.
    * @param {boolean} show - Indicates whether grips should be shown or not
    * @returns {void}
    */
    showGrips(show) {
      const bShow = show ? "inline" : "none";
      selectorManager_.selectorGripsGroup.setAttribute("display", bShow);
      const elem = this.selectedElement;
      this.hasGrips = show;
      if (elem && show) {
        this.selectorGroup.append(selectorManager_.selectorGripsGroup);
        _Selector.updateGripCursors(getRotationAngle(elem));
      }
    }
    /**
    * Updates the selector to match the element's size.
    * @param {module:utilities.BBoxObject} [bbox] - BBox to use for resize (prevents duplicate getBBox call).
    * @returns {void}
    */
    resize(bbox) {
      const dataStorage2 = svgCanvas$1.getDataStorage();
      const selectedBox = this.selectorRect;
      const mgr = selectorManager_;
      const selectedGrips = mgr.selectorGrips;
      const selected = this.selectedElement;
      const zoom = svgCanvas$1.getZoom();
      let offset = 1 / zoom;
      const sw = selected.getAttribute("stroke-width");
      if (selected.getAttribute("stroke") !== "none" && !isNaN(sw)) {
        offset += sw / 2;
      }
      const {
        tagName
      } = selected;
      if (tagName === "text") {
        offset += 2 / zoom;
      }
      const svg2 = document.createElementNS(NS.SVG, "svg");
      let parentTransformationMatrix = svg2.createSVGMatrix();
      let currentElt = selected;
      while (currentElt.parentNode) {
        if (currentElt.parentNode && currentElt.parentNode.tagName === "g" && currentElt.parentNode.transform) {
          if (currentElt.parentNode.transform.baseVal.numberOfItems) {
            parentTransformationMatrix = matrixMultiply(transformListToTransform(getTransformList(selected.parentNode)).matrix, parentTransformationMatrix);
          }
        }
        currentElt = currentElt.parentNode;
      }
      const tlist = getTransformList(selected);
      const m2 = parentTransformationMatrix ? matrixMultiply(parentTransformationMatrix, transformListToTransform(tlist).matrix) : transformListToTransform(tlist).matrix;
      m2.e *= zoom;
      m2.f *= zoom;
      if (!bbox) {
        bbox = getBBox(selected);
      }
      if (tagName === "g" && !dataStorage2.has(selected, "gsvg")) {
        const strokedBbox = getStrokedBBox([selected.childNodes]);
        if (strokedBbox) {
          bbox = strokedBbox;
        }
      }
      if (bbox) {
        const l2 = bbox.x;
        const t3 = bbox.y;
        const w2 = bbox.width;
        const h2 = bbox.height;
        offset *= zoom;
        const nbox = transformBox(l2 * zoom, t3 * zoom, w2 * zoom, h2 * zoom, m2);
        const {
          aabox
        } = nbox;
        let nbax = aabox.x - offset;
        let nbay = aabox.y - offset;
        let nbaw = aabox.width + offset * 2;
        let nbah = aabox.height + offset * 2;
        const cx = nbax + nbaw / 2;
        const cy = nbay + nbah / 2;
        const angle2 = getRotationAngle(selected);
        if (angle2) {
          const rot = svgCanvas$1.getSvgRoot().createSVGTransform();
          rot.setRotate(-angle2, cx, cy);
          const rotm = rot.matrix;
          nbox.tl = transformPoint(nbox.tl.x, nbox.tl.y, rotm);
          nbox.tr = transformPoint(nbox.tr.x, nbox.tr.y, rotm);
          nbox.bl = transformPoint(nbox.bl.x, nbox.bl.y, rotm);
          nbox.br = transformPoint(nbox.br.x, nbox.br.y, rotm);
          const {
            tl
          } = nbox;
          let minx = tl.x;
          let miny = tl.y;
          let maxx = tl.x;
          let maxy = tl.y;
          const {
            min,
            max: max2
          } = Math;
          minx = min(minx, min(nbox.tr.x, min(nbox.bl.x, nbox.br.x))) - offset;
          miny = min(miny, min(nbox.tr.y, min(nbox.bl.y, nbox.br.y))) - offset;
          maxx = max2(maxx, max2(nbox.tr.x, max2(nbox.bl.x, nbox.br.x))) + offset;
          maxy = max2(maxy, max2(nbox.tr.y, max2(nbox.bl.y, nbox.br.y))) + offset;
          nbax = minx;
          nbay = miny;
          nbaw = maxx - minx;
          nbah = maxy - miny;
        }
        const dstr = "M" + nbax + "," + nbay + " L" + (nbax + nbaw) + "," + nbay + " " + (nbax + nbaw) + "," + (nbay + nbah) + " " + nbax + "," + (nbay + nbah) + "z";
        const xform = angle2 ? "rotate(" + [angle2, cx, cy].join(",") + ")" : "";
        this.gripCoords = {
          nw: [nbax, nbay],
          ne: [nbax + nbaw, nbay],
          sw: [nbax, nbay + nbah],
          se: [nbax + nbaw, nbay + nbah],
          n: [nbax + nbaw / 2, nbay],
          w: [nbax, nbay + nbah / 2],
          e: [nbax + nbaw, nbay + nbah / 2],
          s: [nbax + nbaw / 2, nbay + nbah]
        };
        selectedBox.setAttribute("d", dstr);
        this.selectorGroup.setAttribute("transform", xform);
        Object.entries(this.gripCoords).forEach(([dir, coords]) => {
          selectedGrips[dir].setAttribute("cx", coords[0]);
          selectedGrips[dir].setAttribute("cy", coords[1]);
        });
        mgr.rotateGripConnector.setAttribute("x1", nbax + nbaw / 2);
        mgr.rotateGripConnector.setAttribute("y1", nbay);
        mgr.rotateGripConnector.setAttribute("x2", nbax + nbaw / 2);
        mgr.rotateGripConnector.setAttribute("y2", nbay - gripRadius * 5);
        mgr.rotateGrip.setAttribute("cx", nbax + nbaw / 2);
        mgr.rotateGrip.setAttribute("cy", nbay - gripRadius * 5);
      }
    }
    // STATIC methods
    /**
    * Updates cursors for corner grips on rotation so arrows point the right way.
    * @param {Float} angle - Current rotation angle in degrees
    * @returns {void}
    */
    static updateGripCursors(angle2) {
      const dirArr = Object.keys(selectorManager_.selectorGrips);
      let steps = Math.round(angle2 / 45);
      if (steps < 0) {
        steps += 8;
      }
      while (steps > 0) {
        dirArr.push(dirArr.shift());
        steps--;
      }
      Object.values(selectorManager_.selectorGrips).forEach((gripElement, i2) => {
        gripElement.setAttribute("style", "cursor:" + dirArr[i2] + "-resize");
      });
    }
  };
  var SelectorManager = class {
    /**
     * Sets up properties and calls `initGroup`.
     */
    constructor() {
      this.selectorParentGroup = null;
      this.rubberBandBox = null;
      this.selectors = [];
      this.selectorMap = {};
      this.selectorGrips = {
        nw: null,
        n: null,
        ne: null,
        e: null,
        se: null,
        s: null,
        sw: null,
        w: null
      };
      this.selectorGripsGroup = null;
      this.rotateGripConnector = null;
      this.rotateGrip = null;
      this.initGroup();
    }
    /**
    * Resets the parent selector group element.
    * @returns {void}
    */
    initGroup() {
      const dataStorage2 = svgCanvas$1.getDataStorage();
      if (this.selectorParentGroup?.parentNode) {
        this.selectorParentGroup.remove();
      }
      this.selectorParentGroup = svgCanvas$1.createSVGElement({
        element: "g",
        attr: {
          id: "selectorParentGroup"
        }
      });
      this.selectorGripsGroup = svgCanvas$1.createSVGElement({
        element: "g",
        attr: {
          display: "none"
        }
      });
      this.selectorParentGroup.append(this.selectorGripsGroup);
      svgCanvas$1.getSvgRoot().append(this.selectorParentGroup);
      this.selectorMap = {};
      this.selectors = [];
      this.rubberBandBox = null;
      Object.keys(this.selectorGrips).forEach((dir) => {
        const grip = svgCanvas$1.createSVGElement({
          element: "circle",
          attr: {
            id: "selectorGrip_resize_" + dir,
            fill: "#22C",
            r: gripRadius,
            style: "cursor:" + dir + "-resize",
            // This expands the mouse-able area of the grips making them
            // easier to grab with the mouse.
            // This works in Opera and WebKit, but does not work in Firefox
            // see https://bugzilla.mozilla.org/show_bug.cgi?id=500174
            "stroke-width": 2,
            "pointer-events": "all"
          }
        });
        dataStorage2.put(grip, "dir", dir);
        dataStorage2.put(grip, "type", "resize");
        this.selectorGrips[dir] = grip;
        this.selectorGripsGroup.append(grip);
      });
      this.rotateGripConnector = svgCanvas$1.createSVGElement({
        element: "line",
        attr: {
          id: "selectorGrip_rotateconnector",
          stroke: "#22C",
          "stroke-width": "1"
        }
      });
      this.selectorGripsGroup.append(this.rotateGripConnector);
      this.rotateGrip = svgCanvas$1.createSVGElement({
        element: "circle",
        attr: {
          id: "selectorGrip_rotate",
          fill: "lime",
          r: gripRadius,
          stroke: "#22C",
          "stroke-width": 2,
          style: `cursor:url(${svgCanvas$1.curConfig.imgPath}/rotate.svg) 12 12, auto;`
        }
      });
      this.selectorGripsGroup.append(this.rotateGrip);
      dataStorage2.put(this.rotateGrip, "type", "rotate");
      if (document.getElementById("canvasBackground")) {
        return;
      }
      const [width, height] = svgCanvas$1.curConfig.dimensions;
      const canvasbg = svgCanvas$1.createSVGElement({
        element: "svg",
        attr: {
          id: "canvasBackground",
          width,
          height,
          x: 0,
          y: 0,
          overflow: isWebkit() ? "none" : "visible",
          // Chrome 7 has a problem with this when zooming out
          style: "pointer-events:none"
        }
      });
      const rect = svgCanvas$1.createSVGElement({
        element: "rect",
        attr: {
          width: "100%",
          height: "100%",
          x: 0,
          y: 0,
          "stroke-width": 1,
          stroke: "#000",
          fill: "#FFF",
          style: "pointer-events:none"
        }
      });
      canvasbg.append(rect);
      svgCanvas$1.getSvgRoot().insertBefore(canvasbg, svgCanvas$1.getSvgContent());
    }
    /**
    *
    * @param {Element} elem - DOM element to get the selector for
    * @param {module:utilities.BBoxObject} [bbox] - Optional bbox to use for reset (prevents duplicate getBBox call).
    * @returns {Selector} The selector based on the given element
    */
    requestSelector(elem, bbox) {
      if (!elem) {
        return null;
      }
      const N2 = this.selectors.length;
      if (typeof this.selectorMap[elem.id] === "object") {
        this.selectorMap[elem.id].locked = true;
        return this.selectorMap[elem.id];
      }
      for (let i2 = 0; i2 < N2; ++i2) {
        if (!this.selectors[i2]?.locked) {
          this.selectors[i2].locked = true;
          this.selectors[i2].reset(elem, bbox);
          this.selectorMap[elem.id] = this.selectors[i2];
          return this.selectors[i2];
        }
      }
      this.selectors[N2] = new Selector(N2, elem, bbox);
      this.selectorParentGroup.append(this.selectors[N2].selectorGroup);
      this.selectorMap[elem.id] = this.selectors[N2];
      return this.selectors[N2];
    }
    /**
    * Removes the selector of the given element (hides selection box).
    *
    * @param {Element} elem - DOM element to remove the selector for
    * @returns {void}
    */
    releaseSelector(elem) {
      if (!elem) {
        return;
      }
      const N2 = this.selectors.length;
      const sel = this.selectorMap[elem.id];
      if (!sel?.locked) {
        console.warn("WARNING! selector was released but was already unlocked");
      }
      for (let i2 = 0; i2 < N2; ++i2) {
        if (this.selectors[i2] && this.selectors[i2] === sel) {
          delete this.selectorMap[elem.id];
          sel.locked = false;
          sel.selectedElement = null;
          sel.showGrips(false);
          try {
            sel.selectorGroup.setAttribute("display", "none");
          } catch (e2) {
          }
          break;
        }
      }
    }
    /**
    * @returns {SVGRectElement} The rubberBandBox DOM element. This is the rectangle drawn by
    * the user for selecting/zooming
    */
    getRubberBandBox() {
      if (!this.rubberBandBox) {
        this.rubberBandBox = svgCanvas$1.createSVGElement({
          element: "rect",
          attr: {
            id: "selectorRubberBand",
            fill: "#22C",
            "fill-opacity": 0.15,
            stroke: "#22C",
            "stroke-width": 0.5,
            display: "none",
            style: "pointer-events:none"
          }
        });
        this.selectorParentGroup.append(this.rubberBandBox);
      }
      return this.rubberBandBox;
    }
  };
  var init$1 = (canvas) => {
    svgCanvas$1 = canvas;
    selectorManager_ = new SelectorManager();
  };
  var getSelectorManager = () => selectorManager_;
  var svgCanvas = null;
  var init = (canvas) => {
    svgCanvas = canvas;
  };
  var clearSvgContentElementInit = () => {
    const curConfig = svgCanvas.getCurConfig();
    const {
      dimensions
    } = curConfig;
    const el = svgCanvas.getSvgContent();
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
    const pel = svgCanvas.getSvgRoot();
    el.setAttribute("id", "svgcontent");
    el.setAttribute("width", dimensions[0]);
    el.setAttribute("height", dimensions[1]);
    el.setAttribute("x", dimensions[0]);
    el.setAttribute("y", dimensions[1]);
    el.setAttribute("overflow", curConfig.show_outside_canvas ? "visible" : "hidden");
    el.setAttribute("xmlns", NS.SVG);
    el.setAttribute("xmlns:se", NS.SE);
    el.setAttribute("xmlns:xlink", NS.XLINK);
    pel.appendChild(el);
    const comment = svgCanvas.getDOMDocument().createComment(" Created with SVG-edit - https://github.com/SVG-Edit/svgedit");
    svgCanvas.getSvgContent().append(comment);
  };
  var dataStorage = {
    _storage: /* @__PURE__ */ new WeakMap(),
    put: function(element, key, obj) {
      if (!this._storage.has(element)) {
        this._storage.set(element, /* @__PURE__ */ new Map());
      }
      this._storage.get(element).set(key, obj);
    },
    get: function(element, key) {
      return this._storage.get(element)?.get(key);
    },
    has: function(element, key) {
      return this._storage.has(element) && this._storage.get(element).has(key);
    },
    remove: function(element, key) {
      const ret = this._storage.get(element).delete(key);
      if (this._storage.get(element).size === 0) {
        this._storage.delete(element);
      }
      return ret;
    }
  };
  var visElems = "a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use";
  var refAttrs = ["clip-path", "fill", "filter", "marker-end", "marker-mid", "marker-start", "mask", "stroke"];
  var THRESHOLD_DIST = 0.8;
  var STEP_COUNT = 10;
  var CLIPBOARD_ID = "svgedit_clipboard";
  var SvgCanvas = class _SvgCanvas {
    /**
     * @param {HTMLElement} container - The container HTML element that should hold the SVG root element
     * @param {module:SVGeditor.configObj.curConfig} config - An object that contains configuration data
     */
    constructor(container, config) {
      this.initializeSvgCanvasMethods();
      init$k(this);
      const {
        pathActions: pathActions2
      } = pathModule;
      this.saveOptions = {
        round_digits: 2
      };
      this.importIds = {};
      this.extensions = {};
      this.removedElements = {};
      this.started = false;
      this.startTransform = null;
      this.currentMode = "select";
      this.currentResizeMode = "none";
      this.justSelected = null;
      this.rubberBox = null;
      this.curBBoxes = [];
      this.lastClickPoint = null;
      this.events = {};
      this.rootSctm = null;
      this.drawnPath = null;
      this.freehand = {
        // Mouse events
        minx: null,
        miny: null,
        maxx: null,
        maxy: null
      };
      this.dAttr = null;
      this.startX = null;
      this.startY = null;
      this.rStartX = null;
      this.rStartY = null;
      this.initBbox = {};
      this.sumDistance = 0;
      this.controllPoint2 = {
        x: 0,
        y: 0
      };
      this.controllPoint1 = {
        x: 0,
        y: 0
      };
      this.start = {
        x: 0,
        y: 0
      };
      this.end = {
        x: 0,
        y: 0
      };
      this.bSpline = {
        x: 0,
        y: 0
      };
      this.nextPos = {
        x: 0,
        y: 0
      };
      this.idprefix = "svg_";
      this.encodableImages = {};
      this.curConfig = {
        // Default configuration options
        show_outside_canvas: true,
        selectNew: true,
        dimensions: [640, 480]
      };
      if (config) {
        this.curConfig = _SvgCanvas.mergeDeep(this.curConfig, config);
      }
      this.lastGoodImgUrl = `${this.curConfig.imgPath}/logo.svg`;
      const {
        dimensions
      } = this.curConfig;
      this.svgdoc = window.document;
      this.container = container;
      this.svgroot = svgRootElement(this.svgdoc, dimensions);
      container.append(this.svgroot);
      this.svgContent = this.svgdoc.createElementNS(NS.SVG, "svg");
      init$d(this);
      init(this);
      this.clearSvgContentElement();
      this.current_drawing_ = new Drawing(this.svgContent, this.idprefix);
      this.zoom = 1;
      this.currentGroup = null;
      const allProperties = {
        shape: {
          fill: (this.curConfig.initFill.color === "none" ? "" : "#") + this.curConfig.initFill.color,
          fill_paint: null,
          fill_opacity: this.curConfig.initFill.opacity,
          stroke: "#" + this.curConfig.initStroke.color,
          stroke_paint: null,
          stroke_opacity: this.curConfig.initStroke.opacity,
          stroke_width: this.curConfig.initStroke.width,
          stroke_dasharray: "none",
          stroke_linejoin: "miter",
          stroke_linecap: "butt",
          opacity: this.curConfig.initOpacity
        }
      };
      allProperties.text = _SvgCanvas.mergeDeep({}, allProperties.shape);
      allProperties.text = _SvgCanvas.mergeDeep(allProperties.text, {
        fill: "#000000",
        stroke_width: this.curConfig.text?.stroke_width,
        font_size: this.curConfig.text?.font_size,
        font_family: this.curConfig.text?.font_family
      });
      this.curText = allProperties.text;
      this.curShape = allProperties.shape;
      this.curProperties = this.curShape;
      this.selectedElements = [];
      init$8(this);
      init$j(this);
      init$6(this);
      init$5(this);
      init$1(this);
      init$c(this);
      init$b(this);
      this.nsMap = getReverseNS();
      this.selectorManager = getSelectorManager();
      this.pathActions = pathActions2;
      init$g(this);
      this.uiStrings = {};
      this.opacAni = document.createElementNS(NS.SVG, "animate");
      this.opacAni.setAttribute("attributeName", "opacity");
      this.opacAni.setAttribute("begin", "indefinite");
      this.opacAni.setAttribute("dur", 1);
      this.opacAni.setAttribute("fill", "freeze");
      this.svgroot.appendChild(this.opacAni);
      init$9(this);
      init$a(this);
      init$2(this);
      init$f(this);
      init$7(this);
      const handleLinkInCanvas = (e2) => {
        e2.preventDefault();
        return false;
      };
      container.addEventListener("mousedown", this.mouseDownEvent);
      container.addEventListener("mousemove", this.mouseMoveEvent);
      $click(container, handleLinkInCanvas);
      container.addEventListener("dblclick", this.dblClickEvent);
      container.addEventListener("mouseup", this.mouseUpEvent);
      container.addEventListener("mouseleave", this.mouseOutEvent);
      container.addEventListener("mousewheel", this.DOMMouseScrollEvent);
      container.addEventListener("DOMMouseScroll", this.DOMMouseScrollEvent);
      this.linkControlPoints = pathActions2.linkControlPoints;
      this.curCommand = null;
      this.filter = null;
      this.filterHidden = false;
      init$3(this);
      init$4(this);
      const storageChange = (ev) => {
        if (!ev.newValue) return;
        if (ev.key === CLIPBOARD_ID + "_startup") {
          localStorage.removeItem(CLIPBOARD_ID + "_startup");
          this.flashStorage();
        } else if (ev.key === CLIPBOARD_ID) {
          sessionStorage.setItem(CLIPBOARD_ID, ev.newValue);
        }
      };
      window.addEventListener("storage", storageChange, false);
      localStorage.setItem(CLIPBOARD_ID + "_startup", Math.random());
      init$e(this);
      this.contentW = this.getResolution().w;
      this.contentH = this.getResolution().h;
      this.clear();
      this.modeChangeEvent();
    }
    // End constructor
    getSvgOption() {
      return this.saveOptions;
    }
    setSvgOption(key, value) {
      this.saveOptions[key] = value;
    }
    getSelectedElements() {
      return this.selectedElements;
    }
    setSelectedElements(key, value) {
      this.selectedElements[key] = value;
    }
    setEmptySelectedElements() {
      this.selectedElements = [];
    }
    getSvgRoot() {
      return this.svgroot;
    }
    getDOMDocument() {
      return this.svgdoc;
    }
    getDOMContainer() {
      return this.container;
    }
    getCurConfig() {
      return this.curConfig;
    }
    setIdPrefix(p2) {
      this.idprefix = p2;
    }
    getCurrentDrawing() {
      return this.current_drawing_;
    }
    getCurShape() {
      return this.curShape;
    }
    getCurrentGroup() {
      return this.currentGroup;
    }
    getBaseUnit() {
      return this.curConfig.baseUnit;
    }
    getHeight() {
      return this.svgContent.getAttribute("height") / this.zoom;
    }
    getWidth() {
      return this.svgContent.getAttribute("width") / this.zoom;
    }
    getRoundDigits() {
      return this.saveOptions.round_digits;
    }
    getSnappingStep() {
      return this.curConfig.snappingStep;
    }
    getGridSnapping() {
      return this.curConfig.gridSnapping;
    }
    getStartTransform() {
      return this.startTransform;
    }
    setStartTransform(transform) {
      this.startTransform = transform;
    }
    getZoom() {
      return this.zoom;
    }
    round(val) {
      return Number.parseInt(val * this.zoom) / this.zoom;
    }
    createSVGElement(jsonMap) {
      return this.addSVGElementsFromJson(jsonMap);
    }
    getContainer() {
      return this.container;
    }
    setStarted(s2) {
      this.started = s2;
    }
    getRubberBox() {
      return this.rubberBox;
    }
    setRubberBox(rb) {
      this.rubberBox = rb;
      return this.rubberBox;
    }
    addPtsToSelection({
      closedSubpath,
      grips
    }) {
      this.pathActions.canDeleteNodes = true;
      this.pathActions.closed_subpath = closedSubpath;
      this.call("pointsAdded", {
        closedSubpath,
        grips
      });
      this.call("selected", grips);
    }
    /**
     * @param {PlainObject} changes
     * @param {ChangeElementCommand} changes.cmd
     * @param {SVGPathElement} changes.elem
     * @fires module:svgcanvas.SvgCanvas#event:changed
     * @returns {void}
     */
    endChanges({
      cmd,
      elem
    }) {
      this.addCommandToHistory(cmd);
      this.call("changed", [elem]);
    }
    getCurrentMode() {
      return this.currentMode;
    }
    setCurrentMode(cm) {
      this.currentMode = cm;
      return this.currentMode;
    }
    getDrawnPath() {
      return this.drawnPath;
    }
    setDrawnPath(dp) {
      this.drawnPath = dp;
      return this.drawnPath;
    }
    setCurrentGroup(cg) {
      this.currentGroup = cg;
    }
    changeSvgContent() {
      this.call("changed", [this.svgContent]);
    }
    getStarted() {
      return this.started;
    }
    getCanvas() {
      return this;
    }
    getrootSctm() {
      return this.rootSctm;
    }
    getStartX() {
      return this.startX;
    }
    setStartX(value) {
      this.startX = value;
    }
    getStartY() {
      return this.startY;
    }
    setStartY(value) {
      this.startY = value;
    }
    getRStartX() {
      return this.rStartX;
    }
    getRStartY() {
      return this.rStartY;
    }
    getInitBbox() {
      return this.initBbox;
    }
    getCurrentResizeMode() {
      return this.currentResizeMode;
    }
    getJustSelected() {
      return this.justSelected;
    }
    getOpacAni() {
      return this.opacAni;
    }
    getParameter() {
      return this.parameter;
    }
    getNextParameter() {
      return this.nextParameter;
    }
    getStepCount() {
      return STEP_COUNT;
    }
    getThreSholdDist() {
      return THRESHOLD_DIST;
    }
    getSumDistance() {
      return this.sumDistance;
    }
    getStart(key) {
      return this.start[key];
    }
    getEnd(key) {
      return this.end[key];
    }
    getbSpline(key) {
      return this.bSpline[key];
    }
    getNextPos(key) {
      return this.nextPos[key];
    }
    getControllPoint1(key) {
      return this.controllPoint1[key];
    }
    getControllPoint2(key) {
      return this.controllPoint2[key];
    }
    getFreehand(key) {
      return this.freehand[key];
    }
    getDrawing() {
      return this.getCurrentDrawing();
    }
    getDAttr() {
      return this.dAttr;
    }
    getLastGoodImgUrl() {
      return this.lastGoodImgUrl;
    }
    getCurText(key) {
      return this.curText[key];
    }
    setDAttr(value) {
      this.dAttr = value;
    }
    setEnd(key, value) {
      this.end[key] = value;
    }
    setControllPoint1(key, value) {
      this.controllPoint1[key] = value;
    }
    setControllPoint2(key, value) {
      this.controllPoint2[key] = value;
    }
    setJustSelected(value) {
      this.justSelected = value;
    }
    setParameter(value) {
      this.parameter = value;
    }
    setStart(value) {
      this.start = value;
    }
    setRStartX(value) {
      this.rStartX = value;
    }
    setRStartY(value) {
      this.rStartY = value;
    }
    setSumDistance(value) {
      this.sumDistance = value;
    }
    setbSpline(value) {
      this.bSpline = value;
    }
    setNextPos(value) {
      this.nextPos = value;
    }
    setNextParameter(value) {
      this.nextParameter = value;
    }
    setCurText(key, value) {
      this.curText[key] = value;
    }
    setFreehand(key, value) {
      this.freehand[key] = value;
    }
    setCurBBoxes(value) {
      this.curBBoxes = value;
    }
    getCurBBoxes() {
      return this.curBBoxes;
    }
    setInitBbox(value) {
      this.initBbox = value;
    }
    setRootSctm(value) {
      this.rootSctm = value;
    }
    setCurrentResizeMode(value) {
      this.currentResizeMode = value;
    }
    getLastClickPoint(key) {
      return this.lastClickPoint[key];
    }
    setLastClickPoint(value) {
      this.lastClickPoint = value;
    }
    getId() {
      return this.getCurrentDrawing().getId();
    }
    getUIStrings() {
      return this.uiStrings;
    }
    getNsMap() {
      return this.nsMap;
    }
    getSvgOptionApply() {
      return this.saveOptions.apply;
    }
    getSvgOptionImages() {
      return this.saveOptions.images;
    }
    getEncodableImages(key) {
      return this.encodableImages[key];
    }
    setEncodableImages(key, value) {
      this.encodableImages[key] = value;
    }
    getVisElems() {
      return visElems;
    }
    getIdPrefix() {
      return this.idprefix;
    }
    getDataStorage() {
      return dataStorage;
    }
    setZoom(value) {
      this.zoom = value;
    }
    getImportIds(key) {
      return this.importIds[key];
    }
    setImportIds(key, value) {
      this.importIds[key] = value;
    }
    setRemovedElements(key, value) {
      this.removedElements[key] = value;
    }
    setSvgContent(value) {
      this.svgContent = value;
    }
    getrefAttrs() {
      return refAttrs;
    }
    setCanvas(key, value) {
      this[key] = value;
    }
    setCurProperties(key, value) {
      this.curProperties[key] = value;
    }
    getCurProperties(key) {
      return this.curProperties[key];
    }
    setCurShape(key, value) {
      this.curShape[key] = value;
    }
    gettingSelectorManager() {
      return this.selectorManager;
    }
    getContentW() {
      return this.contentW;
    }
    getContentH() {
      return this.contentH;
    }
    getClipboardID() {
      return CLIPBOARD_ID;
    }
    getSvgContent() {
      return this.svgContent;
    }
    getExtensions() {
      return this.extensions;
    }
    getSelector() {
      return Selector;
    }
    getMode() {
      return this.currentMode;
    }
    // The current editor mode string
    getNextId() {
      return this.getCurrentDrawing().getNextId();
    }
    getCurCommand() {
      return this.curCommand;
    }
    setCurCommand(value) {
      this.curCommand = value;
    }
    getFilter() {
      return this.filter;
    }
    setFilter(value) {
      this.filter = value;
    }
    getFilterHidden() {
      return this.filterHidden;
    }
    setFilterHidden(value) {
      this.filterHidden = value;
    }
    /**
     * Sets the editor's mode to the given string.
     * @function module:svgcanvas.SvgCanvas#setMode
     * @param {string} name - String with the new mode to change to
     * @returns {void}
     */
    setMode(name) {
      this.pathActions.clear(true);
      this.textActions.clear();
      this.curProperties = this.selectedElements[0]?.nodeName === "text" ? this.curText : this.curShape;
      this.currentMode = name;
      if (this.modeEvent) {
        document.dispatchEvent(this.modeEvent);
      }
    }
    /**
     * Clears the current document. This is not an undoable action.
     * @function module:svgcanvas.SvgCanvas#clear
     * @fires module:svgcanvas.SvgCanvas#event:beforeClear|afterClear
     * @returns {void}
     */
    clear() {
      this.call("beforeClear");
      this.pathActions.clear();
      this.clearSelection();
      this.clearSvgContentElement();
      this.current_drawing_ = new Drawing(this.svgContent);
      this.createLayer();
      this.undoMgr.resetUndoStack();
      this.selectorManager.initGroup();
      this.rubberBox = this.selectorManager.getRubberBandBox();
      this.call("afterClear");
    }
    async addExtension(name, extInitFunc, {
      importLocale
    }) {
      if (typeof extInitFunc !== "function") {
        throw new TypeError("Function argument expected for `svgcanvas.addExtension`");
      }
      if (name in this.extensions) {
        throw new Error('Cannot add extension "' + name + '", an extension by that name already exists.');
      }
      const argObj = {
        importLocale,
        svgroot: this.svgroot,
        svgContent: this.svgContent,
        nonce: this.getCurrentDrawing().getNonce(),
        selectorManager: this.selectorManager
      };
      const extObj = await extInitFunc(argObj);
      if (extObj) {
        extObj.name = name;
      }
      this.extensions[name] = extObj;
      return this.call("extension_added", extObj);
    }
    addCommandToHistory(cmd) {
      this.undoMgr.addCommandToHistory(cmd);
    }
    restoreRefElements(elem) {
      const attrs = {};
      refAttrs.forEach((item, _2) => {
        attrs[item] = elem.getAttribute(item);
      });
      Object.values(attrs).forEach((val) => {
        if (val?.startsWith("url(")) {
          const id = getUrlFromAttr(val).substr(1);
          const ref = getElement(id);
          if (!ref) {
            findDefs().append(this.removedElements[id]);
            delete this.removedElements[id];
          }
        }
      });
      const childs = elem.getElementsByTagName("*");
      if (childs.length) {
        for (let i2 = 0, l2 = childs.length; i2 < l2; i2++) {
          this.restoreRefElements(childs[i2]);
        }
      }
    }
    call(ev, arg) {
      if (this.events[ev]) {
        return this.events[ev](window, arg);
      }
      return void 0;
    }
    /**
     * Attaches a callback function to an event.
     * @function module:svgcanvas.SvgCanvas#bind
     * @param  {string} ev - String indicating the name of the event
     * @param {module:svgcanvas.EventHandler} f - The callback function to bind to the event
     * @returns {module:svgcanvas.EventHandler} The previous event
     */
    bind(ev, f2) {
      const old = this.events[ev];
      this.events[ev] = f2;
      return old;
    }
    /**
     * Flash the clipboard data momentarily on localStorage so all tabs can see.
     * @returns {void}
     */
    flashStorage() {
      const data = sessionStorage.getItem(CLIPBOARD_ID);
      localStorage.setItem(CLIPBOARD_ID, data);
      setTimeout(() => {
        localStorage.removeItem(CLIPBOARD_ID);
      }, 1);
    }
    /**
     * Selects only the given elements, shortcut for `clearSelection(); addToSelection()`.
     * @function module:svgcanvas.SvgCanvas#selectOnly
     * @param {Element[]} elems - an array of DOM elements to be selected
     * @param {boolean} showGrips - Indicates whether the resize grips should be shown
     * @returns {void}
     */
    selectOnly(elems, showGrips) {
      this.clearSelection(true);
      this.addToSelection(elems, showGrips);
    }
    /**
     * Removes elements from the selection.
     * @function module:svgcanvas.SvgCanvas#removeFromSelection
     * @param {Element[]} elemsToRemove - An array of elements to remove from selection
     * @returns {void}
     */
    removeFromSelection(elemsToRemove) {
      if (!this.selectedElements[0]) {
        return;
      }
      if (!elemsToRemove.length) {
        return;
      }
      const newSelectedItems = [];
      const len = this.selectedElements.length;
      for (let i2 = 0; i2 < len; ++i2) {
        const elem = this.selectedElements[i2];
        if (elem) {
          if (!elemsToRemove.includes(elem)) {
            newSelectedItems.push(elem);
          } else {
            this.selectorManager.releaseSelector(elem);
          }
        }
      }
      this.selectedElements = newSelectedItems;
    }
    /**
     * Clears the selection, then adds all elements in the current layer to the selection.
     * @function module:svgcanvas.SvgCanvas#selectAllInCurrentLayer
     * @returns {void}
     */
    selectAllInCurrentLayer() {
      const currentLayer = this.getCurrentDrawing().getCurrentLayer();
      if (currentLayer) {
        this.currentMode = "select";
        if (this.currentGroup) {
          this.selectOnly(this.currentGroup.children);
        } else {
          this.selectOnly(currentLayer.children);
        }
      }
    }
    getOpacity() {
      return this.curShape.opacity;
    }
    /**
     * @function module:svgcanvas.SvgCanvas#getSnapToGrid
     * @returns {boolean} The current snap to grid setting
     */
    getSnapToGrid() {
      return this.curConfig.gridSnapping;
    }
    /**
     * @function module:svgcanvas.SvgCanvas#getVersion
     * @returns {string} A string which describes the revision number of SvgCanvas.
     */
    getVersion() {
      return "svgcanvas.js ($Rev$)";
    }
    /**
     * Update interface strings with given values.
     * @function module:svgcanvas.SvgCanvas#setUiStrings
     * @param {module:path.uiStrings} strs - Object with strings (see the [locales API]{@link module:locale.LocaleStrings} and the [tutorial]{@tutorial LocaleDocs})
     * @returns {void}
     */
    setUiStrings(strs) {
      Object.assign(this.uiStrings, strs.notification);
      setUiStrings(strs);
    }
    /**
     * Update configuration options with given values.
     * @function module:svgcanvas.SvgCanvas#setConfig
     * @param {module:SVGEditor.Config} opts - Object with options
     * @returns {void}
     */
    setConfig(opts) {
      Object.assign(this.curConfig, opts);
    }
    /**
     * @function module:svgcanvas.SvgCanvas#getDocumentTitle
     * @returns {string|void} The current document title or an empty string if not found
     */
    getDocumentTitle() {
      return this.getTitle(this.svgContent);
    }
    getOffset() {
      return {
        x: Number(this.svgContent.getAttribute("x")),
        y: Number(this.svgContent.getAttribute("y"))
      };
    }
    getColor(type) {
      return this.curProperties[type];
    }
    setStrokePaint(paint) {
      this.setPaint("stroke", paint);
    }
    /**
     * @function module:svgcanvas.SvgCanvas#setFillPaint
     * @param {module:jGraduate~Paint} paint
     * @returns {void}
     */
    setFillPaint(paint) {
      this.setPaint("fill", paint);
    }
    /**
     * @function module:svgcanvas.SvgCanvas#getStrokeWidth
     * @returns {Float|string} The current stroke-width value
     */
    getStrokeWidth() {
      return this.curProperties.stroke_width;
    }
    /**
     * @function module:svgcanvas.SvgCanvas#getStyle
     * @returns {module:svgcanvas.StyleOptions} current style options
     */
    getStyle() {
      return this.curShape;
    }
    /**
     * Sets the given opacity on the current selected elements.
     * @function module:svgcanvas.SvgCanvas#setOpacity
     * @param {string} val
     * @returns {void}
     */
    setOpacity(val) {
      this.curShape.opacity = val;
      this.changeSelectedAttribute("opacity", val);
    }
    /**
     * @function module:svgcanvas.SvgCanvas#getFillOpacity
     * @returns {Float} the current fill opacity
     */
    getFillOpacity() {
      return this.curShape.fill_opacity;
    }
    /**
     * @function module:svgcanvas.SvgCanvas#getStrokeOpacity
     * @returns {string} the current stroke opacity
     */
    getStrokeOpacity() {
      return this.curShape.stroke_opacity;
    }
    /**
     * Sets the current fill/stroke opacity.
     * @function module:svgcanvas.SvgCanvas#setPaintOpacity
     * @param {string} type - String with "fill" or "stroke"
     * @param {Float} val - Float with the new opacity value
     * @param {boolean} preventUndo - Indicates whether or not this should be an undoable action
     * @returns {void}
     */
    setPaintOpacity(type, val, preventUndo) {
      this.curShape[type + "_opacity"] = val;
      if (!preventUndo) {
        this.changeSelectedAttribute(type + "-opacity", val);
      } else {
        this.changeSelectedAttributeNoUndo(type + "-opacity", val);
      }
    }
    /**
     * Gets the current fill/stroke opacity.
     * @function module:svgcanvas.SvgCanvas#getPaintOpacity
     * @param {"fill"|"stroke"} type - String with "fill" or "stroke"
     * @returns {Float} Fill/stroke opacity
     */
    getPaintOpacity(type) {
      return type === "fill" ? this.getFillOpacity() : this.getStrokeOpacity();
    }
    /**
     * Gets the `stdDeviation` blur value of the given element.
     * @function module:svgcanvas.SvgCanvas#getBlur
     * @param {Element} elem - The element to check the blur value for
     * @returns {string} stdDeviation blur attribute value
     */
    getBlur(elem) {
      let val = 0;
      if (elem) {
        const filterUrl = elem.getAttribute("filter");
        if (filterUrl) {
          const blur = getElement(elem.id + "_blur");
          if (blur) {
            val = blur.firstChild.getAttribute("stdDeviation");
          } else {
            const filterElem = getRefElem(filterUrl);
            const blurElem = getFeGaussianBlur(filterElem);
            if (blurElem !== null) {
              val = blurElem.getAttribute("stdDeviation");
            }
          }
        }
      }
      return val;
    }
    /**
     * Sets a given URL to be a "last good image" URL.
     * @function module:svgcanvas.SvgCanvas#setGoodImage
     * @param {string} val
     * @returns {void}
     */
    setGoodImage(val) {
      this.lastGoodImgUrl = val;
    }
    /**
     * Returns the current drawing as raw SVG XML text.
     * @function module:svgcanvas.SvgCanvas#getSvgString
     * @returns {string} The current drawing as raw SVG XML text.
     */
    getSvgString() {
      this.saveOptions.apply = false;
      return this.svgCanvasToString();
    }
    /**
     * This function determines whether to use a nonce in the prefix, when
     * generating IDs for future documents in SVG-Edit.
     * If you're controlling SVG-Edit externally, and want randomized IDs, call
     * this BEFORE calling `svgCanvas.setSvgString`.
     * @function module:svgcanvas.SvgCanvas#randomizeIds
     * @param {boolean} [enableRandomization] If true, adds a nonce to the prefix. Thus
     * `svgCanvas.randomizeIds() <==> svgCanvas.randomizeIds(true)`
     * @returns {void}
     */
    randomizeIds(enableRandomization) {
      if (arguments.length > 0 && enableRandomization === false) {
        randomizeIds(false, this.getCurrentDrawing());
      } else {
        randomizeIds(true, this.getCurrentDrawing());
      }
    }
    /**
     * Convert selected element to a path, or get the BBox of an element-as-path.
     * @function module:svgcanvas.SvgCanvas#convertToPath
     * @todo (codedread): Remove the getBBox argument and split this function into two.
     * @param {Element} elem - The DOM element to be converted
     * @param {boolean} getBBox - Boolean on whether or not to only return the path's BBox
     * @returns {void|DOMRect|false|SVGPathElement|null} If the getBBox flag is true, the resulting path's bounding box object.
     * Otherwise the resulting path element is returned.
     */
    convertToPath(elem, getBBox2) {
      if (!elem) {
        const elems = this.selectedElements;
        elems.forEach((el) => {
          if (el) {
            this.convertToPath(el);
          }
        });
        return void 0;
      }
      if (getBBox2) {
        return getBBoxOfElementAsPath(elem, this.addSVGElementsFromJson, this.pathActions);
      }
      const attrs = {
        fill: this.curShape.fill,
        "fill-opacity": this.curShape.fill_opacity,
        stroke: this.curShape.stroke,
        "stroke-width": this.curShape.stroke_width,
        "stroke-dasharray": this.curShape.stroke_dasharray,
        "stroke-linejoin": this.curShape.stroke_linejoin,
        "stroke-linecap": this.curShape.stroke_linecap,
        "stroke-opacity": this.curShape.stroke_opacity,
        opacity: this.curShape.opacity,
        visibility: "hidden"
      };
      return convertToPath(elem, attrs, this);
    }
    /**
     * Removes all selected elements from the DOM and adds the change to the
     * history stack. Remembers removed elements on the clipboard.
     * @function module:svgcanvas.SvgCanvas#cutSelectedElements
     * @returns {void}
     */
    cutSelectedElements() {
      this.copySelectedElements();
      this.deleteSelectedElements();
    }
    initializeSvgCanvasMethods() {
      this.getJsonFromSvgElements = getJsonFromSvgElements;
      this.addSVGElementsFromJson = addSVGElementsFromJson;
      this.clearSvgContentElement = clearSvgContentElementInit;
      this.textActions = textActionsMethod;
      this.getStrokedBBox = getStrokedBBoxDefaultVisible;
      this.getVisibleElements = getVisibleElements;
      this.stringToHTML = stringToHTML;
      this.insertChildAtIndex = insertChildAtIndex;
      this.getClosest = getClosest;
      this.getParents = getParents;
      this.isLayer = Layer.isLayer;
      this.matrixMultiply = matrixMultiply;
      this.hasMatrixTransform = hasMatrixTransform;
      this.transformListToTransform = transformListToTransform;
      this.convertToNum = convertToNum;
      this.convertUnit = convertUnit;
      this.findDefs = findDefs;
      this.getUrlFromAttr = getUrlFromAttr;
      this.getHref = getHref;
      this.setHref = setHref;
      this.getBBox = getBBox;
      this.getRotationAngle = getRotationAngle;
      this.getElement = getElement;
      this.getRefElem = getRefElem;
      this.assignAttributes = assignAttributes;
      this.cleanupElement = cleanupElement;
      this.remapElement = remapElement;
      this.recalculateDimensions = recalculateDimensions;
      this.sanitizeSvg = sanitizeSvg;
      this.pasteElements = pasteElementsMethod;
      this.identifyLayers = identifyLayers;
      this.createLayer = createLayer;
      this.cloneLayer = cloneLayer;
      this.deleteCurrentLayer = deleteCurrentLayer;
      this.setCurrentLayer = setCurrentLayer;
      this.renameCurrentLayer = renameCurrentLayer;
      this.setCurrentLayerPosition = setCurrentLayerPosition;
      this.indexCurrentLayer = indexCurrentLayer;
      this.setLayerVisibility = setLayerVisibility;
      this.moveSelectedToLayer = moveSelectedToLayer;
      this.mergeLayer = mergeLayer;
      this.mergeAllLayers = mergeAllLayers;
      this.leaveContext = leaveContext;
      this.setContext = setContext;
      this.changeSelectedAttributeNoUndo = changeSelectedAttributeNoUndoMethod;
      this.changeSelectedAttribute = changeSelectedAttributeMethod;
      this.setBlurNoUndo = setBlurNoUndo;
      this.setBlurOffsets = setBlurOffsets;
      this.setBlur = setBlur;
      this.smoothControlPoints = smoothControlPoints;
      this.getTypeMap = getTypeMap;
      this.history = history;
      this.NS = NS;
      this.$id = $id;
      this.$qq = $qq;
      this.$qa = $qa;
      this.$click = $click;
      this.encode64 = encode64;
      this.decode64 = decode64;
      this.mergeDeep = mergeDeep;
    }
    /**
     * Creates modeChange event, adds it as an svgCanvas property
     * **/
    modeChangeEvent() {
      const modeEvent = new CustomEvent("modeChange", {
        detail: {
          getMode: () => this.getMode()
        }
      });
      this.modeEvent = modeEvent;
    }
  };
  SvgCanvas.$id = $id;
  SvgCanvas.$qq = $qq;
  SvgCanvas.$qa = $qa;
  SvgCanvas.$click = $click;
  SvgCanvas.encode64 = encode64;
  SvgCanvas.decode64 = decode64;
  SvgCanvas.mergeDeep = mergeDeep;
  SvgCanvas.getClosest = getClosest;
  SvgCanvas.getParents = getParents;
  SvgCanvas.blankPageObjectURL = blankPageObjectURL;
  SvgCanvas.Paint = Paint;
  SvgCanvas.getTypeMap = getTypeMap;
  SvgCanvas.convertToNum = convertToNum;
  SvgCanvas.isValidUnit = isValidUnit;
  SvgCanvas.convertUnit = convertUnit;
  var html2canvas$3 = { exports: {} };
  var html2canvas$2 = html2canvas$3.exports;
  var hasRequiredHtml2canvas;
  function requireHtml2canvas() {
    if (hasRequiredHtml2canvas) return html2canvas$3.exports;
    hasRequiredHtml2canvas = 1;
    (function(module, exports) {
      (function(global2, factory) {
        module.exports = factory();
      })(html2canvas$2, function() {
        var extendStatics = function(d2, b2) {
          extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
          };
          return extendStatics(d2, b2);
        };
        function __extends(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null) throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        }
        var __assign = function() {
          __assign = Object.assign || function __assign2(t3) {
            for (var s2, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
              s2 = arguments[i3];
              for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t3[p2] = s2[p2];
            }
            return t3;
          };
          return __assign.apply(this, arguments);
        };
        function __awaiter(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e3) {
                reject(e3);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e3) {
                reject(e3);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, [])).next());
          });
        }
        function __generator(thisArg, body) {
          var _2 = {
            label: 0,
            sent: function() {
              if (t3[0] & 1) throw t3[1];
              return t3[1];
            },
            trys: [],
            ops: []
          }, f3, y2, t3, g2;
          return g2 = {
            next: verb(0),
            "throw": verb(1),
            "return": verb(2)
          }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
            return this;
          }), g2;
          function verb(n2) {
            return function(v2) {
              return step([n2, v2]);
            };
          }
          function step(op) {
            if (f3) throw new TypeError("Generator is already executing.");
            while (_2) try {
              if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done) return t3;
              if (y2 = 0, t3) op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _2.label++;
                  return {
                    value: op[1],
                    done: false
                  };
                case 5:
                  _2.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _2.ops.pop();
                  _2.trys.pop();
                  continue;
                default:
                  if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _2 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _2.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _2.label < t3[1]) {
                    _2.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _2.label < t3[2]) {
                    _2.label = t3[2];
                    _2.ops.push(op);
                    break;
                  }
                  if (t3[2]) _2.ops.pop();
                  _2.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _2);
            } catch (e3) {
              op = [6, e3];
              y2 = 0;
            } finally {
              f3 = t3 = 0;
            }
            if (op[0] & 5) throw op[1];
            return {
              value: op[0] ? op[1] : void 0,
              done: true
            };
          }
        }
        function __spreadArray(to, from, pack2) {
          if (arguments.length === 2) for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++) {
            if (ar || !(i3 in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
              ar[i3] = from[i3];
            }
          }
          return to.concat(ar || from);
        }
        var Bounds = (
          /** @class */
          (function() {
            function Bounds2(left, top, width, height) {
              this.left = left;
              this.top = top;
              this.width = width;
              this.height = height;
            }
            Bounds2.prototype.add = function(x2, y2, w2, h2) {
              return new Bounds2(this.left + x2, this.top + y2, this.width + w2, this.height + h2);
            };
            Bounds2.fromClientRect = function(context, clientRect) {
              return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
            };
            Bounds2.fromDOMRectList = function(context, domRectList) {
              var domRect = Array.from(domRectList).find(function(rect) {
                return rect.width !== 0;
              });
              return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
            };
            Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
            return Bounds2;
          })()
        );
        var parseBounds = function(context, node2) {
          return Bounds.fromClientRect(context, node2.getBoundingClientRect());
        };
        var parseDocumentSize = function(document2) {
          var body = document2.body;
          var documentElement = document2.documentElement;
          if (!body || !documentElement) {
            throw new Error("Unable to get document size");
          }
          var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
          var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
          return new Bounds(0, 0, width, height);
        };
        var toCodePoints$1 = function(str) {
          var codePoints = [];
          var i3 = 0;
          var length = str.length;
          while (i3 < length) {
            var value = str.charCodeAt(i3++);
            if (value >= 55296 && value <= 56319 && i3 < length) {
              var extra = str.charCodeAt(i3++);
              if ((extra & 64512) === 56320) {
                codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                codePoints.push(value);
                i3--;
              }
            } else {
              codePoints.push(value);
            }
          }
          return codePoints;
        };
        var fromCodePoint$1 = function() {
          var codePoints = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
          }
          if (String.fromCodePoint) {
            return String.fromCodePoint.apply(String, codePoints);
          }
          var length = codePoints.length;
          if (!length) {
            return "";
          }
          var codeUnits = [];
          var index2 = -1;
          var result = "";
          while (++index2 < length) {
            var codePoint = codePoints[index2];
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
            }
            if (index2 + 1 === length || codeUnits.length > 16384) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
          lookup$2[chars$2.charCodeAt(i$2)] = i$2;
        }
        var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
          lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
        }
        var decode$1 = function(base642) {
          var bufferLength = base642.length * 0.75, len = base642.length, i3, p2 = 0, encoded1, encoded2, encoded3, encoded4;
          if (base642[base642.length - 1] === "=") {
            bufferLength--;
            if (base642[base642.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
          var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
          for (i3 = 0; i3 < len; i3 += 4) {
            encoded1 = lookup$1$1[base642.charCodeAt(i3)];
            encoded2 = lookup$1$1[base642.charCodeAt(i3 + 1)];
            encoded3 = lookup$1$1[base642.charCodeAt(i3 + 2)];
            encoded4 = lookup$1$1[base642.charCodeAt(i3 + 3)];
            bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        };
        var polyUint16Array$1 = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i3 = 0; i3 < length; i3 += 2) {
            bytes.push(buffer[i3 + 1] << 8 | buffer[i3]);
          }
          return bytes;
        };
        var polyUint32Array$1 = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i3 = 0; i3 < length; i3 += 4) {
            bytes.push(buffer[i3 + 3] << 24 | buffer[i3 + 2] << 16 | buffer[i3 + 1] << 8 | buffer[i3]);
          }
          return bytes;
        };
        var UTRIE2_SHIFT_2$1 = 5;
        var UTRIE2_SHIFT_1$1 = 6 + 5;
        var UTRIE2_INDEX_SHIFT$1 = 2;
        var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
        var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
        var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
        var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
        var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
        var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
        var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
        var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
        var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
        var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
        var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
        var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
        var slice16$1 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint16Array(Array.prototype.slice.call(view, start, end));
        };
        var slice32$1 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint32Array(Array.prototype.slice.call(view, start, end));
        };
        var createTrieFromBase64$1 = function(base642, _byteLength) {
          var buffer = decode$1(base642);
          var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
          var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
          var headerLength = 24;
          var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
          var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
          return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data);
        };
        var Trie$1 = (
          /** @class */
          (function() {
            function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
              this.initialValue = initialValue;
              this.errorValue = errorValue;
              this.highStart = highStart;
              this.highValueIndex = highValueIndex;
              this.index = index2;
              this.data = data;
            }
            Trie2.prototype.get = function(codePoint) {
              var ix;
              if (codePoint >= 0) {
                if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                  ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
                }
                if (codePoint <= 65535) {
                  ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
                }
                if (codePoint < this.highStart) {
                  ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                  ix = this.index[ix];
                  ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
                  ix = this.index[ix];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
                }
                if (codePoint <= 1114111) {
                  return this.data[this.highValueIndex];
                }
              }
              return this.errorValue;
            };
            return Trie2;
          })()
        );
        var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
          lookup$3[chars$3.charCodeAt(i$3)] = i$3;
        }
        var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
        var LETTER_NUMBER_MODIFIER = 50;
        var BK = 1;
        var CR$1 = 2;
        var LF$1 = 3;
        var CM = 4;
        var NL = 5;
        var WJ = 7;
        var ZW = 8;
        var GL = 9;
        var SP = 10;
        var ZWJ$1 = 11;
        var B2 = 12;
        var BA = 13;
        var BB = 14;
        var HY = 15;
        var CB = 16;
        var CL = 17;
        var CP = 18;
        var EX = 19;
        var IN = 20;
        var NS2 = 21;
        var OP = 22;
        var QU = 23;
        var IS = 24;
        var NU = 25;
        var PO = 26;
        var PR = 27;
        var SY = 28;
        var AI = 29;
        var AL = 30;
        var CJ = 31;
        var EB = 32;
        var EM = 33;
        var H2 = 34;
        var H3 = 35;
        var HL = 36;
        var ID = 37;
        var JL = 38;
        var JV = 39;
        var JT = 40;
        var RI$1 = 41;
        var SA = 42;
        var XX = 43;
        var ea_OP = [9001, 65288];
        var BREAK_MANDATORY = "!";
        var BREAK_NOT_ALLOWED$1 = "\xD7";
        var BREAK_ALLOWED$1 = "\xF7";
        var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
        var ALPHABETICS = [AL, HL];
        var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
        var SPACE$1 = [SP, ZW];
        var PREFIX_POSTFIX = [PR, PO];
        var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
        var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
        var HYPHEN = [HY, BA];
        var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
          if (lineBreak2 === void 0) {
            lineBreak2 = "strict";
          }
          var types = [];
          var indices = [];
          var categories = [];
          codePoints.forEach(function(codePoint, index2) {
            var classType = UnicodeTrie$1.get(codePoint);
            if (classType > LETTER_NUMBER_MODIFIER) {
              categories.push(true);
              classType -= LETTER_NUMBER_MODIFIER;
            } else {
              categories.push(false);
            }
            if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
              if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
                indices.push(index2);
                return types.push(CB);
              }
            }
            if (classType === CM || classType === ZWJ$1) {
              if (index2 === 0) {
                indices.push(index2);
                return types.push(AL);
              }
              var prev = types[index2 - 1];
              if (LINE_BREAKS.indexOf(prev) === -1) {
                indices.push(indices[index2 - 1]);
                return types.push(prev);
              }
              indices.push(index2);
              return types.push(AL);
            }
            indices.push(index2);
            if (classType === CJ) {
              return types.push(lineBreak2 === "strict" ? NS2 : ID);
            }
            if (classType === SA) {
              return types.push(AL);
            }
            if (classType === AI) {
              return types.push(AL);
            }
            if (classType === XX) {
              if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
                return types.push(ID);
              } else {
                return types.push(AL);
              }
            }
            types.push(classType);
          });
          return [indices, types, categories];
        };
        var isAdjacentWithSpaceIgnored = function(a3, b2, currentIndex, classTypes) {
          var current = classTypes[currentIndex];
          if (Array.isArray(a3) ? a3.indexOf(current) !== -1 : a3 === current) {
            var i3 = currentIndex;
            while (i3 <= classTypes.length) {
              i3++;
              var next = classTypes[i3];
              if (next === b2) {
                return true;
              }
              if (next !== SP) {
                break;
              }
            }
          }
          if (current === SP) {
            var i3 = currentIndex;
            while (i3 > 0) {
              i3--;
              var prev = classTypes[i3];
              if (Array.isArray(a3) ? a3.indexOf(prev) !== -1 : a3 === prev) {
                var n2 = currentIndex;
                while (n2 <= classTypes.length) {
                  n2++;
                  var next = classTypes[n2];
                  if (next === b2) {
                    return true;
                  }
                  if (next !== SP) {
                    break;
                  }
                }
              }
              if (prev !== SP) {
                break;
              }
            }
          }
          return false;
        };
        var previousNonSpaceClassType = function(currentIndex, classTypes) {
          var i3 = currentIndex;
          while (i3 >= 0) {
            var type = classTypes[i3];
            if (type === SP) {
              i3--;
            } else {
              return type;
            }
          }
          return 0;
        };
        var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
          if (indicies[index2] === 0) {
            return BREAK_NOT_ALLOWED$1;
          }
          var currentIndex = index2 - 1;
          if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
            return BREAK_NOT_ALLOWED$1;
          }
          var beforeIndex = currentIndex - 1;
          var afterIndex = currentIndex + 1;
          var current = classTypes[currentIndex];
          var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
          var next = classTypes[afterIndex];
          if (current === CR$1 && next === LF$1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
            return BREAK_MANDATORY;
          }
          if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (SPACE$1.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
            return BREAK_ALLOWED$1;
          }
          if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === WJ || next === WJ) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === GL) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (isAdjacentWithSpaceIgnored([CL, CP], NS2, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === SP) {
            return BREAK_ALLOWED$1;
          }
          if (current === QU || next === QU) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (next === CB || current === CB) {
            return BREAK_ALLOWED$1;
          }
          if ([BA, HY, NS2].indexOf(next) !== -1 || current === BB) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (before === HL && HYPHEN.indexOf(current) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === SY && next === HL) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (next === IN) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (
            // (PR | PO)  ( OP | HY )? NU
            [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY )  NU
            [OP, HY].indexOf(current) !== -1 && next === NU || // NU 	(NU | SY | IS)
            current === NU && [NU, SY, IS].indexOf(next) !== -1
          ) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
            var prevIndex = currentIndex;
            while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                return BREAK_NOT_ALLOWED$1;
              } else if ([SY, IS].indexOf(type) !== -1) {
                prevIndex--;
              } else {
                break;
              }
            }
          }
          if ([PR, PO].indexOf(next) !== -1) {
            var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
            while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                return BREAK_NOT_ALLOWED$1;
              } else if ([SY, IS].indexOf(type) !== -1) {
                prevIndex--;
              } else {
                break;
              }
            }
          }
          if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === RI$1 && next === RI$1) {
            var i3 = indicies[currentIndex];
            var count = 1;
            while (i3 > 0) {
              i3--;
              if (classTypes[i3] === RI$1) {
                count++;
              } else {
                break;
              }
            }
            if (count % 2 !== 0) {
              return BREAK_NOT_ALLOWED$1;
            }
          }
          if (current === EB && next === EM) {
            return BREAK_NOT_ALLOWED$1;
          }
          return BREAK_ALLOWED$1;
        };
        var cssFormattedClasses = function(codePoints, options) {
          if (!options) {
            options = {
              lineBreak: "normal",
              wordBreak: "normal"
            };
          }
          var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
          if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
            classTypes = classTypes.map(function(type) {
              return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
            });
          }
          var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i3) {
            return letterNumber && codePoints[i3] >= 19968 && codePoints[i3] <= 40959;
          }) : void 0;
          return [indicies, classTypes, forbiddenBreakpoints];
        };
        var Break = (
          /** @class */
          (function() {
            function Break2(codePoints, lineBreak2, start, end) {
              this.codePoints = codePoints;
              this.required = lineBreak2 === BREAK_MANDATORY;
              this.start = start;
              this.end = end;
            }
            Break2.prototype.slice = function() {
              return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
            };
            return Break2;
          })()
        );
        var LineBreaker = function(str, options) {
          var codePoints = toCodePoints$1(str);
          var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
          var length = codePoints.length;
          var lastEnd = 0;
          var nextIndex = 0;
          return {
            next: function() {
              if (nextIndex >= length) {
                return {
                  done: true,
                  value: null
                };
              }
              var lineBreak2 = BREAK_NOT_ALLOWED$1;
              while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
              }
              if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
                var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
                lastEnd = nextIndex;
                return {
                  value,
                  done: false
                };
              }
              return {
                done: true,
                value: null
              };
            }
          };
        };
        var FLAG_UNRESTRICTED = 1 << 0;
        var FLAG_ID = 1 << 1;
        var FLAG_INTEGER = 1 << 2;
        var FLAG_NUMBER = 1 << 3;
        var LINE_FEED = 10;
        var SOLIDUS = 47;
        var REVERSE_SOLIDUS = 92;
        var CHARACTER_TABULATION = 9;
        var SPACE = 32;
        var QUOTATION_MARK = 34;
        var EQUALS_SIGN = 61;
        var NUMBER_SIGN = 35;
        var DOLLAR_SIGN = 36;
        var PERCENTAGE_SIGN = 37;
        var APOSTROPHE = 39;
        var LEFT_PARENTHESIS = 40;
        var RIGHT_PARENTHESIS = 41;
        var LOW_LINE = 95;
        var HYPHEN_MINUS = 45;
        var EXCLAMATION_MARK = 33;
        var LESS_THAN_SIGN = 60;
        var GREATER_THAN_SIGN = 62;
        var COMMERCIAL_AT = 64;
        var LEFT_SQUARE_BRACKET = 91;
        var RIGHT_SQUARE_BRACKET = 93;
        var CIRCUMFLEX_ACCENT = 61;
        var LEFT_CURLY_BRACKET = 123;
        var QUESTION_MARK = 63;
        var RIGHT_CURLY_BRACKET = 125;
        var VERTICAL_LINE = 124;
        var TILDE = 126;
        var CONTROL = 128;
        var REPLACEMENT_CHARACTER = 65533;
        var ASTERISK = 42;
        var PLUS_SIGN = 43;
        var COMMA = 44;
        var COLON = 58;
        var SEMICOLON = 59;
        var FULL_STOP = 46;
        var NULL = 0;
        var BACKSPACE = 8;
        var LINE_TABULATION = 11;
        var SHIFT_OUT = 14;
        var INFORMATION_SEPARATOR_ONE = 31;
        var DELETE = 127;
        var EOF = -1;
        var ZERO = 48;
        var a2 = 97;
        var e2 = 101;
        var f2 = 102;
        var u2 = 117;
        var z2 = 122;
        var A2 = 65;
        var E2 = 69;
        var F2 = 70;
        var U2 = 85;
        var Z2 = 90;
        var isDigit = function(codePoint) {
          return codePoint >= ZERO && codePoint <= 57;
        };
        var isSurrogateCodePoint = function(codePoint) {
          return codePoint >= 55296 && codePoint <= 57343;
        };
        var isHex = function(codePoint) {
          return isDigit(codePoint) || codePoint >= A2 && codePoint <= F2 || codePoint >= a2 && codePoint <= f2;
        };
        var isLowerCaseLetter = function(codePoint) {
          return codePoint >= a2 && codePoint <= z2;
        };
        var isUpperCaseLetter = function(codePoint) {
          return codePoint >= A2 && codePoint <= Z2;
        };
        var isLetter = function(codePoint) {
          return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
        };
        var isNonASCIICodePoint = function(codePoint) {
          return codePoint >= CONTROL;
        };
        var isWhiteSpace = function(codePoint) {
          return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
        };
        var isNameStartCodePoint = function(codePoint) {
          return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
        };
        var isNameCodePoint = function(codePoint) {
          return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
        };
        var isNonPrintableCodePoint = function(codePoint) {
          return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
        };
        var isValidEscape = function(c1, c2) {
          if (c1 !== REVERSE_SOLIDUS) {
            return false;
          }
          return c2 !== LINE_FEED;
        };
        var isIdentifierStart = function(c1, c2, c3) {
          if (c1 === HYPHEN_MINUS) {
            return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
          } else if (isNameStartCodePoint(c1)) {
            return true;
          } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
            return true;
          }
          return false;
        };
        var isNumberStart = function(c1, c2, c3) {
          if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
            if (isDigit(c2)) {
              return true;
            }
            return c2 === FULL_STOP && isDigit(c3);
          }
          if (c1 === FULL_STOP) {
            return isDigit(c2);
          }
          return isDigit(c1);
        };
        var stringToNumber = function(codePoints) {
          var c2 = 0;
          var sign = 1;
          if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
            if (codePoints[c2] === HYPHEN_MINUS) {
              sign = -1;
            }
            c2++;
          }
          var integers = [];
          while (isDigit(codePoints[c2])) {
            integers.push(codePoints[c2++]);
          }
          var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
          if (codePoints[c2] === FULL_STOP) {
            c2++;
          }
          var fraction = [];
          while (isDigit(codePoints[c2])) {
            fraction.push(codePoints[c2++]);
          }
          var fracd = fraction.length;
          var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
          if (codePoints[c2] === E2 || codePoints[c2] === e2) {
            c2++;
          }
          var expsign = 1;
          if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
            if (codePoints[c2] === HYPHEN_MINUS) {
              expsign = -1;
            }
            c2++;
          }
          var exponent = [];
          while (isDigit(codePoints[c2])) {
            exponent.push(codePoints[c2++]);
          }
          var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
          return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
        };
        var LEFT_PARENTHESIS_TOKEN = {
          type: 2
          /* LEFT_PARENTHESIS_TOKEN */
        };
        var RIGHT_PARENTHESIS_TOKEN = {
          type: 3
          /* RIGHT_PARENTHESIS_TOKEN */
        };
        var COMMA_TOKEN = {
          type: 4
          /* COMMA_TOKEN */
        };
        var SUFFIX_MATCH_TOKEN = {
          type: 13
          /* SUFFIX_MATCH_TOKEN */
        };
        var PREFIX_MATCH_TOKEN = {
          type: 8
          /* PREFIX_MATCH_TOKEN */
        };
        var COLUMN_TOKEN = {
          type: 21
          /* COLUMN_TOKEN */
        };
        var DASH_MATCH_TOKEN = {
          type: 9
          /* DASH_MATCH_TOKEN */
        };
        var INCLUDE_MATCH_TOKEN = {
          type: 10
          /* INCLUDE_MATCH_TOKEN */
        };
        var LEFT_CURLY_BRACKET_TOKEN = {
          type: 11
          /* LEFT_CURLY_BRACKET_TOKEN */
        };
        var RIGHT_CURLY_BRACKET_TOKEN = {
          type: 12
          /* RIGHT_CURLY_BRACKET_TOKEN */
        };
        var SUBSTRING_MATCH_TOKEN = {
          type: 14
          /* SUBSTRING_MATCH_TOKEN */
        };
        var BAD_URL_TOKEN = {
          type: 23
          /* BAD_URL_TOKEN */
        };
        var BAD_STRING_TOKEN = {
          type: 1
          /* BAD_STRING_TOKEN */
        };
        var CDO_TOKEN = {
          type: 25
          /* CDO_TOKEN */
        };
        var CDC_TOKEN = {
          type: 24
          /* CDC_TOKEN */
        };
        var COLON_TOKEN = {
          type: 26
          /* COLON_TOKEN */
        };
        var SEMICOLON_TOKEN = {
          type: 27
          /* SEMICOLON_TOKEN */
        };
        var LEFT_SQUARE_BRACKET_TOKEN = {
          type: 28
          /* LEFT_SQUARE_BRACKET_TOKEN */
        };
        var RIGHT_SQUARE_BRACKET_TOKEN = {
          type: 29
          /* RIGHT_SQUARE_BRACKET_TOKEN */
        };
        var WHITESPACE_TOKEN = {
          type: 31
          /* WHITESPACE_TOKEN */
        };
        var EOF_TOKEN = {
          type: 32
          /* EOF_TOKEN */
        };
        var Tokenizer = (
          /** @class */
          (function() {
            function Tokenizer2() {
              this._value = [];
            }
            Tokenizer2.prototype.write = function(chunk) {
              this._value = this._value.concat(toCodePoints$1(chunk));
            };
            Tokenizer2.prototype.read = function() {
              var tokens = [];
              var token = this.consumeToken();
              while (token !== EOF_TOKEN) {
                tokens.push(token);
                token = this.consumeToken();
              }
              return tokens;
            };
            Tokenizer2.prototype.consumeToken = function() {
              var codePoint = this.consumeCodePoint();
              switch (codePoint) {
                case QUOTATION_MARK:
                  return this.consumeStringToken(QUOTATION_MARK);
                case NUMBER_SIGN:
                  var c1 = this.peekCodePoint(0);
                  var c2 = this.peekCodePoint(1);
                  var c3 = this.peekCodePoint(2);
                  if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                    var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                    var value = this.consumeName();
                    return {
                      type: 5,
                      value,
                      flags
                    };
                  }
                  break;
                case DOLLAR_SIGN:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                    this.consumeCodePoint();
                    return SUFFIX_MATCH_TOKEN;
                  }
                  break;
                case APOSTROPHE:
                  return this.consumeStringToken(APOSTROPHE);
                case LEFT_PARENTHESIS:
                  return LEFT_PARENTHESIS_TOKEN;
                case RIGHT_PARENTHESIS:
                  return RIGHT_PARENTHESIS_TOKEN;
                case ASTERISK:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                    this.consumeCodePoint();
                    return SUBSTRING_MATCH_TOKEN;
                  }
                  break;
                case PLUS_SIGN:
                  if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                    this.reconsumeCodePoint(codePoint);
                    return this.consumeNumericToken();
                  }
                  break;
                case COMMA:
                  return COMMA_TOKEN;
                case HYPHEN_MINUS:
                  var e1 = codePoint;
                  var e22 = this.peekCodePoint(0);
                  var e3 = this.peekCodePoint(1);
                  if (isNumberStart(e1, e22, e3)) {
                    this.reconsumeCodePoint(codePoint);
                    return this.consumeNumericToken();
                  }
                  if (isIdentifierStart(e1, e22, e3)) {
                    this.reconsumeCodePoint(codePoint);
                    return this.consumeIdentLikeToken();
                  }
                  if (e22 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                    this.consumeCodePoint();
                    this.consumeCodePoint();
                    return CDC_TOKEN;
                  }
                  break;
                case FULL_STOP:
                  if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                    this.reconsumeCodePoint(codePoint);
                    return this.consumeNumericToken();
                  }
                  break;
                case SOLIDUS:
                  if (this.peekCodePoint(0) === ASTERISK) {
                    this.consumeCodePoint();
                    while (true) {
                      var c4 = this.consumeCodePoint();
                      if (c4 === ASTERISK) {
                        c4 = this.consumeCodePoint();
                        if (c4 === SOLIDUS) {
                          return this.consumeToken();
                        }
                      }
                      if (c4 === EOF) {
                        return this.consumeToken();
                      }
                    }
                  }
                  break;
                case COLON:
                  return COLON_TOKEN;
                case SEMICOLON:
                  return SEMICOLON_TOKEN;
                case LESS_THAN_SIGN:
                  if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
                    this.consumeCodePoint();
                    this.consumeCodePoint();
                    return CDO_TOKEN;
                  }
                  break;
                case COMMERCIAL_AT:
                  var a1 = this.peekCodePoint(0);
                  var a22 = this.peekCodePoint(1);
                  var a3 = this.peekCodePoint(2);
                  if (isIdentifierStart(a1, a22, a3)) {
                    var value = this.consumeName();
                    return {
                      type: 7,
                      value
                    };
                  }
                  break;
                case LEFT_SQUARE_BRACKET:
                  return LEFT_SQUARE_BRACKET_TOKEN;
                case REVERSE_SOLIDUS:
                  if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                    this.reconsumeCodePoint(codePoint);
                    return this.consumeIdentLikeToken();
                  }
                  break;
                case RIGHT_SQUARE_BRACKET:
                  return RIGHT_SQUARE_BRACKET_TOKEN;
                case CIRCUMFLEX_ACCENT:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                    this.consumeCodePoint();
                    return PREFIX_MATCH_TOKEN;
                  }
                  break;
                case LEFT_CURLY_BRACKET:
                  return LEFT_CURLY_BRACKET_TOKEN;
                case RIGHT_CURLY_BRACKET:
                  return RIGHT_CURLY_BRACKET_TOKEN;
                case u2:
                case U2:
                  var u1 = this.peekCodePoint(0);
                  var u22 = this.peekCodePoint(1);
                  if (u1 === PLUS_SIGN && (isHex(u22) || u22 === QUESTION_MARK)) {
                    this.consumeCodePoint();
                    this.consumeUnicodeRangeToken();
                  }
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                case VERTICAL_LINE:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                    this.consumeCodePoint();
                    return DASH_MATCH_TOKEN;
                  }
                  if (this.peekCodePoint(0) === VERTICAL_LINE) {
                    this.consumeCodePoint();
                    return COLUMN_TOKEN;
                  }
                  break;
                case TILDE:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                    this.consumeCodePoint();
                    return INCLUDE_MATCH_TOKEN;
                  }
                  break;
                case EOF:
                  return EOF_TOKEN;
              }
              if (isWhiteSpace(codePoint)) {
                this.consumeWhiteSpace();
                return WHITESPACE_TOKEN;
              }
              if (isDigit(codePoint)) {
                this.reconsumeCodePoint(codePoint);
                return this.consumeNumericToken();
              }
              if (isNameStartCodePoint(codePoint)) {
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
              }
              return {
                type: 6,
                value: fromCodePoint$1(codePoint)
              };
            };
            Tokenizer2.prototype.consumeCodePoint = function() {
              var value = this._value.shift();
              return typeof value === "undefined" ? -1 : value;
            };
            Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
              this._value.unshift(codePoint);
            };
            Tokenizer2.prototype.peekCodePoint = function(delta) {
              if (delta >= this._value.length) {
                return -1;
              }
              return this._value[delta];
            };
            Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
              var digits = [];
              var codePoint = this.consumeCodePoint();
              while (isHex(codePoint) && digits.length < 6) {
                digits.push(codePoint);
                codePoint = this.consumeCodePoint();
              }
              var questionMarks = false;
              while (codePoint === QUESTION_MARK && digits.length < 6) {
                digits.push(codePoint);
                codePoint = this.consumeCodePoint();
                questionMarks = true;
              }
              if (questionMarks) {
                var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                  return digit === QUESTION_MARK ? ZERO : digit;
                })), 16);
                var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                  return digit === QUESTION_MARK ? F2 : digit;
                })), 16);
                return {
                  type: 30,
                  start: start_1,
                  end
                };
              }
              var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
              if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
                this.consumeCodePoint();
                codePoint = this.consumeCodePoint();
                var endDigits = [];
                while (isHex(codePoint) && endDigits.length < 6) {
                  endDigits.push(codePoint);
                  codePoint = this.consumeCodePoint();
                }
                var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
                return {
                  type: 30,
                  start,
                  end
                };
              } else {
                return {
                  type: 30,
                  start,
                  end: start
                };
              }
            };
            Tokenizer2.prototype.consumeIdentLikeToken = function() {
              var value = this.consumeName();
              if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
                this.consumeCodePoint();
                return this.consumeUrlToken();
              } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
                this.consumeCodePoint();
                return {
                  type: 19,
                  value
                };
              }
              return {
                type: 20,
                value
              };
            };
            Tokenizer2.prototype.consumeUrlToken = function() {
              var value = [];
              this.consumeWhiteSpace();
              if (this.peekCodePoint(0) === EOF) {
                return {
                  type: 22,
                  value: ""
                };
              }
              var next = this.peekCodePoint(0);
              if (next === APOSTROPHE || next === QUOTATION_MARK) {
                var stringToken = this.consumeStringToken(this.consumeCodePoint());
                if (stringToken.type === 0) {
                  this.consumeWhiteSpace();
                  if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                    this.consumeCodePoint();
                    return {
                      type: 22,
                      value: stringToken.value
                    };
                  }
                }
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              }
              while (true) {
                var codePoint = this.consumeCodePoint();
                if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                  return {
                    type: 22,
                    value: fromCodePoint$1.apply(void 0, value)
                  };
                } else if (isWhiteSpace(codePoint)) {
                  this.consumeWhiteSpace();
                  if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                    this.consumeCodePoint();
                    return {
                      type: 22,
                      value: fromCodePoint$1.apply(void 0, value)
                    };
                  }
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
                } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
                } else if (codePoint === REVERSE_SOLIDUS) {
                  if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                    value.push(this.consumeEscapedCodePoint());
                  } else {
                    this.consumeBadUrlRemnants();
                    return BAD_URL_TOKEN;
                  }
                } else {
                  value.push(codePoint);
                }
              }
            };
            Tokenizer2.prototype.consumeWhiteSpace = function() {
              while (isWhiteSpace(this.peekCodePoint(0))) {
                this.consumeCodePoint();
              }
            };
            Tokenizer2.prototype.consumeBadUrlRemnants = function() {
              while (true) {
                var codePoint = this.consumeCodePoint();
                if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                  return;
                }
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.consumeEscapedCodePoint();
                }
              }
            };
            Tokenizer2.prototype.consumeStringSlice = function(count) {
              var SLICE_STACK_SIZE = 5e4;
              var value = "";
              while (count > 0) {
                var amount = Math.min(SLICE_STACK_SIZE, count);
                value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
                count -= amount;
              }
              this._value.shift();
              return value;
            };
            Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
              var value = "";
              var i3 = 0;
              do {
                var codePoint = this._value[i3];
                if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
                  value += this.consumeStringSlice(i3);
                  return {
                    type: 0,
                    value
                  };
                }
                if (codePoint === LINE_FEED) {
                  this._value.splice(0, i3);
                  return BAD_STRING_TOKEN;
                }
                if (codePoint === REVERSE_SOLIDUS) {
                  var next = this._value[i3 + 1];
                  if (next !== EOF && next !== void 0) {
                    if (next === LINE_FEED) {
                      value += this.consumeStringSlice(i3);
                      i3 = -1;
                      this._value.shift();
                    } else if (isValidEscape(codePoint, next)) {
                      value += this.consumeStringSlice(i3);
                      value += fromCodePoint$1(this.consumeEscapedCodePoint());
                      i3 = -1;
                    }
                  }
                }
                i3++;
              } while (true);
            };
            Tokenizer2.prototype.consumeNumber = function() {
              var repr = [];
              var type = FLAG_INTEGER;
              var c1 = this.peekCodePoint(0);
              if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
                repr.push(this.consumeCodePoint());
              }
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
              c1 = this.peekCodePoint(0);
              var c2 = this.peekCodePoint(1);
              if (c1 === FULL_STOP && isDigit(c2)) {
                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
                type = FLAG_NUMBER;
                while (isDigit(this.peekCodePoint(0))) {
                  repr.push(this.consumeCodePoint());
                }
              }
              c1 = this.peekCodePoint(0);
              c2 = this.peekCodePoint(1);
              var c3 = this.peekCodePoint(2);
              if ((c1 === E2 || c1 === e2) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
                type = FLAG_NUMBER;
                while (isDigit(this.peekCodePoint(0))) {
                  repr.push(this.consumeCodePoint());
                }
              }
              return [stringToNumber(repr), type];
            };
            Tokenizer2.prototype.consumeNumericToken = function() {
              var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
              var c1 = this.peekCodePoint(0);
              var c2 = this.peekCodePoint(1);
              var c3 = this.peekCodePoint(2);
              if (isIdentifierStart(c1, c2, c3)) {
                var unit = this.consumeName();
                return {
                  type: 15,
                  number,
                  flags,
                  unit
                };
              }
              if (c1 === PERCENTAGE_SIGN) {
                this.consumeCodePoint();
                return {
                  type: 16,
                  number,
                  flags
                };
              }
              return {
                type: 17,
                number,
                flags
              };
            };
            Tokenizer2.prototype.consumeEscapedCodePoint = function() {
              var codePoint = this.consumeCodePoint();
              if (isHex(codePoint)) {
                var hex = fromCodePoint$1(codePoint);
                while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                  hex += fromCodePoint$1(this.consumeCodePoint());
                }
                if (isWhiteSpace(this.peekCodePoint(0))) {
                  this.consumeCodePoint();
                }
                var hexCodePoint = parseInt(hex, 16);
                if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
                  return REPLACEMENT_CHARACTER;
                }
                return hexCodePoint;
              }
              if (codePoint === EOF) {
                return REPLACEMENT_CHARACTER;
              }
              return codePoint;
            };
            Tokenizer2.prototype.consumeName = function() {
              var result = "";
              while (true) {
                var codePoint = this.consumeCodePoint();
                if (isNameCodePoint(codePoint)) {
                  result += fromCodePoint$1(codePoint);
                } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  result += fromCodePoint$1(this.consumeEscapedCodePoint());
                } else {
                  this.reconsumeCodePoint(codePoint);
                  return result;
                }
              }
            };
            return Tokenizer2;
          })()
        );
        var Parser2 = (
          /** @class */
          (function() {
            function Parser3(tokens) {
              this._tokens = tokens;
            }
            Parser3.create = function(value) {
              var tokenizer = new Tokenizer();
              tokenizer.write(value);
              return new Parser3(tokenizer.read());
            };
            Parser3.parseValue = function(value) {
              return Parser3.create(value).parseComponentValue();
            };
            Parser3.parseValues = function(value) {
              return Parser3.create(value).parseComponentValues();
            };
            Parser3.prototype.parseComponentValue = function() {
              var token = this.consumeToken();
              while (token.type === 31) {
                token = this.consumeToken();
              }
              if (token.type === 32) {
                throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
              }
              this.reconsumeToken(token);
              var value = this.consumeComponentValue();
              do {
                token = this.consumeToken();
              } while (token.type === 31);
              if (token.type === 32) {
                return value;
              }
              throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
            };
            Parser3.prototype.parseComponentValues = function() {
              var values = [];
              while (true) {
                var value = this.consumeComponentValue();
                if (value.type === 32) {
                  return values;
                }
                values.push(value);
                values.push();
              }
            };
            Parser3.prototype.consumeComponentValue = function() {
              var token = this.consumeToken();
              switch (token.type) {
                case 11:
                case 28:
                case 2:
                  return this.consumeSimpleBlock(token.type);
                case 19:
                  return this.consumeFunction(token);
              }
              return token;
            };
            Parser3.prototype.consumeSimpleBlock = function(type) {
              var block = {
                type,
                values: []
              };
              var token = this.consumeToken();
              while (true) {
                if (token.type === 32 || isEndingTokenFor(token, type)) {
                  return block;
                }
                this.reconsumeToken(token);
                block.values.push(this.consumeComponentValue());
                token = this.consumeToken();
              }
            };
            Parser3.prototype.consumeFunction = function(functionToken) {
              var cssFunction = {
                name: functionToken.value,
                values: [],
                type: 18
                /* FUNCTION */
              };
              while (true) {
                var token = this.consumeToken();
                if (token.type === 32 || token.type === 3) {
                  return cssFunction;
                }
                this.reconsumeToken(token);
                cssFunction.values.push(this.consumeComponentValue());
              }
            };
            Parser3.prototype.consumeToken = function() {
              var token = this._tokens.shift();
              return typeof token === "undefined" ? EOF_TOKEN : token;
            };
            Parser3.prototype.reconsumeToken = function(token) {
              this._tokens.unshift(token);
            };
            return Parser3;
          })()
        );
        var isDimensionToken = function(token) {
          return token.type === 15;
        };
        var isNumberToken = function(token) {
          return token.type === 17;
        };
        var isIdentToken = function(token) {
          return token.type === 20;
        };
        var isStringToken = function(token) {
          return token.type === 0;
        };
        var isIdentWithValue = function(token, value) {
          return isIdentToken(token) && token.value === value;
        };
        var nonWhiteSpace = function(token) {
          return token.type !== 31;
        };
        var nonFunctionArgSeparator = function(token) {
          return token.type !== 31 && token.type !== 4;
        };
        var parseFunctionArgs = function(tokens) {
          var args = [];
          var arg = [];
          tokens.forEach(function(token) {
            if (token.type === 4) {
              if (arg.length === 0) {
                throw new Error("Error parsing function args, zero tokens for arg");
              }
              args.push(arg);
              arg = [];
              return;
            }
            if (token.type !== 31) {
              arg.push(token);
            }
          });
          if (arg.length) {
            args.push(arg);
          }
          return args;
        };
        var isEndingTokenFor = function(token, type) {
          if (type === 11 && token.type === 12) {
            return true;
          }
          if (type === 28 && token.type === 29) {
            return true;
          }
          return type === 2 && token.type === 3;
        };
        var isLength = function(token) {
          return token.type === 17 || token.type === 15;
        };
        var isLengthPercentage = function(token) {
          return token.type === 16 || isLength(token);
        };
        var parseLengthPercentageTuple = function(tokens) {
          return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
        };
        var ZERO_LENGTH = {
          type: 17,
          number: 0,
          flags: FLAG_INTEGER
        };
        var FIFTY_PERCENT = {
          type: 16,
          number: 50,
          flags: FLAG_INTEGER
        };
        var HUNDRED_PERCENT = {
          type: 16,
          number: 100,
          flags: FLAG_INTEGER
        };
        var getAbsoluteValueForTuple = function(tuple, width, height) {
          var x2 = tuple[0], y2 = tuple[1];
          return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y2 !== "undefined" ? y2 : x2, height)];
        };
        var getAbsoluteValue = function(token, parent) {
          if (token.type === 16) {
            return token.number / 100 * parent;
          }
          if (isDimensionToken(token)) {
            switch (token.unit) {
              case "rem":
              case "em":
                return 16 * token.number;
              // TODO use correct font-size
              case "px":
              default:
                return token.number;
            }
          }
          return token.number;
        };
        var DEG = "deg";
        var GRAD = "grad";
        var RAD = "rad";
        var TURN = "turn";
        var angle2 = {
          name: "angle",
          parse: function(_context, value) {
            if (value.type === 15) {
              switch (value.unit) {
                case DEG:
                  return Math.PI * value.number / 180;
                case GRAD:
                  return Math.PI / 200 * value.number;
                case RAD:
                  return value.number;
                case TURN:
                  return Math.PI * 2 * value.number;
              }
            }
            throw new Error("Unsupported angle type");
          }
        };
        var isAngle = function(value) {
          if (value.type === 15) {
            if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
              return true;
            }
          }
          return false;
        };
        var parseNamedSide = function(tokens) {
          var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
            return ident.value;
          }).join(" ");
          switch (sideOrCorner) {
            case "to bottom right":
            case "to right bottom":
            case "left top":
            case "top left":
              return [ZERO_LENGTH, ZERO_LENGTH];
            case "to top":
            case "bottom":
              return deg(0);
            case "to bottom left":
            case "to left bottom":
            case "right top":
            case "top right":
              return [ZERO_LENGTH, HUNDRED_PERCENT];
            case "to right":
            case "left":
              return deg(90);
            case "to top left":
            case "to left top":
            case "right bottom":
            case "bottom right":
              return [HUNDRED_PERCENT, HUNDRED_PERCENT];
            case "to bottom":
            case "top":
              return deg(180);
            case "to top right":
            case "to right top":
            case "left bottom":
            case "bottom left":
              return [HUNDRED_PERCENT, ZERO_LENGTH];
            case "to left":
            case "right":
              return deg(270);
          }
          return 0;
        };
        var deg = function(deg2) {
          return Math.PI * deg2 / 180;
        };
        var color$1 = {
          name: "color",
          parse: function(context, value) {
            if (value.type === 18) {
              var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
              if (typeof colorFunction === "undefined") {
                throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
              }
              return colorFunction(context, value.values);
            }
            if (value.type === 5) {
              if (value.value.length === 3) {
                var r2 = value.value.substring(0, 1);
                var g2 = value.value.substring(1, 2);
                var b2 = value.value.substring(2, 3);
                return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);
              }
              if (value.value.length === 4) {
                var r2 = value.value.substring(0, 1);
                var g2 = value.value.substring(1, 2);
                var b2 = value.value.substring(2, 3);
                var a3 = value.value.substring(3, 4);
                return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a3 + a3, 16) / 255);
              }
              if (value.value.length === 6) {
                var r2 = value.value.substring(0, 2);
                var g2 = value.value.substring(2, 4);
                var b2 = value.value.substring(4, 6);
                return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), 1);
              }
              if (value.value.length === 8) {
                var r2 = value.value.substring(0, 2);
                var g2 = value.value.substring(2, 4);
                var b2 = value.value.substring(4, 6);
                var a3 = value.value.substring(6, 8);
                return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a3, 16) / 255);
              }
            }
            if (value.type === 20) {
              var namedColor = COLORS[value.value.toUpperCase()];
              if (typeof namedColor !== "undefined") {
                return namedColor;
              }
            }
            return COLORS.TRANSPARENT;
          }
        };
        var isTransparent = function(color2) {
          return (255 & color2) === 0;
        };
        var asString = function(color2) {
          var alpha = 255 & color2;
          var blue = 255 & color2 >> 8;
          var green = 255 & color2 >> 16;
          var red = 255 & color2 >> 24;
          return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
        };
        var pack = function(r2, g2, b2, a3) {
          return (r2 << 24 | g2 << 16 | b2 << 8 | Math.round(a3 * 255) << 0) >>> 0;
        };
        var getTokenColorValue = function(token, i3) {
          if (token.type === 17) {
            return token.number;
          }
          if (token.type === 16) {
            var max2 = i3 === 3 ? 1 : 255;
            return i3 === 3 ? token.number / 100 * max2 : Math.round(token.number / 100 * max2);
          }
          return 0;
        };
        var rgb = function(_context, args) {
          var tokens = args.filter(nonFunctionArgSeparator);
          if (tokens.length === 3) {
            var _a2 = tokens.map(getTokenColorValue), r2 = _a2[0], g2 = _a2[1], b2 = _a2[2];
            return pack(r2, g2, b2, 1);
          }
          if (tokens.length === 4) {
            var _b2 = tokens.map(getTokenColorValue), r2 = _b2[0], g2 = _b2[1], b2 = _b2[2], a3 = _b2[3];
            return pack(r2, g2, b2, a3);
          }
          return 0;
        };
        function hue2rgb(t1, t22, hue) {
          if (hue < 0) {
            hue += 1;
          }
          if (hue >= 1) {
            hue -= 1;
          }
          if (hue < 1 / 6) {
            return (t22 - t1) * hue * 6 + t1;
          } else if (hue < 1 / 2) {
            return t22;
          } else if (hue < 2 / 3) {
            return (t22 - t1) * 6 * (2 / 3 - hue) + t1;
          } else {
            return t1;
          }
        }
        var hsl = function(context, args) {
          var tokens = args.filter(nonFunctionArgSeparator);
          var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
          var h2 = (hue.type === 17 ? deg(hue.number) : angle2.parse(context, hue)) / (Math.PI * 2);
          var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
          var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
          var a3 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
          if (s2 === 0) {
            return pack(l2 * 255, l2 * 255, l2 * 255, 1);
          }
          var t22 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
          var t1 = l2 * 2 - t22;
          var r2 = hue2rgb(t1, t22, h2 + 1 / 3);
          var g2 = hue2rgb(t1, t22, h2);
          var b2 = hue2rgb(t1, t22, h2 - 1 / 3);
          return pack(r2 * 255, g2 * 255, b2 * 255, a3);
        };
        var SUPPORTED_COLOR_FUNCTIONS = {
          hsl,
          hsla: hsl,
          rgb,
          rgba: rgb
        };
        var parseColor = function(context, value) {
          return color$1.parse(context, Parser2.create(value).parseComponentValue());
        };
        var COLORS = {
          ALICEBLUE: 4042850303,
          ANTIQUEWHITE: 4209760255,
          AQUA: 16777215,
          AQUAMARINE: 2147472639,
          AZURE: 4043309055,
          BEIGE: 4126530815,
          BISQUE: 4293182719,
          BLACK: 255,
          BLANCHEDALMOND: 4293643775,
          BLUE: 65535,
          BLUEVIOLET: 2318131967,
          BROWN: 2771004159,
          BURLYWOOD: 3736635391,
          CADETBLUE: 1604231423,
          CHARTREUSE: 2147418367,
          CHOCOLATE: 3530104575,
          CORAL: 4286533887,
          CORNFLOWERBLUE: 1687547391,
          CORNSILK: 4294499583,
          CRIMSON: 3692313855,
          CYAN: 16777215,
          DARKBLUE: 35839,
          DARKCYAN: 9145343,
          DARKGOLDENROD: 3095837695,
          DARKGRAY: 2846468607,
          DARKGREEN: 6553855,
          DARKGREY: 2846468607,
          DARKKHAKI: 3182914559,
          DARKMAGENTA: 2332068863,
          DARKOLIVEGREEN: 1433087999,
          DARKORANGE: 4287365375,
          DARKORCHID: 2570243327,
          DARKRED: 2332033279,
          DARKSALMON: 3918953215,
          DARKSEAGREEN: 2411499519,
          DARKSLATEBLUE: 1211993087,
          DARKSLATEGRAY: 793726975,
          DARKSLATEGREY: 793726975,
          DARKTURQUOISE: 13554175,
          DARKVIOLET: 2483082239,
          DEEPPINK: 4279538687,
          DEEPSKYBLUE: 12582911,
          DIMGRAY: 1768516095,
          DIMGREY: 1768516095,
          DODGERBLUE: 512819199,
          FIREBRICK: 2988581631,
          FLORALWHITE: 4294635775,
          FORESTGREEN: 579543807,
          FUCHSIA: 4278255615,
          GAINSBORO: 3705462015,
          GHOSTWHITE: 4177068031,
          GOLD: 4292280575,
          GOLDENROD: 3668254975,
          GRAY: 2155905279,
          GREEN: 8388863,
          GREENYELLOW: 2919182335,
          GREY: 2155905279,
          HONEYDEW: 4043305215,
          HOTPINK: 4285117695,
          INDIANRED: 3445382399,
          INDIGO: 1258324735,
          IVORY: 4294963455,
          KHAKI: 4041641215,
          LAVENDER: 3873897215,
          LAVENDERBLUSH: 4293981695,
          LAWNGREEN: 2096890111,
          LEMONCHIFFON: 4294626815,
          LIGHTBLUE: 2916673279,
          LIGHTCORAL: 4034953471,
          LIGHTCYAN: 3774873599,
          LIGHTGOLDENRODYELLOW: 4210742015,
          LIGHTGRAY: 3553874943,
          LIGHTGREEN: 2431553791,
          LIGHTGREY: 3553874943,
          LIGHTPINK: 4290167295,
          LIGHTSALMON: 4288707327,
          LIGHTSEAGREEN: 548580095,
          LIGHTSKYBLUE: 2278488831,
          LIGHTSLATEGRAY: 2005441023,
          LIGHTSLATEGREY: 2005441023,
          LIGHTSTEELBLUE: 2965692159,
          LIGHTYELLOW: 4294959359,
          LIME: 16711935,
          LIMEGREEN: 852308735,
          LINEN: 4210091775,
          MAGENTA: 4278255615,
          MAROON: 2147483903,
          MEDIUMAQUAMARINE: 1724754687,
          MEDIUMBLUE: 52735,
          MEDIUMORCHID: 3126187007,
          MEDIUMPURPLE: 2473647103,
          MEDIUMSEAGREEN: 1018393087,
          MEDIUMSLATEBLUE: 2070474495,
          MEDIUMSPRINGGREEN: 16423679,
          MEDIUMTURQUOISE: 1221709055,
          MEDIUMVIOLETRED: 3340076543,
          MIDNIGHTBLUE: 421097727,
          MINTCREAM: 4127193855,
          MISTYROSE: 4293190143,
          MOCCASIN: 4293178879,
          NAVAJOWHITE: 4292783615,
          NAVY: 33023,
          OLDLACE: 4260751103,
          OLIVE: 2155872511,
          OLIVEDRAB: 1804477439,
          ORANGE: 4289003775,
          ORANGERED: 4282712319,
          ORCHID: 3664828159,
          PALEGOLDENROD: 4008225535,
          PALEGREEN: 2566625535,
          PALETURQUOISE: 2951671551,
          PALEVIOLETRED: 3681588223,
          PAPAYAWHIP: 4293907967,
          PEACHPUFF: 4292524543,
          PERU: 3448061951,
          PINK: 4290825215,
          PLUM: 3718307327,
          POWDERBLUE: 2967529215,
          PURPLE: 2147516671,
          REBECCAPURPLE: 1714657791,
          RED: 4278190335,
          ROSYBROWN: 3163525119,
          ROYALBLUE: 1097458175,
          SADDLEBROWN: 2336560127,
          SALMON: 4202722047,
          SANDYBROWN: 4104413439,
          SEAGREEN: 780883967,
          SEASHELL: 4294307583,
          SIENNA: 2689740287,
          SILVER: 3233857791,
          SKYBLUE: 2278484991,
          SLATEBLUE: 1784335871,
          SLATEGRAY: 1887473919,
          SLATEGREY: 1887473919,
          SNOW: 4294638335,
          SPRINGGREEN: 16744447,
          STEELBLUE: 1182971135,
          TAN: 3535047935,
          TEAL: 8421631,
          THISTLE: 3636451583,
          TOMATO: 4284696575,
          TRANSPARENT: 0,
          TURQUOISE: 1088475391,
          VIOLET: 4001558271,
          WHEAT: 4125012991,
          WHITE: 4294967295,
          WHITESMOKE: 4126537215,
          YELLOW: 4294902015,
          YELLOWGREEN: 2597139199
        };
        var backgroundClip = {
          name: "background-clip",
          initialValue: "border-box",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.map(function(token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "padding-box":
                    return 1;
                  case "content-box":
                    return 2;
                }
              }
              return 0;
            });
          }
        };
        var backgroundColor = {
          name: "background-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
        var parseColorStop = function(context, args) {
          var color2 = color$1.parse(context, args[0]);
          var stop = args[1];
          return stop && isLengthPercentage(stop) ? {
            color: color2,
            stop
          } : {
            color: color2,
            stop: null
          };
        };
        var processColorStops = function(stops, lineLength) {
          var first = stops[0];
          var last = stops[stops.length - 1];
          if (first.stop === null) {
            first.stop = ZERO_LENGTH;
          }
          if (last.stop === null) {
            last.stop = HUNDRED_PERCENT;
          }
          var processStops = [];
          var previous = 0;
          for (var i3 = 0; i3 < stops.length; i3++) {
            var stop_1 = stops[i3].stop;
            if (stop_1 !== null) {
              var absoluteValue = getAbsoluteValue(stop_1, lineLength);
              if (absoluteValue > previous) {
                processStops.push(absoluteValue);
              } else {
                processStops.push(previous);
              }
              previous = absoluteValue;
            } else {
              processStops.push(null);
            }
          }
          var gapBegin = null;
          for (var i3 = 0; i3 < processStops.length; i3++) {
            var stop_2 = processStops[i3];
            if (stop_2 === null) {
              if (gapBegin === null) {
                gapBegin = i3;
              }
            } else if (gapBegin !== null) {
              var gapLength = i3 - gapBegin;
              var beforeGap = processStops[gapBegin - 1];
              var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
              for (var g2 = 1; g2 <= gapLength; g2++) {
                processStops[gapBegin + g2 - 1] = gapValue * g2;
              }
              gapBegin = null;
            }
          }
          return stops.map(function(_a2, i4) {
            var color2 = _a2.color;
            return {
              color: color2,
              stop: Math.max(Math.min(1, processStops[i4] / lineLength), 0)
            };
          });
        };
        var getAngleFromCorner = function(corner, width, height) {
          var centerX = width / 2;
          var centerY = height / 2;
          var x2 = getAbsoluteValue(corner[0], width) - centerX;
          var y2 = centerY - getAbsoluteValue(corner[1], height);
          return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);
        };
        var calculateGradientDirection = function(angle3, width, height) {
          var radian = typeof angle3 === "number" ? angle3 : getAngleFromCorner(angle3, width, height);
          var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
          var halfWidth = width / 2;
          var halfHeight = height / 2;
          var halfLineLength = lineLength / 2;
          var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
          var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
          return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
        };
        var distance = function(a3, b2) {
          return Math.sqrt(a3 * a3 + b2 * b2);
        };
        var findCorner = function(width, height, x2, y2, closest) {
          var corners = [[0, 0], [0, height], [width, 0], [width, height]];
          return corners.reduce(function(stat, corner) {
            var cx = corner[0], cy = corner[1];
            var d2 = distance(x2 - cx, y2 - cy);
            if (closest ? d2 < stat.optimumDistance : d2 > stat.optimumDistance) {
              return {
                optimumCorner: corner,
                optimumDistance: d2
              };
            }
            return stat;
          }, {
            optimumDistance: closest ? Infinity : -Infinity,
            optimumCorner: null
          }).optimumCorner;
        };
        var calculateRadius = function(gradient, x2, y2, width, height) {
          var rx = 0;
          var ry = 0;
          switch (gradient.size) {
            case 0:
              if (gradient.shape === 0) {
                rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
              } else if (gradient.shape === 1) {
                rx = Math.min(Math.abs(x2), Math.abs(x2 - width));
                ry = Math.min(Math.abs(y2), Math.abs(y2 - height));
              }
              break;
            case 2:
              if (gradient.shape === 0) {
                rx = ry = Math.min(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
              } else if (gradient.shape === 1) {
                var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));
                var _a2 = findCorner(width, height, x2, y2, true), cx = _a2[0], cy = _a2[1];
                rx = distance(cx - x2, (cy - y2) / c2);
                ry = c2 * rx;
              }
              break;
            case 1:
              if (gradient.shape === 0) {
                rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
              } else if (gradient.shape === 1) {
                rx = Math.max(Math.abs(x2), Math.abs(x2 - width));
                ry = Math.max(Math.abs(y2), Math.abs(y2 - height));
              }
              break;
            case 3:
              if (gradient.shape === 0) {
                rx = ry = Math.max(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
              } else if (gradient.shape === 1) {
                var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));
                var _b2 = findCorner(width, height, x2, y2, false), cx = _b2[0], cy = _b2[1];
                rx = distance(cx - x2, (cy - y2) / c2);
                ry = c2 * rx;
              }
              break;
          }
          if (Array.isArray(gradient.size)) {
            rx = getAbsoluteValue(gradient.size[0], width);
            ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
          }
          return [rx, ry];
        };
        var linearGradient = function(context, tokens) {
          var angle$1 = deg(180);
          var stops = [];
          parseFunctionArgs(tokens).forEach(function(arg, i3) {
            if (i3 === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 && firstToken.value === "to") {
                angle$1 = parseNamedSide(arg);
                return;
              } else if (isAngle(firstToken)) {
                angle$1 = angle2.parse(context, firstToken);
                return;
              }
            }
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          });
          return {
            angle: angle$1,
            stops,
            type: 1
            /* LINEAR_GRADIENT */
          };
        };
        var prefixLinearGradient = function(context, tokens) {
          var angle$1 = deg(180);
          var stops = [];
          parseFunctionArgs(tokens).forEach(function(arg, i3) {
            if (i3 === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
                angle$1 = parseNamedSide(arg);
                return;
              } else if (isAngle(firstToken)) {
                angle$1 = (angle2.parse(context, firstToken) + deg(270)) % deg(360);
                return;
              }
            }
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          });
          return {
            angle: angle$1,
            stops,
            type: 1
            /* LINEAR_GRADIENT */
          };
        };
        var webkitGradient = function(context, tokens) {
          var angle3 = deg(180);
          var stops = [];
          var type = 1;
          var shape = 0;
          var size = 3;
          var position2 = [];
          parseFunctionArgs(tokens).forEach(function(arg, i3) {
            var firstToken = arg[0];
            if (i3 === 0) {
              if (isIdentToken(firstToken) && firstToken.value === "linear") {
                type = 1;
                return;
              } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
                type = 2;
                return;
              }
            }
            if (firstToken.type === 18) {
              if (firstToken.name === "from") {
                var color2 = color$1.parse(context, firstToken.values[0]);
                stops.push({
                  stop: ZERO_LENGTH,
                  color: color2
                });
              } else if (firstToken.name === "to") {
                var color2 = color$1.parse(context, firstToken.values[0]);
                stops.push({
                  stop: HUNDRED_PERCENT,
                  color: color2
                });
              } else if (firstToken.name === "color-stop") {
                var values = firstToken.values.filter(nonFunctionArgSeparator);
                if (values.length === 2) {
                  var color2 = color$1.parse(context, values[1]);
                  var stop_1 = values[0];
                  if (isNumberToken(stop_1)) {
                    stops.push({
                      stop: {
                        type: 16,
                        number: stop_1.number * 100,
                        flags: stop_1.flags
                      },
                      color: color2
                    });
                  }
                }
              }
            }
          });
          return type === 1 ? {
            angle: (angle3 + deg(180)) % deg(360),
            stops,
            type
          } : {
            size,
            shape,
            stops,
            position: position2,
            type
          };
        };
        var CLOSEST_SIDE = "closest-side";
        var FARTHEST_SIDE = "farthest-side";
        var CLOSEST_CORNER = "closest-corner";
        var FARTHEST_CORNER = "farthest-corner";
        var CIRCLE = "circle";
        var ELLIPSE = "ellipse";
        var COVER = "cover";
        var CONTAIN = "contain";
        var radialGradient = function(context, tokens) {
          var shape = 0;
          var size = 3;
          var stops = [];
          var position2 = [];
          parseFunctionArgs(tokens).forEach(function(arg, i3) {
            var isColorStop = true;
            if (i3 === 0) {
              var isAtPosition_1 = false;
              isColorStop = arg.reduce(function(acc, token) {
                if (isAtPosition_1) {
                  if (isIdentToken(token)) {
                    switch (token.value) {
                      case "center":
                        position2.push(FIFTY_PERCENT);
                        return acc;
                      case "top":
                      case "left":
                        position2.push(ZERO_LENGTH);
                        return acc;
                      case "right":
                      case "bottom":
                        position2.push(HUNDRED_PERCENT);
                        return acc;
                    }
                  } else if (isLengthPercentage(token) || isLength(token)) {
                    position2.push(token);
                  }
                } else if (isIdentToken(token)) {
                  switch (token.value) {
                    case CIRCLE:
                      shape = 0;
                      return false;
                    case ELLIPSE:
                      shape = 1;
                      return false;
                    case "at":
                      isAtPosition_1 = true;
                      return false;
                    case CLOSEST_SIDE:
                      size = 0;
                      return false;
                    case COVER:
                    case FARTHEST_SIDE:
                      size = 1;
                      return false;
                    case CONTAIN:
                    case CLOSEST_CORNER:
                      size = 2;
                      return false;
                    case FARTHEST_CORNER:
                      size = 3;
                      return false;
                  }
                } else if (isLength(token) || isLengthPercentage(token)) {
                  if (!Array.isArray(size)) {
                    size = [];
                  }
                  size.push(token);
                  return false;
                }
                return acc;
              }, isColorStop);
            }
            if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
            }
          });
          return {
            size,
            shape,
            stops,
            position: position2,
            type: 2
            /* RADIAL_GRADIENT */
          };
        };
        var prefixRadialGradient = function(context, tokens) {
          var shape = 0;
          var size = 3;
          var stops = [];
          var position2 = [];
          parseFunctionArgs(tokens).forEach(function(arg, i3) {
            var isColorStop = true;
            if (i3 === 0) {
              isColorStop = arg.reduce(function(acc, token) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case "center":
                      position2.push(FIFTY_PERCENT);
                      return false;
                    case "top":
                    case "left":
                      position2.push(ZERO_LENGTH);
                      return false;
                    case "right":
                    case "bottom":
                      position2.push(HUNDRED_PERCENT);
                      return false;
                  }
                } else if (isLengthPercentage(token) || isLength(token)) {
                  position2.push(token);
                  return false;
                }
                return acc;
              }, isColorStop);
            } else if (i3 === 1) {
              isColorStop = arg.reduce(function(acc, token) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case CIRCLE:
                      shape = 0;
                      return false;
                    case ELLIPSE:
                      shape = 1;
                      return false;
                    case CONTAIN:
                    case CLOSEST_SIDE:
                      size = 0;
                      return false;
                    case FARTHEST_SIDE:
                      size = 1;
                      return false;
                    case CLOSEST_CORNER:
                      size = 2;
                      return false;
                    case COVER:
                    case FARTHEST_CORNER:
                      size = 3;
                      return false;
                  }
                } else if (isLength(token) || isLengthPercentage(token)) {
                  if (!Array.isArray(size)) {
                    size = [];
                  }
                  size.push(token);
                  return false;
                }
                return acc;
              }, isColorStop);
            }
            if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
            }
          });
          return {
            size,
            shape,
            stops,
            position: position2,
            type: 2
            /* RADIAL_GRADIENT */
          };
        };
        var isLinearGradient = function(background) {
          return background.type === 1;
        };
        var isRadialGradient = function(background) {
          return background.type === 2;
        };
        var image = {
          name: "image",
          parse: function(context, value) {
            if (value.type === 22) {
              var image_1 = {
                url: value.value,
                type: 0
                /* URL */
              };
              context.cache.addImage(value.value);
              return image_1;
            }
            if (value.type === 18) {
              var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
              if (typeof imageFunction === "undefined") {
                throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
              }
              return imageFunction(context, value.values);
            }
            throw new Error("Unsupported image type " + value.type);
          }
        };
        function isSupportedImage(value) {
          return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
        }
        var SUPPORTED_IMAGE_FUNCTIONS = {
          "linear-gradient": linearGradient,
          "-moz-linear-gradient": prefixLinearGradient,
          "-ms-linear-gradient": prefixLinearGradient,
          "-o-linear-gradient": prefixLinearGradient,
          "-webkit-linear-gradient": prefixLinearGradient,
          "radial-gradient": radialGradient,
          "-moz-radial-gradient": prefixRadialGradient,
          "-ms-radial-gradient": prefixRadialGradient,
          "-o-radial-gradient": prefixRadialGradient,
          "-webkit-radial-gradient": prefixRadialGradient,
          "-webkit-gradient": webkitGradient
        };
        var backgroundImage = {
          name: "background-image",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(context, tokens) {
            if (tokens.length === 0) {
              return [];
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return [];
            }
            return tokens.filter(function(value) {
              return nonFunctionArgSeparator(value) && isSupportedImage(value);
            }).map(function(value) {
              return image.parse(context, value);
            });
          }
        };
        var backgroundOrigin = {
          name: "background-origin",
          initialValue: "border-box",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.map(function(token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "padding-box":
                    return 1;
                  case "content-box":
                    return 2;
                }
              }
              return 0;
            });
          }
        };
        var backgroundPosition = {
          name: "background-position",
          initialValue: "0% 0%",
          type: 1,
          prefix: false,
          parse: function(_context, tokens) {
            return parseFunctionArgs(tokens).map(function(values) {
              return values.filter(isLengthPercentage);
            }).map(parseLengthPercentageTuple);
          }
        };
        var backgroundRepeat = {
          name: "background-repeat",
          initialValue: "repeat",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseFunctionArgs(tokens).map(function(values) {
              return values.filter(isIdentToken).map(function(token) {
                return token.value;
              }).join(" ");
            }).map(parseBackgroundRepeat);
          }
        };
        var parseBackgroundRepeat = function(value) {
          switch (value) {
            case "no-repeat":
              return 1;
            case "repeat-x":
            case "repeat no-repeat":
              return 2;
            case "repeat-y":
            case "no-repeat repeat":
              return 3;
            case "repeat":
            default:
              return 0;
          }
        };
        var BACKGROUND_SIZE;
        (function(BACKGROUND_SIZE2) {
          BACKGROUND_SIZE2["AUTO"] = "auto";
          BACKGROUND_SIZE2["CONTAIN"] = "contain";
          BACKGROUND_SIZE2["COVER"] = "cover";
        })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
        var backgroundSize = {
          name: "background-size",
          initialValue: "0",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseFunctionArgs(tokens).map(function(values) {
              return values.filter(isBackgroundSizeInfoToken);
            });
          }
        };
        var isBackgroundSizeInfoToken = function(value) {
          return isIdentToken(value) || isLengthPercentage(value);
        };
        var borderColorForSide = function(side) {
          return {
            name: "border-" + side + "-color",
            initialValue: "transparent",
            prefix: false,
            type: 3,
            format: "color"
          };
        };
        var borderTopColor = borderColorForSide("top");
        var borderRightColor = borderColorForSide("right");
        var borderBottomColor = borderColorForSide("bottom");
        var borderLeftColor = borderColorForSide("left");
        var borderRadiusForSide = function(side) {
          return {
            name: "border-radius-" + side,
            initialValue: "0 0",
            prefix: false,
            type: 1,
            parse: function(_context, tokens) {
              return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
            }
          };
        };
        var borderTopLeftRadius = borderRadiusForSide("top-left");
        var borderTopRightRadius = borderRadiusForSide("top-right");
        var borderBottomRightRadius = borderRadiusForSide("bottom-right");
        var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
        var borderStyleForSide = function(side) {
          return {
            name: "border-" + side + "-style",
            initialValue: "solid",
            prefix: false,
            type: 2,
            parse: function(_context, style) {
              switch (style) {
                case "none":
                  return 0;
                case "dashed":
                  return 2;
                case "dotted":
                  return 3;
                case "double":
                  return 4;
              }
              return 1;
            }
          };
        };
        var borderTopStyle = borderStyleForSide("top");
        var borderRightStyle = borderStyleForSide("right");
        var borderBottomStyle = borderStyleForSide("bottom");
        var borderLeftStyle = borderStyleForSide("left");
        var borderWidthForSide = function(side) {
          return {
            name: "border-" + side + "-width",
            initialValue: "0",
            type: 0,
            prefix: false,
            parse: function(_context, token) {
              if (isDimensionToken(token)) {
                return token.number;
              }
              return 0;
            }
          };
        };
        var borderTopWidth = borderWidthForSide("top");
        var borderRightWidth = borderWidthForSide("right");
        var borderBottomWidth = borderWidthForSide("bottom");
        var borderLeftWidth = borderWidthForSide("left");
        var color = {
          name: "color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
        var direction = {
          name: "direction",
          initialValue: "ltr",
          prefix: false,
          type: 2,
          parse: function(_context, direction2) {
            switch (direction2) {
              case "rtl":
                return 1;
              case "ltr":
              default:
                return 0;
            }
          }
        };
        var display = {
          name: "display",
          initialValue: "inline-block",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).reduce(
              function(bit, token) {
                return bit | parseDisplayValue(token.value);
              },
              0
              /* NONE */
            );
          }
        };
        var parseDisplayValue = function(display2) {
          switch (display2) {
            case "block":
            case "-webkit-box":
              return 2;
            case "inline":
              return 4;
            case "run-in":
              return 8;
            case "flow":
              return 16;
            case "flow-root":
              return 32;
            case "table":
              return 64;
            case "flex":
            case "-webkit-flex":
              return 128;
            case "grid":
            case "-ms-grid":
              return 256;
            case "ruby":
              return 512;
            case "subgrid":
              return 1024;
            case "list-item":
              return 2048;
            case "table-row-group":
              return 4096;
            case "table-header-group":
              return 8192;
            case "table-footer-group":
              return 16384;
            case "table-row":
              return 32768;
            case "table-cell":
              return 65536;
            case "table-column-group":
              return 131072;
            case "table-column":
              return 262144;
            case "table-caption":
              return 524288;
            case "ruby-base":
              return 1048576;
            case "ruby-text":
              return 2097152;
            case "ruby-base-container":
              return 4194304;
            case "ruby-text-container":
              return 8388608;
            case "contents":
              return 16777216;
            case "inline-block":
              return 33554432;
            case "inline-list-item":
              return 67108864;
            case "inline-table":
              return 134217728;
            case "inline-flex":
              return 268435456;
            case "inline-grid":
              return 536870912;
          }
          return 0;
        };
        var float = {
          name: "float",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, float2) {
            switch (float2) {
              case "left":
                return 1;
              case "right":
                return 2;
              case "inline-start":
                return 3;
              case "inline-end":
                return 4;
            }
            return 0;
          }
        };
        var letterSpacing = {
          name: "letter-spacing",
          initialValue: "0",
          prefix: false,
          type: 0,
          parse: function(_context, token) {
            if (token.type === 20 && token.value === "normal") {
              return 0;
            }
            if (token.type === 17) {
              return token.number;
            }
            if (token.type === 15) {
              return token.number;
            }
            return 0;
          }
        };
        var LINE_BREAK;
        (function(LINE_BREAK2) {
          LINE_BREAK2["NORMAL"] = "normal";
          LINE_BREAK2["STRICT"] = "strict";
        })(LINE_BREAK || (LINE_BREAK = {}));
        var lineBreak = {
          name: "line-break",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, lineBreak2) {
            switch (lineBreak2) {
              case "strict":
                return LINE_BREAK.STRICT;
              case "normal":
              default:
                return LINE_BREAK.NORMAL;
            }
          }
        };
        var lineHeight = {
          name: "line-height",
          initialValue: "normal",
          prefix: false,
          type: 4
          /* TOKEN_VALUE */
        };
        var computeLineHeight = function(token, fontSize2) {
          if (isIdentToken(token) && token.value === "normal") {
            return 1.2 * fontSize2;
          } else if (token.type === 17) {
            return fontSize2 * token.number;
          } else if (isLengthPercentage(token)) {
            return getAbsoluteValue(token, fontSize2);
          }
          return fontSize2;
        };
        var listStyleImage = {
          name: "list-style-image",
          initialValue: "none",
          type: 0,
          prefix: false,
          parse: function(context, token) {
            if (token.type === 20 && token.value === "none") {
              return null;
            }
            return image.parse(context, token);
          }
        };
        var listStylePosition = {
          name: "list-style-position",
          initialValue: "outside",
          prefix: false,
          type: 2,
          parse: function(_context, position2) {
            switch (position2) {
              case "inside":
                return 0;
              case "outside":
              default:
                return 1;
            }
          }
        };
        var listStyleType = {
          name: "list-style-type",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, type) {
            switch (type) {
              case "disc":
                return 0;
              case "circle":
                return 1;
              case "square":
                return 2;
              case "decimal":
                return 3;
              case "cjk-decimal":
                return 4;
              case "decimal-leading-zero":
                return 5;
              case "lower-roman":
                return 6;
              case "upper-roman":
                return 7;
              case "lower-greek":
                return 8;
              case "lower-alpha":
                return 9;
              case "upper-alpha":
                return 10;
              case "arabic-indic":
                return 11;
              case "armenian":
                return 12;
              case "bengali":
                return 13;
              case "cambodian":
                return 14;
              case "cjk-earthly-branch":
                return 15;
              case "cjk-heavenly-stem":
                return 16;
              case "cjk-ideographic":
                return 17;
              case "devanagari":
                return 18;
              case "ethiopic-numeric":
                return 19;
              case "georgian":
                return 20;
              case "gujarati":
                return 21;
              case "gurmukhi":
                return 22;
              case "hebrew":
                return 22;
              case "hiragana":
                return 23;
              case "hiragana-iroha":
                return 24;
              case "japanese-formal":
                return 25;
              case "japanese-informal":
                return 26;
              case "kannada":
                return 27;
              case "katakana":
                return 28;
              case "katakana-iroha":
                return 29;
              case "khmer":
                return 30;
              case "korean-hangul-formal":
                return 31;
              case "korean-hanja-formal":
                return 32;
              case "korean-hanja-informal":
                return 33;
              case "lao":
                return 34;
              case "lower-armenian":
                return 35;
              case "malayalam":
                return 36;
              case "mongolian":
                return 37;
              case "myanmar":
                return 38;
              case "oriya":
                return 39;
              case "persian":
                return 40;
              case "simp-chinese-formal":
                return 41;
              case "simp-chinese-informal":
                return 42;
              case "tamil":
                return 43;
              case "telugu":
                return 44;
              case "thai":
                return 45;
              case "tibetan":
                return 46;
              case "trad-chinese-formal":
                return 47;
              case "trad-chinese-informal":
                return 48;
              case "upper-armenian":
                return 49;
              case "disclosure-open":
                return 50;
              case "disclosure-closed":
                return 51;
              case "none":
              default:
                return -1;
            }
          }
        };
        var marginForSide = function(side) {
          return {
            name: "margin-" + side,
            initialValue: "0",
            prefix: false,
            type: 4
            /* TOKEN_VALUE */
          };
        };
        var marginTop = marginForSide("top");
        var marginRight = marginForSide("right");
        var marginBottom = marginForSide("bottom");
        var marginLeft = marginForSide("left");
        var overflow = {
          name: "overflow",
          initialValue: "visible",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).map(function(overflow2) {
              switch (overflow2.value) {
                case "hidden":
                  return 1;
                case "scroll":
                  return 2;
                case "clip":
                  return 3;
                case "auto":
                  return 4;
                case "visible":
                default:
                  return 0;
              }
            });
          }
        };
        var overflowWrap = {
          name: "overflow-wrap",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, overflow2) {
            switch (overflow2) {
              case "break-word":
                return "break-word";
              case "normal":
              default:
                return "normal";
            }
          }
        };
        var paddingForSide = function(side) {
          return {
            name: "padding-" + side,
            initialValue: "0",
            prefix: false,
            type: 3,
            format: "length-percentage"
          };
        };
        var paddingTop = paddingForSide("top");
        var paddingRight = paddingForSide("right");
        var paddingBottom = paddingForSide("bottom");
        var paddingLeft = paddingForSide("left");
        var textAlign = {
          name: "text-align",
          initialValue: "left",
          prefix: false,
          type: 2,
          parse: function(_context, textAlign2) {
            switch (textAlign2) {
              case "right":
                return 2;
              case "center":
              case "justify":
                return 1;
              case "left":
              default:
                return 0;
            }
          }
        };
        var position = {
          name: "position",
          initialValue: "static",
          prefix: false,
          type: 2,
          parse: function(_context, position2) {
            switch (position2) {
              case "relative":
                return 1;
              case "absolute":
                return 2;
              case "fixed":
                return 3;
              case "sticky":
                return 4;
            }
            return 0;
          }
        };
        var textShadow = {
          name: "text-shadow",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(context, tokens) {
            if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
              return [];
            }
            return parseFunctionArgs(tokens).map(function(values) {
              var shadow = {
                color: COLORS.TRANSPARENT,
                offsetX: ZERO_LENGTH,
                offsetY: ZERO_LENGTH,
                blur: ZERO_LENGTH
              };
              var c2 = 0;
              for (var i3 = 0; i3 < values.length; i3++) {
                var token = values[i3];
                if (isLength(token)) {
                  if (c2 === 0) {
                    shadow.offsetX = token;
                  } else if (c2 === 1) {
                    shadow.offsetY = token;
                  } else {
                    shadow.blur = token;
                  }
                  c2++;
                } else {
                  shadow.color = color$1.parse(context, token);
                }
              }
              return shadow;
            });
          }
        };
        var textTransform = {
          name: "text-transform",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, textTransform2) {
            switch (textTransform2) {
              case "uppercase":
                return 2;
              case "lowercase":
                return 1;
              case "capitalize":
                return 3;
            }
            return 0;
          }
        };
        var transform$1 = {
          name: "transform",
          initialValue: "none",
          prefix: true,
          type: 0,
          parse: function(_context, token) {
            if (token.type === 20 && token.value === "none") {
              return null;
            }
            if (token.type === 18) {
              var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
              if (typeof transformFunction === "undefined") {
                throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
              }
              return transformFunction(token.values);
            }
            return null;
          }
        };
        var matrix2 = function(args) {
          var values = args.filter(function(arg) {
            return arg.type === 17;
          }).map(function(arg) {
            return arg.number;
          });
          return values.length === 6 ? values : null;
        };
        var matrix3d = function(args) {
          var values = args.filter(function(arg) {
            return arg.type === 17;
          }).map(function(arg) {
            return arg.number;
          });
          var a1 = values[0], b1 = values[1];
          values[2];
          values[3];
          var a22 = values[4], b2 = values[5];
          values[6];
          values[7];
          values[8];
          values[9];
          values[10];
          values[11];
          var a4 = values[12], b4 = values[13];
          values[14];
          values[15];
          return values.length === 16 ? [a1, b1, a22, b2, a4, b4] : null;
        };
        var SUPPORTED_TRANSFORM_FUNCTIONS = {
          matrix: matrix2,
          matrix3d
        };
        var DEFAULT_VALUE = {
          type: 16,
          number: 50,
          flags: FLAG_INTEGER
        };
        var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
        var transformOrigin = {
          name: "transform-origin",
          initialValue: "50% 50%",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            var origins = tokens.filter(isLengthPercentage);
            if (origins.length !== 2) {
              return DEFAULT;
            }
            return [origins[0], origins[1]];
          }
        };
        var visibility = {
          name: "visible",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, visibility2) {
            switch (visibility2) {
              case "hidden":
                return 1;
              case "collapse":
                return 2;
              case "visible":
              default:
                return 0;
            }
          }
        };
        var WORD_BREAK;
        (function(WORD_BREAK2) {
          WORD_BREAK2["NORMAL"] = "normal";
          WORD_BREAK2["BREAK_ALL"] = "break-all";
          WORD_BREAK2["KEEP_ALL"] = "keep-all";
        })(WORD_BREAK || (WORD_BREAK = {}));
        var wordBreak = {
          name: "word-break",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, wordBreak2) {
            switch (wordBreak2) {
              case "break-all":
                return WORD_BREAK.BREAK_ALL;
              case "keep-all":
                return WORD_BREAK.KEEP_ALL;
              case "normal":
              default:
                return WORD_BREAK.NORMAL;
            }
          }
        };
        var zIndex = {
          name: "z-index",
          initialValue: "auto",
          prefix: false,
          type: 0,
          parse: function(_context, token) {
            if (token.type === 20) {
              return {
                auto: true,
                order: 0
              };
            }
            if (isNumberToken(token)) {
              return {
                auto: false,
                order: token.number
              };
            }
            throw new Error("Invalid z-index number parsed");
          }
        };
        var time = {
          name: "time",
          parse: function(_context, value) {
            if (value.type === 15) {
              switch (value.unit.toLowerCase()) {
                case "s":
                  return 1e3 * value.number;
                case "ms":
                  return value.number;
              }
            }
            throw new Error("Unsupported time type");
          }
        };
        var opacity = {
          name: "opacity",
          initialValue: "1",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isNumberToken(token)) {
              return token.number;
            }
            return 1;
          }
        };
        var textDecorationColor = {
          name: "text-decoration-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
        var textDecorationLine = {
          name: "text-decoration-line",
          initialValue: "none",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).map(function(token) {
              switch (token.value) {
                case "underline":
                  return 1;
                case "overline":
                  return 2;
                case "line-through":
                  return 3;
                case "none":
                  return 4;
              }
              return 0;
            }).filter(function(line) {
              return line !== 0;
            });
          }
        };
        var fontFamily = {
          name: "font-family",
          initialValue: "",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            var accumulator = [];
            var results = [];
            tokens.forEach(function(token) {
              switch (token.type) {
                case 20:
                case 0:
                  accumulator.push(token.value);
                  break;
                case 17:
                  accumulator.push(token.number.toString());
                  break;
                case 4:
                  results.push(accumulator.join(" "));
                  accumulator.length = 0;
                  break;
              }
            });
            if (accumulator.length) {
              results.push(accumulator.join(" "));
            }
            return results.map(function(result) {
              return result.indexOf(" ") === -1 ? result : "'" + result + "'";
            });
          }
        };
        var fontSize = {
          name: "font-size",
          initialValue: "0",
          prefix: false,
          type: 3,
          format: "length"
        };
        var fontWeight = {
          name: "font-weight",
          initialValue: "normal",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isNumberToken(token)) {
              return token.number;
            }
            if (isIdentToken(token)) {
              switch (token.value) {
                case "bold":
                  return 700;
                case "normal":
                default:
                  return 400;
              }
            }
            return 400;
          }
        };
        var fontVariant = {
          name: "font-variant",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).map(function(token) {
              return token.value;
            });
          }
        };
        var fontStyle = {
          name: "font-style",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, overflow2) {
            switch (overflow2) {
              case "oblique":
                return "oblique";
              case "italic":
                return "italic";
              case "normal":
              default:
                return "normal";
            }
          }
        };
        var contains = function(bit, value) {
          return (bit & value) !== 0;
        };
        var content = {
          name: "content",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return [];
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return [];
            }
            return tokens;
          }
        };
        var counterIncrement = {
          name: "counter-increment",
          initialValue: "none",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return null;
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return null;
            }
            var increments = [];
            var filtered = tokens.filter(nonWhiteSpace);
            for (var i3 = 0; i3 < filtered.length; i3++) {
              var counter = filtered[i3];
              var next = filtered[i3 + 1];
              if (counter.type === 20) {
                var increment = next && isNumberToken(next) ? next.number : 1;
                increments.push({
                  counter: counter.value,
                  increment
                });
              }
            }
            return increments;
          }
        };
        var counterReset = {
          name: "counter-reset",
          initialValue: "none",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return [];
            }
            var resets = [];
            var filtered = tokens.filter(nonWhiteSpace);
            for (var i3 = 0; i3 < filtered.length; i3++) {
              var counter = filtered[i3];
              var next = filtered[i3 + 1];
              if (isIdentToken(counter) && counter.value !== "none") {
                var reset = next && isNumberToken(next) ? next.number : 0;
                resets.push({
                  counter: counter.value,
                  reset
                });
              }
            }
            return resets;
          }
        };
        var duration = {
          name: "duration",
          initialValue: "0s",
          prefix: false,
          type: 1,
          parse: function(context, tokens) {
            return tokens.filter(isDimensionToken).map(function(token) {
              return time.parse(context, token);
            });
          }
        };
        var quotes = {
          name: "quotes",
          initialValue: "none",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return null;
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return null;
            }
            var quotes2 = [];
            var filtered = tokens.filter(isStringToken);
            if (filtered.length % 2 !== 0) {
              return null;
            }
            for (var i3 = 0; i3 < filtered.length; i3 += 2) {
              var open_1 = filtered[i3].value;
              var close_1 = filtered[i3 + 1].value;
              quotes2.push({
                open: open_1,
                close: close_1
              });
            }
            return quotes2;
          }
        };
        var getQuote = function(quotes2, depth, open2) {
          if (!quotes2) {
            return "";
          }
          var quote = quotes2[Math.min(depth, quotes2.length - 1)];
          if (!quote) {
            return "";
          }
          return open2 ? quote.open : quote.close;
        };
        var boxShadow = {
          name: "box-shadow",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(context, tokens) {
            if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
              return [];
            }
            return parseFunctionArgs(tokens).map(function(values) {
              var shadow = {
                color: 255,
                offsetX: ZERO_LENGTH,
                offsetY: ZERO_LENGTH,
                blur: ZERO_LENGTH,
                spread: ZERO_LENGTH,
                inset: false
              };
              var c2 = 0;
              for (var i3 = 0; i3 < values.length; i3++) {
                var token = values[i3];
                if (isIdentWithValue(token, "inset")) {
                  shadow.inset = true;
                } else if (isLength(token)) {
                  if (c2 === 0) {
                    shadow.offsetX = token;
                  } else if (c2 === 1) {
                    shadow.offsetY = token;
                  } else if (c2 === 2) {
                    shadow.blur = token;
                  } else {
                    shadow.spread = token;
                  }
                  c2++;
                } else {
                  shadow.color = color$1.parse(context, token);
                }
              }
              return shadow;
            });
          }
        };
        var paintOrder = {
          name: "paint-order",
          initialValue: "normal",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            var DEFAULT_VALUE2 = [
              0,
              1,
              2
              /* MARKERS */
            ];
            var layers = [];
            tokens.filter(isIdentToken).forEach(function(token) {
              switch (token.value) {
                case "stroke":
                  layers.push(
                    1
                    /* STROKE */
                  );
                  break;
                case "fill":
                  layers.push(
                    0
                    /* FILL */
                  );
                  break;
                case "markers":
                  layers.push(
                    2
                    /* MARKERS */
                  );
                  break;
              }
            });
            DEFAULT_VALUE2.forEach(function(value) {
              if (layers.indexOf(value) === -1) {
                layers.push(value);
              }
            });
            return layers;
          }
        };
        var webkitTextStrokeColor = {
          name: "-webkit-text-stroke-color",
          initialValue: "currentcolor",
          prefix: false,
          type: 3,
          format: "color"
        };
        var webkitTextStrokeWidth = {
          name: "-webkit-text-stroke-width",
          initialValue: "0",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isDimensionToken(token)) {
              return token.number;
            }
            return 0;
          }
        };
        var CSSParsedDeclaration = (
          /** @class */
          (function() {
            function CSSParsedDeclaration2(context, declaration) {
              var _a2, _b2;
              this.animationDuration = parse(context, duration, declaration.animationDuration);
              this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
              this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
              this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
              this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
              this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
              this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
              this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
              this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
              this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
              this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
              this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
              this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
              this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
              this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
              this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
              this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
              this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
              this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
              this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
              this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
              this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
              this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
              this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
              this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
              this.color = parse(context, color, declaration.color);
              this.direction = parse(context, direction, declaration.direction);
              this.display = parse(context, display, declaration.display);
              this.float = parse(context, float, declaration.cssFloat);
              this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
              this.fontSize = parse(context, fontSize, declaration.fontSize);
              this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
              this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
              this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
              this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
              this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
              this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
              this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
              this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
              this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
              this.marginTop = parse(context, marginTop, declaration.marginTop);
              this.marginRight = parse(context, marginRight, declaration.marginRight);
              this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
              this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
              this.opacity = parse(context, opacity, declaration.opacity);
              var overflowTuple = parse(context, overflow, declaration.overflow);
              this.overflowX = overflowTuple[0];
              this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
              this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
              this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
              this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
              this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
              this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
              this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
              this.position = parse(context, position, declaration.position);
              this.textAlign = parse(context, textAlign, declaration.textAlign);
              this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
              this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
              this.textShadow = parse(context, textShadow, declaration.textShadow);
              this.textTransform = parse(context, textTransform, declaration.textTransform);
              this.transform = parse(context, transform$1, declaration.transform);
              this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
              this.visibility = parse(context, visibility, declaration.visibility);
              this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
              this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
              this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
              this.zIndex = parse(context, zIndex, declaration.zIndex);
            }
            CSSParsedDeclaration2.prototype.isVisible = function() {
              return this.display > 0 && this.opacity > 0 && this.visibility === 0;
            };
            CSSParsedDeclaration2.prototype.isTransparent = function() {
              return isTransparent(this.backgroundColor);
            };
            CSSParsedDeclaration2.prototype.isTransformed = function() {
              return this.transform !== null;
            };
            CSSParsedDeclaration2.prototype.isPositioned = function() {
              return this.position !== 0;
            };
            CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
              return this.isPositioned() && !this.zIndex.auto;
            };
            CSSParsedDeclaration2.prototype.isFloating = function() {
              return this.float !== 0;
            };
            CSSParsedDeclaration2.prototype.isInlineLevel = function() {
              return contains(
                this.display,
                4
                /* INLINE */
              ) || contains(
                this.display,
                33554432
                /* INLINE_BLOCK */
              ) || contains(
                this.display,
                268435456
                /* INLINE_FLEX */
              ) || contains(
                this.display,
                536870912
                /* INLINE_GRID */
              ) || contains(
                this.display,
                67108864
                /* INLINE_LIST_ITEM */
              ) || contains(
                this.display,
                134217728
                /* INLINE_TABLE */
              );
            };
            return CSSParsedDeclaration2;
          })()
        );
        var CSSParsedPseudoDeclaration = (
          /** @class */
          /* @__PURE__ */ (function() {
            function CSSParsedPseudoDeclaration2(context, declaration) {
              this.content = parse(context, content, declaration.content);
              this.quotes = parse(context, quotes, declaration.quotes);
            }
            return CSSParsedPseudoDeclaration2;
          })()
        );
        var CSSParsedCounterDeclaration = (
          /** @class */
          /* @__PURE__ */ (function() {
            function CSSParsedCounterDeclaration2(context, declaration) {
              this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
              this.counterReset = parse(context, counterReset, declaration.counterReset);
            }
            return CSSParsedCounterDeclaration2;
          })()
        );
        var parse = function(context, descriptor, style) {
          var tokenizer = new Tokenizer();
          var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
          tokenizer.write(value);
          var parser = new Parser2(tokenizer.read());
          switch (descriptor.type) {
            case 2:
              var token = parser.parseComponentValue();
              return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
            case 0:
              return descriptor.parse(context, parser.parseComponentValue());
            case 1:
              return descriptor.parse(context, parser.parseComponentValues());
            case 4:
              return parser.parseComponentValue();
            case 3:
              switch (descriptor.format) {
                case "angle":
                  return angle2.parse(context, parser.parseComponentValue());
                case "color":
                  return color$1.parse(context, parser.parseComponentValue());
                case "image":
                  return image.parse(context, parser.parseComponentValue());
                case "length":
                  var length_1 = parser.parseComponentValue();
                  return isLength(length_1) ? length_1 : ZERO_LENGTH;
                case "length-percentage":
                  var value_1 = parser.parseComponentValue();
                  return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
                case "time":
                  return time.parse(context, parser.parseComponentValue());
              }
              break;
          }
        };
        var elementDebuggerAttribute = "data-html2canvas-debug";
        var getElementDebugType = function(element) {
          var attribute = element.getAttribute(elementDebuggerAttribute);
          switch (attribute) {
            case "all":
              return 1;
            case "clone":
              return 2;
            case "parse":
              return 3;
            case "render":
              return 4;
            default:
              return 0;
          }
        };
        var isDebugging = function(element, type) {
          var elementType = getElementDebugType(element);
          return elementType === 1 || type === elementType;
        };
        var ElementContainer = (
          /** @class */
          /* @__PURE__ */ (function() {
            function ElementContainer2(context, element) {
              this.context = context;
              this.textNodes = [];
              this.elements = [];
              this.flags = 0;
              if (isDebugging(
                element,
                3
                /* PARSE */
              )) {
                debugger;
              }
              this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
              if (isHTMLElementNode(element)) {
                if (this.styles.animationDuration.some(function(duration2) {
                  return duration2 > 0;
                })) {
                  element.style.animationDuration = "0s";
                }
                if (this.styles.transform !== null) {
                  element.style.transform = "none";
                }
              }
              this.bounds = parseBounds(this.context, element);
              if (isDebugging(
                element,
                4
                /* RENDER */
              )) {
                this.flags |= 16;
              }
            }
            return ElementContainer2;
          })()
        );
        var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
        var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i$12 = 0; i$12 < chars$1.length; i$12++) {
          lookup$1[chars$1.charCodeAt(i$12)] = i$12;
        }
        var decode = function(base642) {
          var bufferLength = base642.length * 0.75, len = base642.length, i3, p2 = 0, encoded1, encoded2, encoded3, encoded4;
          if (base642[base642.length - 1] === "=") {
            bufferLength--;
            if (base642[base642.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
          var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
          for (i3 = 0; i3 < len; i3 += 4) {
            encoded1 = lookup$1[base642.charCodeAt(i3)];
            encoded2 = lookup$1[base642.charCodeAt(i3 + 1)];
            encoded3 = lookup$1[base642.charCodeAt(i3 + 2)];
            encoded4 = lookup$1[base642.charCodeAt(i3 + 3)];
            bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        };
        var polyUint16Array = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i3 = 0; i3 < length; i3 += 2) {
            bytes.push(buffer[i3 + 1] << 8 | buffer[i3]);
          }
          return bytes;
        };
        var polyUint32Array = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i3 = 0; i3 < length; i3 += 4) {
            bytes.push(buffer[i3 + 3] << 24 | buffer[i3 + 2] << 16 | buffer[i3 + 1] << 8 | buffer[i3]);
          }
          return bytes;
        };
        var UTRIE2_SHIFT_2 = 5;
        var UTRIE2_SHIFT_1 = 6 + 5;
        var UTRIE2_INDEX_SHIFT = 2;
        var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
        var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
        var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
        var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
        var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
        var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
        var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
        var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
        var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
        var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
        var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
        var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
        var slice16 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint16Array(Array.prototype.slice.call(view, start, end));
        };
        var slice32 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint32Array(Array.prototype.slice.call(view, start, end));
        };
        var createTrieFromBase64 = function(base642, _byteLength) {
          var buffer = decode(base642);
          var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
          var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
          var headerLength = 24;
          var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
          var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
          return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data);
        };
        var Trie = (
          /** @class */
          (function() {
            function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
              this.initialValue = initialValue;
              this.errorValue = errorValue;
              this.highStart = highStart;
              this.highValueIndex = highValueIndex;
              this.index = index2;
              this.data = data;
            }
            Trie2.prototype.get = function(codePoint) {
              var ix;
              if (codePoint >= 0) {
                if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                  ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
                }
                if (codePoint <= 65535) {
                  ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
                }
                if (codePoint < this.highStart) {
                  ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                  ix = this.index[ix];
                  ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
                  ix = this.index[ix];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
                }
                if (codePoint <= 1114111) {
                  return this.data[this.highValueIndex];
                }
              }
              return this.errorValue;
            };
            return Trie2;
          })()
        );
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i2 = 0; i2 < chars.length; i2++) {
          lookup[chars.charCodeAt(i2)] = i2;
        }
        var Prepend = 1;
        var CR = 2;
        var LF = 3;
        var Control = 4;
        var Extend = 5;
        var SpacingMark = 7;
        var L2 = 8;
        var V2 = 9;
        var T2 = 10;
        var LV = 11;
        var LVT = 12;
        var ZWJ = 13;
        var Extended_Pictographic = 14;
        var RI = 15;
        var toCodePoints = function(str) {
          var codePoints = [];
          var i3 = 0;
          var length = str.length;
          while (i3 < length) {
            var value = str.charCodeAt(i3++);
            if (value >= 55296 && value <= 56319 && i3 < length) {
              var extra = str.charCodeAt(i3++);
              if ((extra & 64512) === 56320) {
                codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                codePoints.push(value);
                i3--;
              }
            } else {
              codePoints.push(value);
            }
          }
          return codePoints;
        };
        var fromCodePoint = function() {
          var codePoints = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
          }
          if (String.fromCodePoint) {
            return String.fromCodePoint.apply(String, codePoints);
          }
          var length = codePoints.length;
          if (!length) {
            return "";
          }
          var codeUnits = [];
          var index2 = -1;
          var result = "";
          while (++index2 < length) {
            var codePoint = codePoints[index2];
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
            }
            if (index2 + 1 === length || codeUnits.length > 16384) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        var UnicodeTrie = createTrieFromBase64(base64);
        var BREAK_NOT_ALLOWED = "\xD7";
        var BREAK_ALLOWED = "\xF7";
        var codePointToClass = function(codePoint) {
          return UnicodeTrie.get(codePoint);
        };
        var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
          var prevIndex = index2 - 2;
          var prev = classTypes[prevIndex];
          var current = classTypes[index2 - 1];
          var next = classTypes[index2];
          if (current === CR && next === LF) {
            return BREAK_NOT_ALLOWED;
          }
          if (current === CR || current === LF || current === Control) {
            return BREAK_ALLOWED;
          }
          if (next === CR || next === LF || next === Control) {
            return BREAK_ALLOWED;
          }
          if (current === L2 && [L2, V2, LV, LVT].indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED;
          }
          if ((current === LV || current === V2) && (next === V2 || next === T2)) {
            return BREAK_NOT_ALLOWED;
          }
          if ((current === LVT || current === T2) && next === T2) {
            return BREAK_NOT_ALLOWED;
          }
          if (next === ZWJ || next === Extend) {
            return BREAK_NOT_ALLOWED;
          }
          if (next === SpacingMark) {
            return BREAK_NOT_ALLOWED;
          }
          if (current === Prepend) {
            return BREAK_NOT_ALLOWED;
          }
          if (current === ZWJ && next === Extended_Pictographic) {
            while (prev === Extend) {
              prev = classTypes[--prevIndex];
            }
            if (prev === Extended_Pictographic) {
              return BREAK_NOT_ALLOWED;
            }
          }
          if (current === RI && next === RI) {
            var countRI = 0;
            while (prev === RI) {
              countRI++;
              prev = classTypes[--prevIndex];
            }
            if (countRI % 2 === 0) {
              return BREAK_NOT_ALLOWED;
            }
          }
          return BREAK_ALLOWED;
        };
        var GraphemeBreaker = function(str) {
          var codePoints = toCodePoints(str);
          var length = codePoints.length;
          var index2 = 0;
          var lastEnd = 0;
          var classTypes = codePoints.map(codePointToClass);
          return {
            next: function() {
              if (index2 >= length) {
                return {
                  done: true,
                  value: null
                };
              }
              var graphemeBreak = BREAK_NOT_ALLOWED;
              while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
              }
              if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {
                var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
                lastEnd = index2;
                return {
                  value,
                  done: false
                };
              }
              return {
                done: true,
                value: null
              };
            }
          };
        };
        var splitGraphemes = function(str) {
          var breaker = GraphemeBreaker(str);
          var graphemes = [];
          var bk;
          while (!(bk = breaker.next()).done) {
            if (bk.value) {
              graphemes.push(bk.value.slice());
            }
          }
          return graphemes;
        };
        var testRangeBounds = function(document2) {
          var TEST_HEIGHT = 123;
          if (document2.createRange) {
            var range = document2.createRange();
            if (range.getBoundingClientRect) {
              var testElement = document2.createElement("boundtest");
              testElement.style.height = TEST_HEIGHT + "px";
              testElement.style.display = "block";
              document2.body.appendChild(testElement);
              range.selectNode(testElement);
              var rangeBounds = range.getBoundingClientRect();
              var rangeHeight = Math.round(rangeBounds.height);
              document2.body.removeChild(testElement);
              if (rangeHeight === TEST_HEIGHT) {
                return true;
              }
            }
          }
          return false;
        };
        var testIOSLineBreak = function(document2) {
          var testElement = document2.createElement("boundtest");
          testElement.style.width = "50px";
          testElement.style.display = "block";
          testElement.style.fontSize = "12px";
          testElement.style.letterSpacing = "0px";
          testElement.style.wordSpacing = "0px";
          document2.body.appendChild(testElement);
          var range = document2.createRange();
          testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
          var node2 = testElement.firstChild;
          var textList = toCodePoints$1(node2.data).map(function(i3) {
            return fromCodePoint$1(i3);
          });
          var offset = 0;
          var prev = {};
          var supports = textList.every(function(text2, i3) {
            range.setStart(node2, offset);
            range.setEnd(node2, offset + text2.length);
            var rect = range.getBoundingClientRect();
            offset += text2.length;
            var boundAhead = rect.x > prev.x || rect.y > prev.y;
            prev = rect;
            if (i3 === 0) {
              return true;
            }
            return boundAhead;
          });
          document2.body.removeChild(testElement);
          return supports;
        };
        var testCORS = function() {
          return typeof new Image().crossOrigin !== "undefined";
        };
        var testResponseType = function() {
          return typeof new XMLHttpRequest().responseType === "string";
        };
        var testSVG = function(document2) {
          var img = new Image();
          var canvas = document2.createElement("canvas");
          var ctx = canvas.getContext("2d");
          if (!ctx) {
            return false;
          }
          img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
          try {
            ctx.drawImage(img, 0, 0);
            canvas.toDataURL();
          } catch (e3) {
            return false;
          }
          return true;
        };
        var isGreenPixel = function(data) {
          return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
        };
        var testForeignObject = function(document2) {
          var canvas = document2.createElement("canvas");
          var size = 100;
          canvas.width = size;
          canvas.height = size;
          var ctx = canvas.getContext("2d");
          if (!ctx) {
            return Promise.reject(false);
          }
          ctx.fillStyle = "rgb(0, 255, 0)";
          ctx.fillRect(0, 0, size, size);
          var img = new Image();
          var greenImageSrc = canvas.toDataURL();
          img.src = greenImageSrc;
          var svg2 = createForeignObjectSVG(size, size, 0, 0, img);
          ctx.fillStyle = "red";
          ctx.fillRect(0, 0, size, size);
          return loadSerializedSVG$1(svg2).then(function(img2) {
            ctx.drawImage(img2, 0, 0);
            var data = ctx.getImageData(0, 0, size, size).data;
            ctx.fillStyle = "red";
            ctx.fillRect(0, 0, size, size);
            var node2 = document2.createElement("div");
            node2.style.backgroundImage = "url(" + greenImageSrc + ")";
            node2.style.height = size + "px";
            return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node2)) : Promise.reject(false);
          }).then(function(img2) {
            ctx.drawImage(img2, 0, 0);
            return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
          }).catch(function() {
            return false;
          });
        };
        var createForeignObjectSVG = function(width, height, x2, y2, node2) {
          var xmlns = "http://www.w3.org/2000/svg";
          var svg2 = document.createElementNS(xmlns, "svg");
          var foreignObject = document.createElementNS(xmlns, "foreignObject");
          svg2.setAttributeNS(null, "width", width.toString());
          svg2.setAttributeNS(null, "height", height.toString());
          foreignObject.setAttributeNS(null, "width", "100%");
          foreignObject.setAttributeNS(null, "height", "100%");
          foreignObject.setAttributeNS(null, "x", x2.toString());
          foreignObject.setAttributeNS(null, "y", y2.toString());
          foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
          svg2.appendChild(foreignObject);
          foreignObject.appendChild(node2);
          return svg2;
        };
        var loadSerializedSVG$1 = function(svg2) {
          return new Promise(function(resolve, reject) {
            var img = new Image();
            img.onload = function() {
              return resolve(img);
            };
            img.onerror = reject;
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
          });
        };
        var FEATURES = {
          get SUPPORT_RANGE_BOUNDS() {
            var value = testRangeBounds(document);
            Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", {
              value
            });
            return value;
          },
          get SUPPORT_WORD_BREAKING() {
            var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
            Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", {
              value
            });
            return value;
          },
          get SUPPORT_SVG_DRAWING() {
            var value = testSVG(document);
            Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", {
              value
            });
            return value;
          },
          get SUPPORT_FOREIGNOBJECT_DRAWING() {
            var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
            Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", {
              value
            });
            return value;
          },
          get SUPPORT_CORS_IMAGES() {
            var value = testCORS();
            Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", {
              value
            });
            return value;
          },
          get SUPPORT_RESPONSE_TYPE() {
            var value = testResponseType();
            Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", {
              value
            });
            return value;
          },
          get SUPPORT_CORS_XHR() {
            var value = "withCredentials" in new XMLHttpRequest();
            Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", {
              value
            });
            return value;
          },
          get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
            var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
            Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", {
              value
            });
            return value;
          }
        };
        var TextBounds = (
          /** @class */
          /* @__PURE__ */ (function() {
            function TextBounds2(text2, bounds) {
              this.text = text2;
              this.bounds = bounds;
            }
            return TextBounds2;
          })()
        );
        var parseTextBounds = function(context, value, styles, node2) {
          var textList = breakText(value, styles);
          var textBounds = [];
          var offset = 0;
          textList.forEach(function(text2) {
            if (styles.textDecorationLine.length || text2.trim().length > 0) {
              if (FEATURES.SUPPORT_RANGE_BOUNDS) {
                var clientRects = createRange(node2, offset, text2.length).getClientRects();
                if (clientRects.length > 1) {
                  var subSegments = segmentGraphemes(text2);
                  var subOffset_1 = 0;
                  subSegments.forEach(function(subSegment) {
                    textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node2, subOffset_1 + offset, subSegment.length).getClientRects())));
                    subOffset_1 += subSegment.length;
                  });
                } else {
                  textBounds.push(new TextBounds(text2, Bounds.fromDOMRectList(context, clientRects)));
                }
              } else {
                var replacementNode = node2.splitText(text2.length);
                textBounds.push(new TextBounds(text2, getWrapperBounds(context, node2)));
                node2 = replacementNode;
              }
            } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
              node2 = node2.splitText(text2.length);
            }
            offset += text2.length;
          });
          return textBounds;
        };
        var getWrapperBounds = function(context, node2) {
          var ownerDocument = node2.ownerDocument;
          if (ownerDocument) {
            var wrapper = ownerDocument.createElement("html2canvaswrapper");
            wrapper.appendChild(node2.cloneNode(true));
            var parentNode = node2.parentNode;
            if (parentNode) {
              parentNode.replaceChild(wrapper, node2);
              var bounds = parseBounds(context, wrapper);
              if (wrapper.firstChild) {
                parentNode.replaceChild(wrapper.firstChild, wrapper);
              }
              return bounds;
            }
          }
          return Bounds.EMPTY;
        };
        var createRange = function(node2, offset, length) {
          var ownerDocument = node2.ownerDocument;
          if (!ownerDocument) {
            throw new Error("Node has no owner document");
          }
          var range = ownerDocument.createRange();
          range.setStart(node2, offset);
          range.setEnd(node2, offset + length);
          return range;
        };
        var segmentGraphemes = function(value) {
          if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
            var segmenter = new Intl.Segmenter(void 0, {
              granularity: "grapheme"
            });
            return Array.from(segmenter.segment(value)).map(function(segment) {
              return segment.segment;
            });
          }
          return splitGraphemes(value);
        };
        var segmentWords = function(value, styles) {
          if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
            var segmenter = new Intl.Segmenter(void 0, {
              granularity: "word"
            });
            return Array.from(segmenter.segment(value)).map(function(segment) {
              return segment.segment;
            });
          }
          return breakWords(value, styles);
        };
        var breakText = function(value, styles) {
          return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
        };
        var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
        var breakWords = function(str, styles) {
          var breaker = LineBreaker(str, {
            lineBreak: styles.lineBreak,
            wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
          });
          var words = [];
          var bk;
          var _loop_1 = function() {
            if (bk.value) {
              var value = bk.value.slice();
              var codePoints = toCodePoints$1(value);
              var word_1 = "";
              codePoints.forEach(function(codePoint) {
                if (wordSeparators.indexOf(codePoint) === -1) {
                  word_1 += fromCodePoint$1(codePoint);
                } else {
                  if (word_1.length) {
                    words.push(word_1);
                  }
                  words.push(fromCodePoint$1(codePoint));
                  word_1 = "";
                }
              });
              if (word_1.length) {
                words.push(word_1);
              }
            }
          };
          while (!(bk = breaker.next()).done) {
            _loop_1();
          }
          return words;
        };
        var TextContainer = (
          /** @class */
          /* @__PURE__ */ (function() {
            function TextContainer2(context, node2, styles) {
              this.text = transform(node2.data, styles.textTransform);
              this.textBounds = parseTextBounds(context, this.text, styles, node2);
            }
            return TextContainer2;
          })()
        );
        var transform = function(text2, transform2) {
          switch (transform2) {
            case 1:
              return text2.toLowerCase();
            case 3:
              return text2.replace(CAPITALIZE, capitalize);
            case 2:
              return text2.toUpperCase();
            default:
              return text2;
          }
        };
        var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
        var capitalize = function(m2, p1, p2) {
          if (m2.length > 0) {
            return p1 + p2.toUpperCase();
          }
          return m2;
        };
        var ImageElementContainer = (
          /** @class */
          (function(_super) {
            __extends(ImageElementContainer2, _super);
            function ImageElementContainer2(context, img) {
              var _this = _super.call(this, context, img) || this;
              _this.src = img.currentSrc || img.src;
              _this.intrinsicWidth = img.naturalWidth;
              _this.intrinsicHeight = img.naturalHeight;
              _this.context.cache.addImage(_this.src);
              return _this;
            }
            return ImageElementContainer2;
          })(ElementContainer)
        );
        var CanvasElementContainer = (
          /** @class */
          (function(_super) {
            __extends(CanvasElementContainer2, _super);
            function CanvasElementContainer2(context, canvas) {
              var _this = _super.call(this, context, canvas) || this;
              _this.canvas = canvas;
              _this.intrinsicWidth = canvas.width;
              _this.intrinsicHeight = canvas.height;
              return _this;
            }
            return CanvasElementContainer2;
          })(ElementContainer)
        );
        var SVGElementContainer = (
          /** @class */
          (function(_super) {
            __extends(SVGElementContainer2, _super);
            function SVGElementContainer2(context, img) {
              var _this = _super.call(this, context, img) || this;
              var s2 = new XMLSerializer();
              var bounds = parseBounds(context, img);
              img.setAttribute("width", bounds.width + "px");
              img.setAttribute("height", bounds.height + "px");
              _this.svg = "data:image/svg+xml," + encodeURIComponent(s2.serializeToString(img));
              _this.intrinsicWidth = img.width.baseVal.value;
              _this.intrinsicHeight = img.height.baseVal.value;
              _this.context.cache.addImage(_this.svg);
              return _this;
            }
            return SVGElementContainer2;
          })(ElementContainer)
        );
        var LIElementContainer = (
          /** @class */
          (function(_super) {
            __extends(LIElementContainer2, _super);
            function LIElementContainer2(context, element) {
              var _this = _super.call(this, context, element) || this;
              _this.value = element.value;
              return _this;
            }
            return LIElementContainer2;
          })(ElementContainer)
        );
        var OLElementContainer = (
          /** @class */
          (function(_super) {
            __extends(OLElementContainer2, _super);
            function OLElementContainer2(context, element) {
              var _this = _super.call(this, context, element) || this;
              _this.start = element.start;
              _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
              return _this;
            }
            return OLElementContainer2;
          })(ElementContainer)
        );
        var CHECKBOX_BORDER_RADIUS = [{
          type: 15,
          flags: 0,
          unit: "px",
          number: 3
        }];
        var RADIO_BORDER_RADIUS = [{
          type: 16,
          flags: 0,
          number: 50
        }];
        var reformatInputBounds = function(bounds) {
          if (bounds.width > bounds.height) {
            return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
          } else if (bounds.width < bounds.height) {
            return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
          }
          return bounds;
        };
        var getInputValue = function(node2) {
          var value = node2.type === PASSWORD ? new Array(node2.value.length + 1).join("\u2022") : node2.value;
          return value.length === 0 ? node2.placeholder || "" : value;
        };
        var CHECKBOX = "checkbox";
        var RADIO = "radio";
        var PASSWORD = "password";
        var INPUT_COLOR = 707406591;
        var InputElementContainer = (
          /** @class */
          (function(_super) {
            __extends(InputElementContainer2, _super);
            function InputElementContainer2(context, input) {
              var _this = _super.call(this, context, input) || this;
              _this.type = input.type.toLowerCase();
              _this.checked = input.checked;
              _this.value = getInputValue(input);
              if (_this.type === CHECKBOX || _this.type === RADIO) {
                _this.styles.backgroundColor = 3739148031;
                _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
                _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
                _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
                _this.styles.backgroundClip = [
                  0
                  /* BORDER_BOX */
                ];
                _this.styles.backgroundOrigin = [
                  0
                  /* BORDER_BOX */
                ];
                _this.bounds = reformatInputBounds(_this.bounds);
              }
              switch (_this.type) {
                case CHECKBOX:
                  _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
                  break;
                case RADIO:
                  _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
                  break;
              }
              return _this;
            }
            return InputElementContainer2;
          })(ElementContainer)
        );
        var SelectElementContainer = (
          /** @class */
          (function(_super) {
            __extends(SelectElementContainer2, _super);
            function SelectElementContainer2(context, element) {
              var _this = _super.call(this, context, element) || this;
              var option = element.options[element.selectedIndex || 0];
              _this.value = option ? option.text || "" : "";
              return _this;
            }
            return SelectElementContainer2;
          })(ElementContainer)
        );
        var TextareaElementContainer = (
          /** @class */
          (function(_super) {
            __extends(TextareaElementContainer2, _super);
            function TextareaElementContainer2(context, element) {
              var _this = _super.call(this, context, element) || this;
              _this.value = element.value;
              return _this;
            }
            return TextareaElementContainer2;
          })(ElementContainer)
        );
        var IFrameElementContainer = (
          /** @class */
          (function(_super) {
            __extends(IFrameElementContainer2, _super);
            function IFrameElementContainer2(context, iframe) {
              var _this = _super.call(this, context, iframe) || this;
              _this.src = iframe.src;
              _this.width = parseInt(iframe.width, 10) || 0;
              _this.height = parseInt(iframe.height, 10) || 0;
              _this.backgroundColor = _this.styles.backgroundColor;
              try {
                if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
                  _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
                  var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
                  var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
                  _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
                }
              } catch (e3) {
              }
              return _this;
            }
            return IFrameElementContainer2;
          })(ElementContainer)
        );
        var LIST_OWNERS = ["OL", "UL", "MENU"];
        var parseNodeTree = function(context, node2, parent, root) {
          for (var childNode = node2.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
            nextNode = childNode.nextSibling;
            if (isTextNode(childNode) && childNode.data.trim().length > 0) {
              parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
            } else if (isElementNode(childNode)) {
              if (isSlotElement(childNode) && childNode.assignedNodes) {
                childNode.assignedNodes().forEach(function(childNode2) {
                  return parseNodeTree(context, childNode2, parent, root);
                });
              } else {
                var container = createContainer(context, childNode);
                if (container.styles.isVisible()) {
                  if (createsRealStackingContext(childNode, container, root)) {
                    container.flags |= 4;
                  } else if (createsStackingContext(container.styles)) {
                    container.flags |= 2;
                  }
                  if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                    container.flags |= 8;
                  }
                  parent.elements.push(container);
                  childNode.slot;
                  if (childNode.shadowRoot) {
                    parseNodeTree(context, childNode.shadowRoot, container, root);
                  } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                    parseNodeTree(context, childNode, container, root);
                  }
                }
              }
            }
          }
        };
        var createContainer = function(context, element) {
          if (isImageElement(element)) {
            return new ImageElementContainer(context, element);
          }
          if (isCanvasElement(element)) {
            return new CanvasElementContainer(context, element);
          }
          if (isSVGElement(element)) {
            return new SVGElementContainer(context, element);
          }
          if (isLIElement(element)) {
            return new LIElementContainer(context, element);
          }
          if (isOLElement(element)) {
            return new OLElementContainer(context, element);
          }
          if (isInputElement(element)) {
            return new InputElementContainer(context, element);
          }
          if (isSelectElement(element)) {
            return new SelectElementContainer(context, element);
          }
          if (isTextareaElement(element)) {
            return new TextareaElementContainer(context, element);
          }
          if (isIFrameElement(element)) {
            return new IFrameElementContainer(context, element);
          }
          return new ElementContainer(context, element);
        };
        var parseTree = function(context, element) {
          var container = createContainer(context, element);
          container.flags |= 4;
          parseNodeTree(context, element, container, container);
          return container;
        };
        var createsRealStackingContext = function(node2, container, root) {
          return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node2) && root.styles.isTransparent();
        };
        var createsStackingContext = function(styles) {
          return styles.isPositioned() || styles.isFloating();
        };
        var isTextNode = function(node2) {
          return node2.nodeType === Node.TEXT_NODE;
        };
        var isElementNode = function(node2) {
          return node2.nodeType === Node.ELEMENT_NODE;
        };
        var isHTMLElementNode = function(node2) {
          return isElementNode(node2) && typeof node2.style !== "undefined" && !isSVGElementNode(node2);
        };
        var isSVGElementNode = function(element) {
          return typeof element.className === "object";
        };
        var isLIElement = function(node2) {
          return node2.tagName === "LI";
        };
        var isOLElement = function(node2) {
          return node2.tagName === "OL";
        };
        var isInputElement = function(node2) {
          return node2.tagName === "INPUT";
        };
        var isHTMLElement = function(node2) {
          return node2.tagName === "HTML";
        };
        var isSVGElement = function(node2) {
          return node2.tagName === "svg";
        };
        var isBodyElement = function(node2) {
          return node2.tagName === "BODY";
        };
        var isCanvasElement = function(node2) {
          return node2.tagName === "CANVAS";
        };
        var isVideoElement = function(node2) {
          return node2.tagName === "VIDEO";
        };
        var isImageElement = function(node2) {
          return node2.tagName === "IMG";
        };
        var isIFrameElement = function(node2) {
          return node2.tagName === "IFRAME";
        };
        var isStyleElement = function(node2) {
          return node2.tagName === "STYLE";
        };
        var isScriptElement = function(node2) {
          return node2.tagName === "SCRIPT";
        };
        var isTextareaElement = function(node2) {
          return node2.tagName === "TEXTAREA";
        };
        var isSelectElement = function(node2) {
          return node2.tagName === "SELECT";
        };
        var isSlotElement = function(node2) {
          return node2.tagName === "SLOT";
        };
        var isCustomElement = function(node2) {
          return node2.tagName.indexOf("-") > 0;
        };
        var CounterState = (
          /** @class */
          (function() {
            function CounterState2() {
              this.counters = {};
            }
            CounterState2.prototype.getCounterValue = function(name) {
              var counter = this.counters[name];
              if (counter && counter.length) {
                return counter[counter.length - 1];
              }
              return 1;
            };
            CounterState2.prototype.getCounterValues = function(name) {
              var counter = this.counters[name];
              return counter ? counter : [];
            };
            CounterState2.prototype.pop = function(counters) {
              var _this = this;
              counters.forEach(function(counter) {
                return _this.counters[counter].pop();
              });
            };
            CounterState2.prototype.parse = function(style) {
              var _this = this;
              var counterIncrement2 = style.counterIncrement;
              var counterReset2 = style.counterReset;
              var canReset = true;
              if (counterIncrement2 !== null) {
                counterIncrement2.forEach(function(entry) {
                  var counter = _this.counters[entry.counter];
                  if (counter && entry.increment !== 0) {
                    canReset = false;
                    if (!counter.length) {
                      counter.push(1);
                    }
                    counter[Math.max(0, counter.length - 1)] += entry.increment;
                  }
                });
              }
              var counterNames = [];
              if (canReset) {
                counterReset2.forEach(function(entry) {
                  var counter = _this.counters[entry.counter];
                  counterNames.push(entry.counter);
                  if (!counter) {
                    counter = _this.counters[entry.counter] = [];
                  }
                  counter.push(entry.reset);
                });
              }
              return counterNames;
            };
            return CounterState2;
          })()
        );
        var ROMAN_UPPER = {
          integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
          values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
        };
        var ARMENIAN = {
          integers: [9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
          values: ["\u0554", "\u0553", "\u0552", "\u0551", "\u0550", "\u054F", "\u054E", "\u054D", "\u054C", "\u054B", "\u054A", "\u0549", "\u0548", "\u0547", "\u0546", "\u0545", "\u0544", "\u0543", "\u0542", "\u0541", "\u0540", "\u053F", "\u053E", "\u053D", "\u053C", "\u053B", "\u053A", "\u0539", "\u0538", "\u0537", "\u0536", "\u0535", "\u0534", "\u0533", "\u0532", "\u0531"]
        };
        var HEBREW = {
          integers: [1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
          values: ["\u05D9\u05F3", "\u05D8\u05F3", "\u05D7\u05F3", "\u05D6\u05F3", "\u05D5\u05F3", "\u05D4\u05F3", "\u05D3\u05F3", "\u05D2\u05F3", "\u05D1\u05F3", "\u05D0\u05F3", "\u05EA", "\u05E9", "\u05E8", "\u05E7", "\u05E6", "\u05E4", "\u05E2", "\u05E1", "\u05E0", "\u05DE", "\u05DC", "\u05DB", "\u05D9\u05D8", "\u05D9\u05D7", "\u05D9\u05D6", "\u05D8\u05D6", "\u05D8\u05D5", "\u05D9", "\u05D8", "\u05D7", "\u05D6", "\u05D5", "\u05D4", "\u05D3", "\u05D2", "\u05D1", "\u05D0"]
        };
        var GEORGIAN = {
          integers: [1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
          values: ["\u10F5", "\u10F0", "\u10EF", "\u10F4", "\u10EE", "\u10ED", "\u10EC", "\u10EB", "\u10EA", "\u10E9", "\u10E8", "\u10E7", "\u10E6", "\u10E5", "\u10E4", "\u10F3", "\u10E2", "\u10E1", "\u10E0", "\u10DF", "\u10DE", "\u10DD", "\u10F2", "\u10DC", "\u10DB", "\u10DA", "\u10D9", "\u10D8", "\u10D7", "\u10F1", "\u10D6", "\u10D5", "\u10D4", "\u10D3", "\u10D2", "\u10D1", "\u10D0"]
        };
        var createAdditiveCounter = function(value, min, max2, symbols, fallback, suffix) {
          if (value < min || value > max2) {
            return createCounterText(value, fallback, suffix.length > 0);
          }
          return symbols.integers.reduce(function(string, integer, index2) {
            while (value >= integer) {
              value -= integer;
              string += symbols.values[index2];
            }
            return string;
          }, "") + suffix;
        };
        var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
          var string = "";
          do {
            if (!isNumeric) {
              value--;
            }
            string = resolver(value) + string;
            value /= codePointRangeLength;
          } while (value * codePointRangeLength >= codePointRangeLength);
          return string;
        };
        var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
          var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
          return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
            return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
          }) + suffix);
        };
        var createCounterStyleFromSymbols = function(value, symbols, suffix) {
          if (suffix === void 0) {
            suffix = ". ";
          }
          var codePointRangeLength = symbols.length;
          return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
            return symbols[Math.floor(codePoint % codePointRangeLength)];
          }) + suffix;
        };
        var CJK_ZEROS = 1 << 0;
        var CJK_TEN_COEFFICIENTS = 1 << 1;
        var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
        var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
        var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
          if (value < -9999 || value > 9999) {
            return createCounterText(value, 4, suffix.length > 0);
          }
          var tmp = Math.abs(value);
          var string = suffix;
          if (tmp === 0) {
            return numbers[0] + string;
          }
          for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
            var coefficient = tmp % 10;
            if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
              string = numbers[coefficient] + string;
            } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
              string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
            } else if (coefficient === 1 && digit > 0) {
              string = multipliers[digit - 1] + string;
            }
            tmp = Math.floor(tmp / 10);
          }
          return (value < 0 ? negativeSign : "") + string;
        };
        var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
        var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
        var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
        var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
        var createCounterText = function(value, type, appendSuffix) {
          var defaultSuffix = appendSuffix ? ". " : "";
          var cjkSuffix = appendSuffix ? "\u3001" : "";
          var koreanSuffix = appendSuffix ? ", " : "";
          var spaceSuffix = appendSuffix ? " " : "";
          switch (type) {
            case 0:
              return "\u2022" + spaceSuffix;
            case 1:
              return "\u25E6" + spaceSuffix;
            case 2:
              return "\u25FE" + spaceSuffix;
            case 5:
              var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
              return string.length < 4 ? "0" + string : string;
            case 4:
              return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
            case 6:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
            case 7:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
            case 8:
              return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
            case 9:
              return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
            case 10:
              return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
            case 11:
              return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
            case 12:
            case 49:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
            case 35:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
            case 13:
              return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
            case 14:
            case 30:
              return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
            case 15:
              return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
            case 16:
              return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
            case 17:
            case 48:
              return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case 47:
              return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case 42:
              return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case 41:
              return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case 26:
              return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
            case 25:
              return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case 31:
              return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case 33:
              return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
            case 32:
              return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case 18:
              return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
            case 20:
              return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
            case 21:
              return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
            case 22:
              return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
            case 22:
              return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
            case 23:
              return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
            case 24:
              return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
            case 27:
              return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
            case 28:
              return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
            case 29:
              return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
            case 34:
              return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
            case 37:
              return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
            case 38:
              return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
            case 39:
              return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
            case 40:
              return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
            case 43:
              return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
            case 44:
              return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
            case 45:
              return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
            case 46:
              return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
            case 3:
            default:
              return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
          }
        };
        var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
        var DocumentCloner = (
          /** @class */
          (function() {
            function DocumentCloner2(context, element, options) {
              this.context = context;
              this.options = options;
              this.scrolledElements = [];
              this.referenceElement = element;
              this.counters = new CounterState();
              this.quoteDepth = 0;
              if (!element.ownerDocument) {
                throw new Error("Cloned element does not have an owner document");
              }
              this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
            }
            DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
              var _this = this;
              var iframe = createIFrameContainer(ownerDocument, windowSize);
              if (!iframe.contentWindow) {
                return Promise.reject("Unable to find iframe window");
              }
              var scrollX = ownerDocument.defaultView.pageXOffset;
              var scrollY = ownerDocument.defaultView.pageYOffset;
              var cloneWindow = iframe.contentWindow;
              var documentClone = cloneWindow.document;
              var iframeLoad = iframeLoader(iframe).then(function() {
                return __awaiter(_this, void 0, void 0, function() {
                  var onclone, referenceElement;
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        this.scrolledElements.forEach(restoreNodeScroll);
                        if (cloneWindow) {
                          cloneWindow.scrollTo(windowSize.left, windowSize.top);
                          if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                            this.context.logger.warn("Unable to restore scroll position for cloned document");
                            this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                          }
                        }
                        onclone = this.options.onclone;
                        referenceElement = this.clonedReferenceElement;
                        if (typeof referenceElement === "undefined") {
                          return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                        }
                        if (!(documentClone.fonts && documentClone.fonts.ready)) return [3, 2];
                        return [4, documentClone.fonts.ready];
                      case 1:
                        _a2.sent();
                        _a2.label = 2;
                      case 2:
                        if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3, 4];
                        return [4, imagesReady(documentClone)];
                      case 3:
                        _a2.sent();
                        _a2.label = 4;
                      case 4:
                        if (typeof onclone === "function") {
                          return [2, Promise.resolve().then(function() {
                            return onclone(documentClone, referenceElement);
                          }).then(function() {
                            return iframe;
                          })];
                        }
                        return [2, iframe];
                    }
                  });
                });
              });
              documentClone.open();
              documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
              restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
              documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
              documentClone.close();
              return iframeLoad;
            };
            DocumentCloner2.prototype.createElementClone = function(node2) {
              if (isDebugging(
                node2,
                2
                /* CLONE */
              )) {
                debugger;
              }
              if (isCanvasElement(node2)) {
                return this.createCanvasClone(node2);
              }
              if (isVideoElement(node2)) {
                return this.createVideoClone(node2);
              }
              if (isStyleElement(node2)) {
                return this.createStyleClone(node2);
              }
              var clone2 = node2.cloneNode(false);
              if (isImageElement(clone2)) {
                if (isImageElement(node2) && node2.currentSrc && node2.currentSrc !== node2.src) {
                  clone2.src = node2.currentSrc;
                  clone2.srcset = "";
                }
                if (clone2.loading === "lazy") {
                  clone2.loading = "eager";
                }
              }
              if (isCustomElement(clone2)) {
                return this.createCustomElementClone(clone2);
              }
              return clone2;
            };
            DocumentCloner2.prototype.createCustomElementClone = function(node2) {
              var clone2 = document.createElement("html2canvascustomelement");
              copyCSSStyles(node2.style, clone2);
              return clone2;
            };
            DocumentCloner2.prototype.createStyleClone = function(node2) {
              try {
                var sheet = node2.sheet;
                if (sheet && sheet.cssRules) {
                  var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
                    if (rule && typeof rule.cssText === "string") {
                      return css2 + rule.cssText;
                    }
                    return css2;
                  }, "");
                  var style = node2.cloneNode(false);
                  style.textContent = css;
                  return style;
                }
              } catch (e3) {
                this.context.logger.error("Unable to access cssRules property", e3);
                if (e3.name !== "SecurityError") {
                  throw e3;
                }
              }
              return node2.cloneNode(false);
            };
            DocumentCloner2.prototype.createCanvasClone = function(canvas) {
              var _a2;
              if (this.options.inlineImages && canvas.ownerDocument) {
                var img = canvas.ownerDocument.createElement("img");
                try {
                  img.src = canvas.toDataURL();
                  return img;
                } catch (e3) {
                  this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
                }
              }
              var clonedCanvas = canvas.cloneNode(false);
              try {
                clonedCanvas.width = canvas.width;
                clonedCanvas.height = canvas.height;
                var ctx = canvas.getContext("2d");
                var clonedCtx = clonedCanvas.getContext("2d");
                if (clonedCtx) {
                  if (!this.options.allowTaint && ctx) {
                    clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                  } else {
                    var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
                    if (gl) {
                      var attribs = gl.getContextAttributes();
                      if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                        this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                      }
                    }
                    clonedCtx.drawImage(canvas, 0, 0);
                  }
                }
                return clonedCanvas;
              } catch (e3) {
                this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
              }
              return clonedCanvas;
            };
            DocumentCloner2.prototype.createVideoClone = function(video) {
              var canvas = video.ownerDocument.createElement("canvas");
              canvas.width = video.offsetWidth;
              canvas.height = video.offsetHeight;
              var ctx = canvas.getContext("2d");
              try {
                if (ctx) {
                  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                  if (!this.options.allowTaint) {
                    ctx.getImageData(0, 0, canvas.width, canvas.height);
                  }
                }
                return canvas;
              } catch (e3) {
                this.context.logger.info("Unable to clone video as it is tainted", video);
              }
              var blankCanvas = video.ownerDocument.createElement("canvas");
              blankCanvas.width = video.offsetWidth;
              blankCanvas.height = video.offsetHeight;
              return blankCanvas;
            };
            DocumentCloner2.prototype.appendChildNode = function(clone2, child, copyStyles) {
              if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
                if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                  clone2.appendChild(this.cloneNode(child, copyStyles));
                }
              }
            };
            DocumentCloner2.prototype.cloneChildNodes = function(node2, clone2, copyStyles) {
              var _this = this;
              for (var child = node2.shadowRoot ? node2.shadowRoot.firstChild : node2.firstChild; child; child = child.nextSibling) {
                if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
                  var assignedNodes = child.assignedNodes();
                  if (assignedNodes.length) {
                    assignedNodes.forEach(function(assignedNode) {
                      return _this.appendChildNode(clone2, assignedNode, copyStyles);
                    });
                  }
                } else {
                  this.appendChildNode(clone2, child, copyStyles);
                }
              }
            };
            DocumentCloner2.prototype.cloneNode = function(node2, copyStyles) {
              if (isTextNode(node2)) {
                return document.createTextNode(node2.data);
              }
              if (!node2.ownerDocument) {
                return node2.cloneNode(false);
              }
              var window2 = node2.ownerDocument.defaultView;
              if (window2 && isElementNode(node2) && (isHTMLElementNode(node2) || isSVGElementNode(node2))) {
                var clone2 = this.createElementClone(node2);
                clone2.style.transitionProperty = "none";
                var style = window2.getComputedStyle(node2);
                var styleBefore = window2.getComputedStyle(node2, ":before");
                var styleAfter = window2.getComputedStyle(node2, ":after");
                if (this.referenceElement === node2 && isHTMLElementNode(clone2)) {
                  this.clonedReferenceElement = clone2;
                }
                if (isBodyElement(clone2)) {
                  createPseudoHideStyles(clone2);
                }
                var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
                var before = this.resolvePseudoContent(node2, clone2, styleBefore, PseudoElementType.BEFORE);
                if (isCustomElement(node2)) {
                  copyStyles = true;
                }
                if (!isVideoElement(node2)) {
                  this.cloneChildNodes(node2, clone2, copyStyles);
                }
                if (before) {
                  clone2.insertBefore(before, clone2.firstChild);
                }
                var after = this.resolvePseudoContent(node2, clone2, styleAfter, PseudoElementType.AFTER);
                if (after) {
                  clone2.appendChild(after);
                }
                this.counters.pop(counters);
                if (style && (this.options.copyStyles || isSVGElementNode(node2)) && !isIFrameElement(node2) || copyStyles) {
                  copyCSSStyles(style, clone2);
                }
                if (node2.scrollTop !== 0 || node2.scrollLeft !== 0) {
                  this.scrolledElements.push([clone2, node2.scrollLeft, node2.scrollTop]);
                }
                if ((isTextareaElement(node2) || isSelectElement(node2)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
                  clone2.value = node2.value;
                }
                return clone2;
              }
              return node2.cloneNode(false);
            };
            DocumentCloner2.prototype.resolvePseudoContent = function(node2, clone2, style, pseudoElt) {
              var _this = this;
              if (!style) {
                return;
              }
              var value = style.content;
              var document2 = clone2.ownerDocument;
              if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
                return;
              }
              this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var declaration = new CSSParsedPseudoDeclaration(this.context, style);
              var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
              copyCSSStyles(style, anonymousReplacedElement);
              declaration.content.forEach(function(token) {
                if (token.type === 0) {
                  anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
                } else if (token.type === 22) {
                  var img = document2.createElement("img");
                  img.src = token.value;
                  img.style.opacity = "1";
                  anonymousReplacedElement.appendChild(img);
                } else if (token.type === 18) {
                  if (token.name === "attr") {
                    var attr = token.values.filter(isIdentToken);
                    if (attr.length) {
                      anonymousReplacedElement.appendChild(document2.createTextNode(node2.getAttribute(attr[0].value) || ""));
                    }
                  } else if (token.name === "counter") {
                    var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
                    if (counter && isIdentToken(counter)) {
                      var counterState = _this.counters.getCounterValue(counter.value);
                      var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                      anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
                    }
                  } else if (token.name === "counters") {
                    var _b2 = token.values.filter(nonFunctionArgSeparator), counter = _b2[0], delim = _b2[1], counterStyle = _b2[2];
                    if (counter && isIdentToken(counter)) {
                      var counterStates = _this.counters.getCounterValues(counter.value);
                      var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                      var separator = delim && delim.type === 0 ? delim.value : "";
                      var text2 = counterStates.map(function(value2) {
                        return createCounterText(value2, counterType_1, false);
                      }).join(separator);
                      anonymousReplacedElement.appendChild(document2.createTextNode(text2));
                    }
                  } else ;
                } else if (token.type === 20) {
                  switch (token.value) {
                    case "open-quote":
                      anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                      break;
                    case "close-quote":
                      anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                      break;
                    default:
                      anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
                  }
                }
              });
              anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
              var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
              if (isSVGElementNode(clone2)) {
                clone2.className.baseValue += newClassName;
              } else {
                clone2.className += newClassName;
              }
              return anonymousReplacedElement;
            };
            DocumentCloner2.destroy = function(container) {
              if (container.parentNode) {
                container.parentNode.removeChild(container);
                return true;
              }
              return false;
            };
            return DocumentCloner2;
          })()
        );
        var PseudoElementType;
        (function(PseudoElementType2) {
          PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
          PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
        })(PseudoElementType || (PseudoElementType = {}));
        var createIFrameContainer = function(ownerDocument, bounds) {
          var cloneIframeContainer = ownerDocument.createElement("iframe");
          cloneIframeContainer.className = "html2canvas-container";
          cloneIframeContainer.style.visibility = "hidden";
          cloneIframeContainer.style.position = "fixed";
          cloneIframeContainer.style.left = "-10000px";
          cloneIframeContainer.style.top = "0px";
          cloneIframeContainer.style.border = "0";
          cloneIframeContainer.width = bounds.width.toString();
          cloneIframeContainer.height = bounds.height.toString();
          cloneIframeContainer.scrolling = "no";
          cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
          ownerDocument.body.appendChild(cloneIframeContainer);
          return cloneIframeContainer;
        };
        var imageReady = function(img) {
          return new Promise(function(resolve) {
            if (img.complete) {
              resolve();
              return;
            }
            if (!img.src) {
              resolve();
              return;
            }
            img.onload = resolve;
            img.onerror = resolve;
          });
        };
        var imagesReady = function(document2) {
          return Promise.all([].slice.call(document2.images, 0).map(imageReady));
        };
        var iframeLoader = function(iframe) {
          return new Promise(function(resolve, reject) {
            var cloneWindow = iframe.contentWindow;
            if (!cloneWindow) {
              return reject("No window assigned for iframe");
            }
            var documentClone = cloneWindow.document;
            cloneWindow.onload = iframe.onload = function() {
              cloneWindow.onload = iframe.onload = null;
              var interval = setInterval(function() {
                if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
                  clearInterval(interval);
                  resolve(iframe);
                }
              }, 50);
            };
          });
        };
        var ignoredStyleProperties = [
          "all",
          "d",
          "content"
          // Safari shows pseudoelements if content is set
        ];
        var copyCSSStyles = function(style, target) {
          for (var i3 = style.length - 1; i3 >= 0; i3--) {
            var property = style.item(i3);
            if (ignoredStyleProperties.indexOf(property) === -1) {
              target.style.setProperty(property, style.getPropertyValue(property));
            }
          }
          return target;
        };
        var serializeDoctype = function(doctype) {
          var str = "";
          if (doctype) {
            str += "<!DOCTYPE ";
            if (doctype.name) {
              str += doctype.name;
            }
            if (doctype.internalSubset) {
              str += doctype.internalSubset;
            }
            if (doctype.publicId) {
              str += '"' + doctype.publicId + '"';
            }
            if (doctype.systemId) {
              str += '"' + doctype.systemId + '"';
            }
            str += ">";
          }
          return str;
        };
        var restoreOwnerScroll = function(ownerDocument, x2, y2) {
          if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y2 !== ownerDocument.defaultView.pageYOffset)) {
            ownerDocument.defaultView.scrollTo(x2, y2);
          }
        };
        var restoreNodeScroll = function(_a2) {
          var element = _a2[0], x2 = _a2[1], y2 = _a2[2];
          element.scrollLeft = x2;
          element.scrollTop = y2;
        };
        var PSEUDO_BEFORE = ":before";
        var PSEUDO_AFTER = ":after";
        var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
        var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
        var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
        var createPseudoHideStyles = function(body) {
          createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
        };
        var createStyles = function(body, styles) {
          var document2 = body.ownerDocument;
          if (document2) {
            var style = document2.createElement("style");
            style.textContent = styles;
            body.appendChild(style);
          }
        };
        var CacheStorage = (
          /** @class */
          (function() {
            function CacheStorage2() {
            }
            CacheStorage2.getOrigin = function(url) {
              var link = CacheStorage2._link;
              if (!link) {
                return "about:blank";
              }
              link.href = url;
              link.href = link.href;
              return link.protocol + link.hostname + link.port;
            };
            CacheStorage2.isSameOrigin = function(src) {
              return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
            };
            CacheStorage2.setContext = function(window2) {
              CacheStorage2._link = window2.document.createElement("a");
              CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
            };
            CacheStorage2._origin = "about:blank";
            return CacheStorage2;
          })()
        );
        var Cache = (
          /** @class */
          (function() {
            function Cache2(context, _options) {
              this.context = context;
              this._options = _options;
              this._cache = {};
            }
            Cache2.prototype.addImage = function(src) {
              var result = Promise.resolve();
              if (this.has(src)) {
                return result;
              }
              if (isBlobImage(src) || isRenderable(src)) {
                (this._cache[src] = this.loadImage(src)).catch(function() {
                });
                return result;
              }
              return result;
            };
            Cache2.prototype.match = function(src) {
              return this._cache[src];
            };
            Cache2.prototype.loadImage = function(key) {
              return __awaiter(this, void 0, void 0, function() {
                var isSameOrigin, useCORS, useProxy, src;
                var _this = this;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      isSameOrigin = CacheStorage.isSameOrigin(key);
                      useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                      useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                      if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                        return [
                          2
                          /*return*/
                        ];
                      }
                      src = key;
                      if (!useProxy) return [3, 2];
                      return [4, this.proxy(src)];
                    case 1:
                      src = _a2.sent();
                      _a2.label = 2;
                    case 2:
                      this.context.logger.debug("Added image " + key.substring(0, 256));
                      return [4, new Promise(function(resolve, reject) {
                        var img = new Image();
                        img.onload = function() {
                          return resolve(img);
                        };
                        img.onerror = reject;
                        if (isInlineBase64Image(src) || useCORS) {
                          img.crossOrigin = "anonymous";
                        }
                        img.src = src;
                        if (img.complete === true) {
                          setTimeout(function() {
                            return resolve(img);
                          }, 500);
                        }
                        if (_this._options.imageTimeout > 0) {
                          setTimeout(function() {
                            return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                          }, _this._options.imageTimeout);
                        }
                      })];
                    case 3:
                      return [2, _a2.sent()];
                  }
                });
              });
            };
            Cache2.prototype.has = function(key) {
              return typeof this._cache[key] !== "undefined";
            };
            Cache2.prototype.keys = function() {
              return Promise.resolve(Object.keys(this._cache));
            };
            Cache2.prototype.proxy = function(src) {
              var _this = this;
              var proxy = this._options.proxy;
              if (!proxy) {
                throw new Error("No proxy defined");
              }
              var key = src.substring(0, 256);
              return new Promise(function(resolve, reject) {
                var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
                var xhr = new XMLHttpRequest();
                xhr.onload = function() {
                  if (xhr.status === 200) {
                    if (responseType === "text") {
                      resolve(xhr.response);
                    } else {
                      var reader_1 = new FileReader();
                      reader_1.addEventListener("load", function() {
                        return resolve(reader_1.result);
                      }, false);
                      reader_1.addEventListener("error", function(e3) {
                        return reject(e3);
                      }, false);
                      reader_1.readAsDataURL(xhr.response);
                    }
                  } else {
                    reject("Failed to proxy resource " + key + " with status code " + xhr.status);
                  }
                };
                xhr.onerror = reject;
                var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
                xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
                if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
                  xhr.responseType = responseType;
                }
                if (_this._options.imageTimeout) {
                  var timeout_1 = _this._options.imageTimeout;
                  xhr.timeout = timeout_1;
                  xhr.ontimeout = function() {
                    return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
                  };
                }
                xhr.send();
              });
            };
            return Cache2;
          })()
        );
        var INLINE_SVG = /^data:image\/svg\+xml/i;
        var INLINE_BASE64 = /^data:image\/.*;base64,/i;
        var INLINE_IMG = /^data:image\/.*/i;
        var isRenderable = function(src) {
          return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
        };
        var isInlineImage = function(src) {
          return INLINE_IMG.test(src);
        };
        var isInlineBase64Image = function(src) {
          return INLINE_BASE64.test(src);
        };
        var isBlobImage = function(src) {
          return src.substr(0, 4) === "blob";
        };
        var isSVG = function(src) {
          return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
        };
        var Vector = (
          /** @class */
          (function() {
            function Vector2(x2, y2) {
              this.type = 0;
              this.x = x2;
              this.y = y2;
            }
            Vector2.prototype.add = function(deltaX, deltaY) {
              return new Vector2(this.x + deltaX, this.y + deltaY);
            };
            return Vector2;
          })()
        );
        var lerp = function(a3, b2, t3) {
          return new Vector(a3.x + (b2.x - a3.x) * t3, a3.y + (b2.y - a3.y) * t3);
        };
        var BezierCurve = (
          /** @class */
          (function() {
            function BezierCurve2(start, startControl, endControl, end) {
              this.type = 1;
              this.start = start;
              this.startControl = startControl;
              this.endControl = endControl;
              this.end = end;
            }
            BezierCurve2.prototype.subdivide = function(t3, firstHalf) {
              var ab = lerp(this.start, this.startControl, t3);
              var bc = lerp(this.startControl, this.endControl, t3);
              var cd = lerp(this.endControl, this.end, t3);
              var abbc = lerp(ab, bc, t3);
              var bccd = lerp(bc, cd, t3);
              var dest = lerp(abbc, bccd, t3);
              return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
            };
            BezierCurve2.prototype.add = function(deltaX, deltaY) {
              return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
            };
            BezierCurve2.prototype.reverse = function() {
              return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
            };
            return BezierCurve2;
          })()
        );
        var isBezierCurve = function(path2) {
          return path2.type === 1;
        };
        var BoundCurves = (
          /** @class */
          /* @__PURE__ */ (function() {
            function BoundCurves2(element) {
              var styles = element.styles;
              var bounds = element.bounds;
              var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
              var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
              var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
              var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
              var factors = [];
              factors.push((tlh + trh) / bounds.width);
              factors.push((blh + brh) / bounds.width);
              factors.push((tlv + blv) / bounds.height);
              factors.push((trv + brv) / bounds.height);
              var maxFactor = Math.max.apply(Math, factors);
              if (maxFactor > 1) {
                tlh /= maxFactor;
                tlv /= maxFactor;
                trh /= maxFactor;
                trv /= maxFactor;
                brh /= maxFactor;
                brv /= maxFactor;
                blh /= maxFactor;
                blv /= maxFactor;
              }
              var topWidth = bounds.width - trh;
              var rightHeight = bounds.height - brv;
              var bottomWidth = bounds.width - brh;
              var leftHeight = bounds.height - blv;
              var borderTopWidth2 = styles.borderTopWidth;
              var borderRightWidth2 = styles.borderRightWidth;
              var borderBottomWidth2 = styles.borderBottomWidth;
              var borderLeftWidth2 = styles.borderLeftWidth;
              var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
              var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
              var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
              var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
              this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
              this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
              this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
              this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
              this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
              this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
              this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
              this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
              this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
              this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
              this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
              this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
              this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
              this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
              this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
              this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
              this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
              this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
              this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
              this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
              this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
              this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
              this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
              this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
            }
            return BoundCurves2;
          })()
        );
        var CORNER;
        (function(CORNER2) {
          CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
          CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
          CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
          CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
        })(CORNER || (CORNER = {}));
        var getCurvePoints = function(x2, y2, r1, r2, position2) {
          var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
          var ox = r1 * kappa;
          var oy = r2 * kappa;
          var xm = x2 + r1;
          var ym = y2 + r2;
          switch (position2) {
            case CORNER.TOP_LEFT:
              return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));
            case CORNER.TOP_RIGHT:
              return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));
            case CORNER.BOTTOM_RIGHT:
              return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
            case CORNER.BOTTOM_LEFT:
            default:
              return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));
          }
        };
        var calculateBorderBoxPath = function(curves) {
          return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
        };
        var calculateContentBoxPath = function(curves) {
          return [curves.topLeftContentBox, curves.topRightContentBox, curves.bottomRightContentBox, curves.bottomLeftContentBox];
        };
        var calculatePaddingBoxPath = function(curves) {
          return [curves.topLeftPaddingBox, curves.topRightPaddingBox, curves.bottomRightPaddingBox, curves.bottomLeftPaddingBox];
        };
        var TransformEffect = (
          /** @class */
          /* @__PURE__ */ (function() {
            function TransformEffect2(offsetX, offsetY, matrix3) {
              this.offsetX = offsetX;
              this.offsetY = offsetY;
              this.matrix = matrix3;
              this.type = 0;
              this.target = 2 | 4;
            }
            return TransformEffect2;
          })()
        );
        var ClipEffect = (
          /** @class */
          /* @__PURE__ */ (function() {
            function ClipEffect2(path2, target) {
              this.path = path2;
              this.target = target;
              this.type = 1;
            }
            return ClipEffect2;
          })()
        );
        var OpacityEffect = (
          /** @class */
          /* @__PURE__ */ (function() {
            function OpacityEffect2(opacity2) {
              this.opacity = opacity2;
              this.type = 2;
              this.target = 2 | 4;
            }
            return OpacityEffect2;
          })()
        );
        var isTransformEffect = function(effect) {
          return effect.type === 0;
        };
        var isClipEffect = function(effect) {
          return effect.type === 1;
        };
        var isOpacityEffect = function(effect) {
          return effect.type === 2;
        };
        var equalPath = function(a3, b2) {
          if (a3.length === b2.length) {
            return a3.some(function(v2, i3) {
              return v2 === b2[i3];
            });
          }
          return false;
        };
        var transformPath = function(path2, deltaX, deltaY, deltaW, deltaH) {
          return path2.map(function(point, index2) {
            switch (index2) {
              case 0:
                return point.add(deltaX, deltaY);
              case 1:
                return point.add(deltaX + deltaW, deltaY);
              case 2:
                return point.add(deltaX + deltaW, deltaY + deltaH);
              case 3:
                return point.add(deltaX, deltaY + deltaH);
            }
            return point;
          });
        };
        var StackingContext = (
          /** @class */
          /* @__PURE__ */ (function() {
            function StackingContext2(container) {
              this.element = container;
              this.inlineLevel = [];
              this.nonInlineLevel = [];
              this.negativeZIndex = [];
              this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
              this.positiveZIndex = [];
              this.nonPositionedFloats = [];
              this.nonPositionedInlineLevel = [];
            }
            return StackingContext2;
          })()
        );
        var ElementPaint = (
          /** @class */
          (function() {
            function ElementPaint2(container, parent) {
              this.container = container;
              this.parent = parent;
              this.effects = [];
              this.curves = new BoundCurves(this.container);
              if (this.container.styles.opacity < 1) {
                this.effects.push(new OpacityEffect(this.container.styles.opacity));
              }
              if (this.container.styles.transform !== null) {
                var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
                var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
                var matrix3 = this.container.styles.transform;
                this.effects.push(new TransformEffect(offsetX, offsetY, matrix3));
              }
              if (this.container.styles.overflowX !== 0) {
                var borderBox = calculateBorderBoxPath(this.curves);
                var paddingBox2 = calculatePaddingBoxPath(this.curves);
                if (equalPath(borderBox, paddingBox2)) {
                  this.effects.push(new ClipEffect(
                    borderBox,
                    2 | 4
                    /* CONTENT */
                  ));
                } else {
                  this.effects.push(new ClipEffect(
                    borderBox,
                    2
                    /* BACKGROUND_BORDERS */
                  ));
                  this.effects.push(new ClipEffect(
                    paddingBox2,
                    4
                    /* CONTENT */
                  ));
                }
              }
            }
            ElementPaint2.prototype.getEffects = function(target) {
              var inFlow = [
                2,
                3
                /* FIXED */
              ].indexOf(this.container.styles.position) === -1;
              var parent = this.parent;
              var effects = this.effects.slice(0);
              while (parent) {
                var croplessEffects = parent.effects.filter(function(effect) {
                  return !isClipEffect(effect);
                });
                if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
                  effects.unshift.apply(effects, croplessEffects);
                  inFlow = [
                    2,
                    3
                    /* FIXED */
                  ].indexOf(parent.container.styles.position) === -1;
                  if (parent.container.styles.overflowX !== 0) {
                    var borderBox = calculateBorderBoxPath(parent.curves);
                    var paddingBox2 = calculatePaddingBoxPath(parent.curves);
                    if (!equalPath(borderBox, paddingBox2)) {
                      effects.unshift(new ClipEffect(
                        paddingBox2,
                        2 | 4
                        /* CONTENT */
                      ));
                    }
                  }
                } else {
                  effects.unshift.apply(effects, croplessEffects);
                }
                parent = parent.parent;
              }
              return effects.filter(function(effect) {
                return contains(effect.target, target);
              });
            };
            return ElementPaint2;
          })()
        );
        var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
          parent.container.elements.forEach(function(child) {
            var treatAsRealStackingContext = contains(
              child.flags,
              4
              /* CREATES_REAL_STACKING_CONTEXT */
            );
            var createsStackingContext2 = contains(
              child.flags,
              2
              /* CREATES_STACKING_CONTEXT */
            );
            var paintContainer = new ElementPaint(child, parent);
            if (contains(
              child.styles.display,
              2048
              /* LIST_ITEM */
            )) {
              listItems.push(paintContainer);
            }
            var listOwnerItems = contains(
              child.flags,
              8
              /* IS_LIST_OWNER */
            ) ? [] : listItems;
            if (treatAsRealStackingContext || createsStackingContext2) {
              var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
              var stack = new StackingContext(paintContainer);
              if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
                var order_1 = child.styles.zIndex.order;
                if (order_1 < 0) {
                  var index_1 = 0;
                  parentStack.negativeZIndex.some(function(current, i3) {
                    if (order_1 > current.element.container.styles.zIndex.order) {
                      index_1 = i3;
                      return false;
                    } else if (index_1 > 0) {
                      return true;
                    }
                    return false;
                  });
                  parentStack.negativeZIndex.splice(index_1, 0, stack);
                } else if (order_1 > 0) {
                  var index_2 = 0;
                  parentStack.positiveZIndex.some(function(current, i3) {
                    if (order_1 >= current.element.container.styles.zIndex.order) {
                      index_2 = i3 + 1;
                      return false;
                    } else if (index_2 > 0) {
                      return true;
                    }
                    return false;
                  });
                  parentStack.positiveZIndex.splice(index_2, 0, stack);
                } else {
                  parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
                }
              } else {
                if (child.styles.isFloating()) {
                  parentStack.nonPositionedFloats.push(stack);
                } else {
                  parentStack.nonPositionedInlineLevel.push(stack);
                }
              }
              parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
            } else {
              if (child.styles.isInlineLevel()) {
                stackingContext.inlineLevel.push(paintContainer);
              } else {
                stackingContext.nonInlineLevel.push(paintContainer);
              }
              parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
            }
            if (contains(
              child.flags,
              8
              /* IS_LIST_OWNER */
            )) {
              processListItems(child, listOwnerItems);
            }
          });
        };
        var processListItems = function(owner, elements2) {
          var numbering = owner instanceof OLElementContainer ? owner.start : 1;
          var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
          for (var i3 = 0; i3 < elements2.length; i3++) {
            var item = elements2[i3];
            if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
              numbering = item.container.value;
            }
            item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
            numbering += reversed ? -1 : 1;
          }
        };
        var parseStackingContexts = function(container) {
          var paintContainer = new ElementPaint(container, null);
          var root = new StackingContext(paintContainer);
          var listItems = [];
          parseStackTree(paintContainer, root, root, listItems);
          processListItems(paintContainer.container, listItems);
          return root;
        };
        var parsePathForBorder = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
            case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
            case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
            case 3:
            default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
          }
        };
        var parsePathForBorderDoubleOuter = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
            case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
            case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
            case 3:
            default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
          }
        };
        var parsePathForBorderDoubleInner = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
            case 1:
              return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
            case 2:
              return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
            case 3:
            default:
              return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
          }
        };
        var parsePathForBorderStroke = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
            case 1:
              return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
            case 2:
              return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
            case 3:
            default:
              return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
          }
        };
        var createStrokePathFromCurves = function(outer1, outer2) {
          var path2 = [];
          if (isBezierCurve(outer1)) {
            path2.push(outer1.subdivide(0.5, false));
          } else {
            path2.push(outer1);
          }
          if (isBezierCurve(outer2)) {
            path2.push(outer2.subdivide(0.5, true));
          } else {
            path2.push(outer2);
          }
          return path2;
        };
        var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
          var path2 = [];
          if (isBezierCurve(outer1)) {
            path2.push(outer1.subdivide(0.5, false));
          } else {
            path2.push(outer1);
          }
          if (isBezierCurve(outer2)) {
            path2.push(outer2.subdivide(0.5, true));
          } else {
            path2.push(outer2);
          }
          if (isBezierCurve(inner2)) {
            path2.push(inner2.subdivide(0.5, true).reverse());
          } else {
            path2.push(inner2);
          }
          if (isBezierCurve(inner1)) {
            path2.push(inner1.subdivide(0.5, false).reverse());
          } else {
            path2.push(inner1);
          }
          return path2;
        };
        var paddingBox = function(element) {
          var bounds = element.bounds;
          var styles = element.styles;
          return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
        };
        var contentBox = function(element) {
          var styles = element.styles;
          var bounds = element.bounds;
          var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
          var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
          var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
          var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
          return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
        };
        var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
          if (backgroundOrigin2 === 0) {
            return element.bounds;
          }
          if (backgroundOrigin2 === 2) {
            return contentBox(element);
          }
          return paddingBox(element);
        };
        var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
          if (backgroundClip2 === 0) {
            return element.bounds;
          }
          if (backgroundClip2 === 2) {
            return contentBox(element);
          }
          return paddingBox(element);
        };
        var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
          var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
          var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
          var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
          var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
          var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
          var path2 = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
          var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
          var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
          return [path2, offsetX, offsetY, sizeWidth, sizeHeight];
        };
        var isAuto = function(token) {
          return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
        };
        var hasIntrinsicValue = function(value) {
          return typeof value === "number";
        };
        var calculateBackgroundSize = function(size, _a2, bounds) {
          var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
          var first = size[0], second = size[1];
          if (!first) {
            return [0, 0];
          }
          if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
            return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
          }
          var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
          if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
            if (hasIntrinsicValue(intrinsicProportion)) {
              var targetRatio = bounds.width / bounds.height;
              return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
            }
            return [bounds.width, bounds.height];
          }
          var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
          var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
          var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
          if (isAuto(first) && (!second || isAuto(second))) {
            if (hasIntrinsicWidth && hasIntrinsicHeight) {
              return [intrinsicWidth, intrinsicHeight];
            }
            if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
              return [bounds.width, bounds.height];
            }
            if (hasIntrinsicDimensions && hasIntrinsicProportion) {
              var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
              var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
              return [width_1, height_1];
            }
            var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
            var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
            return [width_2, height_2];
          }
          if (hasIntrinsicProportion) {
            var width_3 = 0;
            var height_3 = 0;
            if (isLengthPercentage(first)) {
              width_3 = getAbsoluteValue(first, bounds.width);
            } else if (isLengthPercentage(second)) {
              height_3 = getAbsoluteValue(second, bounds.height);
            }
            if (isAuto(first)) {
              width_3 = height_3 * intrinsicProportion;
            } else if (!second || isAuto(second)) {
              height_3 = width_3 / intrinsicProportion;
            }
            return [width_3, height_3];
          }
          var width = null;
          var height = null;
          if (isLengthPercentage(first)) {
            width = getAbsoluteValue(first, bounds.width);
          } else if (second && isLengthPercentage(second)) {
            height = getAbsoluteValue(second, bounds.height);
          }
          if (width !== null && (!second || isAuto(second))) {
            height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
          }
          if (height !== null && isAuto(first)) {
            width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
          }
          if (width !== null && height !== null) {
            return [width, height];
          }
          throw new Error("Unable to calculate background-size for element");
        };
        var getBackgroundValueForIndex = function(values, index2) {
          var value = values[index2];
          if (typeof value === "undefined") {
            return values[0];
          }
          return value;
        };
        var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
          var x2 = _a2[0], y2 = _a2[1];
          var width = _b2[0], height = _b2[1];
          switch (repeat) {
            case 2:
              return [new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)), new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)), new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y2)), new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y2))];
            case 3:
              return [new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)), new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)), new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)), new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))];
            case 1:
              return [new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)), new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2)), new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2 + height)), new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height))];
            default:
              return [new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)), new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)), new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)), new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))];
          }
        };
        var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
        var SAMPLE_TEXT = "Hidden Text";
        var FontMetrics = (
          /** @class */
          (function() {
            function FontMetrics2(document2) {
              this._data = {};
              this._document = document2;
            }
            FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
              var container = this._document.createElement("div");
              var img = this._document.createElement("img");
              var span = this._document.createElement("span");
              var body = this._document.body;
              container.style.visibility = "hidden";
              container.style.fontFamily = fontFamily2;
              container.style.fontSize = fontSize2;
              container.style.margin = "0";
              container.style.padding = "0";
              container.style.whiteSpace = "nowrap";
              body.appendChild(container);
              img.src = SMALL_IMAGE;
              img.width = 1;
              img.height = 1;
              img.style.margin = "0";
              img.style.padding = "0";
              img.style.verticalAlign = "baseline";
              span.style.fontFamily = fontFamily2;
              span.style.fontSize = fontSize2;
              span.style.margin = "0";
              span.style.padding = "0";
              span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
              container.appendChild(span);
              container.appendChild(img);
              var baseline = img.offsetTop - span.offsetTop + 2;
              container.removeChild(span);
              container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
              container.style.lineHeight = "normal";
              img.style.verticalAlign = "super";
              var middle = img.offsetTop - container.offsetTop + 2;
              body.removeChild(container);
              return {
                baseline,
                middle
              };
            };
            FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
              var key = fontFamily2 + " " + fontSize2;
              if (typeof this._data[key] === "undefined") {
                this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
              }
              return this._data[key];
            };
            return FontMetrics2;
          })()
        );
        var Renderer = (
          /** @class */
          /* @__PURE__ */ (function() {
            function Renderer2(context, options) {
              this.context = context;
              this.options = options;
            }
            return Renderer2;
          })()
        );
        var MASK_OFFSET = 1e4;
        var CanvasRenderer = (
          /** @class */
          (function(_super) {
            __extends(CanvasRenderer2, _super);
            function CanvasRenderer2(context, options) {
              var _this = _super.call(this, context, options) || this;
              _this._activeEffects = [];
              _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
              _this.ctx = _this.canvas.getContext("2d");
              if (!options.canvas) {
                _this.canvas.width = Math.floor(options.width * options.scale);
                _this.canvas.height = Math.floor(options.height * options.scale);
                _this.canvas.style.width = options.width + "px";
                _this.canvas.style.height = options.height + "px";
              }
              _this.fontMetrics = new FontMetrics(document);
              _this.ctx.scale(_this.options.scale, _this.options.scale);
              _this.ctx.translate(-options.x, -options.y);
              _this.ctx.textBaseline = "bottom";
              _this._activeEffects = [];
              _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
              return _this;
            }
            CanvasRenderer2.prototype.applyEffects = function(effects) {
              var _this = this;
              while (this._activeEffects.length) {
                this.popEffect();
              }
              effects.forEach(function(effect) {
                return _this.applyEffect(effect);
              });
            };
            CanvasRenderer2.prototype.applyEffect = function(effect) {
              this.ctx.save();
              if (isOpacityEffect(effect)) {
                this.ctx.globalAlpha = effect.opacity;
              }
              if (isTransformEffect(effect)) {
                this.ctx.translate(effect.offsetX, effect.offsetY);
                this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
                this.ctx.translate(-effect.offsetX, -effect.offsetY);
              }
              if (isClipEffect(effect)) {
                this.path(effect.path);
                this.ctx.clip();
              }
              this._activeEffects.push(effect);
            };
            CanvasRenderer2.prototype.popEffect = function() {
              this._activeEffects.pop();
              this.ctx.restore();
            };
            CanvasRenderer2.prototype.renderStack = function(stack) {
              return __awaiter(this, void 0, void 0, function() {
                var styles;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      styles = stack.element.container.styles;
                      if (!styles.isVisible()) return [3, 2];
                      return [4, this.renderStackContent(stack)];
                    case 1:
                      _a2.sent();
                      _a2.label = 2;
                    case 2:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            CanvasRenderer2.prototype.renderNode = function(paint) {
              return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (contains(
                        paint.container.flags,
                        16
                        /* DEBUG_RENDER */
                      )) {
                        debugger;
                      }
                      if (!paint.container.styles.isVisible()) return [3, 3];
                      return [4, this.renderNodeBackgroundAndBorders(paint)];
                    case 1:
                      _a2.sent();
                      return [4, this.renderNodeContent(paint)];
                    case 2:
                      _a2.sent();
                      _a2.label = 3;
                    case 3:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text2, letterSpacing2, baseline) {
              var _this = this;
              if (letterSpacing2 === 0) {
                this.ctx.fillText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
              } else {
                var letters = segmentGraphemes(text2.text);
                letters.reduce(function(left, letter) {
                  _this.ctx.fillText(letter, left, text2.bounds.top + baseline);
                  return left + _this.ctx.measureText(letter).width;
                }, text2.bounds.left);
              }
            };
            CanvasRenderer2.prototype.createFontStyle = function(styles) {
              var fontVariant2 = styles.fontVariant.filter(function(variant) {
                return variant === "normal" || variant === "small-caps";
              }).join("");
              var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
              var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
              return [[styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "), fontFamily2, fontSize2];
            };
            CanvasRenderer2.prototype.renderTextNode = function(text2, styles) {
              return __awaiter(this, void 0, void 0, function() {
                var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
                var _this = this;
                return __generator(this, function(_c) {
                  _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
                  this.ctx.font = font;
                  this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
                  this.ctx.textAlign = "left";
                  this.ctx.textBaseline = "alphabetic";
                  _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
                  paintOrder2 = styles.paintOrder;
                  text2.textBounds.forEach(function(text3) {
                    paintOrder2.forEach(function(paintOrderLayer) {
                      switch (paintOrderLayer) {
                        case 0:
                          _this.ctx.fillStyle = asString(styles.color);
                          _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                          var textShadows = styles.textShadow;
                          if (textShadows.length && text3.text.trim().length) {
                            textShadows.slice(0).reverse().forEach(function(textShadow2) {
                              _this.ctx.shadowColor = asString(textShadow2.color);
                              _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                              _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                              _this.ctx.shadowBlur = textShadow2.blur.number;
                              _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                            });
                            _this.ctx.shadowColor = "";
                            _this.ctx.shadowOffsetX = 0;
                            _this.ctx.shadowOffsetY = 0;
                            _this.ctx.shadowBlur = 0;
                          }
                          if (styles.textDecorationLine.length) {
                            _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                            styles.textDecorationLine.forEach(function(textDecorationLine2) {
                              switch (textDecorationLine2) {
                                case 1:
                                  _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top + baseline), text3.bounds.width, 1);
                                  break;
                                case 2:
                                  _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top), text3.bounds.width, 1);
                                  break;
                                case 3:
                                  _this.ctx.fillRect(text3.bounds.left, Math.ceil(text3.bounds.top + middle), text3.bounds.width, 1);
                                  break;
                              }
                            });
                          }
                          break;
                        case 1:
                          if (styles.webkitTextStrokeWidth && text3.text.trim().length) {
                            _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                            _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                            _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                            _this.ctx.strokeText(text3.text, text3.bounds.left, text3.bounds.top + baseline);
                          }
                          _this.ctx.strokeStyle = "";
                          _this.ctx.lineWidth = 0;
                          _this.ctx.lineJoin = "miter";
                          break;
                      }
                    });
                  });
                  return [
                    2
                    /*return*/
                  ];
                });
              });
            };
            CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
              if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
                var box = contentBox(container);
                var path2 = calculatePaddingBoxPath(curves);
                this.path(path2);
                this.ctx.save();
                this.ctx.clip();
                this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
                this.ctx.restore();
              }
            };
            CanvasRenderer2.prototype.renderNodeContent = function(paint) {
              return __awaiter(this, void 0, void 0, function() {
                var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
                return __generator(this, function(_c) {
                  switch (_c.label) {
                    case 0:
                      this.applyEffects(paint.getEffects(
                        4
                        /* CONTENT */
                      ));
                      container = paint.container;
                      curves = paint.curves;
                      styles = container.styles;
                      _i = 0, _a2 = container.textNodes;
                      _c.label = 1;
                    case 1:
                      if (!(_i < _a2.length)) return [3, 4];
                      child = _a2[_i];
                      return [4, this.renderTextNode(child, styles)];
                    case 2:
                      _c.sent();
                      _c.label = 3;
                    case 3:
                      _i++;
                      return [3, 1];
                    case 4:
                      if (!(container instanceof ImageElementContainer)) return [3, 8];
                      _c.label = 5;
                    case 5:
                      _c.trys.push([5, 7, , 8]);
                      return [4, this.context.cache.match(container.src)];
                    case 6:
                      image2 = _c.sent();
                      this.renderReplacedElement(container, curves, image2);
                      return [3, 8];
                    case 7:
                      _c.sent();
                      this.context.logger.error("Error loading image " + container.src);
                      return [3, 8];
                    case 8:
                      if (container instanceof CanvasElementContainer) {
                        this.renderReplacedElement(container, curves, container.canvas);
                      }
                      if (!(container instanceof SVGElementContainer)) return [3, 12];
                      _c.label = 9;
                    case 9:
                      _c.trys.push([9, 11, , 12]);
                      return [4, this.context.cache.match(container.svg)];
                    case 10:
                      image2 = _c.sent();
                      this.renderReplacedElement(container, curves, image2);
                      return [3, 12];
                    case 11:
                      _c.sent();
                      this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                      return [3, 12];
                    case 12:
                      if (!(container instanceof IFrameElementContainer && container.tree)) return [3, 14];
                      iframeRenderer = new CanvasRenderer2(this.context, {
                        scale: this.options.scale,
                        backgroundColor: container.backgroundColor,
                        x: 0,
                        y: 0,
                        width: container.width,
                        height: container.height
                      });
                      return [4, iframeRenderer.render(container.tree)];
                    case 13:
                      canvas = _c.sent();
                      if (container.width && container.height) {
                        this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                      }
                      _c.label = 14;
                    case 14:
                      if (container instanceof InputElementContainer) {
                        size = Math.min(container.bounds.width, container.bounds.height);
                        if (container.type === CHECKBOX) {
                          if (container.checked) {
                            this.ctx.save();
                            this.path([new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79), new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549), new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071), new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649), new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23), new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085), new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)]);
                            this.ctx.fillStyle = asString(INPUT_COLOR);
                            this.ctx.fill();
                            this.ctx.restore();
                          }
                        } else if (container.type === RADIO) {
                          if (container.checked) {
                            this.ctx.save();
                            this.ctx.beginPath();
                            this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                            this.ctx.fillStyle = asString(INPUT_COLOR);
                            this.ctx.fill();
                            this.ctx.restore();
                          }
                        }
                      }
                      if (isTextInputElement(container) && container.value.length) {
                        _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                        baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                        this.ctx.font = fontFamily2;
                        this.ctx.fillStyle = asString(styles.color);
                        this.ctx.textBaseline = "alphabetic";
                        this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                        bounds = contentBox(container);
                        x2 = 0;
                        switch (container.styles.textAlign) {
                          case 1:
                            x2 += bounds.width / 2;
                            break;
                          case 2:
                            x2 += bounds.width;
                            break;
                        }
                        textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                        this.ctx.save();
                        this.path([new Vector(bounds.left, bounds.top), new Vector(bounds.left + bounds.width, bounds.top), new Vector(bounds.left + bounds.width, bounds.top + bounds.height), new Vector(bounds.left, bounds.top + bounds.height)]);
                        this.ctx.clip();
                        this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                        this.ctx.restore();
                        this.ctx.textBaseline = "alphabetic";
                        this.ctx.textAlign = "left";
                      }
                      if (!contains(
                        container.styles.display,
                        2048
                        /* LIST_ITEM */
                      )) return [3, 20];
                      if (!(container.styles.listStyleImage !== null)) return [3, 19];
                      img = container.styles.listStyleImage;
                      if (!(img.type === 0)) return [3, 18];
                      image2 = void 0;
                      url = img.url;
                      _c.label = 15;
                    case 15:
                      _c.trys.push([15, 17, , 18]);
                      return [4, this.context.cache.match(url)];
                    case 16:
                      image2 = _c.sent();
                      this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                      return [3, 18];
                    case 17:
                      _c.sent();
                      this.context.logger.error("Error loading list-style-image " + url);
                      return [3, 18];
                    case 18:
                      return [3, 20];
                    case 19:
                      if (paint.listValue && container.styles.listStyleType !== -1) {
                        fontFamily2 = this.createFontStyle(styles)[0];
                        this.ctx.font = fontFamily2;
                        this.ctx.fillStyle = asString(styles.color);
                        this.ctx.textBaseline = "middle";
                        this.ctx.textAlign = "right";
                        bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                        this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                        this.ctx.textBaseline = "bottom";
                        this.ctx.textAlign = "left";
                      }
                      _c.label = 20;
                    case 20:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            CanvasRenderer2.prototype.renderStackContent = function(stack) {
              return __awaiter(this, void 0, void 0, function() {
                var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
                return __generator(this, function(_p) {
                  switch (_p.label) {
                    case 0:
                      if (contains(
                        stack.element.container.flags,
                        16
                        /* DEBUG_RENDER */
                      )) {
                        debugger;
                      }
                      return [4, this.renderNodeBackgroundAndBorders(stack.element)];
                    case 1:
                      _p.sent();
                      _i = 0, _a2 = stack.negativeZIndex;
                      _p.label = 2;
                    case 2:
                      if (!(_i < _a2.length)) return [3, 5];
                      child = _a2[_i];
                      return [4, this.renderStack(child)];
                    case 3:
                      _p.sent();
                      _p.label = 4;
                    case 4:
                      _i++;
                      return [3, 2];
                    case 5:
                      return [4, this.renderNodeContent(stack.element)];
                    case 6:
                      _p.sent();
                      _b2 = 0, _c = stack.nonInlineLevel;
                      _p.label = 7;
                    case 7:
                      if (!(_b2 < _c.length)) return [3, 10];
                      child = _c[_b2];
                      return [4, this.renderNode(child)];
                    case 8:
                      _p.sent();
                      _p.label = 9;
                    case 9:
                      _b2++;
                      return [3, 7];
                    case 10:
                      _d = 0, _e = stack.nonPositionedFloats;
                      _p.label = 11;
                    case 11:
                      if (!(_d < _e.length)) return [3, 14];
                      child = _e[_d];
                      return [4, this.renderStack(child)];
                    case 12:
                      _p.sent();
                      _p.label = 13;
                    case 13:
                      _d++;
                      return [3, 11];
                    case 14:
                      _f = 0, _g = stack.nonPositionedInlineLevel;
                      _p.label = 15;
                    case 15:
                      if (!(_f < _g.length)) return [3, 18];
                      child = _g[_f];
                      return [4, this.renderStack(child)];
                    case 16:
                      _p.sent();
                      _p.label = 17;
                    case 17:
                      _f++;
                      return [3, 15];
                    case 18:
                      _h = 0, _j = stack.inlineLevel;
                      _p.label = 19;
                    case 19:
                      if (!(_h < _j.length)) return [3, 22];
                      child = _j[_h];
                      return [4, this.renderNode(child)];
                    case 20:
                      _p.sent();
                      _p.label = 21;
                    case 21:
                      _h++;
                      return [3, 19];
                    case 22:
                      _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                      _p.label = 23;
                    case 23:
                      if (!(_k < _l.length)) return [3, 26];
                      child = _l[_k];
                      return [4, this.renderStack(child)];
                    case 24:
                      _p.sent();
                      _p.label = 25;
                    case 25:
                      _k++;
                      return [3, 23];
                    case 26:
                      _m = 0, _o = stack.positiveZIndex;
                      _p.label = 27;
                    case 27:
                      if (!(_m < _o.length)) return [3, 30];
                      child = _o[_m];
                      return [4, this.renderStack(child)];
                    case 28:
                      _p.sent();
                      _p.label = 29;
                    case 29:
                      _m++;
                      return [3, 27];
                    case 30:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            CanvasRenderer2.prototype.mask = function(paths) {
              this.ctx.beginPath();
              this.ctx.moveTo(0, 0);
              this.ctx.lineTo(this.canvas.width, 0);
              this.ctx.lineTo(this.canvas.width, this.canvas.height);
              this.ctx.lineTo(0, this.canvas.height);
              this.ctx.lineTo(0, 0);
              this.formatPath(paths.slice(0).reverse());
              this.ctx.closePath();
            };
            CanvasRenderer2.prototype.path = function(paths) {
              this.ctx.beginPath();
              this.formatPath(paths);
              this.ctx.closePath();
            };
            CanvasRenderer2.prototype.formatPath = function(paths) {
              var _this = this;
              paths.forEach(function(point, index2) {
                var start = isBezierCurve(point) ? point.start : point;
                if (index2 === 0) {
                  _this.ctx.moveTo(start.x, start.y);
                } else {
                  _this.ctx.lineTo(start.x, start.y);
                }
                if (isBezierCurve(point)) {
                  _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
                }
              });
            };
            CanvasRenderer2.prototype.renderRepeat = function(path2, pattern, offsetX, offsetY) {
              this.path(path2);
              this.ctx.fillStyle = pattern;
              this.ctx.translate(offsetX, offsetY);
              this.ctx.fill();
              this.ctx.translate(-offsetX, -offsetY);
            };
            CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
              var _a2;
              if (image2.width === width && image2.height === height) {
                return image2;
              }
              var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
              var canvas = ownerDocument.createElement("canvas");
              canvas.width = Math.max(1, width);
              canvas.height = Math.max(1, height);
              var ctx = canvas.getContext("2d");
              ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
              return canvas;
            };
            CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
              return __awaiter(this, void 0, void 0, function() {
                var index2, _loop_1, this_1, _i, _a2, backgroundImage2;
                return __generator(this, function(_b2) {
                  switch (_b2.label) {
                    case 0:
                      index2 = container.styles.backgroundImage.length - 1;
                      _loop_1 = function(backgroundImage3) {
                        var image2, url, _c, path2, x2, y2, width, height, pattern, _d, path2, x2, y2, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path2, left, top_1, width, height, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f3, invF;
                        return __generator(this, function(_h) {
                          switch (_h.label) {
                            case 0:
                              if (!(backgroundImage3.type === 0)) return [3, 5];
                              image2 = void 0;
                              url = backgroundImage3.url;
                              _h.label = 1;
                            case 1:
                              _h.trys.push([1, 3, , 4]);
                              return [4, this_1.context.cache.match(url)];
                            case 2:
                              image2 = _h.sent();
                              return [3, 4];
                            case 3:
                              _h.sent();
                              this_1.context.logger.error("Error loading background-image " + url);
                              return [3, 4];
                            case 4:
                              if (image2) {
                                _c = calculateBackgroundRendering(container, index2, [image2.width, image2.height, image2.width / image2.height]), path2 = _c[0], x2 = _c[1], y2 = _c[2], width = _c[3], height = _c[4];
                                pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                                this_1.renderRepeat(path2, pattern, x2, y2);
                              }
                              return [3, 6];
                            case 5:
                              if (isLinearGradient(backgroundImage3)) {
                                _d = calculateBackgroundRendering(container, index2, [null, null, null]), path2 = _d[0], x2 = _d[1], y2 = _d[2], width = _d[3], height = _d[4];
                                _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                                canvas = document.createElement("canvas");
                                canvas.width = width;
                                canvas.height = height;
                                ctx = canvas.getContext("2d");
                                gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                                processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                                  return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                });
                                ctx.fillStyle = gradient_1;
                                ctx.fillRect(0, 0, width, height);
                                if (width > 0 && height > 0) {
                                  pattern = this_1.ctx.createPattern(canvas, "repeat");
                                  this_1.renderRepeat(path2, pattern, x2, y2);
                                }
                              } else if (isRadialGradient(backgroundImage3)) {
                                _f = calculateBackgroundRendering(container, index2, [null, null, null]), path2 = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                                position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                                x2 = getAbsoluteValue(position2[0], width);
                                y2 = getAbsoluteValue(position2[position2.length - 1], height);
                                _g = calculateRadius(backgroundImage3, x2, y2, width, height), rx = _g[0], ry = _g[1];
                                if (rx > 0 && ry > 0) {
                                  radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y2, 0, left + x2, top_1 + y2, rx);
                                  processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                                    return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                  });
                                  this_1.path(path2);
                                  this_1.ctx.fillStyle = radialGradient_1;
                                  if (rx !== ry) {
                                    midX = container.bounds.left + 0.5 * container.bounds.width;
                                    midY = container.bounds.top + 0.5 * container.bounds.height;
                                    f3 = ry / rx;
                                    invF = 1 / f3;
                                    this_1.ctx.save();
                                    this_1.ctx.translate(midX, midY);
                                    this_1.ctx.transform(1, 0, 0, f3, 0, 0);
                                    this_1.ctx.translate(-midX, -midY);
                                    this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                    this_1.ctx.restore();
                                  } else {
                                    this_1.ctx.fill();
                                  }
                                }
                              }
                              _h.label = 6;
                            case 6:
                              index2--;
                              return [
                                2
                                /*return*/
                              ];
                          }
                        });
                      };
                      this_1 = this;
                      _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                      _b2.label = 1;
                    case 1:
                      if (!(_i < _a2.length)) return [3, 4];
                      backgroundImage2 = _a2[_i];
                      return [5, _loop_1(backgroundImage2)];
                    case 2:
                      _b2.sent();
                      _b2.label = 3;
                    case 3:
                      _i++;
                      return [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
              return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a2) {
                  this.path(parsePathForBorder(curvePoints, side));
                  this.ctx.fillStyle = asString(color2);
                  this.ctx.fill();
                  return [
                    2
                    /*return*/
                  ];
                });
              });
            };
            CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
              return __awaiter(this, void 0, void 0, function() {
                var outerPaths, innerPaths;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (!(width < 3)) return [3, 2];
                      return [4, this.renderSolidBorder(color2, side, curvePoints)];
                    case 1:
                      _a2.sent();
                      return [
                        2
                        /*return*/
                      ];
                    case 2:
                      outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                      this.path(outerPaths);
                      this.ctx.fillStyle = asString(color2);
                      this.ctx.fill();
                      innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                      this.path(innerPaths);
                      this.ctx.fill();
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
              return __awaiter(this, void 0, void 0, function() {
                var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
                var _this = this;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      this.applyEffects(paint.getEffects(
                        2
                        /* BACKGROUND_BORDERS */
                      ));
                      styles = paint.container.styles;
                      hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                      borders = [{
                        style: styles.borderTopStyle,
                        color: styles.borderTopColor,
                        width: styles.borderTopWidth
                      }, {
                        style: styles.borderRightStyle,
                        color: styles.borderRightColor,
                        width: styles.borderRightWidth
                      }, {
                        style: styles.borderBottomStyle,
                        color: styles.borderBottomColor,
                        width: styles.borderBottomWidth
                      }, {
                        style: styles.borderLeftStyle,
                        color: styles.borderLeftColor,
                        width: styles.borderLeftWidth
                      }];
                      backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                      if (!(hasBackground || styles.boxShadow.length)) return [3, 2];
                      this.ctx.save();
                      this.path(backgroundPaintingArea);
                      this.ctx.clip();
                      if (!isTransparent(styles.backgroundColor)) {
                        this.ctx.fillStyle = asString(styles.backgroundColor);
                        this.ctx.fill();
                      }
                      return [4, this.renderBackgroundImage(paint.container)];
                    case 1:
                      _a2.sent();
                      this.ctx.restore();
                      styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                        _this.ctx.save();
                        var borderBoxArea = calculateBorderBoxPath(paint.curves);
                        var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                        var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                        if (shadow.inset) {
                          _this.path(borderBoxArea);
                          _this.ctx.clip();
                          _this.mask(shadowPaintingArea);
                        } else {
                          _this.mask(borderBoxArea);
                          _this.ctx.clip();
                          _this.path(shadowPaintingArea);
                        }
                        _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                        _this.ctx.shadowOffsetY = shadow.offsetY.number;
                        _this.ctx.shadowColor = asString(shadow.color);
                        _this.ctx.shadowBlur = shadow.blur.number;
                        _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                        _this.ctx.fill();
                        _this.ctx.restore();
                      });
                      _a2.label = 2;
                    case 2:
                      side = 0;
                      _i = 0, borders_1 = borders;
                      _a2.label = 3;
                    case 3:
                      if (!(_i < borders_1.length)) return [3, 13];
                      border = borders_1[_i];
                      if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0)) return [3, 11];
                      if (!(border.style === 2)) return [3, 5];
                      return [4, this.renderDashedDottedBorder(
                        border.color,
                        border.width,
                        side,
                        paint.curves,
                        2
                        /* DASHED */
                      )];
                    case 4:
                      _a2.sent();
                      return [3, 11];
                    case 5:
                      if (!(border.style === 3)) return [3, 7];
                      return [4, this.renderDashedDottedBorder(
                        border.color,
                        border.width,
                        side,
                        paint.curves,
                        3
                        /* DOTTED */
                      )];
                    case 6:
                      _a2.sent();
                      return [3, 11];
                    case 7:
                      if (!(border.style === 4)) return [3, 9];
                      return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                    case 8:
                      _a2.sent();
                      return [3, 11];
                    case 9:
                      return [4, this.renderSolidBorder(border.color, side, paint.curves)];
                    case 10:
                      _a2.sent();
                      _a2.label = 11;
                    case 11:
                      side++;
                      _a2.label = 12;
                    case 12:
                      _i++;
                      return [3, 3];
                    case 13:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
              return __awaiter(this, void 0, void 0, function() {
                var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
                return __generator(this, function(_a2) {
                  this.ctx.save();
                  strokePaths = parsePathForBorderStroke(curvePoints, side);
                  boxPaths = parsePathForBorder(curvePoints, side);
                  if (style === 2) {
                    this.path(boxPaths);
                    this.ctx.clip();
                  }
                  if (isBezierCurve(boxPaths[0])) {
                    startX = boxPaths[0].start.x;
                    startY = boxPaths[0].start.y;
                  } else {
                    startX = boxPaths[0].x;
                    startY = boxPaths[0].y;
                  }
                  if (isBezierCurve(boxPaths[1])) {
                    endX = boxPaths[1].end.x;
                    endY = boxPaths[1].end.y;
                  } else {
                    endX = boxPaths[1].x;
                    endY = boxPaths[1].y;
                  }
                  if (side === 0 || side === 2) {
                    length = Math.abs(startX - endX);
                  } else {
                    length = Math.abs(startY - endY);
                  }
                  this.ctx.beginPath();
                  if (style === 3) {
                    this.formatPath(strokePaths);
                  } else {
                    this.formatPath(boxPaths.slice(0, 2));
                  }
                  dashLength = width < 3 ? width * 3 : width * 2;
                  spaceLength = width < 3 ? width * 2 : width;
                  if (style === 3) {
                    dashLength = width;
                    spaceLength = width;
                  }
                  useLineDash = true;
                  if (length <= dashLength * 2) {
                    useLineDash = false;
                  } else if (length <= dashLength * 2 + spaceLength) {
                    multiplier = length / (2 * dashLength + spaceLength);
                    dashLength *= multiplier;
                    spaceLength *= multiplier;
                  } else {
                    numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
                    minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
                    maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                    spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
                  }
                  if (useLineDash) {
                    if (style === 3) {
                      this.ctx.setLineDash([0, dashLength + spaceLength]);
                    } else {
                      this.ctx.setLineDash([dashLength, spaceLength]);
                    }
                  }
                  if (style === 3) {
                    this.ctx.lineCap = "round";
                    this.ctx.lineWidth = width;
                  } else {
                    this.ctx.lineWidth = width * 2 + 1.1;
                  }
                  this.ctx.strokeStyle = asString(color2);
                  this.ctx.stroke();
                  this.ctx.setLineDash([]);
                  if (style === 2) {
                    if (isBezierCurve(boxPaths[0])) {
                      path1 = boxPaths[3];
                      path2 = boxPaths[0];
                      this.ctx.beginPath();
                      this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                      this.ctx.stroke();
                    }
                    if (isBezierCurve(boxPaths[1])) {
                      path1 = boxPaths[1];
                      path2 = boxPaths[2];
                      this.ctx.beginPath();
                      this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                      this.ctx.stroke();
                    }
                  }
                  this.ctx.restore();
                  return [
                    2
                    /*return*/
                  ];
                });
              });
            };
            CanvasRenderer2.prototype.render = function(element) {
              return __awaiter(this, void 0, void 0, function() {
                var stack;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (this.options.backgroundColor) {
                        this.ctx.fillStyle = asString(this.options.backgroundColor);
                        this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                      }
                      stack = parseStackingContexts(element);
                      return [4, this.renderStack(stack)];
                    case 1:
                      _a2.sent();
                      this.applyEffects([]);
                      return [2, this.canvas];
                  }
                });
              });
            };
            return CanvasRenderer2;
          })(Renderer)
        );
        var isTextInputElement = function(container) {
          if (container instanceof TextareaElementContainer) {
            return true;
          } else if (container instanceof SelectElementContainer) {
            return true;
          } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
            return true;
          }
          return false;
        };
        var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
          switch (clip) {
            case 0:
              return calculateBorderBoxPath(curves);
            case 2:
              return calculateContentBoxPath(curves);
            case 1:
            default:
              return calculatePaddingBoxPath(curves);
          }
        };
        var canvasTextAlign = function(textAlign2) {
          switch (textAlign2) {
            case 1:
              return "center";
            case 2:
              return "right";
            case 0:
            default:
              return "left";
          }
        };
        var iOSBrokenFonts = ["-apple-system", "system-ui"];
        var fixIOSSystemFonts = function(fontFamilies) {
          return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
            return iOSBrokenFonts.indexOf(fontFamily2) === -1;
          }) : fontFamilies;
        };
        var ForeignObjectRenderer = (
          /** @class */
          (function(_super) {
            __extends(ForeignObjectRenderer2, _super);
            function ForeignObjectRenderer2(context, options) {
              var _this = _super.call(this, context, options) || this;
              _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
              _this.ctx = _this.canvas.getContext("2d");
              _this.options = options;
              _this.canvas.width = Math.floor(options.width * options.scale);
              _this.canvas.height = Math.floor(options.height * options.scale);
              _this.canvas.style.width = options.width + "px";
              _this.canvas.style.height = options.height + "px";
              _this.ctx.scale(_this.options.scale, _this.options.scale);
              _this.ctx.translate(-options.x, -options.y);
              _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
              return _this;
            }
            ForeignObjectRenderer2.prototype.render = function(element) {
              return __awaiter(this, void 0, void 0, function() {
                var svg2, img;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      svg2 = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                      return [4, loadSerializedSVG(svg2)];
                    case 1:
                      img = _a2.sent();
                      if (this.options.backgroundColor) {
                        this.ctx.fillStyle = asString(this.options.backgroundColor);
                        this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                      }
                      this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                      return [2, this.canvas];
                  }
                });
              });
            };
            return ForeignObjectRenderer2;
          })(Renderer)
        );
        var loadSerializedSVG = function(svg2) {
          return new Promise(function(resolve, reject) {
            var img = new Image();
            img.onload = function() {
              resolve(img);
            };
            img.onerror = reject;
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
          });
        };
        var Logger = (
          /** @class */
          (function() {
            function Logger2(_a2) {
              var id = _a2.id, enabled = _a2.enabled;
              this.id = id;
              this.enabled = enabled;
              this.start = Date.now();
            }
            Logger2.prototype.debug = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              if (this.enabled) {
                if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
                  console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
                } else {
                  this.info.apply(this, args);
                }
              }
            };
            Logger2.prototype.getTime = function() {
              return Date.now() - this.start;
            };
            Logger2.prototype.info = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              if (this.enabled) {
                if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
                  console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
                }
              }
            };
            Logger2.prototype.warn = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              if (this.enabled) {
                if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
                  console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
                } else {
                  this.info.apply(this, args);
                }
              }
            };
            Logger2.prototype.error = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              if (this.enabled) {
                if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
                  console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
                } else {
                  this.info.apply(this, args);
                }
              }
            };
            Logger2.instances = {};
            return Logger2;
          })()
        );
        var Context = (
          /** @class */
          (function() {
            function Context2(options, windowBounds) {
              var _a2;
              this.windowBounds = windowBounds;
              this.instanceName = "#" + Context2.instanceCount++;
              this.logger = new Logger({
                id: this.instanceName,
                enabled: options.logging
              });
              this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
            }
            Context2.instanceCount = 1;
            return Context2;
          })()
        );
        var html2canvas2 = function(element, options) {
          if (options === void 0) {
            options = {};
          }
          return renderElement(element, options);
        };
        if (typeof window !== "undefined") {
          CacheStorage.setContext(window);
        }
        var renderElement = function(element, opts) {
          return __awaiter(void 0, void 0, void 0, function() {
            var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
            var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
            return __generator(this, function(_u) {
              switch (_u.label) {
                case 0:
                  if (!element || typeof element !== "object") {
                    return [2, Promise.reject("Invalid element provided as first argument")];
                  }
                  ownerDocument = element.ownerDocument;
                  if (!ownerDocument) {
                    throw new Error("Element is not attached to a Document");
                  }
                  defaultView = ownerDocument.defaultView;
                  if (!defaultView) {
                    throw new Error("Document is not attached to a Window");
                  }
                  resourceOptions = {
                    allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
                    imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
                    proxy: opts.proxy,
                    useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
                  };
                  contextOptions = __assign({
                    logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true,
                    cache: opts.cache
                  }, resourceOptions);
                  windowOptions = {
                    windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                    windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                    scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                    scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                  };
                  windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                  context = new Context(contextOptions, windowBounds);
                  foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                  cloneOptions = {
                    allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                    onclone: opts.onclone,
                    ignoreElements: opts.ignoreElements,
                    inlineImages: foreignObjectRendering,
                    copyStyles: foreignObjectRendering
                  };
                  context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                  documentCloner = new DocumentCloner(context, element, cloneOptions);
                  clonedElement = documentCloner.clonedReferenceElement;
                  if (!clonedElement) {
                    return [2, Promise.reject("Unable to find element in cloned iframe")];
                  }
                  return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
                case 1:
                  container = _u.sent();
                  _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
                  backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
                  renderOptions = {
                    canvas: opts.canvas,
                    backgroundColor: backgroundColor2,
                    scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                    x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                    y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                    width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                    height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
                  };
                  if (!foreignObjectRendering) return [3, 3];
                  context.logger.debug("Document cloned, using foreign object rendering");
                  renderer = new ForeignObjectRenderer(context, renderOptions);
                  return [4, renderer.render(clonedElement)];
                case 2:
                  canvas = _u.sent();
                  return [3, 5];
                case 3:
                  context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
                  context.logger.debug("Starting DOM parsing");
                  root = parseTree(context, clonedElement);
                  if (backgroundColor2 === root.styles.backgroundColor) {
                    root.styles.backgroundColor = COLORS.TRANSPARENT;
                  }
                  context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                  renderer = new CanvasRenderer(context, renderOptions);
                  return [4, renderer.render(root)];
                case 4:
                  canvas = _u.sent();
                  _u.label = 5;
                case 5:
                  if ((_t2 = opts.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {
                    if (!DocumentCloner.destroy(container)) {
                      context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                    }
                  }
                  context.logger.debug("Finished rendering");
                  return [2, canvas];
              }
            });
          });
        };
        var parseBackgroundColor = function(context, element, backgroundColorOverride) {
          var ownerDocument = element.ownerDocument;
          var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
          var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
          var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
          return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
        };
        return html2canvas2;
      });
    })(html2canvas$3);
    return html2canvas$3.exports;
  }
  var html2canvasExports = requireHtml2canvas();
  var html2canvas = /* @__PURE__ */ getDefaultExportFromCjs(html2canvasExports);
  var html2canvas$1 = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: html2canvas
  }, [html2canvasExports]);
  var {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  var {
    freeze,
    seal,
    create
  } = Object;
  var {
    apply,
    construct
  } = typeof Reflect !== "undefined" && Reflect;
  if (!freeze) {
    freeze = function freeze2(x2) {
      return x2;
    };
  }
  if (!seal) {
    seal = function seal2(x2) {
      return x2;
    };
  }
  if (!apply) {
    apply = function apply2(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!construct) {
    construct = function construct2(Func, args) {
      return new Func(...args);
    };
  }
  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var arraySplice = unapply(Array.prototype.splice);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringToString = unapply(String.prototype.toString);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim$1 = unapply(String.prototype.trim);
  var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set, null);
    }
    let l2 = array.length;
    while (l2--) {
      let element = array[l2];
      if (typeof element === "string") {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array)) {
            array[l2] = lcElement;
          }
          element = lcElement;
        }
      }
      set[element] = true;
    }
    return set;
  }
  function cleanArray(array) {
    for (let index2 = 0; index2 < array.length; index2++) {
      const isPropertyExist = objectHasOwnProperty(array, index2);
      if (!isPropertyExist) {
        array[index2] = null;
      }
    }
    return array;
  }
  function clone(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object)) {
      const isPropertyExist = objectHasOwnProperty(object, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (value && typeof value === "object" && value.constructor === Object) {
          newObject[property] = clone(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }
  var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  var text = freeze(["#text"]);
  var html$2 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  var IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);
  var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT,
    DATA_ATTR,
    DOCTYPE_NAME,
    ERB_EXPR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR,
    TMPLIT_EXPR
  });
  var NODE_TYPE = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
  };
  var getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html2) {
          return html2;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_2) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  var _createHooksMap = function _createHooksMap2() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify = (root) => createDOMPurify(root);
    DOMPurify.version = "3.2.4";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let {
      document: document2
    } = window2;
    const originalDocument = document2;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node: Node2,
      Element: Element2,
      NodeFilter,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser: DOMParser2,
      trustedTypes
    } = window2;
    const ElementPrototype = Element2.prototype;
    const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    const remove = lookupGetter(ElementPrototype, "remove");
    const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      const template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2;
    const {
      importNode
    } = originalDocument;
    let hooks = _createHooksMap();
    DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html$2, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    let FORBID_TAGS = null;
    let FORBID_ATTR = null;
    let ALLOW_ARIA_ATTR = true;
    let ALLOW_DATA_ATTR = true;
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    let SAFE_FOR_TEMPLATES = false;
    let SAFE_FOR_XML = true;
    let WHOLE_DOCUMENT = false;
    let SET_CONFIG = false;
    let FORCE_BODY = false;
    let RETURN_DOM = false;
    let RETURN_DOM_FRAGMENT = false;
    let RETURN_TRUSTED_TYPE = false;
    let SANITIZE_DOM = true;
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = true;
    let IN_PLACE = false;
    let USE_PROFILES = {};
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    let CONFIG = null;
    const formElement = document2.createElement("form");
    const isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    const _parseConfig = function _parseConfig2() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html$2);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        if (trustedTypesPolicy === void 0) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    const _checkValidNamespace = function _checkValidNamespace2(element) {
      let parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: "template"
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      }
      return false;
    };
    const _forceRemove = function _forceRemove2(node2) {
      arrayPush(DOMPurify.removed, {
        element: node2
      });
      try {
        getParentNode(node2).removeChild(node2);
      } catch (_2) {
        remove(node2);
      }
    };
    const _removeAttribute = function _removeAttribute2(name, element) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element.getAttributeNode(name),
          from: element
        });
      } catch (_2) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element
        });
      }
      element.removeAttribute(name);
      if (name === "is") {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element);
          } catch (_2) {
          }
        } else {
          try {
            element.setAttribute(name, "");
          } catch (_2) {
          }
        }
      }
    };
    const _initDocument = function _initDocument2(dirty) {
      let doc = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        const matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_2) {
        }
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_2) {
        }
      }
      const body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    const _createNodeIterator = function _createNodeIterator2(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    };
    const _isClobbered = function _isClobbered2(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
    };
    const _isNode = function _isNode2(value) {
      return typeof Node2 === "function" && value instanceof Node2;
    };
    function _executeHooks(hooks2, currentNode, data) {
      arrayForEach(hooks2, (hook) => {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    }
    const _sanitizeElements = function _sanitizeElements2(currentNode) {
      let content = null;
      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      const tagName = transformCaseFunc(currentNode.nodeName);
      _executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i2 = childCount - 1; i2 >= 0; --i2) {
              const childClone = cloneNode(childNodes[i2], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        content = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          content = stringReplace(content, expr, " ");
        });
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHooks(hooks.afterSanitizeElements, currentNode, null);
      return false;
    };
    const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
        ) ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if (value) {
        return false;
      } else ;
      return true;
    };
    const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    };
    const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes || _isClobbered(currentNode)) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      };
      let l2 = attributes.length;
      while (l2--) {
        const attr = attributes[l2];
        const {
          name,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name);
        let value = name === "value" ? attrValue : stringTrim$1(attrValue);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        _removeAttribute(name, currentNode);
        if (!hookEvent.keepAttr) {
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            value = stringReplace(value, expr, " ");
          });
        }
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI) ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
              case "TrustedScriptURL": {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
            }
          }
        }
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            currentNode.setAttribute(name, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_2) {
        }
      }
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
        _sanitizeElements(shadowNode);
        _sanitizeAttributes(shadowNode);
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
      }
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    DOMPurify.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node2) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        _sanitizeElements(currentNode);
        _sanitizeAttributes(currentNode);
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
      }
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint, hookFunction) {
      if (hookFunction !== void 0) {
        const index2 = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index2 === -1 ? void 0 : arraySplice(hooks[entryPoint], index2, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    };
    DOMPurify.removeHooks = function(entryPoint) {
      hooks[entryPoint] = [];
    };
    DOMPurify.removeAllHooks = function() {
      hooks = _createHooksMap();
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();
  var purify_es = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    default: purify
  });
  var es_promise = {};
  var es_promise_constructor = {};
  var globalThis_1;
  var hasRequiredGlobalThis;
  function requireGlobalThis() {
    if (hasRequiredGlobalThis) return globalThis_1;
    hasRequiredGlobalThis = 1;
    var check = function(it2) {
      return it2 && it2.Math === Math && it2;
    };
    globalThis_1 = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof globalThis_1 == "object" && globalThis_1) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ (function() {
      return this;
    })() || Function("return this")();
    return globalThis_1;
  }
  var objectGetOwnPropertyDescriptor = {};
  var fails;
  var hasRequiredFails;
  function requireFails() {
    if (hasRequiredFails) return fails;
    hasRequiredFails = 1;
    fails = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
    return fails;
  }
  var descriptors;
  var hasRequiredDescriptors;
  function requireDescriptors() {
    if (hasRequiredDescriptors) return descriptors;
    hasRequiredDescriptors = 1;
    var fails2 = requireFails();
    descriptors = !fails2(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
    return descriptors;
  }
  var functionBindNative;
  var hasRequiredFunctionBindNative;
  function requireFunctionBindNative() {
    if (hasRequiredFunctionBindNative) return functionBindNative;
    hasRequiredFunctionBindNative = 1;
    var fails2 = requireFails();
    functionBindNative = !fails2(function() {
      var test = (function() {
      }).bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
    return functionBindNative;
  }
  var functionCall;
  var hasRequiredFunctionCall;
  function requireFunctionCall() {
    if (hasRequiredFunctionCall) return functionCall;
    hasRequiredFunctionCall = 1;
    var NATIVE_BIND = requireFunctionBindNative();
    var call = Function.prototype.call;
    functionCall = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
    return functionCall;
  }
  var objectPropertyIsEnumerable = {};
  var hasRequiredObjectPropertyIsEnumerable;
  function requireObjectPropertyIsEnumerable() {
    if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
    hasRequiredObjectPropertyIsEnumerable = 1;
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
      var descriptor = getOwnPropertyDescriptor2(this, V2);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
    return objectPropertyIsEnumerable;
  }
  var createPropertyDescriptor;
  var hasRequiredCreatePropertyDescriptor;
  function requireCreatePropertyDescriptor() {
    if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
    hasRequiredCreatePropertyDescriptor = 1;
    createPropertyDescriptor = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
    return createPropertyDescriptor;
  }
  var functionUncurryThis;
  var hasRequiredFunctionUncurryThis;
  function requireFunctionUncurryThis() {
    if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
    hasRequiredFunctionUncurryThis = 1;
    var NATIVE_BIND = requireFunctionBindNative();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
    return functionUncurryThis;
  }
  var classofRaw;
  var hasRequiredClassofRaw;
  function requireClassofRaw() {
    if (hasRequiredClassofRaw) return classofRaw;
    hasRequiredClassofRaw = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var toString2 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    classofRaw = function(it2) {
      return stringSlice(toString2(it2), 8, -1);
    };
    return classofRaw;
  }
  var indexedObject;
  var hasRequiredIndexedObject;
  function requireIndexedObject() {
    if (hasRequiredIndexedObject) return indexedObject;
    hasRequiredIndexedObject = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var fails2 = requireFails();
    var classof2 = requireClassofRaw();
    var $Object = Object;
    var split = uncurryThis("".split);
    indexedObject = fails2(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it2) {
      return classof2(it2) === "String" ? split(it2, "") : $Object(it2);
    } : $Object;
    return indexedObject;
  }
  var isNullOrUndefined;
  var hasRequiredIsNullOrUndefined;
  function requireIsNullOrUndefined() {
    if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
    hasRequiredIsNullOrUndefined = 1;
    isNullOrUndefined = function(it2) {
      return it2 === null || it2 === void 0;
    };
    return isNullOrUndefined;
  }
  var requireObjectCoercible;
  var hasRequiredRequireObjectCoercible;
  function requireRequireObjectCoercible() {
    if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
    hasRequiredRequireObjectCoercible = 1;
    var isNullOrUndefined2 = requireIsNullOrUndefined();
    var $TypeError = TypeError;
    requireObjectCoercible = function(it2) {
      if (isNullOrUndefined2(it2)) throw new $TypeError("Can't call method on " + it2);
      return it2;
    };
    return requireObjectCoercible;
  }
  var toIndexedObject;
  var hasRequiredToIndexedObject;
  function requireToIndexedObject() {
    if (hasRequiredToIndexedObject) return toIndexedObject;
    hasRequiredToIndexedObject = 1;
    var IndexedObject = requireIndexedObject();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    toIndexedObject = function(it2) {
      return IndexedObject(requireObjectCoercible2(it2));
    };
    return toIndexedObject;
  }
  var isCallable;
  var hasRequiredIsCallable;
  function requireIsCallable() {
    if (hasRequiredIsCallable) return isCallable;
    hasRequiredIsCallable = 1;
    var documentAll = typeof document == "object" && document.all;
    isCallable = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
    return isCallable;
  }
  var isObject;
  var hasRequiredIsObject;
  function requireIsObject() {
    if (hasRequiredIsObject) return isObject;
    hasRequiredIsObject = 1;
    var isCallable2 = requireIsCallable();
    isObject = function(it2) {
      return typeof it2 == "object" ? it2 !== null : isCallable2(it2);
    };
    return isObject;
  }
  var getBuiltIn;
  var hasRequiredGetBuiltIn;
  function requireGetBuiltIn() {
    if (hasRequiredGetBuiltIn) return getBuiltIn;
    hasRequiredGetBuiltIn = 1;
    var globalThis2 = requireGlobalThis();
    var isCallable2 = requireIsCallable();
    var aFunction = function(argument) {
      return isCallable2(argument) ? argument : void 0;
    };
    getBuiltIn = function(namespace, method) {
      return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
    };
    return getBuiltIn;
  }
  var objectIsPrototypeOf;
  var hasRequiredObjectIsPrototypeOf;
  function requireObjectIsPrototypeOf() {
    if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
    hasRequiredObjectIsPrototypeOf = 1;
    var uncurryThis = requireFunctionUncurryThis();
    objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
    return objectIsPrototypeOf;
  }
  var environmentUserAgent;
  var hasRequiredEnvironmentUserAgent;
  function requireEnvironmentUserAgent() {
    if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
    hasRequiredEnvironmentUserAgent = 1;
    var globalThis2 = requireGlobalThis();
    var navigator2 = globalThis2.navigator;
    var userAgent2 = navigator2 && navigator2.userAgent;
    environmentUserAgent = userAgent2 ? String(userAgent2) : "";
    return environmentUserAgent;
  }
  var environmentV8Version;
  var hasRequiredEnvironmentV8Version;
  function requireEnvironmentV8Version() {
    if (hasRequiredEnvironmentV8Version) return environmentV8Version;
    hasRequiredEnvironmentV8Version = 1;
    var globalThis2 = requireGlobalThis();
    var userAgent2 = requireEnvironmentUserAgent();
    var process2 = globalThis2.process;
    var Deno2 = globalThis2.Deno;
    var versions = process2 && process2.versions || Deno2 && Deno2.version;
    var v8 = versions && versions.v8;
    var match, version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent2) {
      match = userAgent2.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent2.match(/Chrome\/(\d+)/);
        if (match) version = +match[1];
      }
    }
    environmentV8Version = version;
    return environmentV8Version;
  }
  var symbolConstructorDetection;
  var hasRequiredSymbolConstructorDetection;
  function requireSymbolConstructorDetection() {
    if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
    hasRequiredSymbolConstructorDetection = 1;
    var V8_VERSION = requireEnvironmentV8Version();
    var fails2 = requireFails();
    var globalThis2 = requireGlobalThis();
    var $String = globalThis2.String;
    symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails2(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
    return symbolConstructorDetection;
  }
  var useSymbolAsUid;
  var hasRequiredUseSymbolAsUid;
  function requireUseSymbolAsUid() {
    if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
    hasRequiredUseSymbolAsUid = 1;
    var NATIVE_SYMBOL = requireSymbolConstructorDetection();
    useSymbolAsUid = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    return useSymbolAsUid;
  }
  var isSymbol;
  var hasRequiredIsSymbol;
  function requireIsSymbol() {
    if (hasRequiredIsSymbol) return isSymbol;
    hasRequiredIsSymbol = 1;
    var getBuiltIn2 = requireGetBuiltIn();
    var isCallable2 = requireIsCallable();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
    var $Object = Object;
    isSymbol = USE_SYMBOL_AS_UID ? function(it2) {
      return typeof it2 == "symbol";
    } : function(it2) {
      var $Symbol = getBuiltIn2("Symbol");
      return isCallable2($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it2));
    };
    return isSymbol;
  }
  var tryToString;
  var hasRequiredTryToString;
  function requireTryToString() {
    if (hasRequiredTryToString) return tryToString;
    hasRequiredTryToString = 1;
    var $String = String;
    tryToString = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
    return tryToString;
  }
  var aCallable;
  var hasRequiredACallable;
  function requireACallable() {
    if (hasRequiredACallable) return aCallable;
    hasRequiredACallable = 1;
    var isCallable2 = requireIsCallable();
    var tryToString2 = requireTryToString();
    var $TypeError = TypeError;
    aCallable = function(argument) {
      if (isCallable2(argument)) return argument;
      throw new $TypeError(tryToString2(argument) + " is not a function");
    };
    return aCallable;
  }
  var getMethod;
  var hasRequiredGetMethod;
  function requireGetMethod() {
    if (hasRequiredGetMethod) return getMethod;
    hasRequiredGetMethod = 1;
    var aCallable2 = requireACallable();
    var isNullOrUndefined2 = requireIsNullOrUndefined();
    getMethod = function(V2, P2) {
      var func = V2[P2];
      return isNullOrUndefined2(func) ? void 0 : aCallable2(func);
    };
    return getMethod;
  }
  var ordinaryToPrimitive;
  var hasRequiredOrdinaryToPrimitive;
  function requireOrdinaryToPrimitive() {
    if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
    hasRequiredOrdinaryToPrimitive = 1;
    var call = requireFunctionCall();
    var isCallable2 = requireIsCallable();
    var isObject2 = requireIsObject();
    var $TypeError = TypeError;
    ordinaryToPrimitive = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable2(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
      if (isCallable2(fn = input.valueOf) && !isObject2(val = call(fn, input))) return val;
      if (pref !== "string" && isCallable2(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
    return ordinaryToPrimitive;
  }
  var sharedStore = { exports: {} };
  var isPure;
  var hasRequiredIsPure;
  function requireIsPure() {
    if (hasRequiredIsPure) return isPure;
    hasRequiredIsPure = 1;
    isPure = false;
    return isPure;
  }
  var defineGlobalProperty;
  var hasRequiredDefineGlobalProperty;
  function requireDefineGlobalProperty() {
    if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
    hasRequiredDefineGlobalProperty = 1;
    var globalThis2 = requireGlobalThis();
    var defineProperty = Object.defineProperty;
    defineGlobalProperty = function(key, value) {
      try {
        defineProperty(globalThis2, key, { value, configurable: true, writable: true });
      } catch (error) {
        globalThis2[key] = value;
      }
      return value;
    };
    return defineGlobalProperty;
  }
  var hasRequiredSharedStore;
  function requireSharedStore() {
    if (hasRequiredSharedStore) return sharedStore.exports;
    hasRequiredSharedStore = 1;
    var IS_PURE = requireIsPure();
    var globalThis2 = requireGlobalThis();
    var defineGlobalProperty2 = requireDefineGlobalProperty();
    var SHARED = "__core-js_shared__";
    var store = sharedStore.exports = globalThis2[SHARED] || defineGlobalProperty2(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.43.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2014-2025 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.43.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
    return sharedStore.exports;
  }
  var shared;
  var hasRequiredShared;
  function requireShared() {
    if (hasRequiredShared) return shared;
    hasRequiredShared = 1;
    var store = requireSharedStore();
    shared = function(key, value) {
      return store[key] || (store[key] = value || {});
    };
    return shared;
  }
  var toObject;
  var hasRequiredToObject;
  function requireToObject() {
    if (hasRequiredToObject) return toObject;
    hasRequiredToObject = 1;
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var $Object = Object;
    toObject = function(argument) {
      return $Object(requireObjectCoercible2(argument));
    };
    return toObject;
  }
  var hasOwnProperty_1;
  var hasRequiredHasOwnProperty;
  function requireHasOwnProperty() {
    if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
    hasRequiredHasOwnProperty = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var toObject2 = requireToObject();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    hasOwnProperty_1 = Object.hasOwn || function hasOwn(it2, key) {
      return hasOwnProperty(toObject2(it2), key);
    };
    return hasOwnProperty_1;
  }
  var uid;
  var hasRequiredUid;
  function requireUid() {
    if (hasRequiredUid) return uid;
    hasRequiredUid = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var id = 0;
    var postfix = Math.random();
    var toString2 = uncurryThis(1.1.toString);
    uid = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
    };
    return uid;
  }
  var wellKnownSymbol;
  var hasRequiredWellKnownSymbol;
  function requireWellKnownSymbol() {
    if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
    hasRequiredWellKnownSymbol = 1;
    var globalThis2 = requireGlobalThis();
    var shared2 = requireShared();
    var hasOwn = requireHasOwnProperty();
    var uid2 = requireUid();
    var NATIVE_SYMBOL = requireSymbolConstructorDetection();
    var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
    var Symbol2 = globalThis2.Symbol;
    var WellKnownSymbolsStore = shared2("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
    wellKnownSymbol = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
    return wellKnownSymbol;
  }
  var toPrimitive$1;
  var hasRequiredToPrimitive;
  function requireToPrimitive() {
    if (hasRequiredToPrimitive) return toPrimitive$1;
    hasRequiredToPrimitive = 1;
    var call = requireFunctionCall();
    var isObject2 = requireIsObject();
    var isSymbol2 = requireIsSymbol();
    var getMethod2 = requireGetMethod();
    var ordinaryToPrimitive2 = requireOrdinaryToPrimitive();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol2("toPrimitive");
    toPrimitive$1 = function(input, pref) {
      if (!isObject2(input) || isSymbol2(input)) return input;
      var exoticToPrim = getMethod2(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0) pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject2(result) || isSymbol2(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0) pref = "number";
      return ordinaryToPrimitive2(input, pref);
    };
    return toPrimitive$1;
  }
  var toPropertyKey$1;
  var hasRequiredToPropertyKey;
  function requireToPropertyKey() {
    if (hasRequiredToPropertyKey) return toPropertyKey$1;
    hasRequiredToPropertyKey = 1;
    var toPrimitive2 = requireToPrimitive();
    var isSymbol2 = requireIsSymbol();
    toPropertyKey$1 = function(argument) {
      var key = toPrimitive2(argument, "string");
      return isSymbol2(key) ? key : key + "";
    };
    return toPropertyKey$1;
  }
  var documentCreateElement;
  var hasRequiredDocumentCreateElement;
  function requireDocumentCreateElement() {
    if (hasRequiredDocumentCreateElement) return documentCreateElement;
    hasRequiredDocumentCreateElement = 1;
    var globalThis2 = requireGlobalThis();
    var isObject2 = requireIsObject();
    var document2 = globalThis2.document;
    var EXISTS = isObject2(document2) && isObject2(document2.createElement);
    documentCreateElement = function(it2) {
      return EXISTS ? document2.createElement(it2) : {};
    };
    return documentCreateElement;
  }
  var ie8DomDefine;
  var hasRequiredIe8DomDefine;
  function requireIe8DomDefine() {
    if (hasRequiredIe8DomDefine) return ie8DomDefine;
    hasRequiredIe8DomDefine = 1;
    var DESCRIPTORS = requireDescriptors();
    var fails2 = requireFails();
    var createElement = requireDocumentCreateElement();
    ie8DomDefine = !DESCRIPTORS && !fails2(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
    return ie8DomDefine;
  }
  var hasRequiredObjectGetOwnPropertyDescriptor;
  function requireObjectGetOwnPropertyDescriptor() {
    if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
    hasRequiredObjectGetOwnPropertyDescriptor = 1;
    var DESCRIPTORS = requireDescriptors();
    var call = requireFunctionCall();
    var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
    var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
    var toIndexedObject2 = requireToIndexedObject();
    var toPropertyKey2 = requireToPropertyKey();
    var hasOwn = requireHasOwnProperty();
    var IE8_DOM_DEFINE = requireIe8DomDefine();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O2, P2) {
      O2 = toIndexedObject2(O2);
      P2 = toPropertyKey2(P2);
      if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O2, P2);
      } catch (error) {
      }
      if (hasOwn(O2, P2)) return createPropertyDescriptor2(!call(propertyIsEnumerableModule.f, O2, P2), O2[P2]);
    };
    return objectGetOwnPropertyDescriptor;
  }
  var objectDefineProperty = {};
  var v8PrototypeDefineBug;
  var hasRequiredV8PrototypeDefineBug;
  function requireV8PrototypeDefineBug() {
    if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
    hasRequiredV8PrototypeDefineBug = 1;
    var DESCRIPTORS = requireDescriptors();
    var fails2 = requireFails();
    v8PrototypeDefineBug = DESCRIPTORS && fails2(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
    return v8PrototypeDefineBug;
  }
  var anObject;
  var hasRequiredAnObject;
  function requireAnObject() {
    if (hasRequiredAnObject) return anObject;
    hasRequiredAnObject = 1;
    var isObject2 = requireIsObject();
    var $String = String;
    var $TypeError = TypeError;
    anObject = function(argument) {
      if (isObject2(argument)) return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
    return anObject;
  }
  var hasRequiredObjectDefineProperty;
  function requireObjectDefineProperty() {
    if (hasRequiredObjectDefineProperty) return objectDefineProperty;
    hasRequiredObjectDefineProperty = 1;
    var DESCRIPTORS = requireDescriptors();
    var IE8_DOM_DEFINE = requireIe8DomDefine();
    var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
    var anObject2 = requireAnObject();
    var toPropertyKey2 = requireToPropertyKey();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O2, P2, Attributes) {
      anObject2(O2);
      P2 = toPropertyKey2(P2);
      anObject2(Attributes);
      if (typeof O2 === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O2, P2);
        if (current && current[WRITABLE]) {
          O2[P2] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O2, P2, Attributes);
    } : $defineProperty : function defineProperty(O2, P2, Attributes) {
      anObject2(O2);
      P2 = toPropertyKey2(P2);
      anObject2(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O2, P2, Attributes);
      } catch (error) {
      }
      if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
      if ("value" in Attributes) O2[P2] = Attributes.value;
      return O2;
    };
    return objectDefineProperty;
  }
  var createNonEnumerableProperty;
  var hasRequiredCreateNonEnumerableProperty;
  function requireCreateNonEnumerableProperty() {
    if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
    hasRequiredCreateNonEnumerableProperty = 1;
    var DESCRIPTORS = requireDescriptors();
    var definePropertyModule = requireObjectDefineProperty();
    var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
    createNonEnumerableProperty = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor2(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
    return createNonEnumerableProperty;
  }
  var makeBuiltIn = { exports: {} };
  var functionName;
  var hasRequiredFunctionName;
  function requireFunctionName() {
    if (hasRequiredFunctionName) return functionName;
    hasRequiredFunctionName = 1;
    var DESCRIPTORS = requireDescriptors();
    var hasOwn = requireHasOwnProperty();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && (function something() {
    }).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    functionName = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
    return functionName;
  }
  var inspectSource;
  var hasRequiredInspectSource;
  function requireInspectSource() {
    if (hasRequiredInspectSource) return inspectSource;
    hasRequiredInspectSource = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var isCallable2 = requireIsCallable();
    var store = requireSharedStore();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable2(store.inspectSource)) {
      store.inspectSource = function(it2) {
        return functionToString(it2);
      };
    }
    inspectSource = store.inspectSource;
    return inspectSource;
  }
  var weakMapBasicDetection;
  var hasRequiredWeakMapBasicDetection;
  function requireWeakMapBasicDetection() {
    if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
    hasRequiredWeakMapBasicDetection = 1;
    var globalThis2 = requireGlobalThis();
    var isCallable2 = requireIsCallable();
    var WeakMap2 = globalThis2.WeakMap;
    weakMapBasicDetection = isCallable2(WeakMap2) && /native code/.test(String(WeakMap2));
    return weakMapBasicDetection;
  }
  var sharedKey;
  var hasRequiredSharedKey;
  function requireSharedKey() {
    if (hasRequiredSharedKey) return sharedKey;
    hasRequiredSharedKey = 1;
    var shared2 = requireShared();
    var uid2 = requireUid();
    var keys = shared2("keys");
    sharedKey = function(key) {
      return keys[key] || (keys[key] = uid2(key));
    };
    return sharedKey;
  }
  var hiddenKeys;
  var hasRequiredHiddenKeys;
  function requireHiddenKeys() {
    if (hasRequiredHiddenKeys) return hiddenKeys;
    hasRequiredHiddenKeys = 1;
    hiddenKeys = {};
    return hiddenKeys;
  }
  var internalState;
  var hasRequiredInternalState;
  function requireInternalState() {
    if (hasRequiredInternalState) return internalState;
    hasRequiredInternalState = 1;
    var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
    var globalThis2 = requireGlobalThis();
    var isObject2 = requireIsObject();
    var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
    var hasOwn = requireHasOwnProperty();
    var shared2 = requireSharedStore();
    var sharedKey2 = requireSharedKey();
    var hiddenKeys2 = requireHiddenKeys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = globalThis2.TypeError;
    var WeakMap2 = globalThis2.WeakMap;
    var set, get, has;
    var enforce = function(it2) {
      return has(it2) ? get(it2) : set(it2, {});
    };
    var getterFor = function(TYPE) {
      return function(it2) {
        var state;
        if (!isObject2(it2) || (state = get(it2)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared2.state) {
      var store = shared2.state || (shared2.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it2, metadata) {
        if (store.has(it2)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it2;
        store.set(it2, metadata);
        return metadata;
      };
      get = function(it2) {
        return store.get(it2) || {};
      };
      has = function(it2) {
        return store.has(it2);
      };
    } else {
      var STATE = sharedKey2("state");
      hiddenKeys2[STATE] = true;
      set = function(it2, metadata) {
        if (hasOwn(it2, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it2;
        createNonEnumerableProperty2(it2, STATE, metadata);
        return metadata;
      };
      get = function(it2) {
        return hasOwn(it2, STATE) ? it2[STATE] : {};
      };
      has = function(it2) {
        return hasOwn(it2, STATE);
      };
    }
    internalState = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
    return internalState;
  }
  var hasRequiredMakeBuiltIn;
  function requireMakeBuiltIn() {
    if (hasRequiredMakeBuiltIn) return makeBuiltIn.exports;
    hasRequiredMakeBuiltIn = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var fails2 = requireFails();
    var isCallable2 = requireIsCallable();
    var hasOwn = requireHasOwnProperty();
    var DESCRIPTORS = requireDescriptors();
    var CONFIGURABLE_FUNCTION_NAME = requireFunctionName().CONFIGURABLE;
    var inspectSource2 = requireInspectSource();
    var InternalStateModule = requireInternalState();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis("".slice);
    var replace = uncurryThis("".replace);
    var join = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails2(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn$1 = makeBuiltIn.exports = function(value, name, options) {
      if (stringSlice($String(name), 0, 7) === "Symbol(") {
        name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
      }
      if (options && options.getter) name = "get " + name;
      if (options && options.setter) name = "set " + name;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
        else value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
          if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype) value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn$1(function toString2() {
      return isCallable2(this) && getInternalState(this).source || inspectSource2(this);
    }, "toString");
    return makeBuiltIn.exports;
  }
  var defineBuiltIn;
  var hasRequiredDefineBuiltIn;
  function requireDefineBuiltIn() {
    if (hasRequiredDefineBuiltIn) return defineBuiltIn;
    hasRequiredDefineBuiltIn = 1;
    var isCallable2 = requireIsCallable();
    var definePropertyModule = requireObjectDefineProperty();
    var makeBuiltIn2 = requireMakeBuiltIn();
    var defineGlobalProperty2 = requireDefineGlobalProperty();
    defineBuiltIn = function(O2, key, value, options) {
      if (!options) options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable2(value)) makeBuiltIn2(value, name, options);
      if (options.global) {
        if (simple) O2[key] = value;
        else defineGlobalProperty2(key, value);
      } else {
        try {
          if (!options.unsafe) delete O2[key];
          else if (O2[key]) simple = true;
        } catch (error) {
        }
        if (simple) O2[key] = value;
        else definePropertyModule.f(O2, key, {
          value,
          enumerable: false,
          configurable: !options.nonConfigurable,
          writable: !options.nonWritable
        });
      }
      return O2;
    };
    return defineBuiltIn;
  }
  var objectGetOwnPropertyNames = {};
  var mathTrunc;
  var hasRequiredMathTrunc;
  function requireMathTrunc() {
    if (hasRequiredMathTrunc) return mathTrunc;
    hasRequiredMathTrunc = 1;
    var ceil = Math.ceil;
    var floor = Math.floor;
    mathTrunc = Math.trunc || function trunc(x2) {
      var n2 = +x2;
      return (n2 > 0 ? floor : ceil)(n2);
    };
    return mathTrunc;
  }
  var toIntegerOrInfinity;
  var hasRequiredToIntegerOrInfinity;
  function requireToIntegerOrInfinity() {
    if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
    hasRequiredToIntegerOrInfinity = 1;
    var trunc = requireMathTrunc();
    toIntegerOrInfinity = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
    return toIntegerOrInfinity;
  }
  var toAbsoluteIndex;
  var hasRequiredToAbsoluteIndex;
  function requireToAbsoluteIndex() {
    if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
    hasRequiredToAbsoluteIndex = 1;
    var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
    var max2 = Math.max;
    var min = Math.min;
    toAbsoluteIndex = function(index2, length) {
      var integer = toIntegerOrInfinity2(index2);
      return integer < 0 ? max2(integer + length, 0) : min(integer, length);
    };
    return toAbsoluteIndex;
  }
  var toLength;
  var hasRequiredToLength;
  function requireToLength() {
    if (hasRequiredToLength) return toLength;
    hasRequiredToLength = 1;
    var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
    var min = Math.min;
    toLength = function(argument) {
      var len = toIntegerOrInfinity2(argument);
      return len > 0 ? min(len, 9007199254740991) : 0;
    };
    return toLength;
  }
  var lengthOfArrayLike;
  var hasRequiredLengthOfArrayLike;
  function requireLengthOfArrayLike() {
    if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
    hasRequiredLengthOfArrayLike = 1;
    var toLength2 = requireToLength();
    lengthOfArrayLike = function(obj) {
      return toLength2(obj.length);
    };
    return lengthOfArrayLike;
  }
  var arrayIncludes;
  var hasRequiredArrayIncludes;
  function requireArrayIncludes() {
    if (hasRequiredArrayIncludes) return arrayIncludes;
    hasRequiredArrayIncludes = 1;
    var toIndexedObject2 = requireToIndexedObject();
    var toAbsoluteIndex2 = requireToAbsoluteIndex();
    var lengthOfArrayLike2 = requireLengthOfArrayLike();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O2 = toIndexedObject2($this);
        var length = lengthOfArrayLike2(O2);
        if (length === 0) return !IS_INCLUDES && -1;
        var index2 = toAbsoluteIndex2(fromIndex, length);
        var value;
        if (IS_INCLUDES && el !== el) while (length > index2) {
          value = O2[index2++];
          if (value !== value) return true;
        }
        else for (; length > index2; index2++) {
          if ((IS_INCLUDES || index2 in O2) && O2[index2] === el) return IS_INCLUDES || index2 || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    arrayIncludes = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
    return arrayIncludes;
  }
  var objectKeysInternal;
  var hasRequiredObjectKeysInternal;
  function requireObjectKeysInternal() {
    if (hasRequiredObjectKeysInternal) return objectKeysInternal;
    hasRequiredObjectKeysInternal = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var hasOwn = requireHasOwnProperty();
    var toIndexedObject2 = requireToIndexedObject();
    var indexOf = requireArrayIncludes().indexOf;
    var hiddenKeys2 = requireHiddenKeys();
    var push = uncurryThis([].push);
    objectKeysInternal = function(object, names) {
      var O2 = toIndexedObject2(object);
      var i2 = 0;
      var result = [];
      var key;
      for (key in O2) !hasOwn(hiddenKeys2, key) && hasOwn(O2, key) && push(result, key);
      while (names.length > i2) if (hasOwn(O2, key = names[i2++])) {
        ~indexOf(result, key) || push(result, key);
      }
      return result;
    };
    return objectKeysInternal;
  }
  var enumBugKeys;
  var hasRequiredEnumBugKeys;
  function requireEnumBugKeys() {
    if (hasRequiredEnumBugKeys) return enumBugKeys;
    hasRequiredEnumBugKeys = 1;
    enumBugKeys = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
    return enumBugKeys;
  }
  var hasRequiredObjectGetOwnPropertyNames;
  function requireObjectGetOwnPropertyNames() {
    if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
    hasRequiredObjectGetOwnPropertyNames = 1;
    var internalObjectKeys = requireObjectKeysInternal();
    var enumBugKeys2 = requireEnumBugKeys();
    var hiddenKeys2 = enumBugKeys2.concat("length", "prototype");
    objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
      return internalObjectKeys(O2, hiddenKeys2);
    };
    return objectGetOwnPropertyNames;
  }
  var objectGetOwnPropertySymbols = {};
  var hasRequiredObjectGetOwnPropertySymbols;
  function requireObjectGetOwnPropertySymbols() {
    if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
    hasRequiredObjectGetOwnPropertySymbols = 1;
    objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
    return objectGetOwnPropertySymbols;
  }
  var ownKeys$3;
  var hasRequiredOwnKeys;
  function requireOwnKeys() {
    if (hasRequiredOwnKeys) return ownKeys$3;
    hasRequiredOwnKeys = 1;
    var getBuiltIn2 = requireGetBuiltIn();
    var uncurryThis = requireFunctionUncurryThis();
    var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
    var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
    var anObject2 = requireAnObject();
    var concat = uncurryThis([].concat);
    ownKeys$3 = getBuiltIn2("Reflect", "ownKeys") || function ownKeys2(it2) {
      var keys = getOwnPropertyNamesModule.f(anObject2(it2));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it2)) : keys;
    };
    return ownKeys$3;
  }
  var copyConstructorProperties;
  var hasRequiredCopyConstructorProperties;
  function requireCopyConstructorProperties() {
    if (hasRequiredCopyConstructorProperties) return copyConstructorProperties;
    hasRequiredCopyConstructorProperties = 1;
    var hasOwn = requireHasOwnProperty();
    var ownKeys2 = requireOwnKeys();
    var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
    var definePropertyModule = requireObjectDefineProperty();
    copyConstructorProperties = function(target, source, exceptions) {
      var keys = ownKeys2(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule.f;
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor2(source, key));
        }
      }
    };
    return copyConstructorProperties;
  }
  var isForced_1;
  var hasRequiredIsForced;
  function requireIsForced() {
    if (hasRequiredIsForced) return isForced_1;
    hasRequiredIsForced = 1;
    var fails2 = requireFails();
    var isCallable2 = requireIsCallable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable2(detection) ? fails2(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    isForced_1 = isForced;
    return isForced_1;
  }
  var _export;
  var hasRequired_export;
  function require_export() {
    if (hasRequired_export) return _export;
    hasRequired_export = 1;
    var globalThis2 = requireGlobalThis();
    var getOwnPropertyDescriptor2 = requireObjectGetOwnPropertyDescriptor().f;
    var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
    var defineBuiltIn2 = requireDefineBuiltIn();
    var defineGlobalProperty2 = requireDefineGlobalProperty();
    var copyConstructorProperties2 = requireCopyConstructorProperties();
    var isForced = requireIsForced();
    _export = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = globalThis2;
      } else if (STATIC) {
        target = globalThis2[TARGET] || defineGlobalProperty2(TARGET, {});
      } else {
        target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
      }
      if (target) for (key in source) {
        sourceProperty = source[key];
        if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor2(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        if (!FORCED && targetProperty !== void 0) {
          if (typeof sourceProperty == typeof targetProperty) continue;
          copyConstructorProperties2(sourceProperty, targetProperty);
        }
        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty2(sourceProperty, "sham", true);
        }
        defineBuiltIn2(target, key, sourceProperty, options);
      }
    };
    return _export;
  }
  var environment;
  var hasRequiredEnvironment;
  function requireEnvironment() {
    if (hasRequiredEnvironment) return environment;
    hasRequiredEnvironment = 1;
    var globalThis2 = requireGlobalThis();
    var userAgent2 = requireEnvironmentUserAgent();
    var classof2 = requireClassofRaw();
    var userAgentStartsWith = function(string) {
      return userAgent2.slice(0, string.length) === string;
    };
    environment = (function() {
      if (userAgentStartsWith("Bun/")) return "BUN";
      if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
      if (userAgentStartsWith("Deno/")) return "DENO";
      if (userAgentStartsWith("Node.js/")) return "NODE";
      if (globalThis2.Bun && typeof Bun.version == "string") return "BUN";
      if (globalThis2.Deno && typeof Deno.version == "object") return "DENO";
      if (classof2(globalThis2.process) === "process") return "NODE";
      if (globalThis2.window && globalThis2.document) return "BROWSER";
      return "REST";
    })();
    return environment;
  }
  var environmentIsNode;
  var hasRequiredEnvironmentIsNode;
  function requireEnvironmentIsNode() {
    if (hasRequiredEnvironmentIsNode) return environmentIsNode;
    hasRequiredEnvironmentIsNode = 1;
    var ENVIRONMENT = requireEnvironment();
    environmentIsNode = ENVIRONMENT === "NODE";
    return environmentIsNode;
  }
  var path;
  var hasRequiredPath;
  function requirePath() {
    if (hasRequiredPath) return path;
    hasRequiredPath = 1;
    var globalThis2 = requireGlobalThis();
    path = globalThis2;
    return path;
  }
  var functionUncurryThisAccessor;
  var hasRequiredFunctionUncurryThisAccessor;
  function requireFunctionUncurryThisAccessor() {
    if (hasRequiredFunctionUncurryThisAccessor) return functionUncurryThisAccessor;
    hasRequiredFunctionUncurryThisAccessor = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var aCallable2 = requireACallable();
    functionUncurryThisAccessor = function(object, key, method) {
      try {
        return uncurryThis(aCallable2(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error) {
      }
    };
    return functionUncurryThisAccessor;
  }
  var isPossiblePrototype;
  var hasRequiredIsPossiblePrototype;
  function requireIsPossiblePrototype() {
    if (hasRequiredIsPossiblePrototype) return isPossiblePrototype;
    hasRequiredIsPossiblePrototype = 1;
    var isObject2 = requireIsObject();
    isPossiblePrototype = function(argument) {
      return isObject2(argument) || argument === null;
    };
    return isPossiblePrototype;
  }
  var aPossiblePrototype;
  var hasRequiredAPossiblePrototype;
  function requireAPossiblePrototype() {
    if (hasRequiredAPossiblePrototype) return aPossiblePrototype;
    hasRequiredAPossiblePrototype = 1;
    var isPossiblePrototype2 = requireIsPossiblePrototype();
    var $String = String;
    var $TypeError = TypeError;
    aPossiblePrototype = function(argument) {
      if (isPossiblePrototype2(argument)) return argument;
      throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
    return aPossiblePrototype;
  }
  var objectSetPrototypeOf;
  var hasRequiredObjectSetPrototypeOf;
  function requireObjectSetPrototypeOf() {
    if (hasRequiredObjectSetPrototypeOf) return objectSetPrototypeOf;
    hasRequiredObjectSetPrototypeOf = 1;
    var uncurryThisAccessor = requireFunctionUncurryThisAccessor();
    var isObject2 = requireIsObject();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var aPossiblePrototype2 = requireAPossiblePrototype();
    objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf2(O2, proto) {
        requireObjectCoercible2(O2);
        aPossiblePrototype2(proto);
        if (!isObject2(O2)) return O2;
        if (CORRECT_SETTER) setter(O2, proto);
        else O2.__proto__ = proto;
        return O2;
      };
    })() : void 0);
    return objectSetPrototypeOf;
  }
  var setToStringTag;
  var hasRequiredSetToStringTag;
  function requireSetToStringTag() {
    if (hasRequiredSetToStringTag) return setToStringTag;
    hasRequiredSetToStringTag = 1;
    var defineProperty = requireObjectDefineProperty().f;
    var hasOwn = requireHasOwnProperty();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
    setToStringTag = function(target, TAG, STATIC) {
      if (target && !STATIC) target = target.prototype;
      if (target && !hasOwn(target, TO_STRING_TAG)) {
        defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };
    return setToStringTag;
  }
  var defineBuiltInAccessor;
  var hasRequiredDefineBuiltInAccessor;
  function requireDefineBuiltInAccessor() {
    if (hasRequiredDefineBuiltInAccessor) return defineBuiltInAccessor;
    hasRequiredDefineBuiltInAccessor = 1;
    var makeBuiltIn2 = requireMakeBuiltIn();
    var defineProperty = requireObjectDefineProperty();
    defineBuiltInAccessor = function(target, name, descriptor) {
      if (descriptor.get) makeBuiltIn2(descriptor.get, name, { getter: true });
      if (descriptor.set) makeBuiltIn2(descriptor.set, name, { setter: true });
      return defineProperty.f(target, name, descriptor);
    };
    return defineBuiltInAccessor;
  }
  var setSpecies;
  var hasRequiredSetSpecies;
  function requireSetSpecies() {
    if (hasRequiredSetSpecies) return setSpecies;
    hasRequiredSetSpecies = 1;
    var getBuiltIn2 = requireGetBuiltIn();
    var defineBuiltInAccessor2 = requireDefineBuiltInAccessor();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var DESCRIPTORS = requireDescriptors();
    var SPECIES = wellKnownSymbol2("species");
    setSpecies = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn2(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineBuiltInAccessor2(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
    return setSpecies;
  }
  var anInstance;
  var hasRequiredAnInstance;
  function requireAnInstance() {
    if (hasRequiredAnInstance) return anInstance;
    hasRequiredAnInstance = 1;
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var $TypeError = TypeError;
    anInstance = function(it2, Prototype) {
      if (isPrototypeOf(Prototype, it2)) return it2;
      throw new $TypeError("Incorrect invocation");
    };
    return anInstance;
  }
  var toStringTagSupport;
  var hasRequiredToStringTagSupport;
  function requireToStringTagSupport() {
    if (hasRequiredToStringTagSupport) return toStringTagSupport;
    hasRequiredToStringTagSupport = 1;
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    toStringTagSupport = String(test) === "[object z]";
    return toStringTagSupport;
  }
  var classof;
  var hasRequiredClassof;
  function requireClassof() {
    if (hasRequiredClassof) return classof;
    hasRequiredClassof = 1;
    var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
    var isCallable2 = requireIsCallable();
    var classofRaw2 = requireClassofRaw();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw2(/* @__PURE__ */ (function() {
      return arguments;
    })()) === "Arguments";
    var tryGet = function(it2, key) {
      try {
        return it2[key];
      } catch (error) {
      }
    };
    classof = TO_STRING_TAG_SUPPORT ? classofRaw2 : function(it2) {
      var O2, tag, result;
      return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = $Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw2(O2) : (result = classofRaw2(O2)) === "Object" && isCallable2(O2.callee) ? "Arguments" : result;
    };
    return classof;
  }
  var isConstructor;
  var hasRequiredIsConstructor;
  function requireIsConstructor() {
    if (hasRequiredIsConstructor) return isConstructor;
    hasRequiredIsConstructor = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var fails2 = requireFails();
    var isCallable2 = requireIsCallable();
    var classof2 = requireClassof();
    var getBuiltIn2 = requireGetBuiltIn();
    var inspectSource2 = requireInspectSource();
    var noop2 = function() {
    };
    var construct2 = getBuiltIn2("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop2);
    var isConstructorModern = function isConstructor2(argument) {
      if (!isCallable2(argument)) return false;
      try {
        construct2(noop2, [], argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor2(argument) {
      if (!isCallable2(argument)) return false;
      switch (classof2(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource2(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    isConstructor = !construct2 || fails2(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
    return isConstructor;
  }
  var aConstructor;
  var hasRequiredAConstructor;
  function requireAConstructor() {
    if (hasRequiredAConstructor) return aConstructor;
    hasRequiredAConstructor = 1;
    var isConstructor2 = requireIsConstructor();
    var tryToString2 = requireTryToString();
    var $TypeError = TypeError;
    aConstructor = function(argument) {
      if (isConstructor2(argument)) return argument;
      throw new $TypeError(tryToString2(argument) + " is not a constructor");
    };
    return aConstructor;
  }
  var speciesConstructor;
  var hasRequiredSpeciesConstructor;
  function requireSpeciesConstructor() {
    if (hasRequiredSpeciesConstructor) return speciesConstructor;
    hasRequiredSpeciesConstructor = 1;
    var anObject2 = requireAnObject();
    var aConstructor2 = requireAConstructor();
    var isNullOrUndefined2 = requireIsNullOrUndefined();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var SPECIES = wellKnownSymbol2("species");
    speciesConstructor = function(O2, defaultConstructor) {
      var C2 = anObject2(O2).constructor;
      var S2;
      return C2 === void 0 || isNullOrUndefined2(S2 = anObject2(C2)[SPECIES]) ? defaultConstructor : aConstructor2(S2);
    };
    return speciesConstructor;
  }
  var functionApply;
  var hasRequiredFunctionApply;
  function requireFunctionApply() {
    if (hasRequiredFunctionApply) return functionApply;
    hasRequiredFunctionApply = 1;
    var NATIVE_BIND = requireFunctionBindNative();
    var FunctionPrototype = Function.prototype;
    var apply2 = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply2) : function() {
      return call.apply(apply2, arguments);
    });
    return functionApply;
  }
  var functionUncurryThisClause;
  var hasRequiredFunctionUncurryThisClause;
  function requireFunctionUncurryThisClause() {
    if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
    hasRequiredFunctionUncurryThisClause = 1;
    var classofRaw2 = requireClassofRaw();
    var uncurryThis = requireFunctionUncurryThis();
    functionUncurryThisClause = function(fn) {
      if (classofRaw2(fn) === "Function") return uncurryThis(fn);
    };
    return functionUncurryThisClause;
  }
  var functionBindContext;
  var hasRequiredFunctionBindContext;
  function requireFunctionBindContext() {
    if (hasRequiredFunctionBindContext) return functionBindContext;
    hasRequiredFunctionBindContext = 1;
    var uncurryThis = requireFunctionUncurryThisClause();
    var aCallable2 = requireACallable();
    var NATIVE_BIND = requireFunctionBindNative();
    var bind = uncurryThis(uncurryThis.bind);
    functionBindContext = function(fn, that) {
      aCallable2(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
    return functionBindContext;
  }
  var html;
  var hasRequiredHtml;
  function requireHtml() {
    if (hasRequiredHtml) return html;
    hasRequiredHtml = 1;
    var getBuiltIn2 = requireGetBuiltIn();
    html = getBuiltIn2("document", "documentElement");
    return html;
  }
  var arraySlice;
  var hasRequiredArraySlice;
  function requireArraySlice() {
    if (hasRequiredArraySlice) return arraySlice;
    hasRequiredArraySlice = 1;
    var uncurryThis = requireFunctionUncurryThis();
    arraySlice = uncurryThis([].slice);
    return arraySlice;
  }
  var validateArgumentsLength;
  var hasRequiredValidateArgumentsLength;
  function requireValidateArgumentsLength() {
    if (hasRequiredValidateArgumentsLength) return validateArgumentsLength;
    hasRequiredValidateArgumentsLength = 1;
    var $TypeError = TypeError;
    validateArgumentsLength = function(passed, required) {
      if (passed < required) throw new $TypeError("Not enough arguments");
      return passed;
    };
    return validateArgumentsLength;
  }
  var environmentIsIos;
  var hasRequiredEnvironmentIsIos;
  function requireEnvironmentIsIos() {
    if (hasRequiredEnvironmentIsIos) return environmentIsIos;
    hasRequiredEnvironmentIsIos = 1;
    var userAgent2 = requireEnvironmentUserAgent();
    environmentIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent2);
    return environmentIsIos;
  }
  var task;
  var hasRequiredTask;
  function requireTask() {
    if (hasRequiredTask) return task;
    hasRequiredTask = 1;
    var globalThis2 = requireGlobalThis();
    var apply2 = requireFunctionApply();
    var bind = requireFunctionBindContext();
    var isCallable2 = requireIsCallable();
    var hasOwn = requireHasOwnProperty();
    var fails2 = requireFails();
    var html2 = requireHtml();
    var arraySlice2 = requireArraySlice();
    var createElement = requireDocumentCreateElement();
    var validateArgumentsLength2 = requireValidateArgumentsLength();
    var IS_IOS = requireEnvironmentIsIos();
    var IS_NODE = requireEnvironmentIsNode();
    var set = globalThis2.setImmediate;
    var clear = globalThis2.clearImmediate;
    var process2 = globalThis2.process;
    var Dispatch = globalThis2.Dispatch;
    var Function2 = globalThis2.Function;
    var MessageChannel = globalThis2.MessageChannel;
    var String2 = globalThis2.String;
    var counter = 0;
    var queue2 = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location, defer, channel, port;
    fails2(function() {
      $location = globalThis2.location;
    });
    var run = function(id) {
      if (hasOwn(queue2, id)) {
        var fn = queue2[id];
        delete queue2[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run(id);
      };
    };
    var eventListener = function(event) {
      run(event.data);
    };
    var globalPostMessageDefer = function(id) {
      globalThis2.postMessage(String2(id), $location.protocol + "//" + $location.host);
    };
    if (!set || !clear) {
      set = function setImmediate(handler) {
        validateArgumentsLength2(arguments.length, 1);
        var fn = isCallable2(handler) ? handler : Function2(handler);
        var args = arraySlice2(arguments, 1);
        queue2[++counter] = function() {
          apply2(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue2[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process2.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
      } else if (globalThis2.addEventListener && isCallable2(globalThis2.postMessage) && !globalThis2.importScripts && $location && $location.protocol !== "file:" && !fails2(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        globalThis2.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id) {
          html2.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html2.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    task = {
      set,
      clear
    };
    return task;
  }
  var safeGetBuiltIn;
  var hasRequiredSafeGetBuiltIn;
  function requireSafeGetBuiltIn() {
    if (hasRequiredSafeGetBuiltIn) return safeGetBuiltIn;
    hasRequiredSafeGetBuiltIn = 1;
    var globalThis2 = requireGlobalThis();
    var DESCRIPTORS = requireDescriptors();
    var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
    safeGetBuiltIn = function(name) {
      if (!DESCRIPTORS) return globalThis2[name];
      var descriptor = getOwnPropertyDescriptor2(globalThis2, name);
      return descriptor && descriptor.value;
    };
    return safeGetBuiltIn;
  }
  var queue;
  var hasRequiredQueue;
  function requireQueue() {
    if (hasRequiredQueue) return queue;
    hasRequiredQueue = 1;
    var Queue = function() {
      this.head = null;
      this.tail = null;
    };
    Queue.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail) tail.next = entry;
        else this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null) this.tail = null;
          return entry.item;
        }
      }
    };
    queue = Queue;
    return queue;
  }
  var environmentIsIosPebble;
  var hasRequiredEnvironmentIsIosPebble;
  function requireEnvironmentIsIosPebble() {
    if (hasRequiredEnvironmentIsIosPebble) return environmentIsIosPebble;
    hasRequiredEnvironmentIsIosPebble = 1;
    var userAgent2 = requireEnvironmentUserAgent();
    environmentIsIosPebble = /ipad|iphone|ipod/i.test(userAgent2) && typeof Pebble != "undefined";
    return environmentIsIosPebble;
  }
  var environmentIsWebosWebkit;
  var hasRequiredEnvironmentIsWebosWebkit;
  function requireEnvironmentIsWebosWebkit() {
    if (hasRequiredEnvironmentIsWebosWebkit) return environmentIsWebosWebkit;
    hasRequiredEnvironmentIsWebosWebkit = 1;
    var userAgent2 = requireEnvironmentUserAgent();
    environmentIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent2);
    return environmentIsWebosWebkit;
  }
  var microtask_1;
  var hasRequiredMicrotask;
  function requireMicrotask() {
    if (hasRequiredMicrotask) return microtask_1;
    hasRequiredMicrotask = 1;
    var globalThis2 = requireGlobalThis();
    var safeGetBuiltIn2 = requireSafeGetBuiltIn();
    var bind = requireFunctionBindContext();
    var macrotask = requireTask().set;
    var Queue = requireQueue();
    var IS_IOS = requireEnvironmentIsIos();
    var IS_IOS_PEBBLE = requireEnvironmentIsIosPebble();
    var IS_WEBOS_WEBKIT = requireEnvironmentIsWebosWebkit();
    var IS_NODE = requireEnvironmentIsNode();
    var MutationObserver2 = globalThis2.MutationObserver || globalThis2.WebKitMutationObserver;
    var document2 = globalThis2.document;
    var process2 = globalThis2.process;
    var Promise2 = globalThis2.Promise;
    var microtask = safeGetBuiltIn2("queueMicrotask");
    var notify, toggle, node2, promise, then;
    if (!microtask) {
      var queue2 = new Queue();
      var flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process2.domain)) parent.exit();
        while (fn = queue2.get()) try {
          fn();
        } catch (error) {
          if (queue2.head) notify();
          throw error;
        }
        if (parent) parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver2 && document2) {
        toggle = true;
        node2 = document2.createTextNode("");
        new MutationObserver2(flush).observe(node2, { characterData: true });
        notify = function() {
          node2.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = bind(promise.then, promise);
        notify = function() {
          then(flush);
        };
      } else if (IS_NODE) {
        notify = function() {
          process2.nextTick(flush);
        };
      } else {
        macrotask = bind(macrotask, globalThis2);
        notify = function() {
          macrotask(flush);
        };
      }
      microtask = function(fn) {
        if (!queue2.head) notify();
        queue2.add(fn);
      };
    }
    microtask_1 = microtask;
    return microtask_1;
  }
  var hostReportErrors;
  var hasRequiredHostReportErrors;
  function requireHostReportErrors() {
    if (hasRequiredHostReportErrors) return hostReportErrors;
    hasRequiredHostReportErrors = 1;
    hostReportErrors = function(a2, b2) {
      try {
        arguments.length === 1 ? console.error(a2) : console.error(a2, b2);
      } catch (error) {
      }
    };
    return hostReportErrors;
  }
  var perform;
  var hasRequiredPerform;
  function requirePerform() {
    if (hasRequiredPerform) return perform;
    hasRequiredPerform = 1;
    perform = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
    return perform;
  }
  var promiseNativeConstructor;
  var hasRequiredPromiseNativeConstructor;
  function requirePromiseNativeConstructor() {
    if (hasRequiredPromiseNativeConstructor) return promiseNativeConstructor;
    hasRequiredPromiseNativeConstructor = 1;
    var globalThis2 = requireGlobalThis();
    promiseNativeConstructor = globalThis2.Promise;
    return promiseNativeConstructor;
  }
  var promiseConstructorDetection;
  var hasRequiredPromiseConstructorDetection;
  function requirePromiseConstructorDetection() {
    if (hasRequiredPromiseConstructorDetection) return promiseConstructorDetection;
    hasRequiredPromiseConstructorDetection = 1;
    var globalThis2 = requireGlobalThis();
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var isCallable2 = requireIsCallable();
    var isForced = requireIsForced();
    var inspectSource2 = requireInspectSource();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var ENVIRONMENT = requireEnvironment();
    var IS_PURE = requireIsPure();
    var V8_VERSION = requireEnvironmentV8Version();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var SPECIES = wellKnownSymbol2("species");
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT = isCallable2(globalThis2.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource2(NativePromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
      if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"])) return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise = new NativePromiseConstructor(function(resolve) {
          resolve(1);
        });
        var FakePromise = function(exec) {
          exec(function() {
          }, function() {
          });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING) return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === "BROWSER" || ENVIRONMENT === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT;
    });
    promiseConstructorDetection = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
      SUBCLASSING
    };
    return promiseConstructorDetection;
  }
  var newPromiseCapability = {};
  var hasRequiredNewPromiseCapability;
  function requireNewPromiseCapability() {
    if (hasRequiredNewPromiseCapability) return newPromiseCapability;
    hasRequiredNewPromiseCapability = 1;
    var aCallable2 = requireACallable();
    var $TypeError = TypeError;
    var PromiseCapability = function(C2) {
      var resolve, reject;
      this.promise = new C2(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0) throw new $TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable2(resolve);
      this.reject = aCallable2(reject);
    };
    newPromiseCapability.f = function(C2) {
      return new PromiseCapability(C2);
    };
    return newPromiseCapability;
  }
  var hasRequiredEs_promise_constructor;
  function requireEs_promise_constructor() {
    if (hasRequiredEs_promise_constructor) return es_promise_constructor;
    hasRequiredEs_promise_constructor = 1;
    var $2 = require_export();
    var IS_PURE = requireIsPure();
    var IS_NODE = requireEnvironmentIsNode();
    var globalThis2 = requireGlobalThis();
    var path2 = requirePath();
    var call = requireFunctionCall();
    var defineBuiltIn2 = requireDefineBuiltIn();
    var setPrototypeOf2 = requireObjectSetPrototypeOf();
    var setToStringTag2 = requireSetToStringTag();
    var setSpecies2 = requireSetSpecies();
    var aCallable2 = requireACallable();
    var isCallable2 = requireIsCallable();
    var isObject2 = requireIsObject();
    var anInstance2 = requireAnInstance();
    var speciesConstructor2 = requireSpeciesConstructor();
    var task2 = requireTask().set;
    var microtask = requireMicrotask();
    var hostReportErrors2 = requireHostReportErrors();
    var perform2 = requirePerform();
    var Queue = requireQueue();
    var InternalStateModule = requireInternalState();
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var PromiseConstructorDetection = requirePromiseConstructorDetection();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var PROMISE = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var PromiseConstructor = NativePromiseConstructor;
    var PromisePrototype = NativePromisePrototype;
    var TypeError2 = globalThis2.TypeError;
    var document2 = globalThis2.document;
    var process2 = globalThis2.process;
    var newPromiseCapability2 = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability2;
    var DISPATCH_EVENT = !!(document2 && document2.createEvent && globalThis2.dispatchEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
    var isThenable = function(it2) {
      var then;
      return isObject2(it2) && isCallable2(then = it2.then) ? then : false;
    };
    var callReaction = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError2("Promise-chain cycle"));
          } else if (then = isThenable(result)) {
            call(then, result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    };
    var notify = function(state, isReject) {
      if (state.notified) return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(state);
      });
    };
    var dispatchEvent = function(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document2.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        globalThis2.dispatchEvent(event);
      } else event = { promise, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis2["on" + name])) handler(event);
      else if (name === UNHANDLED_REJECTION) hostReportErrors2("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      call(task2, globalThis2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform2(function() {
            if (IS_NODE) {
              process2.emit("unhandledRejection", value, promise);
            } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error) throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      call(task2, globalThis2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process2.emit("rejectionHandled", promise);
        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      try {
        if (state.facade === value) throw new TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call(
                then,
                value,
                bind(internalResolve, wrapper, state),
                bind(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR) {
      PromiseConstructor = function Promise2(executor) {
        anInstance2(this, PromisePrototype);
        aCallable2(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: null
        });
      };
      Internal.prototype = defineBuiltIn2(PromisePrototype, "then", function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability2(speciesConstructor2(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable2(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable2(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process2.domain : void 0;
        if (state.state === PENDING) state.reactions.add(reaction);
        else microtask(function() {
          callReaction(reaction, state);
        });
        return reaction.promise;
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability2 = function(C2) {
        return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
      };
      if (!IS_PURE && isCallable2(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn2(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              call(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf2) {
          setPrototypeOf2(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $2({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      Promise: PromiseConstructor
    });
    PromiseWrapper = path2.Promise;
    setToStringTag2(PromiseConstructor, PROMISE, false, true);
    setSpecies2(PROMISE);
    return es_promise_constructor;
  }
  var es_promise_all = {};
  var iterators;
  var hasRequiredIterators;
  function requireIterators() {
    if (hasRequiredIterators) return iterators;
    hasRequiredIterators = 1;
    iterators = {};
    return iterators;
  }
  var isArrayIteratorMethod;
  var hasRequiredIsArrayIteratorMethod;
  function requireIsArrayIteratorMethod() {
    if (hasRequiredIsArrayIteratorMethod) return isArrayIteratorMethod;
    hasRequiredIsArrayIteratorMethod = 1;
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var Iterators = requireIterators();
    var ITERATOR = wellKnownSymbol2("iterator");
    var ArrayPrototype = Array.prototype;
    isArrayIteratorMethod = function(it2) {
      return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
    };
    return isArrayIteratorMethod;
  }
  var getIteratorMethod;
  var hasRequiredGetIteratorMethod;
  function requireGetIteratorMethod() {
    if (hasRequiredGetIteratorMethod) return getIteratorMethod;
    hasRequiredGetIteratorMethod = 1;
    var classof2 = requireClassof();
    var getMethod2 = requireGetMethod();
    var isNullOrUndefined2 = requireIsNullOrUndefined();
    var Iterators = requireIterators();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var ITERATOR = wellKnownSymbol2("iterator");
    getIteratorMethod = function(it2) {
      if (!isNullOrUndefined2(it2)) return getMethod2(it2, ITERATOR) || getMethod2(it2, "@@iterator") || Iterators[classof2(it2)];
    };
    return getIteratorMethod;
  }
  var getIterator;
  var hasRequiredGetIterator;
  function requireGetIterator() {
    if (hasRequiredGetIterator) return getIterator;
    hasRequiredGetIterator = 1;
    var call = requireFunctionCall();
    var aCallable2 = requireACallable();
    var anObject2 = requireAnObject();
    var tryToString2 = requireTryToString();
    var getIteratorMethod2 = requireGetIteratorMethod();
    var $TypeError = TypeError;
    getIterator = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod2(argument) : usingIterator;
      if (aCallable2(iteratorMethod)) return anObject2(call(iteratorMethod, argument));
      throw new $TypeError(tryToString2(argument) + " is not iterable");
    };
    return getIterator;
  }
  var iteratorClose;
  var hasRequiredIteratorClose;
  function requireIteratorClose() {
    if (hasRequiredIteratorClose) return iteratorClose;
    hasRequiredIteratorClose = 1;
    var call = requireFunctionCall();
    var anObject2 = requireAnObject();
    var getMethod2 = requireGetMethod();
    iteratorClose = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject2(iterator);
      try {
        innerResult = getMethod2(iterator, "return");
        if (!innerResult) {
          if (kind === "throw") throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw") throw value;
      if (innerError) throw innerResult;
      anObject2(innerResult);
      return value;
    };
    return iteratorClose;
  }
  var iterate;
  var hasRequiredIterate;
  function requireIterate() {
    if (hasRequiredIterate) return iterate;
    hasRequiredIterate = 1;
    var bind = requireFunctionBindContext();
    var call = requireFunctionCall();
    var anObject2 = requireAnObject();
    var tryToString2 = requireTryToString();
    var isArrayIteratorMethod2 = requireIsArrayIteratorMethod();
    var lengthOfArrayLike2 = requireLengthOfArrayLike();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var getIterator2 = requireGetIterator();
    var getIteratorMethod2 = requireGetIteratorMethod();
    var iteratorClose2 = requireIteratorClose();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    iterate = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index2, length, result, next, step;
      var stop = function(condition) {
        if (iterator) iteratorClose2(iterator, "normal");
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject2(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod2(iterable);
        if (!iterFn) throw new $TypeError(tryToString2(iterable) + " is not iterable");
        if (isArrayIteratorMethod2(iterFn)) {
          for (index2 = 0, length = lengthOfArrayLike2(iterable); length > index2; index2++) {
            result = callFn(iterable[index2]);
            if (result && isPrototypeOf(ResultPrototype, result)) return result;
          }
          return new Result(false);
        }
        iterator = getIterator2(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose2(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
      }
      return new Result(false);
    };
    return iterate;
  }
  var checkCorrectnessOfIteration;
  var hasRequiredCheckCorrectnessOfIteration;
  function requireCheckCorrectnessOfIteration() {
    if (hasRequiredCheckCorrectnessOfIteration) return checkCorrectnessOfIteration;
    hasRequiredCheckCorrectnessOfIteration = 1;
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var ITERATOR = wellKnownSymbol2("iterator");
    var SAFE_CLOSING = false;
    try {
      var called = 0;
      var iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    checkCorrectnessOfIteration = function(exec, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
    return checkCorrectnessOfIteration;
  }
  var promiseStaticsIncorrectIteration;
  var hasRequiredPromiseStaticsIncorrectIteration;
  function requirePromiseStaticsIncorrectIteration() {
    if (hasRequiredPromiseStaticsIncorrectIteration) return promiseStaticsIncorrectIteration;
    hasRequiredPromiseStaticsIncorrectIteration = 1;
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var checkCorrectnessOfIteration2 = requireCheckCorrectnessOfIteration();
    var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
    promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration2(function(iterable) {
      NativePromiseConstructor.all(iterable).then(void 0, function() {
      });
    });
    return promiseStaticsIncorrectIteration;
  }
  var hasRequiredEs_promise_all;
  function requireEs_promise_all() {
    if (hasRequiredEs_promise_all) return es_promise_all;
    hasRequiredEs_promise_all = 1;
    var $2 = require_export();
    var call = requireFunctionCall();
    var aCallable2 = requireACallable();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var perform2 = requirePerform();
    var iterate2 = requireIterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();
    $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      all: function all(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule.f(C2);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform2(function() {
          var $promiseResolve = aCallable2(C2.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate2(iterable, function(promise) {
            var index2 = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C2, promise).then(function(value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[index2] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
    return es_promise_all;
  }
  var es_promise_catch = {};
  var hasRequiredEs_promise_catch;
  function requireEs_promise_catch() {
    if (hasRequiredEs_promise_catch) return es_promise_catch;
    hasRequiredEs_promise_catch = 1;
    var $2 = require_export();
    var IS_PURE = requireIsPure();
    var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var getBuiltIn2 = requireGetBuiltIn();
    var isCallable2 = requireIsCallable();
    var defineBuiltIn2 = requireDefineBuiltIn();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $2({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (!IS_PURE && isCallable2(NativePromiseConstructor)) {
      var method = getBuiltIn2("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn2(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    return es_promise_catch;
  }
  var es_promise_race = {};
  var hasRequiredEs_promise_race;
  function requireEs_promise_race() {
    if (hasRequiredEs_promise_race) return es_promise_race;
    hasRequiredEs_promise_race = 1;
    var $2 = require_export();
    var call = requireFunctionCall();
    var aCallable2 = requireACallable();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var perform2 = requirePerform();
    var iterate2 = requireIterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();
    $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: function race(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule.f(C2);
        var reject = capability.reject;
        var result = perform2(function() {
          var $promiseResolve = aCallable2(C2.resolve);
          iterate2(iterable, function(promise) {
            call($promiseResolve, C2, promise).then(capability.resolve, reject);
          });
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
    return es_promise_race;
  }
  var es_promise_reject = {};
  var hasRequiredEs_promise_reject;
  function requireEs_promise_reject() {
    if (hasRequiredEs_promise_reject) return es_promise_reject;
    hasRequiredEs_promise_reject = 1;
    var $2 = require_export();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
    $2({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      reject: function reject(r2) {
        var capability = newPromiseCapabilityModule.f(this);
        var capabilityReject = capability.reject;
        capabilityReject(r2);
        return capability.promise;
      }
    });
    return es_promise_reject;
  }
  var es_promise_resolve = {};
  var promiseResolve;
  var hasRequiredPromiseResolve;
  function requirePromiseResolve() {
    if (hasRequiredPromiseResolve) return promiseResolve;
    hasRequiredPromiseResolve = 1;
    var anObject2 = requireAnObject();
    var isObject2 = requireIsObject();
    var newPromiseCapability2 = requireNewPromiseCapability();
    promiseResolve = function(C2, x2) {
      anObject2(C2);
      if (isObject2(x2) && x2.constructor === C2) return x2;
      var promiseCapability = newPromiseCapability2.f(C2);
      var resolve = promiseCapability.resolve;
      resolve(x2);
      return promiseCapability.promise;
    };
    return promiseResolve;
  }
  var hasRequiredEs_promise_resolve;
  function requireEs_promise_resolve() {
    if (hasRequiredEs_promise_resolve) return es_promise_resolve;
    hasRequiredEs_promise_resolve = 1;
    var $2 = require_export();
    var getBuiltIn2 = requireGetBuiltIn();
    var IS_PURE = requireIsPure();
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
    var promiseResolve2 = requirePromiseResolve();
    var PromiseConstructorWrapper = getBuiltIn2("Promise");
    var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
    $2({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: function resolve(x2) {
        return promiseResolve2(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
      }
    });
    return es_promise_resolve;
  }
  var hasRequiredEs_promise;
  function requireEs_promise() {
    if (hasRequiredEs_promise) return es_promise;
    hasRequiredEs_promise = 1;
    requireEs_promise_constructor();
    requireEs_promise_all();
    requireEs_promise_catch();
    requireEs_promise_race();
    requireEs_promise_reject();
    requireEs_promise_resolve();
    return es_promise;
  }
  requireEs_promise();
  function asyncGeneratorStep(n2, t3, e2, r2, o2, a2, c2) {
    try {
      var i2 = n2[a2](c2), u2 = i2.value;
    } catch (n3) {
      return void e2(n3);
    }
    i2.done ? t3(u2) : Promise.resolve(u2).then(r2, o2);
  }
  function _asyncToGenerator(n2) {
    return function() {
      var t3 = this, e2 = arguments;
      return new Promise(function(r2, o2) {
        var a2 = n2.apply(t3, e2);
        function _next(n3) {
          asyncGeneratorStep(a2, r2, o2, _next, _throw, "next", n3);
        }
        function _throw(n3) {
          asyncGeneratorStep(a2, r2, o2, _next, _throw, "throw", n3);
        }
        _next(void 0);
      });
    };
  }
  var es_string_match = {};
  var es_regexp_exec = {};
  var toString;
  var hasRequiredToString;
  function requireToString() {
    if (hasRequiredToString) return toString;
    hasRequiredToString = 1;
    var classof2 = requireClassof();
    var $String = String;
    toString = function(argument) {
      if (classof2(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
    return toString;
  }
  var regexpFlags;
  var hasRequiredRegexpFlags;
  function requireRegexpFlags() {
    if (hasRequiredRegexpFlags) return regexpFlags;
    hasRequiredRegexpFlags = 1;
    var anObject2 = requireAnObject();
    regexpFlags = function() {
      var that = anObject2(this);
      var result = "";
      if (that.hasIndices) result += "d";
      if (that.global) result += "g";
      if (that.ignoreCase) result += "i";
      if (that.multiline) result += "m";
      if (that.dotAll) result += "s";
      if (that.unicode) result += "u";
      if (that.unicodeSets) result += "v";
      if (that.sticky) result += "y";
      return result;
    };
    return regexpFlags;
  }
  var regexpStickyHelpers;
  var hasRequiredRegexpStickyHelpers;
  function requireRegexpStickyHelpers() {
    if (hasRequiredRegexpStickyHelpers) return regexpStickyHelpers;
    hasRequiredRegexpStickyHelpers = 1;
    var fails2 = requireFails();
    var globalThis2 = requireGlobalThis();
    var $RegExp = globalThis2.RegExp;
    var UNSUPPORTED_Y = fails2(function() {
      var re2 = $RegExp("a", "y");
      re2.lastIndex = 2;
      return re2.exec("abcd") !== null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails2(function() {
      return !$RegExp("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails2(function() {
      var re2 = $RegExp("^r", "gy");
      re2.lastIndex = 2;
      return re2.exec("str") !== null;
    });
    regexpStickyHelpers = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y
    };
    return regexpStickyHelpers;
  }
  var objectDefineProperties = {};
  var objectKeys;
  var hasRequiredObjectKeys;
  function requireObjectKeys() {
    if (hasRequiredObjectKeys) return objectKeys;
    hasRequiredObjectKeys = 1;
    var internalObjectKeys = requireObjectKeysInternal();
    var enumBugKeys2 = requireEnumBugKeys();
    objectKeys = Object.keys || function keys(O2) {
      return internalObjectKeys(O2, enumBugKeys2);
    };
    return objectKeys;
  }
  var hasRequiredObjectDefineProperties;
  function requireObjectDefineProperties() {
    if (hasRequiredObjectDefineProperties) return objectDefineProperties;
    hasRequiredObjectDefineProperties = 1;
    var DESCRIPTORS = requireDescriptors();
    var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
    var definePropertyModule = requireObjectDefineProperty();
    var anObject2 = requireAnObject();
    var toIndexedObject2 = requireToIndexedObject();
    var objectKeys2 = requireObjectKeys();
    objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
      anObject2(O2);
      var props = toIndexedObject2(Properties);
      var keys = objectKeys2(Properties);
      var length = keys.length;
      var index2 = 0;
      var key;
      while (length > index2) definePropertyModule.f(O2, key = keys[index2++], props[key]);
      return O2;
    };
    return objectDefineProperties;
  }
  var objectCreate;
  var hasRequiredObjectCreate;
  function requireObjectCreate() {
    if (hasRequiredObjectCreate) return objectCreate;
    hasRequiredObjectCreate = 1;
    var anObject2 = requireAnObject();
    var definePropertiesModule = requireObjectDefineProperties();
    var enumBugKeys2 = requireEnumBugKeys();
    var hiddenKeys2 = requireHiddenKeys();
    var html2 = requireHtml();
    var documentCreateElement2 = requireDocumentCreateElement();
    var sharedKey2 = requireSharedKey();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey2("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement2("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html2.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys2.length;
      while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys2[length]];
      return NullProtoObject();
    };
    hiddenKeys2[IE_PROTO] = true;
    objectCreate = Object.create || function create2(O2, Properties) {
      var result;
      if (O2 !== null) {
        EmptyConstructor[PROTOTYPE] = anObject2(O2);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O2;
      } else result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
    return objectCreate;
  }
  var regexpUnsupportedDotAll;
  var hasRequiredRegexpUnsupportedDotAll;
  function requireRegexpUnsupportedDotAll() {
    if (hasRequiredRegexpUnsupportedDotAll) return regexpUnsupportedDotAll;
    hasRequiredRegexpUnsupportedDotAll = 1;
    var fails2 = requireFails();
    var globalThis2 = requireGlobalThis();
    var $RegExp = globalThis2.RegExp;
    regexpUnsupportedDotAll = fails2(function() {
      var re2 = $RegExp(".", "s");
      return !(re2.dotAll && re2.test("\n") && re2.flags === "s");
    });
    return regexpUnsupportedDotAll;
  }
  var regexpUnsupportedNcg;
  var hasRequiredRegexpUnsupportedNcg;
  function requireRegexpUnsupportedNcg() {
    if (hasRequiredRegexpUnsupportedNcg) return regexpUnsupportedNcg;
    hasRequiredRegexpUnsupportedNcg = 1;
    var fails2 = requireFails();
    var globalThis2 = requireGlobalThis();
    var $RegExp = globalThis2.RegExp;
    regexpUnsupportedNcg = fails2(function() {
      var re2 = $RegExp("(?<a>b)", "g");
      return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
    });
    return regexpUnsupportedNcg;
  }
  var regexpExec;
  var hasRequiredRegexpExec;
  function requireRegexpExec() {
    if (hasRequiredRegexpExec) return regexpExec;
    hasRequiredRegexpExec = 1;
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var toString2 = requireToString();
    var regexpFlags2 = requireRegexpFlags();
    var stickyHelpers = requireRegexpStickyHelpers();
    var shared2 = requireShared();
    var create2 = requireObjectCreate();
    var getInternalState = requireInternalState().get;
    var UNSUPPORTED_DOT_ALL = requireRegexpUnsupportedDotAll();
    var UNSUPPORTED_NCG = requireRegexpUnsupportedNcg();
    var nativeReplace = shared2("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis("".charAt);
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var UPDATES_LAST_INDEX_WRONG = (function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call(nativeExec, re1, "a");
      call(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    })();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec(string) {
        var re2 = this;
        var state = getInternalState(re2);
        var str = toString2(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i2, object, group;
        if (raw) {
          raw.lastIndex = re2.lastIndex;
          result = call(patchedExec, raw, str);
          re2.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re2.sticky;
        var flags = call(regexpFlags2, re2);
        var source = re2.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice(str, re2.lastIndex);
          if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt(str, re2.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re2.lastIndex;
        match = call(nativeExec, sticky ? reCopy : re2, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re2.lastIndex;
            re2.lastIndex += match[0].length;
          } else re2.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re2.lastIndex = re2.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          call(nativeReplace, match[0], reCopy, function() {
            for (i2 = 1; i2 < arguments.length - 2; i2++) {
              if (arguments[i2] === void 0) match[i2] = void 0;
            }
          });
        }
        if (match && groups) {
          match.groups = object = create2(null);
          for (i2 = 0; i2 < groups.length; i2++) {
            group = groups[i2];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      };
    }
    regexpExec = patchedExec;
    return regexpExec;
  }
  var hasRequiredEs_regexp_exec;
  function requireEs_regexp_exec() {
    if (hasRequiredEs_regexp_exec) return es_regexp_exec;
    hasRequiredEs_regexp_exec = 1;
    var $2 = require_export();
    var exec = requireRegexpExec();
    $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
      exec
    });
    return es_regexp_exec;
  }
  var fixRegexpWellKnownSymbolLogic;
  var hasRequiredFixRegexpWellKnownSymbolLogic;
  function requireFixRegexpWellKnownSymbolLogic() {
    if (hasRequiredFixRegexpWellKnownSymbolLogic) return fixRegexpWellKnownSymbolLogic;
    hasRequiredFixRegexpWellKnownSymbolLogic = 1;
    requireEs_regexp_exec();
    var call = requireFunctionCall();
    var defineBuiltIn2 = requireDefineBuiltIn();
    var regexpExec2 = requireRegexpExec();
    var fails2 = requireFails();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
    var SPECIES = wellKnownSymbol2("species");
    var RegExpPrototype = RegExp.prototype;
    fixRegexpWellKnownSymbolLogic = function(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol2(KEY);
      var DELEGATES_TO_SYMBOL = !fails2(function() {
        var O2 = {};
        O2[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O2) !== 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails2(function() {
        var execCalled = false;
        var re2 = /a/;
        if (KEY === "split") {
          re2 = {};
          re2.constructor = {};
          re2.constructor[SPECIES] = function() {
            return re2;
          };
          re2.flags = "";
          re2[SYMBOL] = /./[SYMBOL];
        }
        re2.exec = function() {
          execCalled = true;
          return null;
        };
        re2[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var $exec = regexp.exec;
          if ($exec === regexpExec2 || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
            }
            return { done: true, value: call(nativeMethod, str, regexp, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn2(String.prototype, KEY, methods[0]);
        defineBuiltIn2(RegExpPrototype, SYMBOL, methods[1]);
      }
      if (SHAM) createNonEnumerableProperty2(RegExpPrototype[SYMBOL], "sham", true);
    };
    return fixRegexpWellKnownSymbolLogic;
  }
  var stringMultibyte;
  var hasRequiredStringMultibyte;
  function requireStringMultibyte() {
    if (hasRequiredStringMultibyte) return stringMultibyte;
    hasRequiredStringMultibyte = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
    var toString2 = requireToString();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S2 = toString2(requireObjectCoercible2($this));
        var position = toIntegerOrInfinity2(pos);
        var size = S2.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S2, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S2, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S2, position) : first : CONVERT_TO_STRING ? stringSlice(S2, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    stringMultibyte = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
    return stringMultibyte;
  }
  var advanceStringIndex;
  var hasRequiredAdvanceStringIndex;
  function requireAdvanceStringIndex() {
    if (hasRequiredAdvanceStringIndex) return advanceStringIndex;
    hasRequiredAdvanceStringIndex = 1;
    var charAt = requireStringMultibyte().charAt;
    advanceStringIndex = function(S2, index2, unicode) {
      return index2 + (unicode ? charAt(S2, index2).length : 1);
    };
    return advanceStringIndex;
  }
  var regexpFlagsDetection;
  var hasRequiredRegexpFlagsDetection;
  function requireRegexpFlagsDetection() {
    if (hasRequiredRegexpFlagsDetection) return regexpFlagsDetection;
    hasRequiredRegexpFlagsDetection = 1;
    var globalThis2 = requireGlobalThis();
    var fails2 = requireFails();
    var RegExp2 = globalThis2.RegExp;
    var FLAGS_GETTER_IS_CORRECT = !fails2(function() {
      var INDICES_SUPPORT = true;
      try {
        RegExp2(".", "d");
      } catch (error) {
        INDICES_SUPPORT = false;
      }
      var O2 = {};
      var calls = "";
      var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
      var addGetter = function(key2, chr) {
        Object.defineProperty(O2, key2, { get: function() {
          calls += chr;
          return true;
        } });
      };
      var pairs = {
        dotAll: "s",
        global: "g",
        ignoreCase: "i",
        multiline: "m",
        sticky: "y"
      };
      if (INDICES_SUPPORT) pairs.hasIndices = "d";
      for (var key in pairs) addGetter(key, pairs[key]);
      var result = Object.getOwnPropertyDescriptor(RegExp2.prototype, "flags").get.call(O2);
      return result !== expected || calls !== expected;
    });
    regexpFlagsDetection = { correct: FLAGS_GETTER_IS_CORRECT };
    return regexpFlagsDetection;
  }
  var regexpGetFlags;
  var hasRequiredRegexpGetFlags;
  function requireRegexpGetFlags() {
    if (hasRequiredRegexpGetFlags) return regexpGetFlags;
    hasRequiredRegexpGetFlags = 1;
    var call = requireFunctionCall();
    var hasOwn = requireHasOwnProperty();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var regExpFlagsDetection = requireRegexpFlagsDetection();
    var regExpFlagsGetterImplementation = requireRegexpFlags();
    var RegExpPrototype = RegExp.prototype;
    regexpGetFlags = regExpFlagsDetection.correct ? function(it2) {
      return it2.flags;
    } : function(it2) {
      return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it2) && !hasOwn(it2, "flags") ? call(regExpFlagsGetterImplementation, it2) : it2.flags;
    };
    return regexpGetFlags;
  }
  var regexpExecAbstract;
  var hasRequiredRegexpExecAbstract;
  function requireRegexpExecAbstract() {
    if (hasRequiredRegexpExecAbstract) return regexpExecAbstract;
    hasRequiredRegexpExecAbstract = 1;
    var call = requireFunctionCall();
    var anObject2 = requireAnObject();
    var isCallable2 = requireIsCallable();
    var classof2 = requireClassofRaw();
    var regexpExec2 = requireRegexpExec();
    var $TypeError = TypeError;
    regexpExecAbstract = function(R2, S2) {
      var exec = R2.exec;
      if (isCallable2(exec)) {
        var result = call(exec, R2, S2);
        if (result !== null) anObject2(result);
        return result;
      }
      if (classof2(R2) === "RegExp") return call(regexpExec2, R2, S2);
      throw new $TypeError("RegExp#exec called on incompatible receiver");
    };
    return regexpExecAbstract;
  }
  var hasRequiredEs_string_match;
  function requireEs_string_match() {
    if (hasRequiredEs_string_match) return es_string_match;
    hasRequiredEs_string_match = 1;
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
    var anObject2 = requireAnObject();
    var isObject2 = requireIsObject();
    var toLength2 = requireToLength();
    var toString2 = requireToString();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var getMethod2 = requireGetMethod();
    var advanceStringIndex2 = requireAdvanceStringIndex();
    var getRegExpFlags = requireRegexpGetFlags();
    var regExpExec = requireRegexpExecAbstract();
    var stringIndexOf2 = uncurryThis("".indexOf);
    fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
      return [
        // `String.prototype.match` method
        // https://tc39.es/ecma262/#sec-string.prototype.match
        function match(regexp) {
          var O2 = requireObjectCoercible2(this);
          var matcher = isObject2(regexp) ? getMethod2(regexp, MATCH) : void 0;
          return matcher ? call(matcher, regexp, O2) : new RegExp(regexp)[MATCH](toString2(O2));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
        function(string) {
          var rx = anObject2(this);
          var S2 = toString2(string);
          var res = maybeCallNative(nativeMatch, rx, S2);
          if (res.done) return res.value;
          var flags = toString2(getRegExpFlags(rx));
          if (stringIndexOf2(flags, "g") === -1) return regExpExec(rx, S2);
          var fullUnicode = stringIndexOf2(flags, "u") !== -1;
          rx.lastIndex = 0;
          var A2 = [];
          var n2 = 0;
          var result;
          while ((result = regExpExec(rx, S2)) !== null) {
            var matchStr = toString2(result[0]);
            A2[n2] = matchStr;
            if (matchStr === "") rx.lastIndex = advanceStringIndex2(S2, toLength2(rx.lastIndex), fullUnicode);
            n2++;
          }
          return n2 === 0 ? null : A2;
        }
      ];
    });
    return es_string_match;
  }
  requireEs_string_match();
  var es_string_replace = {};
  var getSubstitution;
  var hasRequiredGetSubstitution;
  function requireGetSubstitution() {
    if (hasRequiredGetSubstitution) return getSubstitution;
    hasRequiredGetSubstitution = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var toObject2 = requireToObject();
    var floor = Math.floor;
    var charAt = uncurryThis("".charAt);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    getSubstitution = function(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m2 = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject2(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace(replacement, symbols, function(match, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice(str, 0, position);
          case "'":
            return stringSlice(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n2 = +ch;
            if (n2 === 0) return match;
            if (n2 > m2) {
              var f2 = floor(n2 / 10);
              if (f2 === 0) return match;
              if (f2 <= m2) return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);
              return match;
            }
            capture = captures[n2 - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
    return getSubstitution;
  }
  var hasRequiredEs_string_replace;
  function requireEs_string_replace() {
    if (hasRequiredEs_string_replace) return es_string_replace;
    hasRequiredEs_string_replace = 1;
    var apply2 = requireFunctionApply();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
    var fails2 = requireFails();
    var anObject2 = requireAnObject();
    var isCallable2 = requireIsCallable();
    var isObject2 = requireIsObject();
    var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
    var toLength2 = requireToLength();
    var toString2 = requireToString();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var advanceStringIndex2 = requireAdvanceStringIndex();
    var getMethod2 = requireGetMethod();
    var getSubstitution2 = requireGetSubstitution();
    var getRegExpFlags = requireRegexpGetFlags();
    var regExpExec = requireRegexpExecAbstract();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var REPLACE = wellKnownSymbol2("replace");
    var max2 = Math.max;
    var min = Math.min;
    var concat = uncurryThis([].concat);
    var push = uncurryThis([].push);
    var stringIndexOf2 = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var maybeToString = function(it2) {
      return it2 === void 0 ? it2 : String(it2);
    };
    var REPLACE_KEEPS_$0 = (function() {
      return "a".replace(/./, "$0") === "$0";
    })();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    })();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails2(function() {
      var re2 = /./;
      re2.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re2, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_2, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
          var O2 = requireObjectCoercible2(this);
          var replacer = isObject2(searchValue) ? getMethod2(searchValue, REPLACE) : void 0;
          return replacer ? call(replacer, searchValue, O2, replaceValue) : call(nativeReplace, toString2(O2), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string, replaceValue) {
          var rx = anObject2(this);
          var S2 = toString2(string);
          if (typeof replaceValue == "string" && stringIndexOf2(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf2(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace, rx, S2, replaceValue);
            if (res.done) return res.value;
          }
          var functionalReplace = isCallable2(replaceValue);
          if (!functionalReplace) replaceValue = toString2(replaceValue);
          var flags = toString2(getRegExpFlags(rx));
          var global2 = stringIndexOf2(flags, "g") !== -1;
          var fullUnicode;
          if (global2) {
            fullUnicode = stringIndexOf2(flags, "u") !== -1;
            rx.lastIndex = 0;
          }
          var results = [];
          var result;
          while (true) {
            result = regExpExec(rx, S2);
            if (result === null) break;
            push(results, result);
            if (!global2) break;
            var matchStr = toString2(result[0]);
            if (matchStr === "") rx.lastIndex = advanceStringIndex2(S2, toLength2(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i2 = 0; i2 < results.length; i2++) {
            result = results[i2];
            var matched = toString2(result[0]);
            var position = max2(min(toIntegerOrInfinity2(result.index), S2.length), 0);
            var captures = [];
            var replacement;
            for (var j2 = 1; j2 < result.length; j2++) push(captures, maybeToString(result[j2]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat([matched], captures, position, S2);
              if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
              replacement = toString2(apply2(replaceValue, void 0, replacerArgs));
            } else {
              replacement = getSubstitution2(matched, S2, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += stringSlice(S2, nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + stringSlice(S2, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
    return es_string_replace;
  }
  requireEs_string_replace();
  var es_string_startsWith = {};
  var isRegexp;
  var hasRequiredIsRegexp;
  function requireIsRegexp() {
    if (hasRequiredIsRegexp) return isRegexp;
    hasRequiredIsRegexp = 1;
    var isObject2 = requireIsObject();
    var classof2 = requireClassofRaw();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var MATCH = wellKnownSymbol2("match");
    isRegexp = function(it2) {
      var isRegExp;
      return isObject2(it2) && ((isRegExp = it2[MATCH]) !== void 0 ? !!isRegExp : classof2(it2) === "RegExp");
    };
    return isRegexp;
  }
  var notARegexp;
  var hasRequiredNotARegexp;
  function requireNotARegexp() {
    if (hasRequiredNotARegexp) return notARegexp;
    hasRequiredNotARegexp = 1;
    var isRegExp = requireIsRegexp();
    var $TypeError = TypeError;
    notARegexp = function(it2) {
      if (isRegExp(it2)) {
        throw new $TypeError("The method doesn't accept regular expressions");
      }
      return it2;
    };
    return notARegexp;
  }
  var correctIsRegexpLogic;
  var hasRequiredCorrectIsRegexpLogic;
  function requireCorrectIsRegexpLogic() {
    if (hasRequiredCorrectIsRegexpLogic) return correctIsRegexpLogic;
    hasRequiredCorrectIsRegexpLogic = 1;
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var MATCH = wellKnownSymbol2("match");
    correctIsRegexpLogic = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
    return correctIsRegexpLogic;
  }
  var hasRequiredEs_string_startsWith;
  function requireEs_string_startsWith() {
    if (hasRequiredEs_string_startsWith) return es_string_startsWith;
    hasRequiredEs_string_startsWith = 1;
    var $2 = require_export();
    var uncurryThis = requireFunctionUncurryThisClause();
    var getOwnPropertyDescriptor2 = requireObjectGetOwnPropertyDescriptor().f;
    var toLength2 = requireToLength();
    var toString2 = requireToString();
    var notARegExp = requireNotARegexp();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
    var IS_PURE = requireIsPure();
    var stringSlice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!(function() {
      var descriptor = getOwnPropertyDescriptor2(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    })();
    $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString2(requireObjectCoercible2(this));
        notARegExp(searchString);
        var index2 = toLength2(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = toString2(searchString);
        return stringSlice(that, index2, index2 + search.length) === search;
      }
    });
    return es_string_startsWith;
  }
  requireEs_string_startsWith();
  var addToUnscopables;
  var hasRequiredAddToUnscopables;
  function requireAddToUnscopables() {
    if (hasRequiredAddToUnscopables) return addToUnscopables;
    hasRequiredAddToUnscopables = 1;
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var create2 = requireObjectCreate();
    var defineProperty = requireObjectDefineProperty().f;
    var UNSCOPABLES = wellKnownSymbol2("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === void 0) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create2(null)
      });
    }
    addToUnscopables = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
    return addToUnscopables;
  }
  var correctPrototypeGetter;
  var hasRequiredCorrectPrototypeGetter;
  function requireCorrectPrototypeGetter() {
    if (hasRequiredCorrectPrototypeGetter) return correctPrototypeGetter;
    hasRequiredCorrectPrototypeGetter = 1;
    var fails2 = requireFails();
    correctPrototypeGetter = !fails2(function() {
      function F2() {
      }
      F2.prototype.constructor = null;
      return Object.getPrototypeOf(new F2()) !== F2.prototype;
    });
    return correctPrototypeGetter;
  }
  var objectGetPrototypeOf;
  var hasRequiredObjectGetPrototypeOf;
  function requireObjectGetPrototypeOf() {
    if (hasRequiredObjectGetPrototypeOf) return objectGetPrototypeOf;
    hasRequiredObjectGetPrototypeOf = 1;
    var hasOwn = requireHasOwnProperty();
    var isCallable2 = requireIsCallable();
    var toObject2 = requireToObject();
    var sharedKey2 = requireSharedKey();
    var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();
    var IE_PROTO = sharedKey2("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O2) {
      var object = toObject2(O2);
      if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable2(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
    return objectGetPrototypeOf;
  }
  var iteratorsCore;
  var hasRequiredIteratorsCore;
  function requireIteratorsCore() {
    if (hasRequiredIteratorsCore) return iteratorsCore;
    hasRequiredIteratorsCore = 1;
    var fails2 = requireFails();
    var isCallable2 = requireIsCallable();
    var isObject2 = requireIsObject();
    var create2 = requireObjectCreate();
    var getPrototypeOf2 = requireObjectGetPrototypeOf();
    var defineBuiltIn2 = requireDefineBuiltIn();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var IS_PURE = requireIsPure();
    var ITERATOR = wellKnownSymbol2("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf2(getPrototypeOf2(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject2(IteratorPrototype) || fails2(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
    else if (IS_PURE) IteratorPrototype = create2(IteratorPrototype);
    if (!isCallable2(IteratorPrototype[ITERATOR])) {
      defineBuiltIn2(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    iteratorsCore = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
    return iteratorsCore;
  }
  var iteratorCreateConstructor;
  var hasRequiredIteratorCreateConstructor;
  function requireIteratorCreateConstructor() {
    if (hasRequiredIteratorCreateConstructor) return iteratorCreateConstructor;
    hasRequiredIteratorCreateConstructor = 1;
    var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
    var create2 = requireObjectCreate();
    var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
    var setToStringTag2 = requireSetToStringTag();
    var Iterators = requireIterators();
    var returnThis = function() {
      return this;
    };
    iteratorCreateConstructor = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor2(+!ENUMERABLE_NEXT, next) });
      setToStringTag2(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
    return iteratorCreateConstructor;
  }
  var iteratorDefine;
  var hasRequiredIteratorDefine;
  function requireIteratorDefine() {
    if (hasRequiredIteratorDefine) return iteratorDefine;
    hasRequiredIteratorDefine = 1;
    var $2 = require_export();
    var call = requireFunctionCall();
    var IS_PURE = requireIsPure();
    var FunctionName = requireFunctionName();
    var isCallable2 = requireIsCallable();
    var createIteratorConstructor = requireIteratorCreateConstructor();
    var getPrototypeOf2 = requireObjectGetPrototypeOf();
    var setPrototypeOf2 = requireObjectSetPrototypeOf();
    var setToStringTag2 = requireSetToStringTag();
    var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
    var defineBuiltIn2 = requireDefineBuiltIn();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var Iterators = requireIterators();
    var IteratorsCore = requireIteratorsCore();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol2("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    iteratorDefine = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries2() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf2(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf2(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf2) {
              setPrototypeOf2(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable2(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn2(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag2(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty2(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn2(IterablePrototype, KEY, methods[KEY]);
          }
        }
        else $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn2(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME] = defaultIterator;
      return methods;
    };
    return iteratorDefine;
  }
  var createIterResultObject;
  var hasRequiredCreateIterResultObject;
  function requireCreateIterResultObject() {
    if (hasRequiredCreateIterResultObject) return createIterResultObject;
    hasRequiredCreateIterResultObject = 1;
    createIterResultObject = function(value, done) {
      return { value, done };
    };
    return createIterResultObject;
  }
  var es_array_iterator;
  var hasRequiredEs_array_iterator;
  function requireEs_array_iterator() {
    if (hasRequiredEs_array_iterator) return es_array_iterator;
    hasRequiredEs_array_iterator = 1;
    var toIndexedObject2 = requireToIndexedObject();
    var addToUnscopables2 = requireAddToUnscopables();
    var Iterators = requireIterators();
    var InternalStateModule = requireInternalState();
    var defineProperty = requireObjectDefineProperty().f;
    var defineIterator = requireIteratorDefine();
    var createIterResultObject2 = requireCreateIterResultObject();
    var IS_PURE = requireIsPure();
    var DESCRIPTORS = requireDescriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject2(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var index2 = state.index++;
      if (!target || index2 >= target.length) {
        state.target = null;
        return createIterResultObject2(void 0, true);
      }
      switch (state.kind) {
        case "keys":
          return createIterResultObject2(index2, false);
        case "values":
          return createIterResultObject2(target[index2], false);
      }
      return createIterResultObject2([index2, target[index2]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables2("keys");
    addToUnscopables2("values");
    addToUnscopables2("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values") try {
      defineProperty(values, "name", { value: "values" });
    } catch (error) {
    }
    return es_array_iterator;
  }
  requireEs_array_iterator();
  var web_domCollections_iterator = {};
  var domIterables;
  var hasRequiredDomIterables;
  function requireDomIterables() {
    if (hasRequiredDomIterables) return domIterables;
    hasRequiredDomIterables = 1;
    domIterables = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
    return domIterables;
  }
  var domTokenListPrototype;
  var hasRequiredDomTokenListPrototype;
  function requireDomTokenListPrototype() {
    if (hasRequiredDomTokenListPrototype) return domTokenListPrototype;
    hasRequiredDomTokenListPrototype = 1;
    var documentCreateElement2 = requireDocumentCreateElement();
    var classList = documentCreateElement2("span").classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
    return domTokenListPrototype;
  }
  var hasRequiredWeb_domCollections_iterator;
  function requireWeb_domCollections_iterator() {
    if (hasRequiredWeb_domCollections_iterator) return web_domCollections_iterator;
    hasRequiredWeb_domCollections_iterator = 1;
    var globalThis2 = requireGlobalThis();
    var DOMIterables = requireDomIterables();
    var DOMTokenListPrototype = requireDomTokenListPrototype();
    var ArrayIteratorMethods = requireEs_array_iterator();
    var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
    var setToStringTag2 = requireSetToStringTag();
    var wellKnownSymbol2 = requireWellKnownSymbol();
    var ITERATOR = wellKnownSymbol2("iterator");
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
          createNonEnumerableProperty2(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
          CollectionPrototype[ITERATOR] = ArrayValues;
        }
        setToStringTag2(CollectionPrototype, COLLECTION_NAME2, true);
        if (DOMIterables[COLLECTION_NAME2]) for (var METHOD_NAME in ArrayIteratorMethods) {
          if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
            createNonEnumerableProperty2(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
        }
      }
    };
    for (var COLLECTION_NAME in DOMIterables) {
      handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
    return web_domCollections_iterator;
  }
  requireWeb_domCollections_iterator();
  function toPrimitive(t3, r2) {
    if ("object" != _typeof$1(t3) || !t3) return t3;
    var e2 = t3[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t3, r2);
      if ("object" != _typeof$1(i2)) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t3);
  }
  function toPropertyKey(t3) {
    var i2 = toPrimitive(t3, "string");
    return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
  }
  function _defineProperty(e2, r2, t3) {
    return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
      value: t3,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e2[r2] = t3, e2;
  }
  var es_array_reduce = {};
  var arrayReduce;
  var hasRequiredArrayReduce;
  function requireArrayReduce() {
    if (hasRequiredArrayReduce) return arrayReduce;
    hasRequiredArrayReduce = 1;
    var aCallable2 = requireACallable();
    var toObject2 = requireToObject();
    var IndexedObject = requireIndexedObject();
    var lengthOfArrayLike2 = requireLengthOfArrayLike();
    var $TypeError = TypeError;
    var REDUCE_EMPTY = "Reduce of empty array with no initial value";
    var createMethod = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        var O2 = toObject2(that);
        var self2 = IndexedObject(O2);
        var length = lengthOfArrayLike2(O2);
        aCallable2(callbackfn);
        if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
        var index2 = IS_RIGHT ? length - 1 : 0;
        var i2 = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2) while (true) {
          if (index2 in self2) {
            memo = self2[index2];
            index2 += i2;
            break;
          }
          index2 += i2;
          if (IS_RIGHT ? index2 < 0 : length <= index2) {
            throw new $TypeError(REDUCE_EMPTY);
          }
        }
        for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i2) if (index2 in self2) {
          memo = callbackfn(memo, self2[index2], index2, O2);
        }
        return memo;
      };
    };
    arrayReduce = {
      // `Array.prototype.reduce` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
    return arrayReduce;
  }
  var arrayMethodIsStrict;
  var hasRequiredArrayMethodIsStrict;
  function requireArrayMethodIsStrict() {
    if (hasRequiredArrayMethodIsStrict) return arrayMethodIsStrict;
    hasRequiredArrayMethodIsStrict = 1;
    var fails2 = requireFails();
    arrayMethodIsStrict = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails2(function() {
        method.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
    return arrayMethodIsStrict;
  }
  var hasRequiredEs_array_reduce;
  function requireEs_array_reduce() {
    if (hasRequiredEs_array_reduce) return es_array_reduce;
    hasRequiredEs_array_reduce = 1;
    var $2 = require_export();
    var $reduce = requireArrayReduce().left;
    var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
    var CHROME_VERSION = requireEnvironmentV8Version();
    var IS_NODE = requireEnvironmentIsNode();
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    var FORCED = CHROME_BUG || !arrayMethodIsStrict2("reduce");
    $2({ target: "Array", proto: true, forced: FORCED }, {
      reduce: function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
      }
    });
    return es_array_reduce;
  }
  requireEs_array_reduce();
  var es_string_endsWith = {};
  var hasRequiredEs_string_endsWith;
  function requireEs_string_endsWith() {
    if (hasRequiredEs_string_endsWith) return es_string_endsWith;
    hasRequiredEs_string_endsWith = 1;
    var $2 = require_export();
    var uncurryThis = requireFunctionUncurryThisClause();
    var getOwnPropertyDescriptor2 = requireObjectGetOwnPropertyDescriptor().f;
    var toLength2 = requireToLength();
    var toString2 = requireToString();
    var notARegExp = requireNotARegexp();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
    var IS_PURE = requireIsPure();
    var slice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!(function() {
      var descriptor = getOwnPropertyDescriptor2(String.prototype, "endsWith");
      return descriptor && !descriptor.writable;
    })();
    $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      endsWith: function endsWith(searchString) {
        var that = toString2(requireObjectCoercible2(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : void 0;
        var len = that.length;
        var end = endPosition === void 0 ? len : min(toLength2(endPosition), len);
        var search = toString2(searchString);
        return slice(that, end - search.length, end) === search;
      }
    });
    return es_string_endsWith;
  }
  requireEs_string_endsWith();
  var es_string_split = {};
  var hasRequiredEs_string_split;
  function requireEs_string_split() {
    if (hasRequiredEs_string_split) return es_string_split;
    hasRequiredEs_string_split = 1;
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
    var anObject2 = requireAnObject();
    var isObject2 = requireIsObject();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var speciesConstructor2 = requireSpeciesConstructor();
    var advanceStringIndex2 = requireAdvanceStringIndex();
    var toLength2 = requireToLength();
    var toString2 = requireToString();
    var getMethod2 = requireGetMethod();
    var regExpExec = requireRegexpExecAbstract();
    var stickyHelpers = requireRegexpStickyHelpers();
    var fails2 = requireFails();
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var MAX_UINT32 = 4294967295;
    var min = Math.min;
    var push = uncurryThis([].push);
    var stringSlice = uncurryThis("".slice);
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails2(function() {
      var re2 = /(?:)/;
      var originalExec = re2.exec;
      re2.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re2);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
    "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    ".".split(/()()/).length > 1 || "".split(/.?/).length;
    fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
        return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
      } : nativeSplit;
      return [
        // `String.prototype.split` method
        // https://tc39.es/ecma262/#sec-string.prototype.split
        function split(separator, limit) {
          var O2 = requireObjectCoercible2(this);
          var splitter = isObject2(separator) ? getMethod2(separator, SPLIT) : void 0;
          return splitter ? call(splitter, separator, O2, limit) : call(internalSplit, toString2(O2), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(string, limit) {
          var rx = anObject2(this);
          var S2 = toString2(string);
          if (!BUGGY) {
            var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
            if (res.done) return res.value;
          }
          var C2 = speciesConstructor2(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0) return [];
          if (S2.length === 0) return regExpExec(splitter, S2) === null ? [S2] : [];
          var p2 = 0;
          var q2 = 0;
          var A2 = [];
          while (q2 < S2.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
            var z2 = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q2) : S2);
            var e2;
            if (z2 === null || (e2 = min(toLength2(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p2) {
              q2 = advanceStringIndex2(S2, q2, unicodeMatching);
            } else {
              push(A2, stringSlice(S2, p2, q2));
              if (A2.length === lim) return A2;
              for (var i2 = 1; i2 <= z2.length - 1; i2++) {
                push(A2, z2[i2]);
                if (A2.length === lim) return A2;
              }
              q2 = p2 = e2;
            }
          }
          push(A2, stringSlice(S2, p2));
          return A2;
        }
      ];
    }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
    return es_string_split;
  }
  requireEs_string_split();
  var raf = { exports: {} };
  var performanceNow$1 = { exports: {} };
  var performanceNow = performanceNow$1.exports;
  var hasRequiredPerformanceNow;
  function requirePerformanceNow() {
    if (hasRequiredPerformanceNow) return performanceNow$1.exports;
    hasRequiredPerformanceNow = 1;
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        performanceNow$1.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        performanceNow$1.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        performanceNow$1.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        performanceNow$1.exports = function() {
          return (/* @__PURE__ */ new Date()).getTime() - loadTime;
        };
        loadTime = (/* @__PURE__ */ new Date()).getTime();
      }
    }).call(performanceNow);
    return performanceNow$1.exports;
  }
  var hasRequiredRaf;
  function requireRaf() {
    if (hasRequiredRaf) return raf.exports;
    hasRequiredRaf = 1;
    var now = requirePerformanceNow(), root = typeof window === "undefined" ? commonjsGlobal : window, vendors = ["moz", "webkit"], suffix = "AnimationFrame", raf$1 = root["request" + suffix], caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
    for (var i2 = 0; !raf$1 && i2 < vendors.length; i2++) {
      raf$1 = root[vendors[i2] + "Request" + suffix];
      caf = root[vendors[i2] + "Cancel" + suffix] || root[vendors[i2] + "CancelRequest" + suffix];
    }
    if (!raf$1 || !caf) {
      var last = 0, id = 0, queue2 = [], frameDuration = 1e3 / 60;
      raf$1 = function(callback) {
        if (queue2.length === 0) {
          var _now = now(), next = Math.max(0, frameDuration - (_now - last));
          last = next + _now;
          setTimeout(function() {
            var cp = queue2.slice(0);
            queue2.length = 0;
            for (var i3 = 0; i3 < cp.length; i3++) {
              if (!cp[i3].cancelled) {
                try {
                  cp[i3].callback(last);
                } catch (e2) {
                  setTimeout(function() {
                    throw e2;
                  }, 0);
                }
              }
            }
          }, Math.round(next));
        }
        queue2.push({
          handle: ++id,
          callback,
          cancelled: false
        });
        return id;
      };
      caf = function(handle) {
        for (var i3 = 0; i3 < queue2.length; i3++) {
          if (queue2[i3].handle === handle) {
            queue2[i3].cancelled = true;
          }
        }
      };
    }
    raf.exports = function(fn) {
      return raf$1.call(root, fn);
    };
    raf.exports.cancel = function() {
      caf.apply(root, arguments);
    };
    raf.exports.polyfill = function(object) {
      if (!object) {
        object = root;
      }
      object.requestAnimationFrame = raf$1;
      object.cancelAnimationFrame = caf;
    };
    return raf.exports;
  }
  var rafExports = requireRaf();
  var requestAnimationFrame = /* @__PURE__ */ getDefaultExportFromCjs(rafExports);
  var es_string_trim = {};
  var whitespaces;
  var hasRequiredWhitespaces;
  function requireWhitespaces() {
    if (hasRequiredWhitespaces) return whitespaces;
    hasRequiredWhitespaces = 1;
    whitespaces = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    return whitespaces;
  }
  var stringTrim;
  var hasRequiredStringTrim;
  function requireStringTrim() {
    if (hasRequiredStringTrim) return stringTrim;
    hasRequiredStringTrim = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var toString2 = requireToString();
    var whitespaces2 = requireWhitespaces();
    var replace = uncurryThis("".replace);
    var ltrim = RegExp("^[" + whitespaces2 + "]+");
    var rtrim = RegExp("(^|[^" + whitespaces2 + "])[" + whitespaces2 + "]+$");
    var createMethod = function(TYPE) {
      return function($this) {
        var string = toString2(requireObjectCoercible2($this));
        if (TYPE & 1) string = replace(string, ltrim, "");
        if (TYPE & 2) string = replace(string, rtrim, "$1");
        return string;
      };
    };
    stringTrim = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
    return stringTrim;
  }
  var stringTrimForced;
  var hasRequiredStringTrimForced;
  function requireStringTrimForced() {
    if (hasRequiredStringTrimForced) return stringTrimForced;
    hasRequiredStringTrimForced = 1;
    var PROPER_FUNCTION_NAME = requireFunctionName().PROPER;
    var fails2 = requireFails();
    var whitespaces2 = requireWhitespaces();
    var non = "\u200B\x85\u180E";
    stringTrimForced = function(METHOD_NAME) {
      return fails2(function() {
        return !!whitespaces2[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces2[METHOD_NAME].name !== METHOD_NAME;
      });
    };
    return stringTrimForced;
  }
  var hasRequiredEs_string_trim;
  function requireEs_string_trim() {
    if (hasRequiredEs_string_trim) return es_string_trim;
    hasRequiredEs_string_trim = 1;
    var $2 = require_export();
    var $trim = requireStringTrim().trim;
    var forcedStringTrimMethod = requireStringTrimForced();
    $2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim() {
        return $trim(this);
      }
    });
    return es_string_trim;
  }
  requireEs_string_trim();
  var rgbcolor;
  var hasRequiredRgbcolor;
  function requireRgbcolor() {
    if (hasRequiredRgbcolor) return rgbcolor;
    hasRequiredRgbcolor = 1;
    rgbcolor = function(color_string) {
      this.ok = false;
      this.alpha = 1;
      if (color_string.charAt(0) == "#") {
        color_string = color_string.substr(1, 6);
      }
      color_string = color_string.replace(/ /g, "");
      color_string = color_string.toLowerCase();
      var simple_colors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
      };
      color_string = simple_colors[color_string] || color_string;
      var color_defs = [{
        re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
        example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
        process: function(bits3) {
          return [parseInt(bits3[1]), parseInt(bits3[2]), parseInt(bits3[3]), parseFloat(bits3[4])];
        }
      }, {
        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
        example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
        process: function(bits3) {
          return [parseInt(bits3[1]), parseInt(bits3[2]), parseInt(bits3[3])];
        }
      }, {
        re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        example: ["#00ff00", "336699"],
        process: function(bits3) {
          return [parseInt(bits3[1], 16), parseInt(bits3[2], 16), parseInt(bits3[3], 16)];
        }
      }, {
        re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        example: ["#fb0", "f0f"],
        process: function(bits3) {
          return [parseInt(bits3[1] + bits3[1], 16), parseInt(bits3[2] + bits3[2], 16), parseInt(bits3[3] + bits3[3], 16)];
        }
      }];
      for (var i2 = 0; i2 < color_defs.length; i2++) {
        var re2 = color_defs[i2].re;
        var processor = color_defs[i2].process;
        var bits2 = re2.exec(color_string);
        if (bits2) {
          var channels = processor(bits2);
          this.r = channels[0];
          this.g = channels[1];
          this.b = channels[2];
          if (channels.length > 3) {
            this.alpha = channels[3];
          }
          this.ok = true;
        }
      }
      this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
      this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
      this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
      this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
      this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
      };
      this.toRGBA = function() {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
      };
      this.toHex = function() {
        var r2 = this.r.toString(16);
        var g2 = this.g.toString(16);
        var b2 = this.b.toString(16);
        if (r2.length == 1) r2 = "0" + r2;
        if (g2.length == 1) g2 = "0" + g2;
        if (b2.length == 1) b2 = "0" + b2;
        return "#" + r2 + g2 + b2;
      };
      this.getHelpXML = function() {
        var examples = new Array();
        for (var i3 = 0; i3 < color_defs.length; i3++) {
          var example = color_defs[i3].example;
          for (var j2 = 0; j2 < example.length; j2++) {
            examples[examples.length] = example[j2];
          }
        }
        for (var sc in simple_colors) {
          examples[examples.length] = sc;
        }
        var xml2 = document.createElement("ul");
        xml2.setAttribute("id", "rgbcolor-examples");
        for (var i3 = 0; i3 < examples.length; i3++) {
          try {
            var list_item = document.createElement("li");
            var list_color = new RGBColor(examples[i3]);
            var example_div = document.createElement("div");
            example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex();
            example_div.appendChild(document.createTextNode("test"));
            var list_item_value = document.createTextNode(" " + examples[i3] + " -> " + list_color.toRGB() + " -> " + list_color.toHex());
            list_item.appendChild(example_div);
            list_item.appendChild(list_item_value);
            xml2.appendChild(list_item);
          } catch (e2) {
          }
        }
        return xml2;
      };
    };
    return rgbcolor;
  }
  var rgbcolorExports = requireRgbcolor();
  var RGBColor$1 = /* @__PURE__ */ getDefaultExportFromCjs(rgbcolorExports);
  var es_array_indexOf = {};
  var hasRequiredEs_array_indexOf;
  function requireEs_array_indexOf() {
    if (hasRequiredEs_array_indexOf) return es_array_indexOf;
    hasRequiredEs_array_indexOf = 1;
    var $2 = require_export();
    var uncurryThis = requireFunctionUncurryThisClause();
    var $indexOf = requireArrayIncludes().indexOf;
    var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
    var nativeIndexOf = uncurryThis([].indexOf);
    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
    var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict2("indexOf");
    $2({ target: "Array", proto: true, forced: FORCED }, {
      indexOf: function indexOf(searchElement) {
        var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
        return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
      }
    });
    return es_array_indexOf;
  }
  requireEs_array_indexOf();
  var es_string_includes = {};
  var hasRequiredEs_string_includes;
  function requireEs_string_includes() {
    if (hasRequiredEs_string_includes) return es_string_includes;
    hasRequiredEs_string_includes = 1;
    var $2 = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var notARegExp = requireNotARegexp();
    var requireObjectCoercible2 = requireRequireObjectCoercible();
    var toString2 = requireToString();
    var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
    var stringIndexOf2 = uncurryThis("".indexOf);
    $2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf2(
          toString2(requireObjectCoercible2(this)),
          toString2(notARegExp(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
    return es_string_includes;
  }
  requireEs_string_includes();
  var es_array_reverse = {};
  var isArray;
  var hasRequiredIsArray;
  function requireIsArray() {
    if (hasRequiredIsArray) return isArray;
    hasRequiredIsArray = 1;
    var classof2 = requireClassofRaw();
    isArray = Array.isArray || function isArray2(argument) {
      return classof2(argument) === "Array";
    };
    return isArray;
  }
  var hasRequiredEs_array_reverse;
  function requireEs_array_reverse() {
    if (hasRequiredEs_array_reverse) return es_array_reverse;
    hasRequiredEs_array_reverse = 1;
    var $2 = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var isArray2 = requireIsArray();
    var nativeReverse = uncurryThis([].reverse);
    var test = [1, 2];
    $2({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
      reverse: function reverse() {
        if (isArray2(this)) this.length = this.length;
        return nativeReverse(this);
      }
    });
    return es_array_reverse;
  }
  requireEs_array_reverse();
  var t2 = function(r2, e2) {
    return (t2 = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(t3, r3) {
      t3.__proto__ = r3;
    } || function(t3, r3) {
      for (var e3 in r3) Object.prototype.hasOwnProperty.call(r3, e3) && (t3[e3] = r3[e3]);
    })(r2, e2);
  };
  function r(r2, e2) {
    if ("function" != typeof e2 && null !== e2) throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
    function i2() {
      this.constructor = r2;
    }
    t2(r2, e2), r2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  function e(t3) {
    var r2 = "";
    Array.isArray(t3) || (t3 = [t3]);
    for (var e2 = 0; e2 < t3.length; e2++) {
      var i2 = t3[e2];
      if (i2.type === _.CLOSE_PATH) r2 += "z";
      else if (i2.type === _.HORIZ_LINE_TO) r2 += (i2.relative ? "h" : "H") + i2.x;
      else if (i2.type === _.VERT_LINE_TO) r2 += (i2.relative ? "v" : "V") + i2.y;
      else if (i2.type === _.MOVE_TO) r2 += (i2.relative ? "m" : "M") + i2.x + " " + i2.y;
      else if (i2.type === _.LINE_TO) r2 += (i2.relative ? "l" : "L") + i2.x + " " + i2.y;
      else if (i2.type === _.CURVE_TO) r2 += (i2.relative ? "c" : "C") + i2.x1 + " " + i2.y1 + " " + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
      else if (i2.type === _.SMOOTH_CURVE_TO) r2 += (i2.relative ? "s" : "S") + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
      else if (i2.type === _.QUAD_TO) r2 += (i2.relative ? "q" : "Q") + i2.x1 + " " + i2.y1 + " " + i2.x + " " + i2.y;
      else if (i2.type === _.SMOOTH_QUAD_TO) r2 += (i2.relative ? "t" : "T") + i2.x + " " + i2.y;
      else {
        if (i2.type !== _.ARC) throw new Error('Unexpected command type "' + i2.type + '" at index ' + e2 + ".");
        r2 += (i2.relative ? "a" : "A") + i2.rX + " " + i2.rY + " " + i2.xRot + " " + +i2.lArcFlag + " " + +i2.sweepFlag + " " + i2.x + " " + i2.y;
      }
    }
    return r2;
  }
  function i(t3, r2) {
    var e2 = t3[0], i2 = t3[1];
    return [e2 * Math.cos(r2) - i2 * Math.sin(r2), e2 * Math.sin(r2) + i2 * Math.cos(r2)];
  }
  function a() {
    for (var t3 = [], r2 = 0; r2 < arguments.length; r2++) t3[r2] = arguments[r2];
    for (var e2 = 0; e2 < t3.length; e2++) if ("number" != typeof t3[e2]) throw new Error("assertNumbers arguments[" + e2 + "] is not a number. " + typeof t3[e2] + " == typeof " + t3[e2]);
    return true;
  }
  var n = Math.PI;
  function o(t3, r2, e2) {
    t3.lArcFlag = 0 === t3.lArcFlag ? 0 : 1, t3.sweepFlag = 0 === t3.sweepFlag ? 0 : 1;
    var a2 = t3.rX, o2 = t3.rY, s2 = t3.x, u2 = t3.y;
    a2 = Math.abs(t3.rX), o2 = Math.abs(t3.rY);
    var h2 = i([(r2 - s2) / 2, (e2 - u2) / 2], -t3.xRot / 180 * n), c2 = h2[0], y2 = h2[1], p2 = Math.pow(c2, 2) / Math.pow(a2, 2) + Math.pow(y2, 2) / Math.pow(o2, 2);
    1 < p2 && (a2 *= Math.sqrt(p2), o2 *= Math.sqrt(p2)), t3.rX = a2, t3.rY = o2;
    var m2 = Math.pow(a2, 2) * Math.pow(y2, 2) + Math.pow(o2, 2) * Math.pow(c2, 2), O2 = (t3.lArcFlag !== t3.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a2, 2) * Math.pow(o2, 2) - m2) / m2)), l2 = a2 * y2 / o2 * O2, T2 = -o2 * c2 / a2 * O2, v2 = i([l2, T2], t3.xRot / 180 * n);
    t3.cX = v2[0] + (r2 + s2) / 2, t3.cY = v2[1] + (e2 + u2) / 2, t3.phi1 = Math.atan2((y2 - T2) / o2, (c2 - l2) / a2), t3.phi2 = Math.atan2((-y2 - T2) / o2, (-c2 - l2) / a2), 0 === t3.sweepFlag && t3.phi2 > t3.phi1 && (t3.phi2 -= 2 * n), 1 === t3.sweepFlag && t3.phi2 < t3.phi1 && (t3.phi2 += 2 * n), t3.phi1 *= 180 / n, t3.phi2 *= 180 / n;
  }
  function s(t3, r2, e2) {
    a(t3, r2, e2);
    var i2 = t3 * t3 + r2 * r2 - e2 * e2;
    if (0 > i2) return [];
    if (0 === i2) return [[t3 * e2 / (t3 * t3 + r2 * r2), r2 * e2 / (t3 * t3 + r2 * r2)]];
    var n2 = Math.sqrt(i2);
    return [[(t3 * e2 + r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 - t3 * n2) / (t3 * t3 + r2 * r2)], [(t3 * e2 - r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 + t3 * n2) / (t3 * t3 + r2 * r2)]];
  }
  var u;
  var h = Math.PI / 180;
  function c$1(t3, r2, e2) {
    return (1 - e2) * t3 + e2 * r2;
  }
  function y(t3, r2, e2, i2) {
    return t3 + Math.cos(i2 / 180 * n) * r2 + Math.sin(i2 / 180 * n) * e2;
  }
  function p(t3, r2, e2, i2) {
    var a2 = 1e-6, n2 = r2 - t3, o2 = e2 - r2, s2 = 3 * n2 + 3 * (i2 - e2) - 6 * o2, u2 = 6 * (o2 - n2), h2 = 3 * n2;
    return Math.abs(s2) < a2 ? [-h2 / u2] : (function(t4, r3, e3) {
      var i3 = t4 * t4 / 4 - r3;
      if (i3 < -e3) return [];
      if (i3 <= e3) return [-t4 / 2];
      var a3 = Math.sqrt(i3);
      return [-t4 / 2 - a3, -t4 / 2 + a3];
    })(u2 / s2, h2 / s2, a2);
  }
  function m$1(t3, r2, e2, i2, a2) {
    var n2 = 1 - a2;
    return t3 * (n2 * n2 * n2) + r2 * (3 * n2 * n2 * a2) + e2 * (3 * n2 * a2 * a2) + i2 * (a2 * a2 * a2);
  }
  !(function(t3) {
    function r2() {
      return u2(function(t4, r3, e3) {
        return t4.relative && (void 0 !== t4.x1 && (t4.x1 += r3), void 0 !== t4.y1 && (t4.y1 += e3), void 0 !== t4.x2 && (t4.x2 += r3), void 0 !== t4.y2 && (t4.y2 += e3), void 0 !== t4.x && (t4.x += r3), void 0 !== t4.y && (t4.y += e3), t4.relative = false), t4;
      });
    }
    function e2() {
      var t4 = NaN, r3 = NaN, e3 = NaN, i2 = NaN;
      return u2(function(a2, n3, o2) {
        return a2.type & _.SMOOTH_CURVE_TO && (a2.type = _.CURVE_TO, t4 = isNaN(t4) ? n3 : t4, r3 = isNaN(r3) ? o2 : r3, a2.x1 = a2.relative ? n3 - t4 : 2 * n3 - t4, a2.y1 = a2.relative ? o2 - r3 : 2 * o2 - r3), a2.type & _.CURVE_TO ? (t4 = a2.relative ? n3 + a2.x2 : a2.x2, r3 = a2.relative ? o2 + a2.y2 : a2.y2) : (t4 = NaN, r3 = NaN), a2.type & _.SMOOTH_QUAD_TO && (a2.type = _.QUAD_TO, e3 = isNaN(e3) ? n3 : e3, i2 = isNaN(i2) ? o2 : i2, a2.x1 = a2.relative ? n3 - e3 : 2 * n3 - e3, a2.y1 = a2.relative ? o2 - i2 : 2 * o2 - i2), a2.type & _.QUAD_TO ? (e3 = a2.relative ? n3 + a2.x1 : a2.x1, i2 = a2.relative ? o2 + a2.y1 : a2.y1) : (e3 = NaN, i2 = NaN), a2;
      });
    }
    function n2() {
      var t4 = NaN, r3 = NaN;
      return u2(function(e3, i2, a2) {
        if (e3.type & _.SMOOTH_QUAD_TO && (e3.type = _.QUAD_TO, t4 = isNaN(t4) ? i2 : t4, r3 = isNaN(r3) ? a2 : r3, e3.x1 = e3.relative ? i2 - t4 : 2 * i2 - t4, e3.y1 = e3.relative ? a2 - r3 : 2 * a2 - r3), e3.type & _.QUAD_TO) {
          t4 = e3.relative ? i2 + e3.x1 : e3.x1, r3 = e3.relative ? a2 + e3.y1 : e3.y1;
          var n3 = e3.x1, o2 = e3.y1;
          e3.type = _.CURVE_TO, e3.x1 = ((e3.relative ? 0 : i2) + 2 * n3) / 3, e3.y1 = ((e3.relative ? 0 : a2) + 2 * o2) / 3, e3.x2 = (e3.x + 2 * n3) / 3, e3.y2 = (e3.y + 2 * o2) / 3;
        } else t4 = NaN, r3 = NaN;
        return e3;
      });
    }
    function u2(t4) {
      var r3 = 0, e3 = 0, i2 = NaN, a2 = NaN;
      return function(n3) {
        if (isNaN(i2) && !(n3.type & _.MOVE_TO)) throw new Error("path must start with moveto");
        var o2 = t4(n3, r3, e3, i2, a2);
        return n3.type & _.CLOSE_PATH && (r3 = i2, e3 = a2), void 0 !== n3.x && (r3 = n3.relative ? r3 + n3.x : n3.x), void 0 !== n3.y && (e3 = n3.relative ? e3 + n3.y : n3.y), n3.type & _.MOVE_TO && (i2 = r3, a2 = e3), o2;
      };
    }
    function O2(t4, r3, e3, i2, n3, o2) {
      return a(t4, r3, e3, i2, n3, o2), u2(function(a2, s2, u3, h2) {
        var c2 = a2.x1, y2 = a2.x2, p2 = a2.relative && !isNaN(h2), m2 = void 0 !== a2.x ? a2.x : p2 ? 0 : s2, O3 = void 0 !== a2.y ? a2.y : p2 ? 0 : u3;
        function l3(t5) {
          return t5 * t5;
        }
        a2.type & _.HORIZ_LINE_TO && 0 !== r3 && (a2.type = _.LINE_TO, a2.y = a2.relative ? 0 : u3), a2.type & _.VERT_LINE_TO && 0 !== e3 && (a2.type = _.LINE_TO, a2.x = a2.relative ? 0 : s2), void 0 !== a2.x && (a2.x = a2.x * t4 + O3 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y && (a2.y = m2 * r3 + a2.y * i2 + (p2 ? 0 : o2)), void 0 !== a2.x1 && (a2.x1 = a2.x1 * t4 + a2.y1 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y1 && (a2.y1 = c2 * r3 + a2.y1 * i2 + (p2 ? 0 : o2)), void 0 !== a2.x2 && (a2.x2 = a2.x2 * t4 + a2.y2 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y2 && (a2.y2 = y2 * r3 + a2.y2 * i2 + (p2 ? 0 : o2));
        var T2 = t4 * i2 - r3 * e3;
        if (void 0 !== a2.xRot && (1 !== t4 || 0 !== r3 || 0 !== e3 || 1 !== i2)) if (0 === T2) delete a2.rX, delete a2.rY, delete a2.xRot, delete a2.lArcFlag, delete a2.sweepFlag, a2.type = _.LINE_TO;
        else {
          var v2 = a2.xRot * Math.PI / 180, f2 = Math.sin(v2), N2 = Math.cos(v2), x2 = 1 / l3(a2.rX), d2 = 1 / l3(a2.rY), E2 = l3(N2) * x2 + l3(f2) * d2, A2 = 2 * f2 * N2 * (x2 - d2), C2 = l3(f2) * x2 + l3(N2) * d2, M2 = E2 * i2 * i2 - A2 * r3 * i2 + C2 * r3 * r3, R2 = A2 * (t4 * i2 + r3 * e3) - 2 * (E2 * e3 * i2 + C2 * t4 * r3), g2 = E2 * e3 * e3 - A2 * t4 * e3 + C2 * t4 * t4, I2 = (Math.atan2(R2, M2 - g2) + Math.PI) % Math.PI / 2, S2 = Math.sin(I2), L2 = Math.cos(I2);
          a2.rX = Math.abs(T2) / Math.sqrt(M2 * l3(L2) + R2 * S2 * L2 + g2 * l3(S2)), a2.rY = Math.abs(T2) / Math.sqrt(M2 * l3(S2) - R2 * S2 * L2 + g2 * l3(L2)), a2.xRot = 180 * I2 / Math.PI;
        }
        return void 0 !== a2.sweepFlag && 0 > T2 && (a2.sweepFlag = +!a2.sweepFlag), a2;
      });
    }
    function l2() {
      return function(t4) {
        var r3 = {};
        for (var e3 in t4) r3[e3] = t4[e3];
        return r3;
      };
    }
    t3.ROUND = function(t4) {
      function r3(r4) {
        return Math.round(r4 * t4) / t4;
      }
      return void 0 === t4 && (t4 = 1e13), a(t4), function(t5) {
        return void 0 !== t5.x1 && (t5.x1 = r3(t5.x1)), void 0 !== t5.y1 && (t5.y1 = r3(t5.y1)), void 0 !== t5.x2 && (t5.x2 = r3(t5.x2)), void 0 !== t5.y2 && (t5.y2 = r3(t5.y2)), void 0 !== t5.x && (t5.x = r3(t5.x)), void 0 !== t5.y && (t5.y = r3(t5.y)), void 0 !== t5.rX && (t5.rX = r3(t5.rX)), void 0 !== t5.rY && (t5.rY = r3(t5.rY)), t5;
      };
    }, t3.TO_ABS = r2, t3.TO_REL = function() {
      return u2(function(t4, r3, e3) {
        return t4.relative || (void 0 !== t4.x1 && (t4.x1 -= r3), void 0 !== t4.y1 && (t4.y1 -= e3), void 0 !== t4.x2 && (t4.x2 -= r3), void 0 !== t4.y2 && (t4.y2 -= e3), void 0 !== t4.x && (t4.x -= r3), void 0 !== t4.y && (t4.y -= e3), t4.relative = true), t4;
      });
    }, t3.NORMALIZE_HVZ = function(t4, r3, e3) {
      return void 0 === t4 && (t4 = true), void 0 === r3 && (r3 = true), void 0 === e3 && (e3 = true), u2(function(i2, a2, n3, o2, s2) {
        if (isNaN(o2) && !(i2.type & _.MOVE_TO)) throw new Error("path must start with moveto");
        return r3 && i2.type & _.HORIZ_LINE_TO && (i2.type = _.LINE_TO, i2.y = i2.relative ? 0 : n3), e3 && i2.type & _.VERT_LINE_TO && (i2.type = _.LINE_TO, i2.x = i2.relative ? 0 : a2), t4 && i2.type & _.CLOSE_PATH && (i2.type = _.LINE_TO, i2.x = i2.relative ? o2 - a2 : o2, i2.y = i2.relative ? s2 - n3 : s2), i2.type & _.ARC && (0 === i2.rX || 0 === i2.rY) && (i2.type = _.LINE_TO, delete i2.rX, delete i2.rY, delete i2.xRot, delete i2.lArcFlag, delete i2.sweepFlag), i2;
      });
    }, t3.NORMALIZE_ST = e2, t3.QT_TO_C = n2, t3.INFO = u2, t3.SANITIZE = function(t4) {
      void 0 === t4 && (t4 = 0), a(t4);
      var r3 = NaN, e3 = NaN, i2 = NaN, n3 = NaN;
      return u2(function(a2, o2, s2, u3, h2) {
        var c2 = Math.abs, y2 = false, p2 = 0, m2 = 0;
        if (a2.type & _.SMOOTH_CURVE_TO && (p2 = isNaN(r3) ? 0 : o2 - r3, m2 = isNaN(e3) ? 0 : s2 - e3), a2.type & (_.CURVE_TO | _.SMOOTH_CURVE_TO) ? (r3 = a2.relative ? o2 + a2.x2 : a2.x2, e3 = a2.relative ? s2 + a2.y2 : a2.y2) : (r3 = NaN, e3 = NaN), a2.type & _.SMOOTH_QUAD_TO ? (i2 = isNaN(i2) ? o2 : 2 * o2 - i2, n3 = isNaN(n3) ? s2 : 2 * s2 - n3) : a2.type & _.QUAD_TO ? (i2 = a2.relative ? o2 + a2.x1 : a2.x1, n3 = a2.relative ? s2 + a2.y1 : a2.y2) : (i2 = NaN, n3 = NaN), a2.type & _.LINE_COMMANDS || a2.type & _.ARC && (0 === a2.rX || 0 === a2.rY || !a2.lArcFlag) || a2.type & _.CURVE_TO || a2.type & _.SMOOTH_CURVE_TO || a2.type & _.QUAD_TO || a2.type & _.SMOOTH_QUAD_TO) {
          var O3 = void 0 === a2.x ? 0 : a2.relative ? a2.x : a2.x - o2, l3 = void 0 === a2.y ? 0 : a2.relative ? a2.y : a2.y - s2;
          p2 = isNaN(i2) ? void 0 === a2.x1 ? p2 : a2.relative ? a2.x : a2.x1 - o2 : i2 - o2, m2 = isNaN(n3) ? void 0 === a2.y1 ? m2 : a2.relative ? a2.y : a2.y1 - s2 : n3 - s2;
          var T2 = void 0 === a2.x2 ? 0 : a2.relative ? a2.x : a2.x2 - o2, v2 = void 0 === a2.y2 ? 0 : a2.relative ? a2.y : a2.y2 - s2;
          c2(O3) <= t4 && c2(l3) <= t4 && c2(p2) <= t4 && c2(m2) <= t4 && c2(T2) <= t4 && c2(v2) <= t4 && (y2 = true);
        }
        return a2.type & _.CLOSE_PATH && c2(o2 - u3) <= t4 && c2(s2 - h2) <= t4 && (y2 = true), y2 ? [] : a2;
      });
    }, t3.MATRIX = O2, t3.ROTATE = function(t4, r3, e3) {
      void 0 === r3 && (r3 = 0), void 0 === e3 && (e3 = 0), a(t4, r3, e3);
      var i2 = Math.sin(t4), n3 = Math.cos(t4);
      return O2(n3, i2, -i2, n3, r3 - r3 * n3 + e3 * i2, e3 - r3 * i2 - e3 * n3);
    }, t3.TRANSLATE = function(t4, r3) {
      return void 0 === r3 && (r3 = 0), a(t4, r3), O2(1, 0, 0, 1, t4, r3);
    }, t3.SCALE = function(t4, r3) {
      return void 0 === r3 && (r3 = t4), a(t4, r3), O2(t4, 0, 0, r3, 0, 0);
    }, t3.SKEW_X = function(t4) {
      return a(t4), O2(1, 0, Math.atan(t4), 1, 0, 0);
    }, t3.SKEW_Y = function(t4) {
      return a(t4), O2(1, Math.atan(t4), 0, 1, 0, 0);
    }, t3.X_AXIS_SYMMETRY = function(t4) {
      return void 0 === t4 && (t4 = 0), a(t4), O2(-1, 0, 0, 1, t4, 0);
    }, t3.Y_AXIS_SYMMETRY = function(t4) {
      return void 0 === t4 && (t4 = 0), a(t4), O2(1, 0, 0, -1, 0, t4);
    }, t3.A_TO_C = function() {
      return u2(function(t4, r3, e3) {
        return _.ARC === t4.type ? (function(t5, r4, e4) {
          var a2, n3, s2, u3;
          t5.cX || o(t5, r4, e4);
          for (var y2 = Math.min(t5.phi1, t5.phi2), p2 = Math.max(t5.phi1, t5.phi2) - y2, m2 = Math.ceil(p2 / 90), O3 = new Array(m2), l3 = r4, T2 = e4, v2 = 0; v2 < m2; v2++) {
            var f2 = c$1(t5.phi1, t5.phi2, v2 / m2), N2 = c$1(t5.phi1, t5.phi2, (v2 + 1) / m2), x2 = N2 - f2, d2 = 4 / 3 * Math.tan(x2 * h / 4), E2 = [Math.cos(f2 * h) - d2 * Math.sin(f2 * h), Math.sin(f2 * h) + d2 * Math.cos(f2 * h)], A2 = E2[0], C2 = E2[1], M2 = [Math.cos(N2 * h), Math.sin(N2 * h)], R2 = M2[0], g2 = M2[1], I2 = [R2 + d2 * Math.sin(N2 * h), g2 - d2 * Math.cos(N2 * h)], S2 = I2[0], L2 = I2[1];
            O3[v2] = {
              relative: t5.relative,
              type: _.CURVE_TO
            };
            var H2 = function(r5, e5) {
              var a3 = i([r5 * t5.rX, e5 * t5.rY], t5.xRot), n4 = a3[0], o2 = a3[1];
              return [t5.cX + n4, t5.cY + o2];
            };
            a2 = H2(A2, C2), O3[v2].x1 = a2[0], O3[v2].y1 = a2[1], n3 = H2(S2, L2), O3[v2].x2 = n3[0], O3[v2].y2 = n3[1], s2 = H2(R2, g2), O3[v2].x = s2[0], O3[v2].y = s2[1], t5.relative && (O3[v2].x1 -= l3, O3[v2].y1 -= T2, O3[v2].x2 -= l3, O3[v2].y2 -= T2, O3[v2].x -= l3, O3[v2].y -= T2), l3 = (u3 = [O3[v2].x, O3[v2].y])[0], T2 = u3[1];
          }
          return O3;
        })(t4, t4.relative ? 0 : r3, t4.relative ? 0 : e3) : t4;
      });
    }, t3.ANNOTATE_ARCS = function() {
      return u2(function(t4, r3, e3) {
        return t4.relative && (r3 = 0, e3 = 0), _.ARC === t4.type && o(t4, r3, e3), t4;
      });
    }, t3.CLONE = l2, t3.CALCULATE_BOUNDS = function() {
      var t4 = function(t5) {
        var r3 = {};
        for (var e3 in t5) r3[e3] = t5[e3];
        return r3;
      }, i2 = r2(), a2 = n2(), h2 = e2(), c2 = u2(function(r3, e3, n3) {
        var u3 = h2(a2(i2(t4(r3))));
        function O3(t5) {
          t5 > c2.maxX && (c2.maxX = t5), t5 < c2.minX && (c2.minX = t5);
        }
        function l3(t5) {
          t5 > c2.maxY && (c2.maxY = t5), t5 < c2.minY && (c2.minY = t5);
        }
        if (u3.type & _.DRAWING_COMMANDS && (O3(e3), l3(n3)), u3.type & _.HORIZ_LINE_TO && O3(u3.x), u3.type & _.VERT_LINE_TO && l3(u3.y), u3.type & _.LINE_TO && (O3(u3.x), l3(u3.y)), u3.type & _.CURVE_TO) {
          O3(u3.x), l3(u3.y);
          for (var T2 = 0, v2 = p(e3, u3.x1, u3.x2, u3.x); T2 < v2.length; T2++) {
            0 < (w2 = v2[T2]) && 1 > w2 && O3(m$1(e3, u3.x1, u3.x2, u3.x, w2));
          }
          for (var f2 = 0, N2 = p(n3, u3.y1, u3.y2, u3.y); f2 < N2.length; f2++) {
            0 < (w2 = N2[f2]) && 1 > w2 && l3(m$1(n3, u3.y1, u3.y2, u3.y, w2));
          }
        }
        if (u3.type & _.ARC) {
          O3(u3.x), l3(u3.y), o(u3, e3, n3);
          for (var x2 = u3.xRot / 180 * Math.PI, d2 = Math.cos(x2) * u3.rX, E2 = Math.sin(x2) * u3.rX, A2 = -Math.sin(x2) * u3.rY, C2 = Math.cos(x2) * u3.rY, M2 = u3.phi1 < u3.phi2 ? [u3.phi1, u3.phi2] : -180 > u3.phi2 ? [u3.phi2 + 360, u3.phi1 + 360] : [u3.phi2, u3.phi1], R2 = M2[0], g2 = M2[1], I2 = function(t5) {
            var r4 = t5[0], e4 = t5[1], i3 = 180 * Math.atan2(e4, r4) / Math.PI;
            return i3 < R2 ? i3 + 360 : i3;
          }, S2 = 0, L2 = s(A2, -d2, 0).map(I2); S2 < L2.length; S2++) {
            (w2 = L2[S2]) > R2 && w2 < g2 && O3(y(u3.cX, d2, A2, w2));
          }
          for (var H2 = 0, U2 = s(C2, -E2, 0).map(I2); H2 < U2.length; H2++) {
            var w2;
            (w2 = U2[H2]) > R2 && w2 < g2 && l3(y(u3.cY, E2, C2, w2));
          }
        }
        return r3;
      });
      return c2.minX = 1 / 0, c2.maxX = -1 / 0, c2.minY = 1 / 0, c2.maxY = -1 / 0, c2;
    };
  })(u || (u = {}));
  var O;
  var l = (function() {
    function t3() {
    }
    return t3.prototype.round = function(t4) {
      return this.transform(u.ROUND(t4));
    }, t3.prototype.toAbs = function() {
      return this.transform(u.TO_ABS());
    }, t3.prototype.toRel = function() {
      return this.transform(u.TO_REL());
    }, t3.prototype.normalizeHVZ = function(t4, r2, e2) {
      return this.transform(u.NORMALIZE_HVZ(t4, r2, e2));
    }, t3.prototype.normalizeST = function() {
      return this.transform(u.NORMALIZE_ST());
    }, t3.prototype.qtToC = function() {
      return this.transform(u.QT_TO_C());
    }, t3.prototype.aToC = function() {
      return this.transform(u.A_TO_C());
    }, t3.prototype.sanitize = function(t4) {
      return this.transform(u.SANITIZE(t4));
    }, t3.prototype.translate = function(t4, r2) {
      return this.transform(u.TRANSLATE(t4, r2));
    }, t3.prototype.scale = function(t4, r2) {
      return this.transform(u.SCALE(t4, r2));
    }, t3.prototype.rotate = function(t4, r2, e2) {
      return this.transform(u.ROTATE(t4, r2, e2));
    }, t3.prototype.matrix = function(t4, r2, e2, i2, a2, n2) {
      return this.transform(u.MATRIX(t4, r2, e2, i2, a2, n2));
    }, t3.prototype.skewX = function(t4) {
      return this.transform(u.SKEW_X(t4));
    }, t3.prototype.skewY = function(t4) {
      return this.transform(u.SKEW_Y(t4));
    }, t3.prototype.xSymmetry = function(t4) {
      return this.transform(u.X_AXIS_SYMMETRY(t4));
    }, t3.prototype.ySymmetry = function(t4) {
      return this.transform(u.Y_AXIS_SYMMETRY(t4));
    }, t3.prototype.annotateArcs = function() {
      return this.transform(u.ANNOTATE_ARCS());
    }, t3;
  })();
  var T = function(t3) {
    return " " === t3 || "	" === t3 || "\r" === t3 || "\n" === t3;
  };
  var v = function(t3) {
    return "0".charCodeAt(0) <= t3.charCodeAt(0) && t3.charCodeAt(0) <= "9".charCodeAt(0);
  };
  var f = (function(t3) {
    function e2() {
      var r2 = t3.call(this) || this;
      return r2.curNumber = "", r2.curCommandType = -1, r2.curCommandRelative = false, r2.canParseCommandOrComma = true, r2.curNumberHasExp = false, r2.curNumberHasExpDigits = false, r2.curNumberHasDecimal = false, r2.curArgs = [], r2;
    }
    return r(e2, t3), e2.prototype.finish = function(t4) {
      if (void 0 === t4 && (t4 = []), this.parse(" ", t4), 0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
      return t4;
    }, e2.prototype.parse = function(t4, r2) {
      var e3 = this;
      void 0 === r2 && (r2 = []);
      for (var i2 = function(t5) {
        r2.push(t5), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;
      }, a2 = 0; a2 < t4.length; a2++) {
        var n2 = t4[a2], o2 = !(this.curCommandType !== _.ARC || 3 !== this.curArgs.length && 4 !== this.curArgs.length || 1 !== this.curNumber.length || "0" !== this.curNumber && "1" !== this.curNumber), s2 = v(n2) && ("0" === this.curNumber && "0" === n2 || o2);
        if (!v(n2) || s2) {
          if ("e" !== n2 && "E" !== n2) {
            if ("-" !== n2 && "+" !== n2 || !this.curNumberHasExp || this.curNumberHasExpDigits) {
              if ("." !== n2 || this.curNumberHasExp || this.curNumberHasDecimal || o2) {
                if (this.curNumber && -1 !== this.curCommandType) {
                  var u2 = Number(this.curNumber);
                  if (isNaN(u2)) throw new SyntaxError("Invalid number ending at " + a2);
                  if (this.curCommandType === _.ARC) {
                    if (0 === this.curArgs.length || 1 === this.curArgs.length) {
                      if (0 > u2) throw new SyntaxError('Expected positive number, got "' + u2 + '" at index "' + a2 + '"');
                    } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && "0" !== this.curNumber && "1" !== this.curNumber) throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a2 + '"');
                  }
                  this.curArgs.push(u2), this.curArgs.length === N[this.curCommandType] && (_.HORIZ_LINE_TO === this.curCommandType ? i2({
                    type: _.HORIZ_LINE_TO,
                    relative: this.curCommandRelative,
                    x: u2
                  }) : _.VERT_LINE_TO === this.curCommandType ? i2({
                    type: _.VERT_LINE_TO,
                    relative: this.curCommandRelative,
                    y: u2
                  }) : this.curCommandType === _.MOVE_TO || this.curCommandType === _.LINE_TO || this.curCommandType === _.SMOOTH_QUAD_TO ? (i2({
                    type: this.curCommandType,
                    relative: this.curCommandRelative,
                    x: this.curArgs[0],
                    y: this.curArgs[1]
                  }), _.MOVE_TO === this.curCommandType && (this.curCommandType = _.LINE_TO)) : this.curCommandType === _.CURVE_TO ? i2({
                    type: _.CURVE_TO,
                    relative: this.curCommandRelative,
                    x1: this.curArgs[0],
                    y1: this.curArgs[1],
                    x2: this.curArgs[2],
                    y2: this.curArgs[3],
                    x: this.curArgs[4],
                    y: this.curArgs[5]
                  }) : this.curCommandType === _.SMOOTH_CURVE_TO ? i2({
                    type: _.SMOOTH_CURVE_TO,
                    relative: this.curCommandRelative,
                    x2: this.curArgs[0],
                    y2: this.curArgs[1],
                    x: this.curArgs[2],
                    y: this.curArgs[3]
                  }) : this.curCommandType === _.QUAD_TO ? i2({
                    type: _.QUAD_TO,
                    relative: this.curCommandRelative,
                    x1: this.curArgs[0],
                    y1: this.curArgs[1],
                    x: this.curArgs[2],
                    y: this.curArgs[3]
                  }) : this.curCommandType === _.ARC && i2({
                    type: _.ARC,
                    relative: this.curCommandRelative,
                    rX: this.curArgs[0],
                    rY: this.curArgs[1],
                    xRot: this.curArgs[2],
                    lArcFlag: this.curArgs[3],
                    sweepFlag: this.curArgs[4],
                    x: this.curArgs[5],
                    y: this.curArgs[6]
                  })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
                }
                if (!T(n2)) if ("," === n2 && this.canParseCommandOrComma) this.canParseCommandOrComma = false;
                else if ("+" !== n2 && "-" !== n2 && "." !== n2) {
                  if (s2) this.curNumber = n2, this.curNumberHasDecimal = false;
                  else {
                    if (0 !== this.curArgs.length) throw new SyntaxError("Unterminated command at index " + a2 + ".");
                    if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ". Command cannot follow comma");
                    if (this.canParseCommandOrComma = false, "z" !== n2 && "Z" !== n2) {
                      if ("h" === n2 || "H" === n2) this.curCommandType = _.HORIZ_LINE_TO, this.curCommandRelative = "h" === n2;
                      else if ("v" === n2 || "V" === n2) this.curCommandType = _.VERT_LINE_TO, this.curCommandRelative = "v" === n2;
                      else if ("m" === n2 || "M" === n2) this.curCommandType = _.MOVE_TO, this.curCommandRelative = "m" === n2;
                      else if ("l" === n2 || "L" === n2) this.curCommandType = _.LINE_TO, this.curCommandRelative = "l" === n2;
                      else if ("c" === n2 || "C" === n2) this.curCommandType = _.CURVE_TO, this.curCommandRelative = "c" === n2;
                      else if ("s" === n2 || "S" === n2) this.curCommandType = _.SMOOTH_CURVE_TO, this.curCommandRelative = "s" === n2;
                      else if ("q" === n2 || "Q" === n2) this.curCommandType = _.QUAD_TO, this.curCommandRelative = "q" === n2;
                      else if ("t" === n2 || "T" === n2) this.curCommandType = _.SMOOTH_QUAD_TO, this.curCommandRelative = "t" === n2;
                      else {
                        if ("a" !== n2 && "A" !== n2) throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ".");
                        this.curCommandType = _.ARC, this.curCommandRelative = "a" === n2;
                      }
                    } else r2.push({
                      type: _.CLOSE_PATH
                    }), this.canParseCommandOrComma = true, this.curCommandType = -1;
                  }
                } else this.curNumber = n2, this.curNumberHasDecimal = "." === n2;
              } else this.curNumber += n2, this.curNumberHasDecimal = true;
            } else this.curNumber += n2;
          } else this.curNumber += n2, this.curNumberHasExp = true;
        } else this.curNumber += n2, this.curNumberHasExpDigits = this.curNumberHasExp;
      }
      return r2;
    }, e2.prototype.transform = function(t4) {
      return Object.create(this, {
        parse: {
          value: function(r2, e3) {
            void 0 === e3 && (e3 = []);
            for (var i2 = 0, a2 = Object.getPrototypeOf(this).parse.call(this, r2); i2 < a2.length; i2++) {
              var n2 = a2[i2], o2 = t4(n2);
              Array.isArray(o2) ? e3.push.apply(e3, o2) : e3.push(o2);
            }
            return e3;
          }
        }
      });
    }, e2;
  })(l);
  var _ = (function(t3) {
    function i2(r2) {
      var e2 = t3.call(this) || this;
      return e2.commands = "string" == typeof r2 ? i2.parse(r2) : r2, e2;
    }
    return r(i2, t3), i2.prototype.encode = function() {
      return i2.encode(this.commands);
    }, i2.prototype.getBounds = function() {
      var t4 = u.CALCULATE_BOUNDS();
      return this.transform(t4), t4;
    }, i2.prototype.transform = function(t4) {
      for (var r2 = [], e2 = 0, i3 = this.commands; e2 < i3.length; e2++) {
        var a2 = t4(i3[e2]);
        Array.isArray(a2) ? r2.push.apply(r2, a2) : r2.push(a2);
      }
      return this.commands = r2, this;
    }, i2.encode = function(t4) {
      return e(t4);
    }, i2.parse = function(t4) {
      var r2 = new f(), e2 = [];
      return r2.parse(t4, e2), r2.finish(e2), e2;
    }, i2.CLOSE_PATH = 1, i2.MOVE_TO = 2, i2.HORIZ_LINE_TO = 4, i2.VERT_LINE_TO = 8, i2.LINE_TO = 16, i2.CURVE_TO = 32, i2.SMOOTH_CURVE_TO = 64, i2.QUAD_TO = 128, i2.SMOOTH_QUAD_TO = 256, i2.ARC = 512, i2.LINE_COMMANDS = i2.LINE_TO | i2.HORIZ_LINE_TO | i2.VERT_LINE_TO, i2.DRAWING_COMMANDS = i2.HORIZ_LINE_TO | i2.VERT_LINE_TO | i2.LINE_TO | i2.CURVE_TO | i2.SMOOTH_CURVE_TO | i2.QUAD_TO | i2.SMOOTH_QUAD_TO | i2.ARC, i2;
  })(l);
  var N = ((O = {})[_.MOVE_TO] = 2, O[_.LINE_TO] = 2, O[_.HORIZ_LINE_TO] = 1, O[_.VERT_LINE_TO] = 1, O[_.CLOSE_PATH] = 0, O[_.QUAD_TO] = 4, O[_.SMOOTH_QUAD_TO] = 2, O[_.CURVE_TO] = 6, O[_.SMOOTH_CURVE_TO] = 4, O[_.ARC] = 7, O);
  var es_regexp_toString = {};
  var hasRequiredEs_regexp_toString;
  function requireEs_regexp_toString() {
    if (hasRequiredEs_regexp_toString) return es_regexp_toString;
    hasRequiredEs_regexp_toString = 1;
    var PROPER_FUNCTION_NAME = requireFunctionName().PROPER;
    var defineBuiltIn2 = requireDefineBuiltIn();
    var anObject2 = requireAnObject();
    var $toString = requireToString();
    var fails2 = requireFails();
    var getRegExpFlags = requireRegexpGetFlags();
    var TO_STRING = "toString";
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails2(function() {
      return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
    });
    var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      defineBuiltIn2(RegExpPrototype, TO_STRING, function toString2() {
        var R2 = anObject2(this);
        var pattern = $toString(R2.source);
        var flags = $toString(getRegExpFlags(R2));
        return "/" + pattern + "/" + flags;
      }, { unsafe: true });
    }
    return es_regexp_toString;
  }
  requireEs_regexp_toString();
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
  var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
  function getImageDataFromCanvas(canvas, topX, topY, width, height) {
    if (typeof canvas === "string") {
      canvas = document.getElementById(canvas);
    }
    if (!canvas || _typeof(canvas) !== "object" || !("getContext" in canvas)) {
      throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
    }
    var context = canvas.getContext("2d");
    try {
      return context.getImageData(topX, topY, width, height);
    } catch (e2) {
      throw new Error("unable to access image data: " + e2);
    }
  }
  function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
    if (isNaN(radius) || radius < 1) {
      return;
    }
    radius |= 0;
    var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
    imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
    canvas.getContext("2d").putImageData(imageData, topX, topY);
  }
  function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
    var pixels = imageData.data;
    var div = 2 * radius + 1;
    var widthMinus1 = width - 1;
    var heightMinus1 = height - 1;
    var radiusPlus1 = radius + 1;
    var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
    var stackStart = new BlurStack();
    var stack = stackStart;
    var stackEnd;
    for (var i2 = 1; i2 < div; i2++) {
      stack = stack.next = new BlurStack();
      if (i2 === radiusPlus1) {
        stackEnd = stack;
      }
    }
    stack.next = stackStart;
    var stackIn = null, stackOut = null, yw = 0, yi = 0;
    var mulSum = mulTable[radius];
    var shgSum = shgTable[radius];
    for (var y2 = 0; y2 < height; y2++) {
      stack = stackStart;
      var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
      for (var _i = 0; _i < radiusPlus1; _i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }
      var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
      for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
        var p2 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
        var r2 = pixels[p2], g2 = pixels[p2 + 1], b2 = pixels[p2 + 2], a2 = pixels[p2 + 3];
        var rbs = radiusPlus1 - _i2;
        rSum += (stack.r = r2) * rbs;
        gSum += (stack.g = g2) * rbs;
        bSum += (stack.b = b2) * rbs;
        aSum += (stack.a = a2) * rbs;
        rInSum += r2;
        gInSum += g2;
        bInSum += b2;
        aInSum += a2;
        stack = stack.next;
      }
      stackIn = stackStart;
      stackOut = stackEnd;
      for (var x2 = 0; x2 < width; x2++) {
        var paInitial = aSum * mulSum >>> shgSum;
        pixels[yi + 3] = paInitial;
        if (paInitial !== 0) {
          var _a2 = 255 / paInitial;
          pixels[yi] = (rSum * mulSum >>> shgSum) * _a2;
          pixels[yi + 1] = (gSum * mulSum >>> shgSum) * _a2;
          pixels[yi + 2] = (bSum * mulSum >>> shgSum) * _a2;
        } else {
          pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
        }
        rSum -= rOutSum;
        gSum -= gOutSum;
        bSum -= bOutSum;
        aSum -= aOutSum;
        rOutSum -= stackIn.r;
        gOutSum -= stackIn.g;
        bOutSum -= stackIn.b;
        aOutSum -= stackIn.a;
        var _p = x2 + radius + 1;
        _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
        rInSum += stackIn.r = pixels[_p];
        gInSum += stackIn.g = pixels[_p + 1];
        bInSum += stackIn.b = pixels[_p + 2];
        aInSum += stackIn.a = pixels[_p + 3];
        rSum += rInSum;
        gSum += gInSum;
        bSum += bInSum;
        aSum += aInSum;
        stackIn = stackIn.next;
        var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;
        rOutSum += _r;
        gOutSum += _g;
        bOutSum += _b2;
        aOutSum += _a3;
        rInSum -= _r;
        gInSum -= _g;
        bInSum -= _b2;
        aInSum -= _a3;
        stackOut = stackOut.next;
        yi += 4;
      }
      yw += width;
    }
    for (var _x = 0; _x < width; _x++) {
      yi = _x << 2;
      var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
      stack = stackStart;
      for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
        stack.r = _pr;
        stack.g = _pg;
        stack.b = _pb;
        stack.a = _pa;
        stack = stack.next;
      }
      var yp = width;
      var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
      for (var _i4 = 1; _i4 <= radius; _i4++) {
        yi = yp + _x << 2;
        var _rbs = radiusPlus1 - _i4;
        _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
        _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
        _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
        _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
        _rInSum += _pr;
        _gInSum += _pg;
        _bInSum += _pb;
        _aInSum += _pa;
        stack = stack.next;
        if (_i4 < heightMinus1) {
          yp += width;
        }
      }
      yi = _x;
      stackIn = stackStart;
      stackOut = stackEnd;
      for (var _y = 0; _y < height; _y++) {
        var _p2 = yi << 2;
        pixels[_p2 + 3] = _pa = _aSum * mulSum >>> shgSum;
        if (_pa > 0) {
          _pa = 255 / _pa;
          pixels[_p2] = (_rSum * mulSum >>> shgSum) * _pa;
          pixels[_p2 + 1] = (_gSum * mulSum >>> shgSum) * _pa;
          pixels[_p2 + 2] = (_bSum * mulSum >>> shgSum) * _pa;
        } else {
          pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
        }
        _rSum -= _rOutSum;
        _gSum -= _gOutSum;
        _bSum -= _bOutSum;
        _aSum -= _aOutSum;
        _rOutSum -= stackIn.r;
        _gOutSum -= stackIn.g;
        _bOutSum -= stackIn.b;
        _aOutSum -= stackIn.a;
        _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
        _rSum += _rInSum += stackIn.r = pixels[_p2];
        _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
        _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
        _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
        stackIn = stackIn.next;
        _rOutSum += _pr = stackOut.r;
        _gOutSum += _pg = stackOut.g;
        _bOutSum += _pb = stackOut.b;
        _aOutSum += _pa = stackOut.a;
        _rInSum -= _pr;
        _gInSum -= _pg;
        _bInSum -= _pb;
        _aInSum -= _pa;
        stackOut = stackOut.next;
        yi += width;
      }
    }
    return imageData;
  }
  var BlurStack = (
    /**
     * Set properties.
     */
    function BlurStack2() {
      _classCallCheck(this, BlurStack2);
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.next = null;
    }
  );
  function offscreen() {
    var {
      DOMParser: DOMParserFallback
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var preset = {
      window: null,
      ignoreAnimation: true,
      ignoreMouse: true,
      DOMParser: DOMParserFallback,
      createCanvas(width, height) {
        return new OffscreenCanvas(width, height);
      },
      createImage(url) {
        return _asyncToGenerator(function* () {
          var response = yield fetch(url);
          var blob = yield response.blob();
          var img = yield createImageBitmap(blob);
          return img;
        })();
      }
    };
    if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
      Reflect.deleteProperty(preset, "DOMParser");
    }
    return preset;
  }
  function node(_ref) {
    var {
      DOMParser: DOMParser2,
      canvas,
      fetch: fetch2
    } = _ref;
    return {
      window: null,
      ignoreAnimation: true,
      ignoreMouse: true,
      DOMParser: DOMParser2,
      fetch: fetch2,
      createCanvas: canvas.createCanvas,
      createImage: canvas.loadImage
    };
  }
  var index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    offscreen,
    node
  });
  function compressSpaces(str) {
    return str.replace(/(?!\u3000)\s+/gm, " ");
  }
  function trimLeft(str) {
    return str.replace(/^[\n \t]+/, "");
  }
  function trimRight(str) {
    return str.replace(/[\n \t]+$/, "");
  }
  function toNumbers(str) {
    var matches = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
    return matches.map(parseFloat);
  }
  var allUppercase = /^[A-Z-]+$/;
  function normalizeAttributeName(name) {
    if (allUppercase.test(name)) {
      return name.toLowerCase();
    }
    return name;
  }
  function parseExternalUrl(url) {
    var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
    return urlMatch[2] || urlMatch[3] || urlMatch[4];
  }
  function normalizeColor(color) {
    if (!color.startsWith("rgb")) {
      return color;
    }
    var rgbParts = 3;
    var normalizedColor = color.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
    return normalizedColor;
  }
  var attributeRegex = /(\[[^\]]+\])/g;
  var idRegex = /(#[^\s+>~.[:]+)/g;
  var classRegex = /(\.[^\s+>~.[:]+)/g;
  var pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
  var pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
  var pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
  var elementRegex = /([^\s+>~.[:]+)/g;
  function findSelectorMatch(selector, regex) {
    var matches = regex.exec(selector);
    if (!matches) {
      return [selector, 0];
    }
    return [selector.replace(regex, " "), matches.length];
  }
  function getSelectorSpecificity(selector) {
    var specificity = [0, 0, 0];
    var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
    var delta = 0;
    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
    specificity[0] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
    specificity[2] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
    specificity[1] += delta;
    currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);
    specificity[2] += delta;
    return specificity.join("");
  }
  var PSEUDO_ZERO = 1e-8;
  function vectorMagnitude(v2) {
    return Math.sqrt(Math.pow(v2[0], 2) + Math.pow(v2[1], 2));
  }
  function vectorsRatio(u2, v2) {
    return (u2[0] * v2[0] + u2[1] * v2[1]) / (vectorMagnitude(u2) * vectorMagnitude(v2));
  }
  function vectorsAngle(u2, v2) {
    return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vectorsRatio(u2, v2));
  }
  function CB1(t3) {
    return t3 * t3 * t3;
  }
  function CB2(t3) {
    return 3 * t3 * t3 * (1 - t3);
  }
  function CB3(t3) {
    return 3 * t3 * (1 - t3) * (1 - t3);
  }
  function CB4(t3) {
    return (1 - t3) * (1 - t3) * (1 - t3);
  }
  function QB1(t3) {
    return t3 * t3;
  }
  function QB2(t3) {
    return 2 * t3 * (1 - t3);
  }
  function QB3(t3) {
    return (1 - t3) * (1 - t3);
  }
  var Property = class _Property {
    constructor(document2, name, value) {
      this.document = document2;
      this.name = name;
      this.value = value;
      this.isNormalizedColor = false;
    }
    static empty(document2) {
      return new _Property(document2, "EMPTY", "");
    }
    split() {
      var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
      var {
        document: document2,
        name
      } = this;
      return compressSpaces(this.getString()).trim().split(separator).map((value) => new _Property(document2, name, value));
    }
    hasValue(zeroIsValue) {
      var {
        value
      } = this;
      return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
    }
    isString(regexp) {
      var {
        value
      } = this;
      var result = typeof value === "string";
      if (!result || !regexp) {
        return result;
      }
      return regexp.test(value);
    }
    isUrlDefinition() {
      return this.isString(/^url\(/);
    }
    isPixels() {
      if (!this.hasValue()) {
        return false;
      }
      var asString = this.getString();
      switch (true) {
        case asString.endsWith("px"):
        case /^[0-9]+$/.test(asString):
          return true;
        default:
          return false;
      }
    }
    setValue(value) {
      this.value = value;
      return this;
    }
    getValue(def) {
      if (typeof def === "undefined" || this.hasValue()) {
        return this.value;
      }
      return def;
    }
    getNumber(def) {
      if (!this.hasValue()) {
        if (typeof def === "undefined") {
          return 0;
        }
        return parseFloat(def);
      }
      var {
        value
      } = this;
      var n2 = parseFloat(value);
      if (this.isString(/%$/)) {
        n2 /= 100;
      }
      return n2;
    }
    getString(def) {
      if (typeof def === "undefined" || this.hasValue()) {
        return typeof this.value === "undefined" ? "" : String(this.value);
      }
      return String(def);
    }
    getColor(def) {
      var color = this.getString(def);
      if (this.isNormalizedColor) {
        return color;
      }
      this.isNormalizedColor = true;
      color = normalizeColor(color);
      this.value = color;
      return color;
    }
    getDpi() {
      return 96;
    }
    getRem() {
      return this.document.rootEmSize;
    }
    getEm() {
      return this.document.emSize;
    }
    getUnits() {
      return this.getString().replace(/[0-9.-]/g, "");
    }
    getPixels(axisOrIsFontSize) {
      var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!this.hasValue()) {
        return 0;
      }
      var [axis, isFontSize] = typeof axisOrIsFontSize === "boolean" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize];
      var {
        viewPort
      } = this.document.screen;
      switch (true) {
        case this.isString(/vmin$/):
          return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
        case this.isString(/vmax$/):
          return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
        case this.isString(/vw$/):
          return this.getNumber() / 100 * viewPort.computeSize("x");
        case this.isString(/vh$/):
          return this.getNumber() / 100 * viewPort.computeSize("y");
        case this.isString(/rem$/):
          return this.getNumber() * this.getRem();
        case this.isString(/em$/):
          return this.getNumber() * this.getEm();
        case this.isString(/ex$/):
          return this.getNumber() * this.getEm() / 2;
        case this.isString(/px$/):
          return this.getNumber();
        case this.isString(/pt$/):
          return this.getNumber() * this.getDpi() * (1 / 72);
        case this.isString(/pc$/):
          return this.getNumber() * 15;
        case this.isString(/cm$/):
          return this.getNumber() * this.getDpi() / 2.54;
        case this.isString(/mm$/):
          return this.getNumber() * this.getDpi() / 25.4;
        case this.isString(/in$/):
          return this.getNumber() * this.getDpi();
        case (this.isString(/%$/) && isFontSize):
          return this.getNumber() * this.getEm();
        case this.isString(/%$/):
          return this.getNumber() * viewPort.computeSize(axis);
        default: {
          var n2 = this.getNumber();
          if (processPercent && n2 < 1) {
            return n2 * viewPort.computeSize(axis);
          }
          return n2;
        }
      }
    }
    getMilliseconds() {
      if (!this.hasValue()) {
        return 0;
      }
      if (this.isString(/ms$/)) {
        return this.getNumber();
      }
      return this.getNumber() * 1e3;
    }
    getRadians() {
      if (!this.hasValue()) {
        return 0;
      }
      switch (true) {
        case this.isString(/deg$/):
          return this.getNumber() * (Math.PI / 180);
        case this.isString(/grad$/):
          return this.getNumber() * (Math.PI / 200);
        case this.isString(/rad$/):
          return this.getNumber();
        default:
          return this.getNumber() * (Math.PI / 180);
      }
    }
    getDefinition() {
      var asString = this.getString();
      var name = /#([^)'"]+)/.exec(asString);
      if (name) {
        name = name[1];
      }
      if (!name) {
        name = asString;
      }
      return this.document.definitions[name];
    }
    getFillStyleDefinition(element, opacity) {
      var def = this.getDefinition();
      if (!def) {
        return null;
      }
      if (typeof def.createGradient === "function") {
        return def.createGradient(this.document.ctx, element, opacity);
      }
      if (typeof def.createPattern === "function") {
        if (def.getHrefAttribute().hasValue()) {
          var patternTransform = def.getAttribute("patternTransform");
          def = def.getHrefAttribute().getDefinition();
          if (patternTransform.hasValue()) {
            def.getAttribute("patternTransform", true).setValue(patternTransform.value);
          }
        }
        return def.createPattern(this.document.ctx, element, opacity);
      }
      return null;
    }
    getTextBaseline() {
      if (!this.hasValue()) {
        return null;
      }
      return _Property.textBaselineMapping[this.getString()];
    }
    addOpacity(opacity) {
      var value = this.getColor();
      var len = value.length;
      var commas = 0;
      for (var i2 = 0; i2 < len; i2++) {
        if (value[i2] === ",") {
          commas++;
        }
        if (commas === 3) {
          break;
        }
      }
      if (opacity.hasValue() && this.isString() && commas !== 3) {
        var color = new RGBColor$1(value);
        if (color.ok) {
          color.alpha = opacity.getNumber();
          value = color.toRGBA();
        }
      }
      return new _Property(this.document, this.name, value);
    }
  };
  Property.textBaselineMapping = {
    "baseline": "alphabetic",
    "before-edge": "top",
    "text-before-edge": "top",
    "middle": "middle",
    "central": "middle",
    "after-edge": "bottom",
    "text-after-edge": "bottom",
    "ideographic": "ideographic",
    "alphabetic": "alphabetic",
    "hanging": "hanging",
    "mathematical": "alphabetic"
  };
  var ViewPort = class {
    constructor() {
      this.viewPorts = [];
    }
    clear() {
      this.viewPorts = [];
    }
    setCurrent(width, height) {
      this.viewPorts.push({
        width,
        height
      });
    }
    removeCurrent() {
      this.viewPorts.pop();
    }
    getCurrent() {
      var {
        viewPorts
      } = this;
      return viewPorts[viewPorts.length - 1];
    }
    get width() {
      return this.getCurrent().width;
    }
    get height() {
      return this.getCurrent().height;
    }
    computeSize(d2) {
      if (typeof d2 === "number") {
        return d2;
      }
      if (d2 === "x") {
        return this.width;
      }
      if (d2 === "y") {
        return this.height;
      }
      return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
    }
  };
  var Point = class _Point {
    constructor(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
    static parse(point) {
      var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var [x2 = defaultValue, y2 = defaultValue] = toNumbers(point);
      return new _Point(x2, y2);
    }
    static parseScale(scale) {
      var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var [x2 = defaultValue, y2 = x2] = toNumbers(scale);
      return new _Point(x2, y2);
    }
    static parsePath(path2) {
      var points = toNumbers(path2);
      var len = points.length;
      var pathPoints = [];
      for (var i2 = 0; i2 < len; i2 += 2) {
        pathPoints.push(new _Point(points[i2], points[i2 + 1]));
      }
      return pathPoints;
    }
    angleTo(point) {
      return Math.atan2(point.y - this.y, point.x - this.x);
    }
    applyTransform(transform) {
      var {
        x: x2,
        y: y2
      } = this;
      var xp = x2 * transform[0] + y2 * transform[2] + transform[4];
      var yp = x2 * transform[1] + y2 * transform[3] + transform[5];
      this.x = xp;
      this.y = yp;
    }
  };
  var Mouse = class {
    constructor(screen) {
      this.screen = screen;
      this.working = false;
      this.events = [];
      this.eventElements = [];
      this.onClick = this.onClick.bind(this);
      this.onMouseMove = this.onMouseMove.bind(this);
    }
    isWorking() {
      return this.working;
    }
    start() {
      if (this.working) {
        return;
      }
      var {
        screen,
        onClick,
        onMouseMove
      } = this;
      var canvas = screen.ctx.canvas;
      canvas.onclick = onClick;
      canvas.onmousemove = onMouseMove;
      this.working = true;
    }
    stop() {
      if (!this.working) {
        return;
      }
      var canvas = this.screen.ctx.canvas;
      this.working = false;
      canvas.onclick = null;
      canvas.onmousemove = null;
    }
    hasEvents() {
      return this.working && this.events.length > 0;
    }
    runEvents() {
      if (!this.working) {
        return;
      }
      var {
        screen: document2,
        events,
        eventElements
      } = this;
      var {
        style
      } = document2.ctx.canvas;
      if (style) {
        style.cursor = "";
      }
      events.forEach((_ref, i2) => {
        var {
          run
        } = _ref;
        var element = eventElements[i2];
        while (element) {
          run(element);
          element = element.parent;
        }
      });
      this.events = [];
      this.eventElements = [];
    }
    checkPath(element, ctx) {
      if (!this.working || !ctx) {
        return;
      }
      var {
        events,
        eventElements
      } = this;
      events.forEach((_ref2, i2) => {
        var {
          x: x2,
          y: y2
        } = _ref2;
        if (!eventElements[i2] && ctx.isPointInPath && ctx.isPointInPath(x2, y2)) {
          eventElements[i2] = element;
        }
      });
    }
    checkBoundingBox(element, boundingBox) {
      if (!this.working || !boundingBox) {
        return;
      }
      var {
        events,
        eventElements
      } = this;
      events.forEach((_ref3, i2) => {
        var {
          x: x2,
          y: y2
        } = _ref3;
        if (!eventElements[i2] && boundingBox.isPointInBox(x2, y2)) {
          eventElements[i2] = element;
        }
      });
    }
    mapXY(x2, y2) {
      var {
        window: window2,
        ctx
      } = this.screen;
      var point = new Point(x2, y2);
      var element = ctx.canvas;
      while (element) {
        point.x -= element.offsetLeft;
        point.y -= element.offsetTop;
        element = element.offsetParent;
      }
      if (window2.scrollX) {
        point.x += window2.scrollX;
      }
      if (window2.scrollY) {
        point.y += window2.scrollY;
      }
      return point;
    }
    onClick(event) {
      var {
        x: x2,
        y: y2
      } = this.mapXY(event.clientX, event.clientY);
      this.events.push({
        type: "onclick",
        x: x2,
        y: y2,
        run(eventTarget) {
          if (eventTarget.onClick) {
            eventTarget.onClick();
          }
        }
      });
    }
    onMouseMove(event) {
      var {
        x: x2,
        y: y2
      } = this.mapXY(event.clientX, event.clientY);
      this.events.push({
        type: "onmousemove",
        x: x2,
        y: y2,
        run(eventTarget) {
          if (eventTarget.onMouseMove) {
            eventTarget.onMouseMove();
          }
        }
      });
    }
  };
  var defaultWindow = typeof window !== "undefined" ? window : null;
  var defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(void 0) : null;
  var Screen = class {
    constructor(ctx) {
      var {
        fetch: fetch2 = defaultFetch$1,
        window: window2 = defaultWindow
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.ctx = ctx;
      this.FRAMERATE = 30;
      this.MAX_VIRTUAL_PIXELS = 3e4;
      this.CLIENT_WIDTH = 800;
      this.CLIENT_HEIGHT = 600;
      this.viewPort = new ViewPort();
      this.mouse = new Mouse(this);
      this.animations = [];
      this.waits = [];
      this.frameDuration = 0;
      this.isReadyLock = false;
      this.isFirstRender = true;
      this.intervalId = null;
      this.window = window2;
      this.fetch = fetch2;
    }
    wait(checker) {
      this.waits.push(checker);
    }
    ready() {
      if (!this.readyPromise) {
        return Promise.resolve();
      }
      return this.readyPromise;
    }
    isReady() {
      if (this.isReadyLock) {
        return true;
      }
      var isReadyLock = this.waits.every((_2) => _2());
      if (isReadyLock) {
        this.waits = [];
        if (this.resolveReady) {
          this.resolveReady();
        }
      }
      this.isReadyLock = isReadyLock;
      return isReadyLock;
    }
    setDefaults(ctx) {
      ctx.strokeStyle = "rgba(0,0,0,0)";
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 4;
    }
    setViewBox(_ref) {
      var {
        document: document2,
        ctx,
        aspectRatio,
        width,
        desiredWidth,
        height,
        desiredHeight,
        minX = 0,
        minY = 0,
        refX,
        refY,
        clip = false,
        clipX = 0,
        clipY = 0
      } = _ref;
      var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
      var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(" ");
      var align = aspectRatioAlign || "xMidYMid";
      var meetOrSlice = aspectRatioMeetOrSlice || "meet";
      var scaleX = width / desiredWidth;
      var scaleY = height / desiredHeight;
      var scaleMin = Math.min(scaleX, scaleY);
      var scaleMax = Math.max(scaleX, scaleY);
      var finalDesiredWidth = desiredWidth;
      var finalDesiredHeight = desiredHeight;
      if (meetOrSlice === "meet") {
        finalDesiredWidth *= scaleMin;
        finalDesiredHeight *= scaleMin;
      }
      if (meetOrSlice === "slice") {
        finalDesiredWidth *= scaleMax;
        finalDesiredHeight *= scaleMax;
      }
      var refXProp = new Property(document2, "refX", refX);
      var refYProp = new Property(document2, "refY", refY);
      var hasRefs = refXProp.hasValue() && refYProp.hasValue();
      if (hasRefs) {
        ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
      }
      if (clip) {
        var scaledClipX = scaleMin * clipX;
        var scaledClipY = scaleMin * clipY;
        ctx.beginPath();
        ctx.moveTo(scaledClipX, scaledClipY);
        ctx.lineTo(width, scaledClipY);
        ctx.lineTo(width, height);
        ctx.lineTo(scaledClipX, height);
        ctx.closePath();
        ctx.clip();
      }
      if (!hasRefs) {
        var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
        var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
        var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
        var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
        if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
          ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
        }
        if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
          ctx.translate(0, height / 2 - finalDesiredHeight / 2);
        }
        if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
          ctx.translate(width - finalDesiredWidth, 0);
        }
        if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
          ctx.translate(0, height - finalDesiredHeight);
        }
      }
      switch (true) {
        case align === "none":
          ctx.scale(scaleX, scaleY);
          break;
        case meetOrSlice === "meet":
          ctx.scale(scaleMin, scaleMin);
          break;
        case meetOrSlice === "slice":
          ctx.scale(scaleMax, scaleMax);
          break;
      }
      ctx.translate(-minX, -minY);
    }
    start(element) {
      var {
        enableRedraw = false,
        ignoreMouse = false,
        ignoreAnimation = false,
        ignoreDimensions = false,
        ignoreClear = false,
        forceRedraw,
        scaleWidth,
        scaleHeight,
        offsetX,
        offsetY
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var {
        FRAMERATE,
        mouse
      } = this;
      var frameDuration = 1e3 / FRAMERATE;
      this.frameDuration = frameDuration;
      this.readyPromise = new Promise((resolve) => {
        this.resolveReady = resolve;
      });
      if (this.isReady()) {
        this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
      }
      if (!enableRedraw) {
        return;
      }
      var now = Date.now();
      var then = now;
      var delta = 0;
      var tick = () => {
        now = Date.now();
        delta = now - then;
        if (delta >= frameDuration) {
          then = now - delta % frameDuration;
          if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
            mouse.runEvents();
          }
        }
        this.intervalId = requestAnimationFrame(tick);
      };
      if (!ignoreMouse) {
        mouse.start();
      }
      this.intervalId = requestAnimationFrame(tick);
    }
    stop() {
      if (this.intervalId) {
        requestAnimationFrame.cancel(this.intervalId);
        this.intervalId = null;
      }
      this.mouse.stop();
    }
    shouldUpdate(ignoreAnimation, forceRedraw) {
      if (!ignoreAnimation) {
        var {
          frameDuration
        } = this;
        var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);
        if (shouldUpdate) {
          return true;
        }
      }
      if (typeof forceRedraw === "function" && forceRedraw()) {
        return true;
      }
      if (!this.isReadyLock && this.isReady()) {
        return true;
      }
      if (this.mouse.hasEvents()) {
        return true;
      }
      return false;
    }
    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
      var {
        CLIENT_WIDTH,
        CLIENT_HEIGHT,
        viewPort,
        ctx,
        isFirstRender
      } = this;
      var canvas = ctx.canvas;
      viewPort.clear();
      if (canvas.width && canvas.height) {
        viewPort.setCurrent(canvas.width, canvas.height);
      } else {
        viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
      }
      var widthStyle = element.getStyle("width");
      var heightStyle = element.getStyle("height");
      if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
        if (widthStyle.hasValue()) {
          canvas.width = widthStyle.getPixels("x");
          if (canvas.style) {
            canvas.style.width = "".concat(canvas.width, "px");
          }
        }
        if (heightStyle.hasValue()) {
          canvas.height = heightStyle.getPixels("y");
          if (canvas.style) {
            canvas.style.height = "".concat(canvas.height, "px");
          }
        }
      }
      var cWidth = canvas.clientWidth || canvas.width;
      var cHeight = canvas.clientHeight || canvas.height;
      if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
        cWidth = widthStyle.getPixels("x");
        cHeight = heightStyle.getPixels("y");
      }
      viewPort.setCurrent(cWidth, cHeight);
      if (typeof offsetX === "number") {
        element.getAttribute("x", true).setValue(offsetX);
      }
      if (typeof offsetY === "number") {
        element.getAttribute("y", true).setValue(offsetY);
      }
      if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
        var viewBox = toNumbers(element.getAttribute("viewBox").getString());
        var xRatio = 0;
        var yRatio = 0;
        if (typeof scaleWidth === "number") {
          var _widthStyle = element.getStyle("width");
          if (_widthStyle.hasValue()) {
            xRatio = _widthStyle.getPixels("x") / scaleWidth;
          } else if (!isNaN(viewBox[2])) {
            xRatio = viewBox[2] / scaleWidth;
          }
        }
        if (typeof scaleHeight === "number") {
          var _heightStyle = element.getStyle("height");
          if (_heightStyle.hasValue()) {
            yRatio = _heightStyle.getPixels("y") / scaleHeight;
          } else if (!isNaN(viewBox[3])) {
            yRatio = viewBox[3] / scaleHeight;
          }
        }
        if (!xRatio) {
          xRatio = yRatio;
        }
        if (!yRatio) {
          yRatio = xRatio;
        }
        element.getAttribute("width", true).setValue(scaleWidth);
        element.getAttribute("height", true).setValue(scaleHeight);
        var transformStyle = element.getStyle("transform", true, true);
        transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
      }
      if (!ignoreClear) {
        ctx.clearRect(0, 0, cWidth, cHeight);
      }
      element.render(ctx);
      if (isFirstRender) {
        this.isFirstRender = false;
      }
    }
  };
  Screen.defaultWindow = defaultWindow;
  Screen.defaultFetch = defaultFetch$1;
  var {
    defaultFetch
  } = Screen;
  var DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
  var Parser = class {
    constructor() {
      var {
        fetch: fetch2 = defaultFetch,
        DOMParser: DOMParser2 = DefaultDOMParser
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.fetch = fetch2;
      this.DOMParser = DOMParser2;
    }
    parse(resource) {
      var _this = this;
      return _asyncToGenerator(function* () {
        if (resource.startsWith("<")) {
          return _this.parseFromString(resource);
        }
        return _this.load(resource);
      })();
    }
    parseFromString(xml2) {
      var parser = new this.DOMParser();
      try {
        return this.checkDocument(parser.parseFromString(xml2, "image/svg+xml"));
      } catch (err2) {
        return this.checkDocument(parser.parseFromString(xml2, "text/xml"));
      }
    }
    checkDocument(document2) {
      var parserError = document2.getElementsByTagName("parsererror")[0];
      if (parserError) {
        throw new Error(parserError.textContent);
      }
      return document2;
    }
    load(url) {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        var response = yield _this2.fetch(url);
        var xml2 = yield response.text();
        return _this2.parseFromString(xml2);
      })();
    }
  };
  var Translate = class {
    constructor(_2, point) {
      this.type = "translate";
      this.point = null;
      this.point = Point.parse(point);
    }
    apply(ctx) {
      var {
        x: x2,
        y: y2
      } = this.point;
      ctx.translate(x2 || 0, y2 || 0);
    }
    unapply(ctx) {
      var {
        x: x2,
        y: y2
      } = this.point;
      ctx.translate(-1 * x2 || 0, -1 * y2 || 0);
    }
    applyToPoint(point) {
      var {
        x: x2,
        y: y2
      } = this.point;
      point.applyTransform([1, 0, 0, 1, x2 || 0, y2 || 0]);
    }
  };
  var Rotate = class {
    constructor(document2, rotate, transformOrigin) {
      this.type = "rotate";
      this.angle = null;
      this.originX = null;
      this.originY = null;
      this.cx = 0;
      this.cy = 0;
      var numbers = toNumbers(rotate);
      this.angle = new Property(document2, "angle", numbers[0]);
      this.originX = transformOrigin[0];
      this.originY = transformOrigin[1];
      this.cx = numbers[1] || 0;
      this.cy = numbers[2] || 0;
    }
    apply(ctx) {
      var {
        cx,
        cy,
        originX,
        originY,
        angle: angle2
      } = this;
      var tx = cx + originX.getPixels("x");
      var ty = cy + originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.rotate(angle2.getRadians());
      ctx.translate(-tx, -ty);
    }
    unapply(ctx) {
      var {
        cx,
        cy,
        originX,
        originY,
        angle: angle2
      } = this;
      var tx = cx + originX.getPixels("x");
      var ty = cy + originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.rotate(-1 * angle2.getRadians());
      ctx.translate(-tx, -ty);
    }
    applyToPoint(point) {
      var {
        cx,
        cy,
        angle: angle2
      } = this;
      var rad = angle2.getRadians();
      point.applyTransform([
        1,
        0,
        0,
        1,
        cx || 0,
        cy || 0
        // this.p.y
      ]);
      point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
      point.applyTransform([
        1,
        0,
        0,
        1,
        -cx || 0,
        -cy || 0
        // -this.p.y
      ]);
    }
  };
  var Scale = class {
    constructor(_2, scale, transformOrigin) {
      this.type = "scale";
      this.scale = null;
      this.originX = null;
      this.originY = null;
      var scaleSize = Point.parseScale(scale);
      if (scaleSize.x === 0 || scaleSize.y === 0) {
        scaleSize.x = PSEUDO_ZERO;
        scaleSize.y = PSEUDO_ZERO;
      }
      this.scale = scaleSize;
      this.originX = transformOrigin[0];
      this.originY = transformOrigin[1];
    }
    apply(ctx) {
      var {
        scale: {
          x: x2,
          y: y2
        },
        originX,
        originY
      } = this;
      var tx = originX.getPixels("x");
      var ty = originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.scale(x2, y2 || x2);
      ctx.translate(-tx, -ty);
    }
    unapply(ctx) {
      var {
        scale: {
          x: x2,
          y: y2
        },
        originX,
        originY
      } = this;
      var tx = originX.getPixels("x");
      var ty = originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.scale(1 / x2, 1 / y2 || x2);
      ctx.translate(-tx, -ty);
    }
    applyToPoint(point) {
      var {
        x: x2,
        y: y2
      } = this.scale;
      point.applyTransform([x2 || 0, 0, 0, y2 || 0, 0, 0]);
    }
  };
  var Matrix = class {
    constructor(_2, matrix2, transformOrigin) {
      this.type = "matrix";
      this.matrix = [];
      this.originX = null;
      this.originY = null;
      this.matrix = toNumbers(matrix2);
      this.originX = transformOrigin[0];
      this.originY = transformOrigin[1];
    }
    apply(ctx) {
      var {
        originX,
        originY,
        matrix: matrix2
      } = this;
      var tx = originX.getPixels("x");
      var ty = originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.transform(matrix2[0], matrix2[1], matrix2[2], matrix2[3], matrix2[4], matrix2[5]);
      ctx.translate(-tx, -ty);
    }
    unapply(ctx) {
      var {
        originX,
        originY,
        matrix: matrix2
      } = this;
      var a2 = matrix2[0];
      var b2 = matrix2[2];
      var c2 = matrix2[4];
      var d2 = matrix2[1];
      var e2 = matrix2[3];
      var f2 = matrix2[5];
      var g2 = 0;
      var h2 = 0;
      var i2 = 1;
      var det = 1 / (a2 * (e2 * i2 - f2 * h2) - b2 * (d2 * i2 - f2 * g2) + c2 * (d2 * h2 - e2 * g2));
      var tx = originX.getPixels("x");
      var ty = originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.transform(det * (e2 * i2 - f2 * h2), det * (f2 * g2 - d2 * i2), det * (c2 * h2 - b2 * i2), det * (a2 * i2 - c2 * g2), det * (b2 * f2 - c2 * e2), det * (c2 * d2 - a2 * f2));
      ctx.translate(-tx, -ty);
    }
    applyToPoint(point) {
      point.applyTransform(this.matrix);
    }
  };
  var Skew = class extends Matrix {
    constructor(document2, skew, transformOrigin) {
      super(document2, skew, transformOrigin);
      this.type = "skew";
      this.angle = null;
      this.angle = new Property(document2, "angle", skew);
    }
  };
  var SkewX = class extends Skew {
    constructor(document2, skew, transformOrigin) {
      super(document2, skew, transformOrigin);
      this.type = "skewX";
      this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
    }
  };
  var SkewY = class extends Skew {
    constructor(document2, skew, transformOrigin) {
      super(document2, skew, transformOrigin);
      this.type = "skewY";
      this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
    }
  };
  function parseTransforms(transform) {
    return compressSpaces(transform).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
  }
  function parseTransform(transform) {
    var [type, value] = transform.split("(");
    return [type.trim(), value.trim().replace(")", "")];
  }
  var Transform = class _Transform {
    constructor(document2, transform, transformOrigin) {
      this.document = document2;
      this.transforms = [];
      var data = parseTransforms(transform);
      data.forEach((transform2) => {
        if (transform2 === "none") {
          return;
        }
        var [type, value] = parseTransform(transform2);
        var TransformType = _Transform.transformTypes[type];
        if (typeof TransformType !== "undefined") {
          this.transforms.push(new TransformType(this.document, value, transformOrigin));
        }
      });
    }
    static fromElement(document2, element) {
      var transformStyle = element.getStyle("transform", false, true);
      var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle("transform-origin", false, true).split();
      var transformOrigin = [transformOriginXProperty, transformOriginYProperty];
      if (transformStyle.hasValue()) {
        return new _Transform(document2, transformStyle.getString(), transformOrigin);
      }
      return null;
    }
    apply(ctx) {
      var {
        transforms
      } = this;
      var len = transforms.length;
      for (var i2 = 0; i2 < len; i2++) {
        transforms[i2].apply(ctx);
      }
    }
    unapply(ctx) {
      var {
        transforms
      } = this;
      var len = transforms.length;
      for (var i2 = len - 1; i2 >= 0; i2--) {
        transforms[i2].unapply(ctx);
      }
    }
    // TODO: applyToPoint unused ... remove?
    applyToPoint(point) {
      var {
        transforms
      } = this;
      var len = transforms.length;
      for (var i2 = 0; i2 < len; i2++) {
        transforms[i2].applyToPoint(point);
      }
    }
  };
  Transform.transformTypes = {
    translate: Translate,
    rotate: Rotate,
    scale: Scale,
    matrix: Matrix,
    skewX: SkewX,
    skewY: SkewY
  };
  var Element = class _Element {
    constructor(document2, node2) {
      var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.document = document2;
      this.node = node2;
      this.captureTextNodes = captureTextNodes;
      this.attributes = /* @__PURE__ */ Object.create(null);
      this.styles = /* @__PURE__ */ Object.create(null);
      this.stylesSpecificity = /* @__PURE__ */ Object.create(null);
      this.animationFrozen = false;
      this.animationFrozenValue = "";
      this.parent = null;
      this.children = [];
      if (!node2 || node2.nodeType !== 1) {
        return;
      }
      Array.from(node2.attributes).forEach((attribute) => {
        var nodeName = normalizeAttributeName(attribute.nodeName);
        this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);
      });
      this.addStylesFromStyleDefinition();
      if (this.getAttribute("style").hasValue()) {
        var styles = this.getAttribute("style").getString().split(";").map((_2) => _2.trim());
        styles.forEach((style) => {
          if (!style) {
            return;
          }
          var [name, value] = style.split(":").map((_2) => _2.trim());
          this.styles[name] = new Property(document2, name, value);
        });
      }
      var {
        definitions
      } = document2;
      var id = this.getAttribute("id");
      if (id.hasValue()) {
        if (!definitions[id.getString()]) {
          definitions[id.getString()] = this;
        }
      }
      Array.from(node2.childNodes).forEach((childNode) => {
        if (childNode.nodeType === 1) {
          this.addChild(childNode);
        } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
          var textNode = document2.createTextNode(childNode);
          if (textNode.getText().length > 0) {
            this.addChild(textNode);
          }
        }
      });
    }
    getAttribute(name) {
      var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var attr = this.attributes[name];
      if (!attr && createIfNotExists) {
        var _attr = new Property(this.document, name, "");
        this.attributes[name] = _attr;
        return _attr;
      }
      return attr || Property.empty(this.document);
    }
    getHrefAttribute() {
      for (var key in this.attributes) {
        if (key === "href" || key.endsWith(":href")) {
          return this.attributes[key];
        }
      }
      return Property.empty(this.document);
    }
    getStyle(name) {
      var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var style = this.styles[name];
      if (style) {
        return style;
      }
      var attr = this.getAttribute(name);
      if (attr !== null && attr !== void 0 && attr.hasValue()) {
        this.styles[name] = attr;
        return attr;
      }
      if (!skipAncestors) {
        var {
          parent
        } = this;
        if (parent) {
          var parentStyle = parent.getStyle(name);
          if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
            return parentStyle;
          }
        }
      }
      if (createIfNotExists) {
        var _style = new Property(this.document, name, "");
        this.styles[name] = _style;
        return _style;
      }
      return style || Property.empty(this.document);
    }
    render(ctx) {
      if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
        return;
      }
      ctx.save();
      if (this.getStyle("mask").hasValue()) {
        var mask = this.getStyle("mask").getDefinition();
        if (mask) {
          this.applyEffects(ctx);
          mask.apply(ctx, this);
        }
      } else if (this.getStyle("filter").getValue("none") !== "none") {
        var filter = this.getStyle("filter").getDefinition();
        if (filter) {
          this.applyEffects(ctx);
          filter.apply(ctx, this);
        }
      } else {
        this.setContext(ctx);
        this.renderChildren(ctx);
        this.clearContext(ctx);
      }
      ctx.restore();
    }
    setContext(_2) {
    }
    applyEffects(ctx) {
      var transform = Transform.fromElement(this.document, this);
      if (transform) {
        transform.apply(ctx);
      }
      var clipPathStyleProp = this.getStyle("clip-path", false, true);
      if (clipPathStyleProp.hasValue()) {
        var clip = clipPathStyleProp.getDefinition();
        if (clip) {
          clip.apply(ctx);
        }
      }
    }
    clearContext(_2) {
    }
    renderChildren(ctx) {
      this.children.forEach((child) => {
        child.render(ctx);
      });
    }
    addChild(childNode) {
      var child = childNode instanceof _Element ? childNode : this.document.createElement(childNode);
      child.parent = this;
      if (!_Element.ignoreChildTypes.includes(child.type)) {
        this.children.push(child);
      }
    }
    matchesSelector(selector) {
      var _node$getAttribute;
      var {
        node: node2
      } = this;
      if (typeof node2.matches === "function") {
        return node2.matches(selector);
      }
      var styleClasses = (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "class");
      if (!styleClasses || styleClasses === "") {
        return false;
      }
      return styleClasses.split(" ").some((styleClass) => ".".concat(styleClass) === selector);
    }
    addStylesFromStyleDefinition() {
      var {
        styles,
        stylesSpecificity
      } = this.document;
      for (var selector in styles) {
        if (!selector.startsWith("@") && this.matchesSelector(selector)) {
          var style = styles[selector];
          var specificity = stylesSpecificity[selector];
          if (style) {
            for (var name in style) {
              var existingSpecificity = this.stylesSpecificity[name];
              if (typeof existingSpecificity === "undefined") {
                existingSpecificity = "000";
              }
              if (specificity >= existingSpecificity) {
                this.styles[name] = style[name];
                this.stylesSpecificity[name] = specificity;
              }
            }
          }
        }
      }
    }
    removeStyles(element, ignoreStyles) {
      var toRestore = ignoreStyles.reduce((toRestore2, name) => {
        var styleProp = element.getStyle(name);
        if (!styleProp.hasValue()) {
          return toRestore2;
        }
        var value = styleProp.getString();
        styleProp.setValue("");
        return [...toRestore2, [name, value]];
      }, []);
      return toRestore;
    }
    restoreStyles(element, styles) {
      styles.forEach((_ref) => {
        var [name, value] = _ref;
        element.getStyle(name, true).setValue(value);
      });
    }
    isFirstChild() {
      var _this$parent;
      return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
    }
  };
  Element.ignoreChildTypes = ["title"];
  var UnknownElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
    }
  };
  function wrapFontFamily(fontFamily) {
    var trimmed = fontFamily.trim();
    return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
  }
  function prepareFontFamily(fontFamily) {
    return typeof process === "undefined" ? fontFamily : fontFamily.trim().split(",").map(wrapFontFamily).join(",");
  }
  function prepareFontStyle(fontStyle) {
    if (!fontStyle) {
      return "";
    }
    var targetFontStyle = fontStyle.trim().toLowerCase();
    switch (targetFontStyle) {
      case "normal":
      case "italic":
      case "oblique":
      case "inherit":
      case "initial":
      case "unset":
        return targetFontStyle;
      default:
        if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
          return targetFontStyle;
        }
        return "";
    }
  }
  function prepareFontWeight(fontWeight) {
    if (!fontWeight) {
      return "";
    }
    var targetFontWeight = fontWeight.trim().toLowerCase();
    switch (targetFontWeight) {
      case "normal":
      case "bold":
      case "lighter":
      case "bolder":
      case "inherit":
      case "initial":
      case "unset":
        return targetFontWeight;
      default:
        if (/^[\d.]+$/.test(targetFontWeight)) {
          return targetFontWeight;
        }
        return "";
    }
  }
  var Font = class _Font {
    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
      var inheritFont = inherit ? typeof inherit === "string" ? _Font.parse(inherit) : inherit : {};
      this.fontFamily = fontFamily || inheritFont.fontFamily;
      this.fontSize = fontSize || inheritFont.fontSize;
      this.fontStyle = fontStyle || inheritFont.fontStyle;
      this.fontWeight = fontWeight || inheritFont.fontWeight;
      this.fontVariant = fontVariant || inheritFont.fontVariant;
    }
    static parse() {
      var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var inherit = arguments.length > 1 ? arguments[1] : void 0;
      var fontStyle = "";
      var fontVariant = "";
      var fontWeight = "";
      var fontSize = "";
      var fontFamily = "";
      var parts = compressSpaces(font).trim().split(" ");
      var set = {
        fontSize: false,
        fontStyle: false,
        fontWeight: false,
        fontVariant: false
      };
      parts.forEach((part) => {
        switch (true) {
          case (!set.fontStyle && _Font.styles.includes(part)):
            if (part !== "inherit") {
              fontStyle = part;
            }
            set.fontStyle = true;
            break;
          case (!set.fontVariant && _Font.variants.includes(part)):
            if (part !== "inherit") {
              fontVariant = part;
            }
            set.fontStyle = true;
            set.fontVariant = true;
            break;
          case (!set.fontWeight && _Font.weights.includes(part)):
            if (part !== "inherit") {
              fontWeight = part;
            }
            set.fontStyle = true;
            set.fontVariant = true;
            set.fontWeight = true;
            break;
          case !set.fontSize:
            if (part !== "inherit") {
              [fontSize] = part.split("/");
            }
            set.fontStyle = true;
            set.fontVariant = true;
            set.fontWeight = true;
            set.fontSize = true;
            break;
          default:
            if (part !== "inherit") {
              fontFamily += part;
            }
        }
      });
      return new _Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);
    }
    toString() {
      return [
        prepareFontStyle(this.fontStyle),
        this.fontVariant,
        prepareFontWeight(this.fontWeight),
        this.fontSize,
        // Wrap fontFamily only on nodejs and only for canvas.ctx
        prepareFontFamily(this.fontFamily)
      ].join(" ").trim();
    }
  };
  Font.styles = "normal|italic|oblique|inherit";
  Font.variants = "normal|small-caps|inherit";
  Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
  var BoundingBox = class {
    constructor() {
      var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;
      var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;
      var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;
      var y2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.addPoint(x1, y1);
      this.addPoint(x2, y2);
    }
    get x() {
      return this.x1;
    }
    get y() {
      return this.y1;
    }
    get width() {
      return this.x2 - this.x1;
    }
    get height() {
      return this.y2 - this.y1;
    }
    addPoint(x2, y2) {
      if (typeof x2 !== "undefined") {
        if (isNaN(this.x1) || isNaN(this.x2)) {
          this.x1 = x2;
          this.x2 = x2;
        }
        if (x2 < this.x1) {
          this.x1 = x2;
        }
        if (x2 > this.x2) {
          this.x2 = x2;
        }
      }
      if (typeof y2 !== "undefined") {
        if (isNaN(this.y1) || isNaN(this.y2)) {
          this.y1 = y2;
          this.y2 = y2;
        }
        if (y2 < this.y1) {
          this.y1 = y2;
        }
        if (y2 > this.y2) {
          this.y2 = y2;
        }
      }
    }
    addX(x2) {
      this.addPoint(x2, null);
    }
    addY(y2) {
      this.addPoint(null, y2);
    }
    addBoundingBox(boundingBox) {
      if (!boundingBox) {
        return;
      }
      var {
        x1,
        y1,
        x2,
        y2
      } = boundingBox;
      this.addPoint(x1, y1);
      this.addPoint(x2, y2);
    }
    sumCubic(t3, p0, p1, p2, p3) {
      return Math.pow(1 - t3, 3) * p0 + 3 * Math.pow(1 - t3, 2) * t3 * p1 + 3 * (1 - t3) * Math.pow(t3, 2) * p2 + Math.pow(t3, 3) * p3;
    }
    bezierCurveAdd(forX, p0, p1, p2, p3) {
      var b2 = 6 * p0 - 12 * p1 + 6 * p2;
      var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
      var c2 = 3 * p1 - 3 * p0;
      if (a2 === 0) {
        if (b2 === 0) {
          return;
        }
        var t3 = -c2 / b2;
        if (0 < t3 && t3 < 1) {
          if (forX) {
            this.addX(this.sumCubic(t3, p0, p1, p2, p3));
          } else {
            this.addY(this.sumCubic(t3, p0, p1, p2, p3));
          }
        }
        return;
      }
      var b2ac = Math.pow(b2, 2) - 4 * c2 * a2;
      if (b2ac < 0) {
        return;
      }
      var t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a2);
      if (0 < t1 && t1 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t1, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t1, p0, p1, p2, p3));
        }
      }
      var t22 = (-b2 - Math.sqrt(b2ac)) / (2 * a2);
      if (0 < t22 && t22 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t22, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t22, p0, p1, p2, p3));
        }
      }
    }
    // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
      this.addPoint(p0x, p0y);
      this.addPoint(p3x, p3y);
      this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
      this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
    }
    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
      var cp1x = p0x + 2 / 3 * (p1x - p0x);
      var cp1y = p0y + 2 / 3 * (p1y - p0y);
      var cp2x = cp1x + 1 / 3 * (p2x - p0x);
      var cp2y = cp1y + 1 / 3 * (p2y - p0y);
      this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
    }
    isPointInBox(x2, y2) {
      var {
        x1,
        y1,
        x2: x22,
        y2: y22
      } = this;
      return x1 <= x2 && x2 <= x22 && y1 <= y2 && y2 <= y22;
    }
  };
  var PathParser = class extends _ {
    constructor(path2) {
      super(path2.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
      this.control = null;
      this.start = null;
      this.current = null;
      this.command = null;
      this.commands = this.commands;
      this.i = -1;
      this.previousCommand = null;
      this.points = [];
      this.angles = [];
    }
    reset() {
      this.i = -1;
      this.command = null;
      this.previousCommand = null;
      this.start = new Point(0, 0);
      this.control = new Point(0, 0);
      this.current = new Point(0, 0);
      this.points = [];
      this.angles = [];
    }
    isEnd() {
      var {
        i: i2,
        commands
      } = this;
      return i2 >= commands.length - 1;
    }
    next() {
      var command = this.commands[++this.i];
      this.previousCommand = this.command;
      this.command = command;
      return command;
    }
    getPoint() {
      var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x";
      var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
      var point = new Point(this.command[xProp], this.command[yProp]);
      return this.makeAbsolute(point);
    }
    getAsControlPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.control = point;
      return point;
    }
    getAsCurrentPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.current = point;
      return point;
    }
    getReflectedControlPoint() {
      var previousCommand = this.previousCommand.type;
      if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
        return this.current;
      }
      var {
        current: {
          x: cx,
          y: cy
        },
        control: {
          x: ox,
          y: oy
        }
      } = this;
      var point = new Point(2 * cx - ox, 2 * cy - oy);
      return point;
    }
    makeAbsolute(point) {
      if (this.command.relative) {
        var {
          x: x2,
          y: y2
        } = this.current;
        point.x += x2;
        point.y += y2;
      }
      return point;
    }
    addMarker(point, from, priorTo) {
      var {
        points,
        angles
      } = this;
      if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
        angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
      }
      this.addMarkerAngle(point, from ? from.angleTo(point) : null);
    }
    addMarkerAngle(point, angle2) {
      this.points.push(point);
      this.angles.push(angle2);
    }
    getMarkerPoints() {
      return this.points;
    }
    getMarkerAngles() {
      var {
        angles
      } = this;
      var len = angles.length;
      for (var i2 = 0; i2 < len; i2++) {
        if (!angles[i2]) {
          for (var j2 = i2 + 1; j2 < len; j2++) {
            if (angles[j2]) {
              angles[i2] = angles[j2];
              break;
            }
          }
        }
      }
      return angles;
    }
  };
  var RenderedElement = class extends Element {
    constructor() {
      super(...arguments);
      this.modifiedEmSizeStack = false;
    }
    calculateOpacity() {
      var opacity = 1;
      var element = this;
      while (element) {
        var opacityStyle = element.getStyle("opacity", false, true);
        if (opacityStyle.hasValue(true)) {
          opacity *= opacityStyle.getNumber();
        }
        element = element.parent;
      }
      return opacity;
    }
    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!fromMeasure) {
        var fillStyleProp = this.getStyle("fill");
        var fillOpacityStyleProp = this.getStyle("fill-opacity");
        var strokeStyleProp = this.getStyle("stroke");
        var strokeOpacityProp = this.getStyle("stroke-opacity");
        if (fillStyleProp.isUrlDefinition()) {
          var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
          if (fillStyle) {
            ctx.fillStyle = fillStyle;
          }
        } else if (fillStyleProp.hasValue()) {
          if (fillStyleProp.getString() === "currentColor") {
            fillStyleProp.setValue(this.getStyle("color").getColor());
          }
          var _fillStyle = fillStyleProp.getColor();
          if (_fillStyle !== "inherit") {
            ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
          }
        }
        if (fillOpacityStyleProp.hasValue()) {
          var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
          ctx.fillStyle = _fillStyle2;
        }
        if (strokeStyleProp.isUrlDefinition()) {
          var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
          if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
          }
        } else if (strokeStyleProp.hasValue()) {
          if (strokeStyleProp.getString() === "currentColor") {
            strokeStyleProp.setValue(this.getStyle("color").getColor());
          }
          var _strokeStyle = strokeStyleProp.getString();
          if (_strokeStyle !== "inherit") {
            ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
          }
        }
        if (strokeOpacityProp.hasValue()) {
          var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
          ctx.strokeStyle = _strokeStyle2;
        }
        var strokeWidthStyleProp = this.getStyle("stroke-width");
        if (strokeWidthStyleProp.hasValue()) {
          var newLineWidth = strokeWidthStyleProp.getPixels();
          ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
        }
        var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
        var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
        var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
        var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
        var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
        if (strokeLinecapStyleProp.hasValue()) {
          ctx.lineCap = strokeLinecapStyleProp.getString();
        }
        if (strokeLinejoinStyleProp.hasValue()) {
          ctx.lineJoin = strokeLinejoinStyleProp.getString();
        }
        if (strokeMiterlimitProp.hasValue()) {
          ctx.miterLimit = strokeMiterlimitProp.getNumber();
        }
        if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
          var gaps = toNumbers(strokeDasharrayStyleProp.getString());
          if (typeof ctx.setLineDash !== "undefined") {
            ctx.setLineDash(gaps);
          } else if (typeof ctx.webkitLineDash !== "undefined") {
            ctx.webkitLineDash = gaps;
          } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
            ctx.mozDash = gaps;
          }
          var offset = strokeDashoffsetProp.getPixels();
          if (typeof ctx.lineDashOffset !== "undefined") {
            ctx.lineDashOffset = offset;
          } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
            ctx.webkitLineDashOffset = offset;
          } else if (typeof ctx.mozDashOffset !== "undefined") {
            ctx.mozDashOffset = offset;
          }
        }
      }
      this.modifiedEmSizeStack = false;
      if (typeof ctx.font !== "undefined") {
        var fontStyleProp = this.getStyle("font");
        var fontStyleStyleProp = this.getStyle("font-style");
        var fontVariantStyleProp = this.getStyle("font-variant");
        var fontWeightStyleProp = this.getStyle("font-weight");
        var fontSizeStyleProp = this.getStyle("font-size");
        var fontFamilyStyleProp = this.getStyle("font-family");
        var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
        fontStyleStyleProp.setValue(font.fontStyle);
        fontVariantStyleProp.setValue(font.fontVariant);
        fontWeightStyleProp.setValue(font.fontWeight);
        fontSizeStyleProp.setValue(font.fontSize);
        fontFamilyStyleProp.setValue(font.fontFamily);
        ctx.font = font.toString();
        if (fontSizeStyleProp.isPixels()) {
          this.document.emSize = fontSizeStyleProp.getPixels();
          this.modifiedEmSizeStack = true;
        }
      }
      if (!fromMeasure) {
        this.applyEffects(ctx);
        ctx.globalAlpha = this.calculateOpacity();
      }
    }
    clearContext(ctx) {
      super.clearContext(ctx);
      if (this.modifiedEmSizeStack) {
        this.document.popEmSize();
      }
    }
  };
  var PathElement = class _PathElement extends RenderedElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "path";
      this.pathParser = null;
      this.pathParser = new PathParser(this.getAttribute("d").getString());
    }
    path(ctx) {
      var {
        pathParser
      } = this;
      var boundingBox = new BoundingBox();
      pathParser.reset();
      if (ctx) {
        ctx.beginPath();
      }
      while (!pathParser.isEnd()) {
        switch (pathParser.next().type) {
          case PathParser.MOVE_TO:
            this.pathM(ctx, boundingBox);
            break;
          case PathParser.LINE_TO:
            this.pathL(ctx, boundingBox);
            break;
          case PathParser.HORIZ_LINE_TO:
            this.pathH(ctx, boundingBox);
            break;
          case PathParser.VERT_LINE_TO:
            this.pathV(ctx, boundingBox);
            break;
          case PathParser.CURVE_TO:
            this.pathC(ctx, boundingBox);
            break;
          case PathParser.SMOOTH_CURVE_TO:
            this.pathS(ctx, boundingBox);
            break;
          case PathParser.QUAD_TO:
            this.pathQ(ctx, boundingBox);
            break;
          case PathParser.SMOOTH_QUAD_TO:
            this.pathT(ctx, boundingBox);
            break;
          case PathParser.ARC:
            this.pathA(ctx, boundingBox);
            break;
          case PathParser.CLOSE_PATH:
            this.pathZ(ctx, boundingBox);
            break;
        }
      }
      return boundingBox;
    }
    getBoundingBox(_2) {
      return this.path();
    }
    getMarkers() {
      var {
        pathParser
      } = this;
      var points = pathParser.getMarkerPoints();
      var angles = pathParser.getMarkerAngles();
      var markers = points.map((point, i2) => [point, angles[i2]]);
      return markers;
    }
    renderChildren(ctx) {
      this.path(ctx);
      this.document.screen.mouse.checkPath(this, ctx);
      var fillRuleStyleProp = this.getStyle("fill-rule");
      if (ctx.fillStyle !== "") {
        if (fillRuleStyleProp.getString("inherit") !== "inherit") {
          ctx.fill(fillRuleStyleProp.getString());
        } else {
          ctx.fill();
        }
      }
      if (ctx.strokeStyle !== "") {
        if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.stroke();
        }
      }
      var markers = this.getMarkers();
      if (markers) {
        var markersLastIndex = markers.length - 1;
        var markerStartStyleProp = this.getStyle("marker-start");
        var markerMidStyleProp = this.getStyle("marker-mid");
        var markerEndStyleProp = this.getStyle("marker-end");
        if (markerStartStyleProp.isUrlDefinition()) {
          var marker = markerStartStyleProp.getDefinition();
          var [point, angle2] = markers[0];
          marker.render(ctx, point, angle2);
        }
        if (markerMidStyleProp.isUrlDefinition()) {
          var _marker = markerMidStyleProp.getDefinition();
          for (var i2 = 1; i2 < markersLastIndex; i2++) {
            var [_point, _angle] = markers[i2];
            _marker.render(ctx, _point, _angle);
          }
        }
        if (markerEndStyleProp.isUrlDefinition()) {
          var _marker2 = markerEndStyleProp.getDefinition();
          var [_point2, _angle2] = markers[markersLastIndex];
          _marker2.render(ctx, _point2, _angle2);
        }
      }
    }
    static pathM(pathParser) {
      var point = pathParser.getAsCurrentPoint();
      pathParser.start = pathParser.current;
      return {
        point
      };
    }
    pathM(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        point
      } = _PathElement.pathM(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.moveTo(x2, y2);
      }
    }
    static pathL(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getAsCurrentPoint();
      return {
        current,
        point
      };
    }
    pathL(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = _PathElement.pathL(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    }
    static pathH(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }
    pathH(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = _PathElement.pathH(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    }
    static pathV(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }
    pathV(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = _PathElement.pathV(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    }
    static pathC(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getPoint("x1", "y1");
      var controlPoint = pathParser.getAsControlPoint("x2", "y2");
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }
    pathC(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = _PathElement.pathC(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathS(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getReflectedControlPoint();
      var controlPoint = pathParser.getAsControlPoint("x2", "y2");
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }
    pathS(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = _PathElement.pathS(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathQ(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getAsControlPoint("x1", "y1");
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }
    pathQ(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = _PathElement.pathQ(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathT(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getReflectedControlPoint();
      pathParser.control = controlPoint;
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }
    pathT(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = _PathElement.pathT(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathA(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var {
        rX,
        rY,
        xRot,
        lArcFlag,
        sweepFlag
      } = command;
      var xAxisRotation = xRot * (Math.PI / 180);
      var currentPoint = pathParser.getAsCurrentPoint();
      var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
      var l2 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
      if (l2 > 1) {
        rX *= Math.sqrt(l2);
        rY *= Math.sqrt(l2);
      }
      var s2 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
      if (isNaN(s2)) {
        s2 = 0;
      }
      var cpp = new Point(s2 * rX * currp.y / rY, s2 * -rY * currp.x / rX);
      var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
      var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
      var u2 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
      var v2 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
      var ad = vectorsAngle(u2, v2);
      if (vectorsRatio(u2, v2) <= -1) {
        ad = Math.PI;
      }
      if (vectorsRatio(u2, v2) >= 1) {
        ad = 0;
      }
      return {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      };
    }
    pathA(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = _PathElement.pathA(pathParser);
      var dir = 1 - sweepFlag ? 1 : -1;
      var ah = a1 + dir * (ad / 2);
      var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
      pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
      pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
      boundingBox.addPoint(currentPoint.x, currentPoint.y);
      if (ctx && !isNaN(a1) && !isNaN(ad)) {
        var r2 = rX > rY ? rX : rY;
        var sx = rX > rY ? 1 : rX / rY;
        var sy = rX > rY ? rY / rX : 1;
        ctx.translate(centp.x, centp.y);
        ctx.rotate(xAxisRotation);
        ctx.scale(sx, sy);
        ctx.arc(0, 0, r2, a1, a1 + ad, Boolean(1 - sweepFlag));
        ctx.scale(1 / sx, 1 / sy);
        ctx.rotate(-xAxisRotation);
        ctx.translate(-centp.x, -centp.y);
      }
    }
    static pathZ(pathParser) {
      pathParser.current = pathParser.start;
    }
    pathZ(ctx, boundingBox) {
      _PathElement.pathZ(this.pathParser);
      if (ctx) {
        if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
          ctx.closePath();
        }
      }
    }
  };
  var GlyphElement = class extends PathElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "glyph";
      this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
      this.unicode = this.getAttribute("unicode").getString();
      this.arabicForm = this.getAttribute("arabic-form").getString();
    }
  };
  var TextElement = class _TextElement extends RenderedElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, new.target === _TextElement ? true : captureTextNodes);
      this.type = "text";
      this.x = 0;
      this.y = 0;
      this.measureCache = -1;
    }
    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      super.setContext(ctx, fromMeasure);
      var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
      if (textBaseline) {
        ctx.textBaseline = textBaseline;
      }
    }
    initializeCoordinates() {
      this.x = 0;
      this.y = 0;
      this.leafTexts = [];
      this.textChunkStart = 0;
      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
    }
    getBoundingBox(ctx) {
      if (this.type !== "text") {
        return this.getTElementBoundingBox(ctx);
      }
      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx);
      var boundingBox = null;
      this.children.forEach((_2, i2) => {
        var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i2);
        if (!boundingBox) {
          boundingBox = childBoundingBox;
        } else {
          boundingBox.addBoundingBox(childBoundingBox);
        }
      });
      return boundingBox;
    }
    getFontSize() {
      var {
        document: document2,
        parent
      } = this;
      var inheritFontSize = Font.parse(document2.ctx.font).fontSize;
      var fontSize = parent.getStyle("font-size").getNumber(inheritFontSize);
      return fontSize;
    }
    getTElementBoundingBox(ctx) {
      var fontSize = this.getFontSize();
      return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);
    }
    getGlyph(font, text2, i2) {
      var char = text2[i2];
      var glyph = null;
      if (font.isArabic) {
        var len = text2.length;
        var prevChar = text2[i2 - 1];
        var nextChar = text2[i2 + 1];
        var arabicForm = "isolated";
        if ((i2 === 0 || prevChar === " ") && i2 < len - 1 && nextChar !== " ") {
          arabicForm = "terminal";
        }
        if (i2 > 0 && prevChar !== " " && i2 < len - 1 && nextChar !== " ") {
          arabicForm = "medial";
        }
        if (i2 > 0 && prevChar !== " " && (i2 === len - 1 || nextChar === " ")) {
          arabicForm = "initial";
        }
        if (typeof font.glyphs[char] !== "undefined") {
          var maybeGlyph = font.glyphs[char];
          glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
        }
      } else {
        glyph = font.glyphs[char];
      }
      if (!glyph) {
        glyph = font.missingGlyph;
      }
      return glyph;
    }
    getText() {
      return "";
    }
    getTextFromNode(node2) {
      var textNode = node2 || this.node;
      var childNodes = Array.from(textNode.parentNode.childNodes);
      var index2 = childNodes.indexOf(textNode);
      var lastIndex = childNodes.length - 1;
      var text2 = compressSpaces(
        // textNode.value
        // || textNode.text
        textNode.textContent || ""
      );
      if (index2 === 0) {
        text2 = trimLeft(text2);
      }
      if (index2 === lastIndex) {
        text2 = trimRight(text2);
      }
      return text2;
    }
    renderChildren(ctx) {
      if (this.type !== "text") {
        this.renderTElementChildren(ctx);
        return;
      }
      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx);
      this.children.forEach((_2, i2) => {
        this.renderChild(ctx, this, this, i2);
      });
      var {
        mouse
      } = this.document.screen;
      if (mouse.isWorking()) {
        mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
      }
    }
    renderTElementChildren(ctx) {
      var {
        document: document2,
        parent
      } = this;
      var renderText = this.getText();
      var customFont = parent.getStyle("font-family").getDefinition();
      if (customFont) {
        var {
          unitsPerEm
        } = customFont.fontFace;
        var ctxFont = Font.parse(document2.ctx.font);
        var fontSize = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
        var fontStyle = parent.getStyle("font-style").getString(ctxFont.fontStyle);
        var scale = fontSize / unitsPerEm;
        var text2 = customFont.isRTL ? renderText.split("").reverse().join("") : renderText;
        var dx = toNumbers(parent.getAttribute("dx").getString());
        var len = text2.length;
        for (var i2 = 0; i2 < len; i2++) {
          var glyph = this.getGlyph(customFont, text2, i2);
          ctx.translate(this.x, this.y);
          ctx.scale(scale, -scale);
          var lw = ctx.lineWidth;
          ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;
          if (fontStyle === "italic") {
            ctx.transform(1, 0, 0.4, 1, 0, 0);
          }
          glyph.render(ctx);
          if (fontStyle === "italic") {
            ctx.transform(1, 0, -0.4, 1, 0, 0);
          }
          ctx.lineWidth = lw;
          ctx.scale(1 / scale, -1 / scale);
          ctx.translate(-this.x, -this.y);
          this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
          if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
            this.x += dx[i2];
          }
        }
        return;
      }
      var {
        x: x2,
        y: y2
      } = this;
      if (ctx.fillStyle) {
        ctx.fillText(renderText, x2, y2);
      }
      if (ctx.strokeStyle) {
        ctx.strokeText(renderText, x2, y2);
      }
    }
    applyAnchoring() {
      if (this.textChunkStart >= this.leafTexts.length) {
        return;
      }
      var firstElement = this.leafTexts[this.textChunkStart];
      var textAnchor = firstElement.getStyle("text-anchor").getString("start");
      var isRTL = false;
      var shift = 0;
      if (textAnchor === "start" && !isRTL || textAnchor === "end" && isRTL) {
        shift = firstElement.x - this.minX;
      } else if (textAnchor === "end" && !isRTL || textAnchor === "start" && isRTL) {
        shift = firstElement.x - this.maxX;
      } else {
        shift = firstElement.x - (this.minX + this.maxX) / 2;
      }
      for (var i2 = this.textChunkStart; i2 < this.leafTexts.length; i2++) {
        this.leafTexts[i2].x += shift;
      }
      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
      this.textChunkStart = this.leafTexts.length;
    }
    adjustChildCoordinatesRecursive(ctx) {
      this.children.forEach((_2, i2) => {
        this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i2);
      });
      this.applyAnchoring();
    }
    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i2) {
      var child = parent.children[i2];
      if (child.children.length > 0) {
        child.children.forEach((_2, i3) => {
          textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i3);
        });
      } else {
        this.adjustChildCoordinates(ctx, textParent, parent, i2);
      }
    }
    adjustChildCoordinates(ctx, textParent, parent, i2) {
      var child = parent.children[i2];
      if (typeof child.measureText !== "function") {
        return child;
      }
      ctx.save();
      child.setContext(ctx, true);
      var xAttr = child.getAttribute("x");
      var yAttr = child.getAttribute("y");
      var dxAttr = child.getAttribute("dx");
      var dyAttr = child.getAttribute("dy");
      var customFont = child.getStyle("font-family").getDefinition();
      var isRTL = Boolean(customFont) && customFont.isRTL;
      if (i2 === 0) {
        if (!xAttr.hasValue()) {
          xAttr.setValue(child.getInheritedAttribute("x"));
        }
        if (!yAttr.hasValue()) {
          yAttr.setValue(child.getInheritedAttribute("y"));
        }
        if (!dxAttr.hasValue()) {
          dxAttr.setValue(child.getInheritedAttribute("dx"));
        }
        if (!dyAttr.hasValue()) {
          dyAttr.setValue(child.getInheritedAttribute("dy"));
        }
      }
      var width = child.measureText(ctx);
      if (isRTL) {
        textParent.x -= width;
      }
      if (xAttr.hasValue()) {
        textParent.applyAnchoring();
        child.x = xAttr.getPixels("x");
        if (dxAttr.hasValue()) {
          child.x += dxAttr.getPixels("x");
        }
      } else {
        if (dxAttr.hasValue()) {
          textParent.x += dxAttr.getPixels("x");
        }
        child.x = textParent.x;
      }
      textParent.x = child.x;
      if (!isRTL) {
        textParent.x += width;
      }
      if (yAttr.hasValue()) {
        child.y = yAttr.getPixels("y");
        if (dyAttr.hasValue()) {
          child.y += dyAttr.getPixels("y");
        }
      } else {
        if (dyAttr.hasValue()) {
          textParent.y += dyAttr.getPixels("y");
        }
        child.y = textParent.y;
      }
      textParent.y = child.y;
      textParent.leafTexts.push(child);
      textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
      textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
      child.clearContext(ctx);
      ctx.restore();
      return child;
    }
    getChildBoundingBox(ctx, textParent, parent, i2) {
      var child = parent.children[i2];
      if (typeof child.getBoundingBox !== "function") {
        return null;
      }
      var boundingBox = child.getBoundingBox(ctx);
      if (!boundingBox) {
        return null;
      }
      child.children.forEach((_2, i3) => {
        var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i3);
        boundingBox.addBoundingBox(childBoundingBox);
      });
      return boundingBox;
    }
    renderChild(ctx, textParent, parent, i2) {
      var child = parent.children[i2];
      child.render(ctx);
      child.children.forEach((_2, i3) => {
        textParent.renderChild(ctx, textParent, child, i3);
      });
    }
    measureText(ctx) {
      var {
        measureCache
      } = this;
      if (~measureCache) {
        return measureCache;
      }
      var renderText = this.getText();
      var measure = this.measureTargetText(ctx, renderText);
      this.measureCache = measure;
      return measure;
    }
    measureTargetText(ctx, targetText) {
      if (!targetText.length) {
        return 0;
      }
      var {
        parent
      } = this;
      var customFont = parent.getStyle("font-family").getDefinition();
      if (customFont) {
        var fontSize = this.getFontSize();
        var text2 = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
        var dx = toNumbers(parent.getAttribute("dx").getString());
        var len = text2.length;
        var _measure = 0;
        for (var i2 = 0; i2 < len; i2++) {
          var glyph = this.getGlyph(customFont, text2, i2);
          _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
          if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
            _measure += dx[i2];
          }
        }
        return _measure;
      }
      if (!ctx.measureText) {
        return targetText.length * 10;
      }
      ctx.save();
      this.setContext(ctx, true);
      var {
        width: measure
      } = ctx.measureText(targetText);
      this.clearContext(ctx);
      ctx.restore();
      return measure;
    }
    /**
     * Inherits positional attributes from {@link TextElement} parent(s). Attributes
     * are only inherited from a parent to its first child.
     * @param name - The attribute name.
     * @returns The attribute value or null.
     */
    getInheritedAttribute(name) {
      var current = this;
      while (current instanceof _TextElement && current.isFirstChild()) {
        var parentAttr = current.parent.getAttribute(name);
        if (parentAttr.hasValue(true)) {
          return parentAttr.getValue("0");
        }
        current = current.parent;
      }
      return null;
    }
  };
  var TSpanElement = class _TSpanElement extends TextElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, new.target === _TSpanElement ? true : captureTextNodes);
      this.type = "tspan";
      this.text = this.children.length > 0 ? "" : this.getTextFromNode();
    }
    getText() {
      return this.text;
    }
  };
  var TextNode = class extends TSpanElement {
    constructor() {
      super(...arguments);
      this.type = "textNode";
    }
  };
  var SVGElement = class extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.root = false;
    }
    setContext(ctx) {
      var _this$node$parentNode;
      var {
        document: document2
      } = this;
      var {
        screen,
        window: window2
      } = document2;
      var canvas = ctx.canvas;
      screen.setDefaults(ctx);
      if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
        ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
        var fontSizeProp = new Property(document2, "fontSize", Font.parse(ctx.font).fontSize);
        if (fontSizeProp.hasValue()) {
          document2.rootEmSize = fontSizeProp.getPixels("y");
          document2.emSize = document2.rootEmSize;
        }
      }
      if (!this.getAttribute("x").hasValue()) {
        this.getAttribute("x", true).setValue(0);
      }
      if (!this.getAttribute("y").hasValue()) {
        this.getAttribute("y", true).setValue(0);
      }
      var {
        width,
        height
      } = screen.viewPort;
      if (!this.getStyle("width").hasValue()) {
        this.getStyle("width", true).setValue("100%");
      }
      if (!this.getStyle("height").hasValue()) {
        this.getStyle("height", true).setValue("100%");
      }
      if (!this.getStyle("color").hasValue()) {
        this.getStyle("color", true).setValue("black");
      }
      var refXAttr = this.getAttribute("refX");
      var refYAttr = this.getAttribute("refY");
      var viewBoxAttr = this.getAttribute("viewBox");
      var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
      var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
      var minX = 0;
      var minY = 0;
      var clipX = 0;
      var clipY = 0;
      if (viewBox) {
        minX = viewBox[0];
        minY = viewBox[1];
      }
      if (!this.root) {
        width = this.getStyle("width").getPixels("x");
        height = this.getStyle("height").getPixels("y");
        if (this.type === "marker") {
          clipX = minX;
          clipY = minY;
          minX = 0;
          minY = 0;
        }
      }
      screen.viewPort.setCurrent(width, height);
      if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
        this.getStyle("transform-origin", true, true).setValue("50% 50%");
      }
      super.setContext(ctx);
      ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
      if (viewBox) {
        width = viewBox[2];
        height = viewBox[3];
      }
      document2.setViewBox({
        ctx,
        aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
        width: screen.viewPort.width,
        desiredWidth: width,
        height: screen.viewPort.height,
        desiredHeight: height,
        minX,
        minY,
        refX: refXAttr.getValue(),
        refY: refYAttr.getValue(),
        clip,
        clipX,
        clipY
      });
      if (viewBox) {
        screen.viewPort.removeCurrent();
        screen.viewPort.setCurrent(width, height);
      }
    }
    clearContext(ctx) {
      super.clearContext(ctx);
      this.document.screen.viewPort.removeCurrent();
    }
    /**
     * Resize SVG to fit in given size.
     * @param width
     * @param height
     * @param preserveAspectRatio
     */
    resize(width) {
      var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
      var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var widthAttr = this.getAttribute("width", true);
      var heightAttr = this.getAttribute("height", true);
      var viewBoxAttr = this.getAttribute("viewBox");
      var styleAttr = this.getAttribute("style");
      var originWidth = widthAttr.getNumber(0);
      var originHeight = heightAttr.getNumber(0);
      if (preserveAspectRatio) {
        if (typeof preserveAspectRatio === "string") {
          this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
        } else {
          var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
          if (preserveAspectRatioAttr.hasValue()) {
            preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
          }
        }
      }
      widthAttr.setValue(width);
      heightAttr.setValue(height);
      if (!viewBoxAttr.hasValue()) {
        viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
      }
      if (styleAttr.hasValue()) {
        var widthStyle = this.getStyle("width");
        var heightStyle = this.getStyle("height");
        if (widthStyle.hasValue()) {
          widthStyle.setValue("".concat(width, "px"));
        }
        if (heightStyle.hasValue()) {
          heightStyle.setValue("".concat(height, "px"));
        }
      }
    }
  };
  var RectElement = class extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "rect";
    }
    path(ctx) {
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width", false, true).getPixels("x");
      var height = this.getStyle("height", false, true).getPixels("y");
      var rxAttr = this.getAttribute("rx");
      var ryAttr = this.getAttribute("ry");
      var rx = rxAttr.getPixels("x");
      var ry = ryAttr.getPixels("y");
      if (rxAttr.hasValue() && !ryAttr.hasValue()) {
        ry = rx;
      }
      if (ryAttr.hasValue() && !rxAttr.hasValue()) {
        rx = ry;
      }
      rx = Math.min(rx, width / 2);
      ry = Math.min(ry, height / 2);
      if (ctx) {
        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
        ctx.beginPath();
        if (height > 0 && width > 0) {
          ctx.moveTo(x2 + rx, y2);
          ctx.lineTo(x2 + width - rx, y2);
          ctx.bezierCurveTo(x2 + width - rx + KAPPA * rx, y2, x2 + width, y2 + ry - KAPPA * ry, x2 + width, y2 + ry);
          ctx.lineTo(x2 + width, y2 + height - ry);
          ctx.bezierCurveTo(x2 + width, y2 + height - ry + KAPPA * ry, x2 + width - rx + KAPPA * rx, y2 + height, x2 + width - rx, y2 + height);
          ctx.lineTo(x2 + rx, y2 + height);
          ctx.bezierCurveTo(x2 + rx - KAPPA * rx, y2 + height, x2, y2 + height - ry + KAPPA * ry, x2, y2 + height - ry);
          ctx.lineTo(x2, y2 + ry);
          ctx.bezierCurveTo(x2, y2 + ry - KAPPA * ry, x2 + rx - KAPPA * rx, y2, x2 + rx, y2);
          ctx.closePath();
        }
      }
      return new BoundingBox(x2, y2, x2 + width, y2 + height);
    }
    getMarkers() {
      return null;
    }
  };
  var CircleElement = class extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "circle";
    }
    path(ctx) {
      var cx = this.getAttribute("cx").getPixels("x");
      var cy = this.getAttribute("cy").getPixels("y");
      var r2 = this.getAttribute("r").getPixels();
      if (ctx && r2 > 0) {
        ctx.beginPath();
        ctx.arc(cx, cy, r2, 0, Math.PI * 2, false);
        ctx.closePath();
      }
      return new BoundingBox(cx - r2, cy - r2, cx + r2, cy + r2);
    }
    getMarkers() {
      return null;
    }
  };
  var EllipseElement = class extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "ellipse";
    }
    path(ctx) {
      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
      var rx = this.getAttribute("rx").getPixels("x");
      var ry = this.getAttribute("ry").getPixels("y");
      var cx = this.getAttribute("cx").getPixels("x");
      var cy = this.getAttribute("cy").getPixels("y");
      if (ctx && rx > 0 && ry > 0) {
        ctx.beginPath();
        ctx.moveTo(cx + rx, cy);
        ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
        ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
        ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
        ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
        ctx.closePath();
      }
      return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
    }
    getMarkers() {
      return null;
    }
  };
  var LineElement = class extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "line";
    }
    getPoints() {
      return [new Point(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
    }
    path(ctx) {
      var [{
        x: x0,
        y: y0
      }, {
        x: x1,
        y: y1
      }] = this.getPoints();
      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
      }
      return new BoundingBox(x0, y0, x1, y1);
    }
    getMarkers() {
      var [p0, p1] = this.getPoints();
      var a2 = p0.angleTo(p1);
      return [[p0, a2], [p1, a2]];
    }
  };
  var PolylineElement = class extends PathElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "polyline";
      this.points = [];
      this.points = Point.parsePath(this.getAttribute("points").getString());
    }
    path(ctx) {
      var {
        points
      } = this;
      var [{
        x: x0,
        y: y0
      }] = points;
      var boundingBox = new BoundingBox(x0, y0);
      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
      }
      points.forEach((_ref) => {
        var {
          x: x2,
          y: y2
        } = _ref;
        boundingBox.addPoint(x2, y2);
        if (ctx) {
          ctx.lineTo(x2, y2);
        }
      });
      return boundingBox;
    }
    getMarkers() {
      var {
        points
      } = this;
      var lastIndex = points.length - 1;
      var markers = [];
      points.forEach((point, i2) => {
        if (i2 === lastIndex) {
          return;
        }
        markers.push([point, point.angleTo(points[i2 + 1])]);
      });
      if (markers.length > 0) {
        markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
      }
      return markers;
    }
  };
  var PolygonElement = class extends PolylineElement {
    constructor() {
      super(...arguments);
      this.type = "polygon";
    }
    path(ctx) {
      var boundingBox = super.path(ctx);
      var [{
        x: x2,
        y: y2
      }] = this.points;
      if (ctx) {
        ctx.lineTo(x2, y2);
        ctx.closePath();
      }
      return boundingBox;
    }
  };
  var PatternElement = class extends Element {
    constructor() {
      super(...arguments);
      this.type = "pattern";
    }
    createPattern(ctx, _2, parentOpacityProp) {
      var width = this.getStyle("width").getPixels("x", true);
      var height = this.getStyle("height").getPixels("y", true);
      var patternSvg = new SVGElement(this.document, null);
      patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
      patternSvg.attributes.width = new Property(this.document, "width", "".concat(width, "px"));
      patternSvg.attributes.height = new Property(this.document, "height", "".concat(height, "px"));
      patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
      patternSvg.children = this.children;
      var patternCanvas = this.document.createCanvas(width, height);
      var patternCtx = patternCanvas.getContext("2d");
      var xAttr = this.getAttribute("x");
      var yAttr = this.getAttribute("y");
      if (xAttr.hasValue() && yAttr.hasValue()) {
        patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
      }
      if (parentOpacityProp.hasValue()) {
        this.styles["fill-opacity"] = parentOpacityProp;
      } else {
        Reflect.deleteProperty(this.styles, "fill-opacity");
      }
      for (var x2 = -1; x2 <= 1; x2++) {
        for (var y2 = -1; y2 <= 1; y2++) {
          patternCtx.save();
          patternSvg.attributes.x = new Property(this.document, "x", x2 * patternCanvas.width);
          patternSvg.attributes.y = new Property(this.document, "y", y2 * patternCanvas.height);
          patternSvg.render(patternCtx);
          patternCtx.restore();
        }
      }
      var pattern = ctx.createPattern(patternCanvas, "repeat");
      return pattern;
    }
  };
  var MarkerElement = class extends Element {
    constructor() {
      super(...arguments);
      this.type = "marker";
    }
    render(ctx, point, angle2) {
      if (!point) {
        return;
      }
      var {
        x: x2,
        y: y2
      } = point;
      var orient = this.getAttribute("orient").getString("auto");
      var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
      ctx.translate(x2, y2);
      if (orient === "auto") {
        ctx.rotate(angle2);
      }
      if (markerUnits === "strokeWidth") {
        ctx.scale(ctx.lineWidth, ctx.lineWidth);
      }
      ctx.save();
      var markerSvg = new SVGElement(this.document, null);
      markerSvg.type = this.type;
      markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
      markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
      markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
      markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
      markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
      markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
      markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
      markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
      markerSvg.children = this.children;
      markerSvg.render(ctx);
      ctx.restore();
      if (markerUnits === "strokeWidth") {
        ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
      }
      if (orient === "auto") {
        ctx.rotate(-angle2);
      }
      ctx.translate(-x2, -y2);
    }
  };
  var DefsElement = class extends Element {
    constructor() {
      super(...arguments);
      this.type = "defs";
    }
    render() {
    }
  };
  var GElement = class extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "g";
    }
    getBoundingBox(ctx) {
      var boundingBox = new BoundingBox();
      this.children.forEach((child) => {
        boundingBox.addBoundingBox(child.getBoundingBox(ctx));
      });
      return boundingBox;
    }
  };
  var GradientElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.attributesToInherit = ["gradientUnits"];
      this.stops = [];
      var {
        stops,
        children
      } = this;
      children.forEach((child) => {
        if (child.type === "stop") {
          stops.push(child);
        }
      });
    }
    getGradientUnits() {
      return this.getAttribute("gradientUnits").getString("objectBoundingBox");
    }
    createGradient(ctx, element, parentOpacityProp) {
      var stopsContainer = this;
      if (this.getHrefAttribute().hasValue()) {
        stopsContainer = this.getHrefAttribute().getDefinition();
        this.inheritStopContainer(stopsContainer);
      }
      var {
        stops
      } = stopsContainer;
      var gradient = this.getGradient(ctx, element);
      if (!gradient) {
        return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
      }
      stops.forEach((stop) => {
        gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
      });
      if (this.getAttribute("gradientTransform").hasValue()) {
        var {
          document: document2
        } = this;
        var {
          MAX_VIRTUAL_PIXELS,
          viewPort
        } = document2.screen;
        var [rootView] = viewPort.viewPorts;
        var rect = new RectElement(document2, null);
        rect.attributes.x = new Property(document2, "x", -MAX_VIRTUAL_PIXELS / 3);
        rect.attributes.y = new Property(document2, "y", -MAX_VIRTUAL_PIXELS / 3);
        rect.attributes.width = new Property(document2, "width", MAX_VIRTUAL_PIXELS);
        rect.attributes.height = new Property(document2, "height", MAX_VIRTUAL_PIXELS);
        var group = new GElement(document2, null);
        group.attributes.transform = new Property(document2, "transform", this.getAttribute("gradientTransform").getValue());
        group.children = [rect];
        var patternSvg = new SVGElement(document2, null);
        patternSvg.attributes.x = new Property(document2, "x", 0);
        patternSvg.attributes.y = new Property(document2, "y", 0);
        patternSvg.attributes.width = new Property(document2, "width", rootView.width);
        patternSvg.attributes.height = new Property(document2, "height", rootView.height);
        patternSvg.children = [group];
        var patternCanvas = document2.createCanvas(rootView.width, rootView.height);
        var patternCtx = patternCanvas.getContext("2d");
        patternCtx.fillStyle = gradient;
        patternSvg.render(patternCtx);
        return patternCtx.createPattern(patternCanvas, "no-repeat");
      }
      return gradient;
    }
    inheritStopContainer(stopsContainer) {
      this.attributesToInherit.forEach((attributeToInherit) => {
        if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
          this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
        }
      });
    }
    addParentOpacity(parentOpacityProp, color) {
      if (parentOpacityProp.hasValue()) {
        var colorProp = new Property(this.document, "color", color);
        return colorProp.addOpacity(parentOpacityProp).getColor();
      }
      return color;
    }
  };
  var LinearGradientElement = class extends GradientElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "linearGradient";
      this.attributesToInherit.push("x1", "y1", "x2", "y2");
    }
    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
      var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }
      if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
        this.getAttribute("x1", true).setValue(0);
        this.getAttribute("y1", true).setValue(0);
        this.getAttribute("x2", true).setValue(1);
        this.getAttribute("y2", true).setValue(0);
      }
      var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
      var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
      var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
      var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
      if (x1 === x2 && y1 === y2) {
        return null;
      }
      return ctx.createLinearGradient(x1, y1, x2, y2);
    }
  };
  var RadialGradientElement = class extends GradientElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "radialGradient";
      this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
    }
    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
      var boundingBox = element.getBoundingBox(ctx);
      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }
      if (!this.getAttribute("cx").hasValue()) {
        this.getAttribute("cx", true).setValue("50%");
      }
      if (!this.getAttribute("cy").hasValue()) {
        this.getAttribute("cy", true).setValue("50%");
      }
      if (!this.getAttribute("r").hasValue()) {
        this.getAttribute("r", true).setValue("50%");
      }
      var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
      var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
      var fx = cx;
      var fy = cy;
      if (this.getAttribute("fx").hasValue()) {
        fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
      }
      if (this.getAttribute("fy").hasValue()) {
        fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
      }
      var r2 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
      var fr = this.getAttribute("fr").getPixels();
      return ctx.createRadialGradient(fx, fy, fr, cx, cy, r2);
    }
  };
  var StopElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "stop";
      var offset = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber()));
      var stopOpacity = this.getStyle("stop-opacity");
      var stopColor = this.getStyle("stop-color", true);
      if (stopColor.getString() === "") {
        stopColor.setValue("#000");
      }
      if (stopOpacity.hasValue()) {
        stopColor = stopColor.addOpacity(stopOpacity);
      }
      this.offset = offset;
      this.color = stopColor.getColor();
    }
  };
  var AnimateElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "animate";
      this.duration = 0;
      this.initialValue = null;
      this.initialUnits = "";
      this.removed = false;
      this.frozen = false;
      document2.screen.animations.push(this);
      this.begin = this.getAttribute("begin").getMilliseconds();
      this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds();
      this.from = this.getAttribute("from");
      this.to = this.getAttribute("to");
      this.values = new Property(document2, "values", null);
      var valuesAttr = this.getAttribute("values");
      if (valuesAttr.hasValue()) {
        this.values.setValue(valuesAttr.getString().split(";"));
      }
    }
    getProperty() {
      var attributeType = this.getAttribute("attributeType").getString();
      var attributeName = this.getAttribute("attributeName").getString();
      if (attributeType === "CSS") {
        return this.parent.getStyle(attributeName, true);
      }
      return this.parent.getAttribute(attributeName, true);
    }
    calcValue() {
      var {
        initialUnits
      } = this;
      var {
        progress,
        from,
        to
      } = this.getProgress();
      var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;
      if (initialUnits === "%") {
        newValue *= 100;
      }
      return "".concat(newValue).concat(initialUnits);
    }
    update(delta) {
      var {
        parent
      } = this;
      var prop = this.getProperty();
      if (!this.initialValue) {
        this.initialValue = prop.getString();
        this.initialUnits = prop.getUnits();
      }
      if (this.duration > this.maxDuration) {
        var fill = this.getAttribute("fill").getString("remove");
        if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
          this.duration = 0;
        } else if (fill === "freeze" && !this.frozen) {
          this.frozen = true;
          parent.animationFrozen = true;
          parent.animationFrozenValue = prop.getString();
        } else if (fill === "remove" && !this.removed) {
          this.removed = true;
          prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
          return true;
        }
        return false;
      }
      this.duration += delta;
      var updated = false;
      if (this.begin < this.duration) {
        var newValue = this.calcValue();
        var typeAttr = this.getAttribute("type");
        if (typeAttr.hasValue()) {
          var type = typeAttr.getString();
          newValue = "".concat(type, "(").concat(newValue, ")");
        }
        prop.setValue(newValue);
        updated = true;
      }
      return updated;
    }
    getProgress() {
      var {
        document: document2,
        values
      } = this;
      var result = {
        progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
      };
      if (values.hasValue()) {
        var p2 = result.progress * (values.getValue().length - 1);
        var lb = Math.floor(p2);
        var ub = Math.ceil(p2);
        result.from = new Property(document2, "from", parseFloat(values.getValue()[lb]));
        result.to = new Property(document2, "to", parseFloat(values.getValue()[ub]));
        result.progress = (p2 - lb) / (ub - lb);
      } else {
        result.from = this.from;
        result.to = this.to;
      }
      return result;
    }
  };
  var AnimateColorElement = class extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = "animateColor";
    }
    calcValue() {
      var {
        progress,
        from,
        to
      } = this.getProgress();
      var colorFrom = new RGBColor$1(from.getColor());
      var colorTo = new RGBColor$1(to.getColor());
      if (colorFrom.ok && colorTo.ok) {
        var r2 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
        var g2 = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
        var b2 = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
        return "rgb(".concat(Math.floor(r2), ", ").concat(Math.floor(g2), ", ").concat(Math.floor(b2), ")");
      }
      return this.getAttribute("from").getColor();
    }
  };
  var AnimateTransformElement = class extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = "animateTransform";
    }
    calcValue() {
      var {
        progress,
        from,
        to
      } = this.getProgress();
      var transformFrom = toNumbers(from.getString());
      var transformTo = toNumbers(to.getString());
      var newValue = transformFrom.map((from2, i2) => {
        var to2 = transformTo[i2];
        return from2 + (to2 - from2) * progress;
      }).join(" ");
      return newValue;
    }
  };
  var FontElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "font";
      this.glyphs = /* @__PURE__ */ Object.create(null);
      this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
      var {
        definitions
      } = document2;
      var {
        children
      } = this;
      for (var child of children) {
        switch (child.type) {
          case "font-face": {
            this.fontFace = child;
            var fontFamilyStyle = child.getStyle("font-family");
            if (fontFamilyStyle.hasValue()) {
              definitions[fontFamilyStyle.getString()] = this;
            }
            break;
          }
          case "missing-glyph":
            this.missingGlyph = child;
            break;
          case "glyph": {
            var glyph = child;
            if (glyph.arabicForm) {
              this.isRTL = true;
              this.isArabic = true;
              if (typeof this.glyphs[glyph.unicode] === "undefined") {
                this.glyphs[glyph.unicode] = /* @__PURE__ */ Object.create(null);
              }
              this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
            } else {
              this.glyphs[glyph.unicode] = glyph;
            }
            break;
          }
        }
      }
    }
    render() {
    }
  };
  var FontFaceElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "font-face";
      this.ascent = this.getAttribute("ascent").getNumber();
      this.descent = this.getAttribute("descent").getNumber();
      this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
    }
  };
  var MissingGlyphElement = class extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "missing-glyph";
      this.horizAdvX = 0;
    }
  };
  var TRefElement = class extends TextElement {
    constructor() {
      super(...arguments);
      this.type = "tref";
    }
    getText() {
      var element = this.getHrefAttribute().getDefinition();
      if (element) {
        var firstChild = element.children[0];
        if (firstChild) {
          return firstChild.getText();
        }
      }
      return "";
    }
  };
  var AElement = class extends TextElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "a";
      var {
        childNodes
      } = node2;
      var firstChild = childNodes[0];
      var hasText = childNodes.length > 0 && Array.from(childNodes).every((node3) => node3.nodeType === 3);
      this.hasText = hasText;
      this.text = hasText ? this.getTextFromNode(firstChild) : "";
    }
    getText() {
      return this.text;
    }
    renderChildren(ctx) {
      if (this.hasText) {
        super.renderChildren(ctx);
        var {
          document: document2,
          x: x2,
          y: y2
        } = this;
        var {
          mouse
        } = document2.screen;
        var fontSize = new Property(document2, "fontSize", Font.parse(document2.ctx.font).fontSize);
        if (mouse.isWorking()) {
          mouse.checkBoundingBox(this, new BoundingBox(x2, y2 - fontSize.getPixels("y"), x2 + this.measureText(ctx), y2));
        }
      } else if (this.children.length > 0) {
        var g2 = new GElement(this.document, null);
        g2.children = this.children;
        g2.parent = this;
        g2.render(ctx);
      }
    }
    onClick() {
      var {
        window: window2
      } = this.document;
      if (window2) {
        window2.open(this.getHrefAttribute().getString());
      }
    }
    onMouseMove() {
      var ctx = this.document.ctx;
      ctx.canvas.style.cursor = "pointer";
    }
  };
  function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys$2(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var TextPathElement = class extends TextElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "textPath";
      this.textWidth = 0;
      this.textHeight = 0;
      this.pathLength = -1;
      this.glyphInfo = null;
      this.letterSpacingCache = [];
      this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
      var pathElement = this.getHrefAttribute().getDefinition();
      this.text = this.getTextFromNode();
      this.dataArray = this.parsePathData(pathElement);
    }
    getText() {
      return this.text;
    }
    path(ctx) {
      var {
        dataArray
      } = this;
      if (ctx) {
        ctx.beginPath();
      }
      dataArray.forEach((_ref) => {
        var {
          type,
          points
        } = _ref;
        switch (type) {
          case PathParser.LINE_TO:
            if (ctx) {
              ctx.lineTo(points[0], points[1]);
            }
            break;
          case PathParser.MOVE_TO:
            if (ctx) {
              ctx.moveTo(points[0], points[1]);
            }
            break;
          case PathParser.CURVE_TO:
            if (ctx) {
              ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
            }
            break;
          case PathParser.QUAD_TO:
            if (ctx) {
              ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
            }
            break;
          case PathParser.ARC: {
            var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
            var r2 = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            if (ctx) {
              ctx.translate(cx, cy);
              ctx.rotate(psi);
              ctx.scale(scaleX, scaleY);
              ctx.arc(0, 0, r2, theta, theta + dTheta, Boolean(1 - fs));
              ctx.scale(1 / scaleX, 1 / scaleY);
              ctx.rotate(-psi);
              ctx.translate(-cx, -cy);
            }
            break;
          }
          case PathParser.CLOSE_PATH:
            if (ctx) {
              ctx.closePath();
            }
            break;
        }
      });
    }
    renderChildren(ctx) {
      this.setTextData(ctx);
      ctx.save();
      var textDecoration = this.parent.getStyle("text-decoration").getString();
      var fontSize = this.getFontSize();
      var {
        glyphInfo
      } = this;
      var fill = ctx.fillStyle;
      if (textDecoration === "underline") {
        ctx.beginPath();
      }
      glyphInfo.forEach((glyph, i2) => {
        var {
          p0,
          p1,
          rotation,
          text: partialText
        } = glyph;
        ctx.save();
        ctx.translate(p0.x, p0.y);
        ctx.rotate(rotation);
        if (ctx.fillStyle) {
          ctx.fillText(partialText, 0, 0);
        }
        if (ctx.strokeStyle) {
          ctx.strokeText(partialText, 0, 0);
        }
        ctx.restore();
        if (textDecoration === "underline") {
          if (i2 === 0) {
            ctx.moveTo(p0.x, p0.y + fontSize / 8);
          }
          ctx.lineTo(p1.x, p1.y + fontSize / 5);
        }
      });
      if (textDecoration === "underline") {
        ctx.lineWidth = fontSize / 20;
        ctx.strokeStyle = fill;
        ctx.stroke();
        ctx.closePath();
      }
      ctx.restore();
    }
    getLetterSpacingAt() {
      var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return this.letterSpacingCache[idx] || 0;
    }
    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c2, charI) {
      var offset = inputOffset;
      var glyphWidth = this.measureText(ctx, c2);
      if (c2 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
      }
      if (charI > -1) {
        offset += this.getLetterSpacingAt(charI);
      }
      var splineStep = this.textHeight / 20;
      var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
      var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
      var segment = {
        p0,
        p1
      };
      var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;
      if (dy) {
        var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
        var dyY = Math.cos(-rotation) * dy;
        segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
          x: p0.x + dyX,
          y: p0.y + dyY
        });
        segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
          x: p1.x + dyX,
          y: p1.y + dyY
        });
      }
      offset += glyphWidth;
      return {
        offset,
        segment,
        rotation
      };
    }
    measureText(ctx, text2) {
      var {
        measuresCache
      } = this;
      var targetText = text2 || this.getText();
      if (measuresCache.has(targetText)) {
        return measuresCache.get(targetText);
      }
      var measure = this.measureTargetText(ctx, targetText);
      measuresCache.set(targetText, measure);
      return measure;
    }
    // This method supposes what all custom fonts already loaded.
    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
    // You need to call this method manually to update glyphs cache.
    setTextData(ctx) {
      if (this.glyphInfo) {
        return;
      }
      var renderText = this.getText();
      var chars = renderText.split("");
      var spacesNumber = renderText.split(" ").length - 1;
      var dx = this.parent.getAttribute("dx").split().map((_2) => _2.getPixels("x"));
      var dy = this.parent.getAttribute("dy").getPixels("y");
      var anchor = this.parent.getStyle("text-anchor").getString("start");
      var thisSpacing = this.getStyle("letter-spacing");
      var parentSpacing = this.parent.getStyle("letter-spacing");
      var letterSpacing = 0;
      if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
        letterSpacing = parentSpacing.getPixels();
      } else if (thisSpacing.hasValue()) {
        if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
          letterSpacing = thisSpacing.getPixels();
        }
      }
      var letterSpacingCache = [];
      var textLen = renderText.length;
      this.letterSpacingCache = letterSpacingCache;
      for (var i2 = 0; i2 < textLen; i2++) {
        letterSpacingCache.push(typeof dx[i2] !== "undefined" ? dx[i2] : letterSpacing);
      }
      var dxSum = letterSpacingCache.reduce((acc, cur, i3) => i3 === 0 ? 0 : acc + cur || 0, 0);
      var textWidth = this.measureText(ctx);
      var textFullWidth = Math.max(textWidth + dxSum, 0);
      this.textWidth = textWidth;
      this.textHeight = this.getFontSize();
      this.glyphInfo = [];
      var fullPathWidth = this.getPathLength();
      var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
      var offset = 0;
      if (anchor === "middle" || anchor === "center") {
        offset = -textFullWidth / 2;
      }
      if (anchor === "end" || anchor === "right") {
        offset = -textFullWidth;
      }
      offset += startOffset;
      chars.forEach((char, i3) => {
        var {
          offset: nextOffset,
          segment,
          rotation
        } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i3);
        offset = nextOffset;
        if (!segment.p0 || !segment.p1) {
          return;
        }
        this.glyphInfo.push({
          // transposeX: midpoint.x,
          // transposeY: midpoint.y,
          text: chars[i3],
          p0: segment.p0,
          p1: segment.p1,
          rotation
        });
      });
    }
    parsePathData(path2) {
      this.pathLength = -1;
      if (!path2) {
        return [];
      }
      var pathCommands = [];
      var {
        pathParser
      } = path2;
      pathParser.reset();
      while (!pathParser.isEnd()) {
        var {
          current
        } = pathParser;
        var startX = current ? current.x : 0;
        var startY = current ? current.y : 0;
        var command = pathParser.next();
        var nextCommandType = command.type;
        var points = [];
        switch (command.type) {
          case PathParser.MOVE_TO:
            this.pathM(pathParser, points);
            break;
          case PathParser.LINE_TO:
            nextCommandType = this.pathL(pathParser, points);
            break;
          case PathParser.HORIZ_LINE_TO:
            nextCommandType = this.pathH(pathParser, points);
            break;
          case PathParser.VERT_LINE_TO:
            nextCommandType = this.pathV(pathParser, points);
            break;
          case PathParser.CURVE_TO:
            this.pathC(pathParser, points);
            break;
          case PathParser.SMOOTH_CURVE_TO:
            nextCommandType = this.pathS(pathParser, points);
            break;
          case PathParser.QUAD_TO:
            this.pathQ(pathParser, points);
            break;
          case PathParser.SMOOTH_QUAD_TO:
            nextCommandType = this.pathT(pathParser, points);
            break;
          case PathParser.ARC:
            points = this.pathA(pathParser);
            break;
          case PathParser.CLOSE_PATH:
            PathElement.pathZ(pathParser);
            break;
        }
        if (command.type !== PathParser.CLOSE_PATH) {
          pathCommands.push({
            type: nextCommandType,
            points,
            start: {
              x: startX,
              y: startY
            },
            pathLength: this.calcLength(startX, startY, nextCommandType, points)
          });
        } else {
          pathCommands.push({
            type: PathParser.CLOSE_PATH,
            points: [],
            pathLength: 0
          });
        }
      }
      return pathCommands;
    }
    pathM(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathM(pathParser).point;
      points.push(x2, y2);
    }
    pathL(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathL(pathParser).point;
      points.push(x2, y2);
      return PathParser.LINE_TO;
    }
    pathH(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathH(pathParser).point;
      points.push(x2, y2);
      return PathParser.LINE_TO;
    }
    pathV(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathV(pathParser).point;
      points.push(x2, y2);
      return PathParser.LINE_TO;
    }
    pathC(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathC(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
    pathS(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathS(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.CURVE_TO;
    }
    pathQ(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathQ(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
    pathT(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathT(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.QUAD_TO;
    }
    pathA(pathParser) {
      var {
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = PathElement.pathA(pathParser);
      if (sweepFlag === 0 && ad > 0) {
        ad -= 2 * Math.PI;
      }
      if (sweepFlag === 1 && ad < 0) {
        ad += 2 * Math.PI;
      }
      return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
    }
    calcLength(x2, y2, commandType, points) {
      var len = 0;
      var p1 = null;
      var p2 = null;
      var t3 = 0;
      switch (commandType) {
        case PathParser.LINE_TO:
          return this.getLineLength(x2, y2, points[0], points[1]);
        case PathParser.CURVE_TO:
          len = 0;
          p1 = this.getPointOnCubicBezier(0, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
          for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
            p2 = this.getPointOnCubicBezier(t3, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
          return len;
        case PathParser.QUAD_TO:
          len = 0;
          p1 = this.getPointOnQuadraticBezier(0, x2, y2, points[0], points[1], points[2], points[3]);
          for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
            p2 = this.getPointOnQuadraticBezier(t3, x2, y2, points[0], points[1], points[2], points[3]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
          return len;
        case PathParser.ARC: {
          len = 0;
          var start = points[4];
          var dTheta = points[5];
          var end = points[4] + dTheta;
          var inc = Math.PI / 180;
          if (Math.abs(start - end) < inc) {
            inc = Math.abs(start - end);
          }
          p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
          if (dTheta < 0) {
            for (t3 = start - inc; t3 > end; t3 -= inc) {
              p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
          } else {
            for (t3 = start + inc; t3 < end; t3 += inc) {
              p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
          }
          p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
          len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
          return len;
        }
      }
      return 0;
    }
    getPointOnLine(dist, p1x, p1y, p2x, p2y) {
      var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;
      var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
      var m2 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
      var run = Math.sqrt(dist * dist / (1 + m2 * m2));
      if (p2x < p1x) {
        run *= -1;
      }
      var rise = m2 * run;
      var pt2 = null;
      if (p2x === p1x) {
        pt2 = {
          x: fromX,
          y: fromY + rise
        };
      } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m2) {
        pt2 = {
          x: fromX + run,
          y: fromY + rise
        };
      } else {
        var ix = 0;
        var iy = 0;
        var len = this.getLineLength(p1x, p1y, p2x, p2y);
        if (len < PSEUDO_ZERO) {
          return null;
        }
        var u2 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
        u2 /= len * len;
        ix = p1x + u2 * (p2x - p1x);
        iy = p1y + u2 * (p2y - p1y);
        var pRise = this.getLineLength(fromX, fromY, ix, iy);
        var pRun = Math.sqrt(dist * dist - pRise * pRise);
        run = Math.sqrt(pRun * pRun / (1 + m2 * m2));
        if (p2x < p1x) {
          run *= -1;
        }
        rise = m2 * run;
        pt2 = {
          x: ix + run,
          y: iy + rise
        };
      }
      return pt2;
    }
    getPointOnPath(distance) {
      var fullLen = this.getPathLength();
      var cumulativePathLength = 0;
      var p2 = null;
      if (distance < -5e-5 || distance - 5e-5 > fullLen) {
        return null;
      }
      var {
        dataArray
      } = this;
      for (var command of dataArray) {
        if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance)) {
          cumulativePathLength += command.pathLength;
          continue;
        }
        var delta = distance - cumulativePathLength;
        var currentT = 0;
        switch (command.type) {
          case PathParser.LINE_TO:
            p2 = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
            break;
          case PathParser.ARC: {
            var start = command.points[4];
            var dTheta = command.points[5];
            var end = command.points[4] + dTheta;
            currentT = start + delta / command.pathLength * dTheta;
            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
              break;
            }
            p2 = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
            break;
          }
          case PathParser.CURVE_TO:
            currentT = delta / command.pathLength;
            if (currentT > 1) {
              currentT = 1;
            }
            p2 = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
            break;
          case PathParser.QUAD_TO:
            currentT = delta / command.pathLength;
            if (currentT > 1) {
              currentT = 1;
            }
            p2 = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
            break;
        }
        if (p2) {
          return p2;
        }
        break;
      }
      return null;
    }
    getLineLength(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    getPathLength() {
      if (this.pathLength === -1) {
        this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);
      }
      return this.pathLength;
    }
    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
      var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
      var y2 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
      return {
        x: x2,
        y: y2
      };
    }
    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
      var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
      var y2 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
      return {
        x: x2,
        y: y2
      };
    }
    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
      var cosPsi = Math.cos(psi);
      var sinPsi = Math.sin(psi);
      var pt2 = {
        x: rx * Math.cos(theta),
        y: ry * Math.sin(theta)
      };
      return {
        x: cx + (pt2.x * cosPsi - pt2.y * sinPsi),
        y: cy + (pt2.x * sinPsi + pt2.y * cosPsi)
      };
    }
    // TODO need some optimisations. possibly build cache only for curved segments?
    buildEquidistantCache(inputStep, inputPrecision) {
      var fullLen = this.getPathLength();
      var precision = inputPrecision || 0.25;
      var step = inputStep || fullLen / 100;
      if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
        this.equidistantCache = {
          step,
          precision,
          points: []
        };
        var s2 = 0;
        for (var l2 = 0; l2 <= fullLen; l2 += precision) {
          var p0 = this.getPointOnPath(l2);
          var p1 = this.getPointOnPath(l2 + precision);
          if (!p0 || !p1) {
            continue;
          }
          s2 += this.getLineLength(p0.x, p0.y, p1.x, p1.y);
          if (s2 >= step) {
            this.equidistantCache.points.push({
              x: p0.x,
              y: p0.y,
              distance: l2
            });
            s2 -= step;
          }
        }
      }
    }
    getEquidistantPointOnPath(targetDistance, step, precision) {
      this.buildEquidistantCache(step, precision);
      if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {
        return null;
      }
      var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
      return this.equidistantCache.points[idx] || null;
    }
  };
  var dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
  var ImageElement = class extends RenderedElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "image";
      this.loaded = false;
      var href = this.getHrefAttribute().getString();
      if (!href) {
        return;
      }
      var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
      document2.images.push(this);
      if (!isSvg) {
        void this.loadImage(href);
      } else {
        void this.loadSvg(href);
      }
      this.isSvg = isSvg;
    }
    loadImage(href) {
      var _this = this;
      return _asyncToGenerator(function* () {
        try {
          var image = yield _this.document.createImage(href);
          _this.image = image;
        } catch (err2) {
          console.error('Error while loading image "'.concat(href, '":'), err2);
        }
        _this.loaded = true;
      })();
    }
    loadSvg(href) {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        var match = dataUriRegex.exec(href);
        if (match) {
          var data = match[5];
          if (match[4] === "base64") {
            _this2.image = atob(data);
          } else {
            _this2.image = decodeURIComponent(data);
          }
        } else {
          try {
            var response = yield _this2.document.fetch(href);
            var svg2 = yield response.text();
            _this2.image = svg2;
          } catch (err2) {
            console.error('Error while loading image "'.concat(href, '":'), err2);
          }
        }
        _this2.loaded = true;
      })();
    }
    renderChildren(ctx) {
      var {
        document: document2,
        image,
        loaded
      } = this;
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width").getPixels("x");
      var height = this.getStyle("height").getPixels("y");
      if (!loaded || !image || !width || !height) {
        return;
      }
      ctx.save();
      ctx.translate(x2, y2);
      if (this.isSvg) {
        var subDocument = document2.canvg.forkString(ctx, this.image, {
          ignoreMouse: true,
          ignoreAnimation: true,
          ignoreDimensions: true,
          ignoreClear: true,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: width,
          scaleHeight: height
        });
        subDocument.document.documentElement.parent = this;
        void subDocument.render();
      } else {
        var _image = this.image;
        document2.setViewBox({
          ctx,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width,
          desiredWidth: _image.width,
          height,
          desiredHeight: _image.height
        });
        if (this.loaded) {
          if (typeof _image.complete === "undefined" || _image.complete) {
            ctx.drawImage(_image, 0, 0);
          }
        }
      }
      ctx.restore();
    }
    getBoundingBox() {
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width").getPixels("x");
      var height = this.getStyle("height").getPixels("y");
      return new BoundingBox(x2, y2, x2 + width, y2 + height);
    }
  };
  var SymbolElement = class extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "symbol";
    }
    render(_2) {
    }
  };
  var SVGFontLoader = class {
    constructor(document2) {
      this.document = document2;
      this.loaded = false;
      document2.fonts.push(this);
    }
    load(fontFamily, url) {
      var _this = this;
      return _asyncToGenerator(function* () {
        try {
          var {
            document: document2
          } = _this;
          var svgDocument = yield document2.canvg.parser.load(url);
          var fonts = svgDocument.getElementsByTagName("font");
          Array.from(fonts).forEach((fontNode) => {
            var font = document2.createElement(fontNode);
            document2.definitions[fontFamily] = font;
          });
        } catch (err2) {
          console.error('Error while loading font "'.concat(url, '":'), err2);
        }
        _this.loaded = true;
      })();
    }
  };
  var StyleElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "style";
      var css = compressSpaces(
        Array.from(node2.childNodes).map((_2) => _2.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
        // remove imports
      );
      var cssDefs = css.split("}");
      cssDefs.forEach((_2) => {
        var def = _2.trim();
        if (!def) {
          return;
        }
        var cssParts = def.split("{");
        var cssClasses = cssParts[0].split(",");
        var cssProps = cssParts[1].split(";");
        cssClasses.forEach((_3) => {
          var cssClass = _3.trim();
          if (!cssClass) {
            return;
          }
          var props = document2.styles[cssClass] || {};
          cssProps.forEach((cssProp) => {
            var prop = cssProp.indexOf(":");
            var name = cssProp.substr(0, prop).trim();
            var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
            if (name && value) {
              props[name] = new Property(document2, name, value);
            }
          });
          document2.styles[cssClass] = props;
          document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
          if (cssClass === "@font-face") {
            var fontFamily = props["font-family"].getString().replace(/"|'/g, "");
            var srcs = props.src.getString().split(",");
            srcs.forEach((src) => {
              if (src.indexOf('format("svg")') > 0) {
                var url = parseExternalUrl(src);
                if (url) {
                  void new SVGFontLoader(document2).load(fontFamily, url);
                }
              }
            });
          }
        });
      });
    }
  };
  StyleElement.parseExternalUrl = parseExternalUrl;
  var UseElement = class extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "use";
    }
    setContext(ctx) {
      super.setContext(ctx);
      var xAttr = this.getAttribute("x");
      var yAttr = this.getAttribute("y");
      if (xAttr.hasValue()) {
        ctx.translate(xAttr.getPixels("x"), 0);
      }
      if (yAttr.hasValue()) {
        ctx.translate(0, yAttr.getPixels("y"));
      }
    }
    path(ctx) {
      var {
        element
      } = this;
      if (element) {
        element.path(ctx);
      }
    }
    renderChildren(ctx) {
      var {
        document: document2,
        element
      } = this;
      if (element) {
        var tempSvg = element;
        if (element.type === "symbol") {
          tempSvg = new SVGElement(document2, null);
          tempSvg.attributes.viewBox = new Property(document2, "viewBox", element.getAttribute("viewBox").getString());
          tempSvg.attributes.preserveAspectRatio = new Property(document2, "preserveAspectRatio", element.getAttribute("preserveAspectRatio").getString());
          tempSvg.attributes.overflow = new Property(document2, "overflow", element.getAttribute("overflow").getString());
          tempSvg.children = element.children;
          element.styles.opacity = new Property(document2, "opacity", this.calculateOpacity());
        }
        if (tempSvg.type === "svg") {
          var widthStyle = this.getStyle("width", false, true);
          var heightStyle = this.getStyle("height", false, true);
          if (widthStyle.hasValue()) {
            tempSvg.attributes.width = new Property(document2, "width", widthStyle.getString());
          }
          if (heightStyle.hasValue()) {
            tempSvg.attributes.height = new Property(document2, "height", heightStyle.getString());
          }
        }
        var oldParent = tempSvg.parent;
        tempSvg.parent = this;
        tempSvg.render(ctx);
        tempSvg.parent = oldParent;
      }
    }
    getBoundingBox(ctx) {
      var {
        element
      } = this;
      if (element) {
        return element.getBoundingBox(ctx);
      }
      return null;
    }
    elementTransform() {
      var {
        document: document2,
        element
      } = this;
      return Transform.fromElement(document2, element);
    }
    get element() {
      if (!this.cachedElement) {
        this.cachedElement = this.getHrefAttribute().getDefinition();
      }
      return this.cachedElement;
    }
  };
  function imGet(img, x2, y2, width, _height, rgba) {
    return img[y2 * width * 4 + x2 * 4 + rgba];
  }
  function imSet(img, x2, y2, width, _height, rgba, val) {
    img[y2 * width * 4 + x2 * 4 + rgba] = val;
  }
  function m(matrix2, i2, v2) {
    var mi = matrix2[i2];
    return mi * v2;
  }
  function c(a2, m1, m2, m3) {
    return m1 + Math.cos(a2) * m2 + Math.sin(a2) * m3;
  }
  var FeColorMatrixElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "feColorMatrix";
      var matrix2 = toNumbers(this.getAttribute("values").getString());
      switch (this.getAttribute("type").getString("matrix")) {
        // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
        case "saturate": {
          var s2 = matrix2[0];
          matrix2 = [0.213 + 0.787 * s2, 0.715 - 0.715 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 + 0.285 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 - 0.715 * s2, 0.072 + 0.928 * s2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
          break;
        }
        case "hueRotate": {
          var a2 = matrix2[0] * Math.PI / 180;
          matrix2 = [c(a2, 0.213, 0.787, -0.213), c(a2, 0.715, -0.715, -0.715), c(a2, 0.072, -0.072, 0.928), 0, 0, c(a2, 0.213, -0.213, 0.143), c(a2, 0.715, 0.285, 0.14), c(a2, 0.072, -0.072, -0.283), 0, 0, c(a2, 0.213, -0.213, -0.787), c(a2, 0.715, -0.715, 0.715), c(a2, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
          break;
        }
        case "luminanceToAlpha":
          matrix2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
          break;
      }
      this.matrix = matrix2;
      this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
    }
    apply(ctx, _x, _y, width, height) {
      var {
        includeOpacity,
        matrix: matrix2
      } = this;
      var srcData = ctx.getImageData(0, 0, width, height);
      for (var y2 = 0; y2 < height; y2++) {
        for (var x2 = 0; x2 < width; x2++) {
          var r2 = imGet(srcData.data, x2, y2, width, height, 0);
          var g2 = imGet(srcData.data, x2, y2, width, height, 1);
          var b2 = imGet(srcData.data, x2, y2, width, height, 2);
          var a2 = imGet(srcData.data, x2, y2, width, height, 3);
          var nr = m(matrix2, 0, r2) + m(matrix2, 1, g2) + m(matrix2, 2, b2) + m(matrix2, 3, a2) + m(matrix2, 4, 1);
          var ng = m(matrix2, 5, r2) + m(matrix2, 6, g2) + m(matrix2, 7, b2) + m(matrix2, 8, a2) + m(matrix2, 9, 1);
          var nb = m(matrix2, 10, r2) + m(matrix2, 11, g2) + m(matrix2, 12, b2) + m(matrix2, 13, a2) + m(matrix2, 14, 1);
          var na = m(matrix2, 15, r2) + m(matrix2, 16, g2) + m(matrix2, 17, b2) + m(matrix2, 18, a2) + m(matrix2, 19, 1);
          if (includeOpacity) {
            nr = 0;
            ng = 0;
            nb = 0;
            na *= a2 / 255;
          }
          imSet(srcData.data, x2, y2, width, height, 0, nr);
          imSet(srcData.data, x2, y2, width, height, 1, ng);
          imSet(srcData.data, x2, y2, width, height, 2, nb);
          imSet(srcData.data, x2, y2, width, height, 3, na);
        }
      }
      ctx.clearRect(0, 0, width, height);
      ctx.putImageData(srcData, 0, 0);
    }
  };
  var MaskElement = class _MaskElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "mask";
    }
    apply(ctx, element) {
      var {
        document: document2
      } = this;
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width").getPixels("x");
      var height = this.getStyle("height").getPixels("y");
      if (!width && !height) {
        var boundingBox = new BoundingBox();
        this.children.forEach((child) => {
          boundingBox.addBoundingBox(child.getBoundingBox(ctx));
        });
        x2 = Math.floor(boundingBox.x1);
        y2 = Math.floor(boundingBox.y1);
        width = Math.floor(boundingBox.width);
        height = Math.floor(boundingBox.height);
      }
      var ignoredStyles = this.removeStyles(element, _MaskElement.ignoreStyles);
      var maskCanvas = document2.createCanvas(x2 + width, y2 + height);
      var maskCtx = maskCanvas.getContext("2d");
      document2.screen.setDefaults(maskCtx);
      this.renderChildren(maskCtx);
      new FeColorMatrixElement(document2, {
        nodeType: 1,
        childNodes: [],
        attributes: [{
          nodeName: "type",
          value: "luminanceToAlpha"
        }, {
          nodeName: "includeOpacity",
          value: "true"
        }]
      }).apply(maskCtx, 0, 0, x2 + width, y2 + height);
      var tmpCanvas = document2.createCanvas(x2 + width, y2 + height);
      var tmpCtx = tmpCanvas.getContext("2d");
      document2.screen.setDefaults(tmpCtx);
      element.render(tmpCtx);
      tmpCtx.globalCompositeOperation = "destination-in";
      tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
      tmpCtx.fillRect(0, 0, x2 + width, y2 + height);
      ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
      ctx.fillRect(0, 0, x2 + width, y2 + height);
      this.restoreStyles(element, ignoredStyles);
    }
    render(_2) {
    }
  };
  MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
  var noop = () => {
  };
  var ClipPathElement = class extends Element {
    constructor() {
      super(...arguments);
      this.type = "clipPath";
    }
    apply(ctx) {
      var {
        document: document2
      } = this;
      var contextProto = Reflect.getPrototypeOf(ctx);
      var {
        beginPath,
        closePath
      } = ctx;
      if (contextProto) {
        contextProto.beginPath = noop;
        contextProto.closePath = noop;
      }
      Reflect.apply(beginPath, ctx, []);
      this.children.forEach((child) => {
        if (typeof child.path === "undefined") {
          return;
        }
        var transform = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
        if (!transform) {
          transform = Transform.fromElement(document2, child);
        }
        if (transform) {
          transform.apply(ctx);
        }
        child.path(ctx);
        if (contextProto) {
          contextProto.closePath = closePath;
        }
        if (transform) {
          transform.unapply(ctx);
        }
      });
      Reflect.apply(closePath, ctx, []);
      ctx.clip();
      if (contextProto) {
        contextProto.beginPath = beginPath;
        contextProto.closePath = closePath;
      }
    }
    render(_2) {
    }
  };
  var FilterElement = class _FilterElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "filter";
    }
    apply(ctx, element) {
      var {
        document: document2,
        children
      } = this;
      var boundingBox = element.getBoundingBox(ctx);
      if (!boundingBox) {
        return;
      }
      var px = 0;
      var py = 0;
      children.forEach((child) => {
        var efd = child.extraFilterDistance || 0;
        px = Math.max(px, efd);
        py = Math.max(py, efd);
      });
      var width = Math.floor(boundingBox.width);
      var height = Math.floor(boundingBox.height);
      var tmpCanvasWidth = width + 2 * px;
      var tmpCanvasHeight = height + 2 * py;
      if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
        return;
      }
      var x2 = Math.floor(boundingBox.x);
      var y2 = Math.floor(boundingBox.y);
      var ignoredStyles = this.removeStyles(element, _FilterElement.ignoreStyles);
      var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
      var tmpCtx = tmpCanvas.getContext("2d");
      document2.screen.setDefaults(tmpCtx);
      tmpCtx.translate(-x2 + px, -y2 + py);
      element.render(tmpCtx);
      children.forEach((child) => {
        if (typeof child.apply === "function") {
          child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
        }
      });
      ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px, y2 - py, tmpCanvasWidth, tmpCanvasHeight);
      this.restoreStyles(element, ignoredStyles);
    }
    render(_2) {
    }
  };
  FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
  var FeDropShadowElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "feDropShadow";
      this.addStylesFromStyleDefinition();
    }
    apply(_2, _x, _y, _width, _height) {
    }
  };
  var FeMorphologyElement = class extends Element {
    constructor() {
      super(...arguments);
      this.type = "feMorphology";
    }
    apply(_2, _x, _y, _width, _height) {
    }
  };
  var FeCompositeElement = class extends Element {
    constructor() {
      super(...arguments);
      this.type = "feComposite";
    }
    apply(_2, _x, _y, _width, _height) {
    }
  };
  var FeGaussianBlurElement = class extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "feGaussianBlur";
      this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber());
      this.extraFilterDistance = this.blurRadius;
    }
    apply(ctx, x2, y2, width, height) {
      var {
        document: document2,
        blurRadius
      } = this;
      var body = document2.window ? document2.window.document.body : null;
      var canvas = ctx.canvas;
      canvas.id = document2.getUniqueId();
      if (body) {
        canvas.style.display = "none";
        body.appendChild(canvas);
      }
      processCanvasRGBA(canvas, x2, y2, width, height, blurRadius);
      if (body) {
        body.removeChild(canvas);
      }
    }
  };
  var TitleElement = class extends Element {
    constructor() {
      super(...arguments);
      this.type = "title";
    }
  };
  var DescElement = class extends Element {
    constructor() {
      super(...arguments);
      this.type = "desc";
    }
  };
  var elements = {
    "svg": SVGElement,
    "rect": RectElement,
    "circle": CircleElement,
    "ellipse": EllipseElement,
    "line": LineElement,
    "polyline": PolylineElement,
    "polygon": PolygonElement,
    "path": PathElement,
    "pattern": PatternElement,
    "marker": MarkerElement,
    "defs": DefsElement,
    "linearGradient": LinearGradientElement,
    "radialGradient": RadialGradientElement,
    "stop": StopElement,
    "animate": AnimateElement,
    "animateColor": AnimateColorElement,
    "animateTransform": AnimateTransformElement,
    "font": FontElement,
    "font-face": FontFaceElement,
    "missing-glyph": MissingGlyphElement,
    "glyph": GlyphElement,
    "text": TextElement,
    "tspan": TSpanElement,
    "tref": TRefElement,
    "a": AElement,
    "textPath": TextPathElement,
    "image": ImageElement,
    "g": GElement,
    "symbol": SymbolElement,
    "style": StyleElement,
    "use": UseElement,
    "mask": MaskElement,
    "clipPath": ClipPathElement,
    "filter": FilterElement,
    "feDropShadow": FeDropShadowElement,
    "feMorphology": FeMorphologyElement,
    "feComposite": FeCompositeElement,
    "feColorMatrix": FeColorMatrixElement,
    "feGaussianBlur": FeGaussianBlurElement,
    "title": TitleElement,
    "desc": DescElement
  };
  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$1(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys$1(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$1(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function createCanvas(width, height) {
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
  function createImage(_x) {
    return _createImage.apply(this, arguments);
  }
  function _createImage() {
    _createImage = _asyncToGenerator(function* (src) {
      var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var image = document.createElement("img");
      if (anonymousCrossOrigin) {
        image.crossOrigin = "Anonymous";
      }
      return new Promise((resolve, reject) => {
        image.onload = () => {
          resolve(image);
        };
        image.onerror = (_event, _source, _lineno, _colno, error) => {
          reject(error);
        };
        image.src = src;
      });
    });
    return _createImage.apply(this, arguments);
  }
  var Document = class _Document {
    constructor(canvg) {
      var {
        rootEmSize = 12,
        emSize = 12,
        createCanvas: createCanvas2 = _Document.createCanvas,
        createImage: createImage2 = _Document.createImage,
        anonymousCrossOrigin
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.canvg = canvg;
      this.definitions = /* @__PURE__ */ Object.create(null);
      this.styles = /* @__PURE__ */ Object.create(null);
      this.stylesSpecificity = /* @__PURE__ */ Object.create(null);
      this.images = [];
      this.fonts = [];
      this.emSizeStack = [];
      this.uniqueId = 0;
      this.screen = canvg.screen;
      this.rootEmSize = rootEmSize;
      this.emSize = emSize;
      this.createCanvas = createCanvas2;
      this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
      this.screen.wait(this.isImagesLoaded.bind(this));
      this.screen.wait(this.isFontsLoaded.bind(this));
    }
    bindCreateImage(createImage2, anonymousCrossOrigin) {
      if (typeof anonymousCrossOrigin === "boolean") {
        return (source, forceAnonymousCrossOrigin) => createImage2(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
      }
      return createImage2;
    }
    get window() {
      return this.screen.window;
    }
    get fetch() {
      return this.screen.fetch;
    }
    get ctx() {
      return this.screen.ctx;
    }
    get emSize() {
      var {
        emSizeStack
      } = this;
      return emSizeStack[emSizeStack.length - 1];
    }
    set emSize(value) {
      var {
        emSizeStack
      } = this;
      emSizeStack.push(value);
    }
    popEmSize() {
      var {
        emSizeStack
      } = this;
      emSizeStack.pop();
    }
    getUniqueId() {
      return "canvg".concat(++this.uniqueId);
    }
    isImagesLoaded() {
      return this.images.every((_2) => _2.loaded);
    }
    isFontsLoaded() {
      return this.fonts.every((_2) => _2.loaded);
    }
    createDocumentElement(document2) {
      var documentElement = this.createElement(document2.documentElement);
      documentElement.root = true;
      documentElement.addStylesFromStyleDefinition();
      this.documentElement = documentElement;
      return documentElement;
    }
    createElement(node2) {
      var elementType = node2.nodeName.replace(/^[^:]+:/, "");
      var ElementType = _Document.elementTypes[elementType];
      if (typeof ElementType !== "undefined") {
        return new ElementType(this, node2);
      }
      return new UnknownElement(this, node2);
    }
    createTextNode(node2) {
      return new TextNode(this, node2);
    }
    setViewBox(config) {
      this.screen.setViewBox(_objectSpread$1({
        document: this
      }, config));
    }
  };
  Document.createCanvas = createCanvas;
  Document.createImage = createImage;
  Document.elementTypes = elements;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var Canvg = class _Canvg {
    /**
     * Main constructor.
     * @param ctx - Rendering context.
     * @param svg - SVG Document.
     * @param options - Rendering options.
     */
    constructor(ctx, svg2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.parser = new Parser(options);
      this.screen = new Screen(ctx, options);
      this.options = options;
      var document2 = new Document(this, options);
      var documentElement = document2.createDocumentElement(svg2);
      this.document = document2;
      this.documentElement = documentElement;
    }
    /**
     * Create Canvg instance from SVG source string or URL.
     * @param ctx - Rendering context.
     * @param svg - SVG source string or URL.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */
    static from(ctx, svg2) {
      var _arguments = arguments;
      return _asyncToGenerator(function* () {
        var options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
        var parser = new Parser(options);
        var svgDocument = yield parser.parse(svg2);
        return new _Canvg(ctx, svgDocument, options);
      })();
    }
    /**
     * Create Canvg instance from SVG source string.
     * @param ctx - Rendering context.
     * @param svg - SVG source string.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */
    static fromString(ctx, svg2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var parser = new Parser(options);
      var svgDocument = parser.parseFromString(svg2);
      return new _Canvg(ctx, svgDocument, options);
    }
    /**
     * Create new Canvg instance with inherited options.
     * @param ctx - Rendering context.
     * @param svg - SVG source string or URL.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */
    fork(ctx, svg2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return _Canvg.from(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
    }
    /**
     * Create new Canvg instance with inherited options.
     * @param ctx - Rendering context.
     * @param svg - SVG source string.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */
    forkString(ctx, svg2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return _Canvg.fromString(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
    }
    /**
     * Document is ready promise.
     * @returns Ready promise.
     */
    ready() {
      return this.screen.ready();
    }
    /**
     * Document is ready value.
     * @returns Is ready or not.
     */
    isReady() {
      return this.screen.isReady();
    }
    /**
     * Render only first frame, ignoring animations and mouse.
     * @param options - Rendering options.
     */
    render() {
      var _arguments2 = arguments, _this = this;
      return _asyncToGenerator(function* () {
        var options = _arguments2.length > 0 && _arguments2[0] !== void 0 ? _arguments2[0] : {};
        _this.start(_objectSpread({
          enableRedraw: true,
          ignoreAnimation: true,
          ignoreMouse: true
        }, options));
        yield _this.ready();
        _this.stop();
      })();
    }
    /**
     * Start rendering.
     * @param options - Render options.
     */
    start() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var {
        documentElement,
        screen,
        options: baseOptions
      } = this;
      screen.start(documentElement, _objectSpread(_objectSpread({
        enableRedraw: true
      }, baseOptions), options));
    }
    /**
     * Stop rendering.
     */
    stop() {
      this.screen.stop();
    }
    /**
     * Resize SVG to fit in given size.
     * @param width
     * @param height
     * @param preserveAspectRatio
     */
    resize(width) {
      var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
      var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.documentElement.resize(width, height, preserveAspectRatio);
    }
  };
  var index_es = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    AElement,
    AnimateColorElement,
    AnimateElement,
    AnimateTransformElement,
    BoundingBox,
    CB1,
    CB2,
    CB3,
    CB4,
    Canvg,
    CircleElement,
    ClipPathElement,
    DefsElement,
    DescElement,
    Document,
    Element,
    EllipseElement,
    FeColorMatrixElement,
    FeCompositeElement,
    FeDropShadowElement,
    FeGaussianBlurElement,
    FeMorphologyElement,
    FilterElement,
    Font,
    FontElement,
    FontFaceElement,
    GElement,
    GlyphElement,
    GradientElement,
    ImageElement,
    LineElement,
    LinearGradientElement,
    MarkerElement,
    MaskElement,
    Matrix,
    MissingGlyphElement,
    Mouse,
    PSEUDO_ZERO,
    Parser,
    PathElement,
    PathParser,
    PatternElement,
    Point,
    PolygonElement,
    PolylineElement,
    Property,
    QB1,
    QB2,
    QB3,
    RadialGradientElement,
    RectElement,
    RenderedElement,
    Rotate,
    SVGElement,
    SVGFontLoader,
    Scale,
    Screen,
    Skew,
    SkewX,
    SkewY,
    StopElement,
    StyleElement,
    SymbolElement,
    TRefElement,
    TSpanElement,
    TextElement,
    TextPathElement,
    TitleElement,
    Transform,
    Translate,
    UnknownElement,
    UseElement,
    ViewPort,
    compressSpaces,
    default: Canvg,
    getSelectorSpecificity,
    normalizeAttributeName,
    normalizeColor,
    parseExternalUrl,
    presets: index,
    toNumbers,
    trimLeft,
    trimRight,
    vectorMagnitude,
    vectorsAngle,
    vectorsRatio
  });

  // index.js
  window.svgcanvas = svgcanvas_exports;
  window.SvgCanvas = SvgCanvas || void 0 || svgcanvas_exports;
})();
/*! Bundled license information:

@svgedit/svgcanvas/dist/svgcanvas.js:
  (**
   * Tools for working with units.
   * @module units
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   *)
  (**
   * Namespaces or tools therefor.
   * @module namespaces
   * @license MIT
  *)
  (**
   * Mathematical utilities.
   * @module math
   * @license MIT
   *
   * 2010 Alexis Deveria, 2010 Jeff Schiller
   *)
  (**
   * Miscellaneous utilities.
   * @module utilities
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   *)
  (**
   * For command history tracking and undo functionality.
   * @module history
   * @license MIT
   * @copyright 2010 Jeff Schiller
   *)
  (**
   * Path functionality.
   * @module path
   * @license MIT
   *
   * @copyright 2011 Alexis Deveria, 2011 Jeff Schiller
   *)
  (**
   * Provides tools for the layer concept.
   * @module layer
   * @license MIT
   *
   * @copyright 2011 Jeff Schiller, 2016 Flint O'Brien
   *)
  (**
   * HistoryRecordingService component of history.
   * @module history
   * @license MIT
   * @copyright 2016 Flint O'Brien
   *)
  (**
   * Tools for drawing.
   * @module draw
   * @license MIT
   * @copyright 2011 Jeff Schiller
   *)
  (**
   * Tools for SVG Root Element.
   * @module svgcanvas
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   *)
  (**
   * Browser detection.
   * @module browser
   * @license MIT
   *
   * @copyright 2010 Jeff Schiller, 2010 Alexis Deveria
   *)
  (**
   * Tools for undo.
   * @module undo
   * @license MIT
   * @copyright 2011 Jeff Schiller
   *)
  (**
   * Tools for selection.
   * @module selection
   * @license MIT
   * @copyright 2011 Jeff Schiller
   *)
  (**
   * @module text-actions Tools for Text edit functions
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   *)
  (**
   * Tools for event.
   * @module event
   * @license MIT
   * @copyright 2011 Jeff Schiller
   *)
  (**
   * Tools for SVG handle on JSON format.
   * @module svgcanvas
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   *)
  (**
   * @module elem-get-set get and set methods.
   * @license MIT
   * @copyright 2011 Jeff Schiller
   *)
  (**
   * Manipulating coordinates.
   * @module coords
   * @license MIT
   *)
  (**
   * Recalculate dimensions and transformations of SVG elements.
   * @module recalculate
   * @license MIT
   *)
  (**
   * Tools for SVG selected element operation.
   * @module selected-elem
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   *)
  (**
   * Tools for blur event.
   * @module blur
   * @license MIT
   * @copyright 2011 Jeff Schiller
   *)
  (**
   * Tools for SVG sanitization.
   * @module sanitize
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   *)
  (** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 3.0.1 Built on 2025-03-17T14:19:36.873Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2021 yWorks GmbH, http://www.yworks.com
   *               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   *)
  (**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   *)
  (**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   *)
  (**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   *
   * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   *)
  (**
   * @license
   * (c) Dean McNamee <dean@gmail.com>, 2013.
   *
   * https://github.com/deanm/omggif
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
   * including animation and compression.  It does not rely on any specific
   * underlying system, so should run in the browser, Node, or Plask.
   *)
  (**
   * @license
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.
  
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:
  
    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.
  
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   *)
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
  (**
   * Tools for svg.
   * @module svg
   * @license MIT
   * @copyright 2011 Jeff Schiller
   *)
  (**
   * DOM element selection box tools.
   * @module select
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   *)
  (**
   * Tools for clear.
   * @module clear
   * @license MIT
   * @copyright 2011 Jeff Schiller
   *)
  (**
   * Numerous tools for working with the editor's "canvas".
   * @module svgcanvas
   *
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Pavol Rusnak, 2010 Jeff Schiller, 2021 OptimistikSAS
   *
   *)
  (*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
  (*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
